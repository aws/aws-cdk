// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`alexa-ask 1`] = `
{
  "augmentations": undefined,
  "metrics": undefined,
  "module": "/* eslint-disable prettier/prettier,max-len */
import * as cdk from "aws-cdk-lib";
import * as constructs from "constructs";
import * as cfn_parse from "aws-cdk-lib/core/lib/helpers-internal";

/**
 * The \`Alexa::ASK::Skill\` resource creates an Alexa skill that enables customers to access new abilities.
 *
 * For more information about developing a skill, see the  .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ask-skill.html
 */
export class CfnSkill extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "Alexa::ASK::Skill";

  /**
   * Build a CfnSkill from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnSkill {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnSkillPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnSkill(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * Login with Amazon (LWA) configuration used to authenticate with the Alexa service.
   */
  public authenticationConfiguration: CfnSkill.AuthenticationConfigurationProperty | cdk.IResolvable;

  /**
   * Configuration for the skill package that contains the components of the Alexa skill.
   */
  public skillPackage: cdk.IResolvable | CfnSkill.SkillPackageProperty;

  /**
   * The vendor ID associated with the Amazon developer account that will host the skill.
   */
  public vendorId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnSkillProps) {
    super(scope, id, {
      "type": CfnSkill.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "authenticationConfiguration", this);
    cdk.requireProperty(props, "skillPackage", this);
    cdk.requireProperty(props, "vendorId", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.authenticationConfiguration = props.authenticationConfiguration;
    this.skillPackage = props.skillPackage;
    this.vendorId = props.vendorId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "authenticationConfiguration": this.authenticationConfiguration,
      "skillPackage": this.skillPackage,
      "vendorId": this.vendorId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnSkill.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnSkillPropsToCloudFormation(props);
  }
}

export namespace CfnSkill {
  /**
   * The \`AuthenticationConfiguration\` property type specifies the Login with Amazon (LWA) configuration used to authenticate with the Alexa service.
   *
   * Only Login with Amazon security profiles created through the  are supported for authentication. A client ID, client secret, and refresh token are required. You can generate a client ID and client secret by creating a new  on the Amazon Developer Portal or you can retrieve them from an existing profile. You can then retrieve the refresh token using the Alexa Skills Kit CLI. For instructions, see  in the  .
   *
   * \`AuthenticationConfiguration\` is a property of the \`Alexa::ASK::Skill\` resource.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ask-skill-authenticationconfiguration.html
   */
  export interface AuthenticationConfigurationProperty {
    /**
     * Client ID from Login with Amazon (LWA).
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ask-skill-authenticationconfiguration.html#cfn-ask-skill-authenticationconfiguration-clientid
     */
    readonly clientId: string;

    /**
     * Client secret from Login with Amazon (LWA).
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ask-skill-authenticationconfiguration.html#cfn-ask-skill-authenticationconfiguration-clientsecret
     */
    readonly clientSecret: string;

    /**
     * Refresh token from Login with Amazon (LWA).
     *
     * This token is secret.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ask-skill-authenticationconfiguration.html#cfn-ask-skill-authenticationconfiguration-refreshtoken
     */
    readonly refreshToken: string;
  }

  /**
   * The \`SkillPackage\` property type contains configuration details for the skill package that contains the components of the Alexa skill.
   *
   * Skill packages are retrieved from an Amazon S3 bucket and key and used to create and update the skill. More details about the skill package format are located in the  .
   *
   * \`SkillPackage\` is a property of the \`Alexa::ASK::Skill\` resource.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ask-skill-skillpackage.html
   */
  export interface SkillPackageProperty {
    /**
     * Overrides to the skill package to apply when creating or updating the skill.
     *
     * Values provided here do not modify the contents of the original skill package. Currently, only overriding values inside of the skill manifest component of the package is supported.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ask-skill-skillpackage.html#cfn-ask-skill-skillpackage-overrides
     */
    readonly overrides?: cdk.IResolvable | CfnSkill.OverridesProperty;

    /**
     * The name of the Amazon S3 bucket where the .zip file that contains the skill package is stored.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ask-skill-skillpackage.html#cfn-ask-skill-skillpackage-s3bucket
     */
    readonly s3Bucket: string;

    /**
     * ARN of the IAM role that grants the Alexa service ( \`alexa-appkit.amazon.com\` ) permission to access the bucket and retrieve the skill package. This property is optional. If you do not provide it, the bucket must be publicly accessible or configured with a policy that allows this access. Otherwise, AWS CloudFormation cannot create the skill.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ask-skill-skillpackage.html#cfn-ask-skill-skillpackage-s3bucketrole
     */
    readonly s3BucketRole?: string;

    /**
     * The location and name of the skill package .zip file.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ask-skill-skillpackage.html#cfn-ask-skill-skillpackage-s3key
     */
    readonly s3Key: string;

    /**
     * If you have S3 versioning enabled, the version ID of the skill package.zip file.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ask-skill-skillpackage.html#cfn-ask-skill-skillpackage-s3objectversion
     */
    readonly s3ObjectVersion?: string;
  }

  /**
   * The \`Overrides\` property type provides overrides to the skill package to apply when creating or updating the skill.
   *
   * Values provided here do not modify the contents of the original skill package. Currently, only overriding values inside of the skill manifest component of the package is supported.
   *
   * \`Overrides\` is a property of the \`Alexa::ASK::Skill SkillPackage\` property type.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ask-skill-overrides.html
   */
  export interface OverridesProperty {
    /**
     * Overrides to apply to the skill manifest inside of the skill package.
     *
     * The skill manifest contains metadata about the skill. For more information, see  .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ask-skill-overrides.html#cfn-ask-skill-overrides-manifest
     */
    readonly manifest?: any | cdk.IResolvable;
  }
}

/**
 * Properties for defining a \`CfnSkill\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ask-skill.html
 */
export interface CfnSkillProps {
  /**
   * Login with Amazon (LWA) configuration used to authenticate with the Alexa service.
   *
   * Only Login with Amazon clients created through the  are supported. The client ID, client secret, and refresh token are required.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ask-skill.html#cfn-ask-skill-authenticationconfiguration
   */
  readonly authenticationConfiguration: CfnSkill.AuthenticationConfigurationProperty | cdk.IResolvable;

  /**
   * Configuration for the skill package that contains the components of the Alexa skill.
   *
   * Skill packages are retrieved from an Amazon S3 bucket and key and used to create and update the skill. For more information about the skill package format, see the  .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ask-skill.html#cfn-ask-skill-skillpackage
   */
  readonly skillPackage: cdk.IResolvable | CfnSkill.SkillPackageProperty;

  /**
   * The vendor ID associated with the Amazon developer account that will host the skill.
   *
   * Details for retrieving the vendor ID are in  . The provided LWA credentials must be linked to the developer account associated with this vendor ID.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ask-skill.html#cfn-ask-skill-vendorid
   */
  readonly vendorId: string;
}

/**
 * Determine whether the given properties match those of a \`AuthenticationConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`AuthenticationConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSkillAuthenticationConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("clientId", cdk.requiredValidator)(properties.clientId));
  errors.collect(cdk.propertyValidator("clientId", cdk.validateString)(properties.clientId));
  errors.collect(cdk.propertyValidator("clientSecret", cdk.requiredValidator)(properties.clientSecret));
  errors.collect(cdk.propertyValidator("clientSecret", cdk.validateString)(properties.clientSecret));
  errors.collect(cdk.propertyValidator("refreshToken", cdk.requiredValidator)(properties.refreshToken));
  errors.collect(cdk.propertyValidator("refreshToken", cdk.validateString)(properties.refreshToken));
  return errors.wrap("supplied properties not correct for \\"AuthenticationConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnSkillAuthenticationConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSkillAuthenticationConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "ClientId": cdk.stringToCloudFormation(properties.clientId),
    "ClientSecret": cdk.stringToCloudFormation(properties.clientSecret),
    "RefreshToken": cdk.stringToCloudFormation(properties.refreshToken)
  };
}

// @ts-ignore TS6133
function CfnSkillAuthenticationConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSkill.AuthenticationConfigurationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSkill.AuthenticationConfigurationProperty>();
  ret.addPropertyResult("clientId", "ClientId", (properties.ClientId != null ? cfn_parse.FromCloudFormation.getString(properties.ClientId) : undefined));
  ret.addPropertyResult("clientSecret", "ClientSecret", (properties.ClientSecret != null ? cfn_parse.FromCloudFormation.getString(properties.ClientSecret) : undefined));
  ret.addPropertyResult("refreshToken", "RefreshToken", (properties.RefreshToken != null ? cfn_parse.FromCloudFormation.getString(properties.RefreshToken) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`OverridesProperty\`
 *
 * @param properties - the TypeScript properties of a \`OverridesProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSkillOverridesPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("manifest", cdk.validateObject)(properties.manifest));
  return errors.wrap("supplied properties not correct for \\"OverridesProperty\\"");
}

// @ts-ignore TS6133
function convertCfnSkillOverridesPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSkillOverridesPropertyValidator(properties).assertSuccess();
  return {
    "Manifest": cdk.objectToCloudFormation(properties.manifest)
  };
}

// @ts-ignore TS6133
function CfnSkillOverridesPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSkill.OverridesProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSkill.OverridesProperty>();
  ret.addPropertyResult("manifest", "Manifest", (properties.Manifest != null ? cfn_parse.FromCloudFormation.getAny(properties.Manifest) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`SkillPackageProperty\`
 *
 * @param properties - the TypeScript properties of a \`SkillPackageProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSkillSkillPackagePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("overrides", CfnSkillOverridesPropertyValidator)(properties.overrides));
  errors.collect(cdk.propertyValidator("s3Bucket", cdk.requiredValidator)(properties.s3Bucket));
  errors.collect(cdk.propertyValidator("s3Bucket", cdk.validateString)(properties.s3Bucket));
  errors.collect(cdk.propertyValidator("s3BucketRole", cdk.validateString)(properties.s3BucketRole));
  errors.collect(cdk.propertyValidator("s3Key", cdk.requiredValidator)(properties.s3Key));
  errors.collect(cdk.propertyValidator("s3Key", cdk.validateString)(properties.s3Key));
  errors.collect(cdk.propertyValidator("s3ObjectVersion", cdk.validateString)(properties.s3ObjectVersion));
  return errors.wrap("supplied properties not correct for \\"SkillPackageProperty\\"");
}

// @ts-ignore TS6133
function convertCfnSkillSkillPackagePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSkillSkillPackagePropertyValidator(properties).assertSuccess();
  return {
    "Overrides": convertCfnSkillOverridesPropertyToCloudFormation(properties.overrides),
    "S3Bucket": cdk.stringToCloudFormation(properties.s3Bucket),
    "S3BucketRole": cdk.stringToCloudFormation(properties.s3BucketRole),
    "S3Key": cdk.stringToCloudFormation(properties.s3Key),
    "S3ObjectVersion": cdk.stringToCloudFormation(properties.s3ObjectVersion)
  };
}

// @ts-ignore TS6133
function CfnSkillSkillPackagePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSkill.SkillPackageProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSkill.SkillPackageProperty>();
  ret.addPropertyResult("overrides", "Overrides", (properties.Overrides != null ? CfnSkillOverridesPropertyFromCloudFormation(properties.Overrides) : undefined));
  ret.addPropertyResult("s3Bucket", "S3Bucket", (properties.S3Bucket != null ? cfn_parse.FromCloudFormation.getString(properties.S3Bucket) : undefined));
  ret.addPropertyResult("s3BucketRole", "S3BucketRole", (properties.S3BucketRole != null ? cfn_parse.FromCloudFormation.getString(properties.S3BucketRole) : undefined));
  ret.addPropertyResult("s3Key", "S3Key", (properties.S3Key != null ? cfn_parse.FromCloudFormation.getString(properties.S3Key) : undefined));
  ret.addPropertyResult("s3ObjectVersion", "S3ObjectVersion", (properties.S3ObjectVersion != null ? cfn_parse.FromCloudFormation.getString(properties.S3ObjectVersion) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnSkillProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnSkillProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSkillPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("authenticationConfiguration", cdk.requiredValidator)(properties.authenticationConfiguration));
  errors.collect(cdk.propertyValidator("authenticationConfiguration", CfnSkillAuthenticationConfigurationPropertyValidator)(properties.authenticationConfiguration));
  errors.collect(cdk.propertyValidator("skillPackage", cdk.requiredValidator)(properties.skillPackage));
  errors.collect(cdk.propertyValidator("skillPackage", CfnSkillSkillPackagePropertyValidator)(properties.skillPackage));
  errors.collect(cdk.propertyValidator("vendorId", cdk.requiredValidator)(properties.vendorId));
  errors.collect(cdk.propertyValidator("vendorId", cdk.validateString)(properties.vendorId));
  return errors.wrap("supplied properties not correct for \\"CfnSkillProps\\"");
}

// @ts-ignore TS6133
function convertCfnSkillPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSkillPropsValidator(properties).assertSuccess();
  return {
    "AuthenticationConfiguration": convertCfnSkillAuthenticationConfigurationPropertyToCloudFormation(properties.authenticationConfiguration),
    "SkillPackage": convertCfnSkillSkillPackagePropertyToCloudFormation(properties.skillPackage),
    "VendorId": cdk.stringToCloudFormation(properties.vendorId)
  };
}

// @ts-ignore TS6133
function CfnSkillPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSkillProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSkillProps>();
  ret.addPropertyResult("authenticationConfiguration", "AuthenticationConfiguration", (properties.AuthenticationConfiguration != null ? CfnSkillAuthenticationConfigurationPropertyFromCloudFormation(properties.AuthenticationConfiguration) : undefined));
  ret.addPropertyResult("skillPackage", "SkillPackage", (properties.SkillPackage != null ? CfnSkillSkillPackagePropertyFromCloudFormation(properties.SkillPackage) : undefined));
  ret.addPropertyResult("vendorId", "VendorId", (properties.VendorId != null ? cfn_parse.FromCloudFormation.getString(properties.VendorId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}",
}
`;

exports[`aws-chatbot 1`] = `
{
  "augmentations": undefined,
  "metrics": undefined,
  "module": "/* eslint-disable prettier/prettier,max-len */
import * as cdk from "aws-cdk-lib";
import * as constructs from "constructs";
import * as cfn_parse from "aws-cdk-lib/core/lib/helpers-internal";

/**
 * The \`AWS::Chatbot::MicrosoftTeamsChannelConfiguration\` resource configures a Microsoft Teams channel to allow users to use AWS Chatbot with AWS CloudFormation templates.
 *
 * This resource requires some setup to be done in the AWS Chatbot console. To provide the required Microsoft Teams team and tenant IDs, you must perform the initial authorization flow with Microsoft Teams in the AWS Chatbot console, then copy and paste the IDs from the console. For more details, see steps 1-4 in [Setting Up AWS Chatbot with Microsoft Teams](https://docs.aws.amazon.com/chatbot/latest/adminguide/teams-setup.html#teams-client-setup) in the *AWS Chatbot Administrator Guide* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-microsoftteamschannelconfiguration.html
 */
export class CfnMicrosoftTeamsChannelConfiguration extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::Chatbot::MicrosoftTeamsChannelConfiguration";

  /**
   * Build a CfnMicrosoftTeamsChannelConfiguration from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnMicrosoftTeamsChannelConfiguration {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnMicrosoftTeamsChannelConfigurationPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnMicrosoftTeamsChannelConfiguration(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * Amazon Resource Name (ARN) of the configuration
   *
   * @cloudformationAttribute Arn
   */
  public readonly attrArn: string;

  /**
   * The name of the configuration.
   */
  public configurationName: string;

  /**
   * The list of IAM policy ARNs that are applied as channel guardrails.
   */
  public guardrailPolicies?: Array<string>;

  /**
   * The ARN of the IAM role that defines the permissions for AWS Chatbot .
   */
  public iamRoleArn: string;

  /**
   * Specifies the logging level for this configuration. This property affects the log entries pushed to Amazon CloudWatch Logs.
   */
  public loggingLevel?: string;

  /**
   * The ARNs of the SNS topics that deliver notifications to AWS Chatbot .
   */
  public snsTopicArns?: Array<string>;

  /**
   * The ID of the Microsoft Team authorized with AWS Chatbot .
   */
  public teamId: string;

  /**
   * The ID of the Microsoft Teams channel.
   */
  public teamsChannelId: string;

  /**
   * The ID of the Microsoft Teams tenant.
   */
  public teamsTenantId: string;

  /**
   * Enables use of a user role requirement in your chat configuration.
   */
  public userRoleRequired?: boolean | cdk.IResolvable;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnMicrosoftTeamsChannelConfigurationProps) {
    super(scope, id, {
      "type": CfnMicrosoftTeamsChannelConfiguration.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "configurationName", this);
    cdk.requireProperty(props, "iamRoleArn", this);
    cdk.requireProperty(props, "teamId", this);
    cdk.requireProperty(props, "teamsChannelId", this);
    cdk.requireProperty(props, "teamsTenantId", this);

    this.attrArn = cdk.Token.asString(this.getAtt("Arn", cdk.ResolutionTypeHint.STRING));
    this.configurationName = props.configurationName;
    this.guardrailPolicies = props.guardrailPolicies;
    this.iamRoleArn = props.iamRoleArn;
    this.loggingLevel = props.loggingLevel;
    this.snsTopicArns = props.snsTopicArns;
    this.teamId = props.teamId;
    this.teamsChannelId = props.teamsChannelId;
    this.teamsTenantId = props.teamsTenantId;
    this.userRoleRequired = props.userRoleRequired;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "configurationName": this.configurationName,
      "guardrailPolicies": this.guardrailPolicies,
      "iamRoleArn": this.iamRoleArn,
      "loggingLevel": this.loggingLevel,
      "snsTopicArns": this.snsTopicArns,
      "teamId": this.teamId,
      "teamsChannelId": this.teamsChannelId,
      "teamsTenantId": this.teamsTenantId,
      "userRoleRequired": this.userRoleRequired
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnMicrosoftTeamsChannelConfiguration.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnMicrosoftTeamsChannelConfigurationPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnMicrosoftTeamsChannelConfiguration\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-microsoftteamschannelconfiguration.html
 */
export interface CfnMicrosoftTeamsChannelConfigurationProps {
  /**
   * The name of the configuration.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-microsoftteamschannelconfiguration.html#cfn-chatbot-microsoftteamschannelconfiguration-configurationname
   */
  readonly configurationName: string;

  /**
   * The list of IAM policy ARNs that are applied as channel guardrails.
   *
   * The AWS managed 'AdministratorAccess' policy is applied as a default if this is not set.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-microsoftteamschannelconfiguration.html#cfn-chatbot-microsoftteamschannelconfiguration-guardrailpolicies
   */
  readonly guardrailPolicies?: Array<string>;

  /**
   * The ARN of the IAM role that defines the permissions for AWS Chatbot .
   *
   * This is a user-defined role that AWS Chatbot will assume. This is not the service-linked role. For more information, see [IAM Policies for AWS Chatbot](https://docs.aws.amazon.com/chatbot/latest/adminguide/chatbot-iam-policies.html) .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-microsoftteamschannelconfiguration.html#cfn-chatbot-microsoftteamschannelconfiguration-iamrolearn
   */
  readonly iamRoleArn: string;

  /**
   * Specifies the logging level for this configuration. This property affects the log entries pushed to Amazon CloudWatch Logs.
   *
   * Logging levels include \`ERROR\` , \`INFO\` , or \`NONE\` .
   *
   * @default - "NONE"
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-microsoftteamschannelconfiguration.html#cfn-chatbot-microsoftteamschannelconfiguration-logginglevel
   */
  readonly loggingLevel?: string;

  /**
   * The ARNs of the SNS topics that deliver notifications to AWS Chatbot .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-microsoftteamschannelconfiguration.html#cfn-chatbot-microsoftteamschannelconfiguration-snstopicarns
   */
  readonly snsTopicArns?: Array<string>;

  /**
   * The ID of the Microsoft Team authorized with AWS Chatbot .
   *
   * To get the team ID, you must perform the initial authorization flow with Microsoft Teams in the AWS Chatbot console. Then you can copy and paste the team ID from the console. For more details, see steps 1-4 in [Get started with Microsoft Teams](https://docs.aws.amazon.com/chatbot/latest/adminguide/teams-setup.html#teams-client-setup) in the *AWS Chatbot Administrator Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-microsoftteamschannelconfiguration.html#cfn-chatbot-microsoftteamschannelconfiguration-teamid
   */
  readonly teamId: string;

  /**
   * The ID of the Microsoft Teams channel.
   *
   * To get the channel ID, open Microsoft Teams, right click on the channel name in the left pane, then choose Copy. An example of the channel ID syntax is: \`19%3ab6ef35dc342d56ba5654e6fc6d25a071%40thread.tacv2\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-microsoftteamschannelconfiguration.html#cfn-chatbot-microsoftteamschannelconfiguration-teamschannelid
   */
  readonly teamsChannelId: string;

  /**
   * The ID of the Microsoft Teams tenant.
   *
   * To get the tenant ID, you must perform the initial authorization flow with Microsoft Teams in the AWS Chatbot console. Then you can copy and paste the tenant ID from the console. For more details, see steps 1-4 in [Get started with Microsoft Teams](https://docs.aws.amazon.com/chatbot/latest/adminguide/teams-setup.html#teams-client-setup) in the *AWS Chatbot Administrator Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-microsoftteamschannelconfiguration.html#cfn-chatbot-microsoftteamschannelconfiguration-teamstenantid
   */
  readonly teamsTenantId: string;

  /**
   * Enables use of a user role requirement in your chat configuration.
   *
   * @default - false
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-microsoftteamschannelconfiguration.html#cfn-chatbot-microsoftteamschannelconfiguration-userrolerequired
   */
  readonly userRoleRequired?: boolean | cdk.IResolvable;
}

/**
 * Determine whether the given properties match those of a \`CfnMicrosoftTeamsChannelConfigurationProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnMicrosoftTeamsChannelConfigurationProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnMicrosoftTeamsChannelConfigurationPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("configurationName", cdk.requiredValidator)(properties.configurationName));
  errors.collect(cdk.propertyValidator("configurationName", cdk.validateString)(properties.configurationName));
  errors.collect(cdk.propertyValidator("guardrailPolicies", cdk.listValidator(cdk.validateString))(properties.guardrailPolicies));
  errors.collect(cdk.propertyValidator("iamRoleArn", cdk.requiredValidator)(properties.iamRoleArn));
  errors.collect(cdk.propertyValidator("iamRoleArn", cdk.validateString)(properties.iamRoleArn));
  errors.collect(cdk.propertyValidator("loggingLevel", cdk.validateString)(properties.loggingLevel));
  errors.collect(cdk.propertyValidator("snsTopicArns", cdk.listValidator(cdk.validateString))(properties.snsTopicArns));
  errors.collect(cdk.propertyValidator("teamId", cdk.requiredValidator)(properties.teamId));
  errors.collect(cdk.propertyValidator("teamId", cdk.validateString)(properties.teamId));
  errors.collect(cdk.propertyValidator("teamsChannelId", cdk.requiredValidator)(properties.teamsChannelId));
  errors.collect(cdk.propertyValidator("teamsChannelId", cdk.validateString)(properties.teamsChannelId));
  errors.collect(cdk.propertyValidator("teamsTenantId", cdk.requiredValidator)(properties.teamsTenantId));
  errors.collect(cdk.propertyValidator("teamsTenantId", cdk.validateString)(properties.teamsTenantId));
  errors.collect(cdk.propertyValidator("userRoleRequired", cdk.validateBoolean)(properties.userRoleRequired));
  return errors.wrap("supplied properties not correct for \\"CfnMicrosoftTeamsChannelConfigurationProps\\"");
}

// @ts-ignore TS6133
function convertCfnMicrosoftTeamsChannelConfigurationPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnMicrosoftTeamsChannelConfigurationPropsValidator(properties).assertSuccess();
  return {
    "ConfigurationName": cdk.stringToCloudFormation(properties.configurationName),
    "GuardrailPolicies": cdk.listMapper(cdk.stringToCloudFormation)(properties.guardrailPolicies),
    "IamRoleArn": cdk.stringToCloudFormation(properties.iamRoleArn),
    "LoggingLevel": cdk.stringToCloudFormation(properties.loggingLevel),
    "SnsTopicArns": cdk.listMapper(cdk.stringToCloudFormation)(properties.snsTopicArns),
    "TeamId": cdk.stringToCloudFormation(properties.teamId),
    "TeamsChannelId": cdk.stringToCloudFormation(properties.teamsChannelId),
    "TeamsTenantId": cdk.stringToCloudFormation(properties.teamsTenantId),
    "UserRoleRequired": cdk.booleanToCloudFormation(properties.userRoleRequired)
  };
}

// @ts-ignore TS6133
function CfnMicrosoftTeamsChannelConfigurationPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnMicrosoftTeamsChannelConfigurationProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnMicrosoftTeamsChannelConfigurationProps>();
  ret.addPropertyResult("configurationName", "ConfigurationName", (properties.ConfigurationName != null ? cfn_parse.FromCloudFormation.getString(properties.ConfigurationName) : undefined));
  ret.addPropertyResult("guardrailPolicies", "GuardrailPolicies", (properties.GuardrailPolicies != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.GuardrailPolicies) : undefined));
  ret.addPropertyResult("iamRoleArn", "IamRoleArn", (properties.IamRoleArn != null ? cfn_parse.FromCloudFormation.getString(properties.IamRoleArn) : undefined));
  ret.addPropertyResult("loggingLevel", "LoggingLevel", (properties.LoggingLevel != null ? cfn_parse.FromCloudFormation.getString(properties.LoggingLevel) : undefined));
  ret.addPropertyResult("snsTopicArns", "SnsTopicArns", (properties.SnsTopicArns != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SnsTopicArns) : undefined));
  ret.addPropertyResult("teamId", "TeamId", (properties.TeamId != null ? cfn_parse.FromCloudFormation.getString(properties.TeamId) : undefined));
  ret.addPropertyResult("teamsChannelId", "TeamsChannelId", (properties.TeamsChannelId != null ? cfn_parse.FromCloudFormation.getString(properties.TeamsChannelId) : undefined));
  ret.addPropertyResult("teamsTenantId", "TeamsTenantId", (properties.TeamsTenantId != null ? cfn_parse.FromCloudFormation.getString(properties.TeamsTenantId) : undefined));
  ret.addPropertyResult("userRoleRequired", "UserRoleRequired", (properties.UserRoleRequired != null ? cfn_parse.FromCloudFormation.getBoolean(properties.UserRoleRequired) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * The \`AWS::Chatbot::SlackChannelConfiguration\` resource configures a Slack channel to allow users to use AWS Chatbot with AWS CloudFormation templates.
 *
 * This resource requires some setup to be done in the AWS Chatbot console. To provide the required Slack workspace ID, you must perform the initial authorization flow with Slack in the AWS Chatbot console, then copy and paste the workspace ID from the console. For more details, see steps 1-4 in [Setting Up AWS Chatbot with Slack](https://docs.aws.amazon.com/chatbot/latest/adminguide/setting-up.html#Setup_intro) in the *AWS Chatbot User Guide* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-slackchannelconfiguration.html
 */
export class CfnSlackChannelConfiguration extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::Chatbot::SlackChannelConfiguration";

  /**
   * Build a CfnSlackChannelConfiguration from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnSlackChannelConfiguration {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnSlackChannelConfigurationPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnSlackChannelConfiguration(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * Amazon Resource Name (ARN) of the configuration
   *
   * @cloudformationAttribute Arn
   */
  public readonly attrArn: string;

  /**
   * The name of the configuration.
   */
  public configurationName: string;

  /**
   * The list of IAM policy ARNs that are applied as channel guardrails.
   */
  public guardrailPolicies?: Array<string>;

  /**
   * The ARN of the IAM role that defines the permissions for AWS Chatbot .
   */
  public iamRoleArn: string;

  /**
   * Specifies the logging level for this configuration. This property affects the log entries pushed to Amazon CloudWatch Logs.
   */
  public loggingLevel?: string;

  /**
   * The ID of the Slack channel.
   */
  public slackChannelId: string;

  /**
   * The ID of the Slack workspace authorized with AWS Chatbot .
   */
  public slackWorkspaceId: string;

  /**
   * The ARNs of the SNS topics that deliver notifications to AWS Chatbot .
   */
  public snsTopicArns?: Array<string>;

  /**
   * Enables use of a user role requirement in your chat configuration.
   */
  public userRoleRequired?: boolean | cdk.IResolvable;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnSlackChannelConfigurationProps) {
    super(scope, id, {
      "type": CfnSlackChannelConfiguration.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "configurationName", this);
    cdk.requireProperty(props, "iamRoleArn", this);
    cdk.requireProperty(props, "slackChannelId", this);
    cdk.requireProperty(props, "slackWorkspaceId", this);

    this.attrArn = cdk.Token.asString(this.getAtt("Arn", cdk.ResolutionTypeHint.STRING));
    this.configurationName = props.configurationName;
    this.guardrailPolicies = props.guardrailPolicies;
    this.iamRoleArn = props.iamRoleArn;
    this.loggingLevel = props.loggingLevel;
    this.slackChannelId = props.slackChannelId;
    this.slackWorkspaceId = props.slackWorkspaceId;
    this.snsTopicArns = props.snsTopicArns;
    this.userRoleRequired = props.userRoleRequired;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "configurationName": this.configurationName,
      "guardrailPolicies": this.guardrailPolicies,
      "iamRoleArn": this.iamRoleArn,
      "loggingLevel": this.loggingLevel,
      "slackChannelId": this.slackChannelId,
      "slackWorkspaceId": this.slackWorkspaceId,
      "snsTopicArns": this.snsTopicArns,
      "userRoleRequired": this.userRoleRequired
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnSlackChannelConfiguration.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnSlackChannelConfigurationPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnSlackChannelConfiguration\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-slackchannelconfiguration.html
 */
export interface CfnSlackChannelConfigurationProps {
  /**
   * The name of the configuration.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-slackchannelconfiguration.html#cfn-chatbot-slackchannelconfiguration-configurationname
   */
  readonly configurationName: string;

  /**
   * The list of IAM policy ARNs that are applied as channel guardrails.
   *
   * The AWS managed 'AdministratorAccess' policy is applied as a default if this is not set.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-slackchannelconfiguration.html#cfn-chatbot-slackchannelconfiguration-guardrailpolicies
   */
  readonly guardrailPolicies?: Array<string>;

  /**
   * The ARN of the IAM role that defines the permissions for AWS Chatbot .
   *
   * This is a user-defined role that AWS Chatbot will assume. This is not the service-linked role. For more information, see [IAM Policies for AWS Chatbot](https://docs.aws.amazon.com/chatbot/latest/adminguide/chatbot-iam-policies.html) .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-slackchannelconfiguration.html#cfn-chatbot-slackchannelconfiguration-iamrolearn
   */
  readonly iamRoleArn: string;

  /**
   * Specifies the logging level for this configuration. This property affects the log entries pushed to Amazon CloudWatch Logs.
   *
   * Logging levels include \`ERROR\` , \`INFO\` , or \`NONE\` .
   *
   * @default - "NONE"
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-slackchannelconfiguration.html#cfn-chatbot-slackchannelconfiguration-logginglevel
   */
  readonly loggingLevel?: string;

  /**
   * The ID of the Slack channel.
   *
   * To get the ID, open Slack, right click on the channel name in the left pane, then choose Copy Link. The channel ID is the 9-character string at the end of the URL. For example, \`ABCBBLZZZ\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-slackchannelconfiguration.html#cfn-chatbot-slackchannelconfiguration-slackchannelid
   */
  readonly slackChannelId: string;

  /**
   * The ID of the Slack workspace authorized with AWS Chatbot .
   *
   * To get the workspace ID, you must perform the initial authorization flow with Slack in the AWS Chatbot console. Then you can copy and paste the workspace ID from the console. For more details, see steps 1-4 in [Setting Up AWS Chatbot with Slack](https://docs.aws.amazon.com/chatbot/latest/adminguide/setting-up.html#Setup_intro) in the *AWS Chatbot User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-slackchannelconfiguration.html#cfn-chatbot-slackchannelconfiguration-slackworkspaceid
   */
  readonly slackWorkspaceId: string;

  /**
   * The ARNs of the SNS topics that deliver notifications to AWS Chatbot .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-slackchannelconfiguration.html#cfn-chatbot-slackchannelconfiguration-snstopicarns
   */
  readonly snsTopicArns?: Array<string>;

  /**
   * Enables use of a user role requirement in your chat configuration.
   *
   * @default - false
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-slackchannelconfiguration.html#cfn-chatbot-slackchannelconfiguration-userrolerequired
   */
  readonly userRoleRequired?: boolean | cdk.IResolvable;
}

/**
 * Determine whether the given properties match those of a \`CfnSlackChannelConfigurationProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnSlackChannelConfigurationProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSlackChannelConfigurationPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("configurationName", cdk.requiredValidator)(properties.configurationName));
  errors.collect(cdk.propertyValidator("configurationName", cdk.validateString)(properties.configurationName));
  errors.collect(cdk.propertyValidator("guardrailPolicies", cdk.listValidator(cdk.validateString))(properties.guardrailPolicies));
  errors.collect(cdk.propertyValidator("iamRoleArn", cdk.requiredValidator)(properties.iamRoleArn));
  errors.collect(cdk.propertyValidator("iamRoleArn", cdk.validateString)(properties.iamRoleArn));
  errors.collect(cdk.propertyValidator("loggingLevel", cdk.validateString)(properties.loggingLevel));
  errors.collect(cdk.propertyValidator("slackChannelId", cdk.requiredValidator)(properties.slackChannelId));
  errors.collect(cdk.propertyValidator("slackChannelId", cdk.validateString)(properties.slackChannelId));
  errors.collect(cdk.propertyValidator("slackWorkspaceId", cdk.requiredValidator)(properties.slackWorkspaceId));
  errors.collect(cdk.propertyValidator("slackWorkspaceId", cdk.validateString)(properties.slackWorkspaceId));
  errors.collect(cdk.propertyValidator("snsTopicArns", cdk.listValidator(cdk.validateString))(properties.snsTopicArns));
  errors.collect(cdk.propertyValidator("userRoleRequired", cdk.validateBoolean)(properties.userRoleRequired));
  return errors.wrap("supplied properties not correct for \\"CfnSlackChannelConfigurationProps\\"");
}

// @ts-ignore TS6133
function convertCfnSlackChannelConfigurationPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSlackChannelConfigurationPropsValidator(properties).assertSuccess();
  return {
    "ConfigurationName": cdk.stringToCloudFormation(properties.configurationName),
    "GuardrailPolicies": cdk.listMapper(cdk.stringToCloudFormation)(properties.guardrailPolicies),
    "IamRoleArn": cdk.stringToCloudFormation(properties.iamRoleArn),
    "LoggingLevel": cdk.stringToCloudFormation(properties.loggingLevel),
    "SlackChannelId": cdk.stringToCloudFormation(properties.slackChannelId),
    "SlackWorkspaceId": cdk.stringToCloudFormation(properties.slackWorkspaceId),
    "SnsTopicArns": cdk.listMapper(cdk.stringToCloudFormation)(properties.snsTopicArns),
    "UserRoleRequired": cdk.booleanToCloudFormation(properties.userRoleRequired)
  };
}

// @ts-ignore TS6133
function CfnSlackChannelConfigurationPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSlackChannelConfigurationProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSlackChannelConfigurationProps>();
  ret.addPropertyResult("configurationName", "ConfigurationName", (properties.ConfigurationName != null ? cfn_parse.FromCloudFormation.getString(properties.ConfigurationName) : undefined));
  ret.addPropertyResult("guardrailPolicies", "GuardrailPolicies", (properties.GuardrailPolicies != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.GuardrailPolicies) : undefined));
  ret.addPropertyResult("iamRoleArn", "IamRoleArn", (properties.IamRoleArn != null ? cfn_parse.FromCloudFormation.getString(properties.IamRoleArn) : undefined));
  ret.addPropertyResult("loggingLevel", "LoggingLevel", (properties.LoggingLevel != null ? cfn_parse.FromCloudFormation.getString(properties.LoggingLevel) : undefined));
  ret.addPropertyResult("slackChannelId", "SlackChannelId", (properties.SlackChannelId != null ? cfn_parse.FromCloudFormation.getString(properties.SlackChannelId) : undefined));
  ret.addPropertyResult("slackWorkspaceId", "SlackWorkspaceId", (properties.SlackWorkspaceId != null ? cfn_parse.FromCloudFormation.getString(properties.SlackWorkspaceId) : undefined));
  ret.addPropertyResult("snsTopicArns", "SnsTopicArns", (properties.SnsTopicArns != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SnsTopicArns) : undefined));
  ret.addPropertyResult("userRoleRequired", "UserRoleRequired", (properties.UserRoleRequired != null ? cfn_parse.FromCloudFormation.getBoolean(properties.UserRoleRequired) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}",
}
`;

exports[`aws-ec2 1`] = `
{
  "augmentations": "// Copyright 2012-2023 Amazon.com, Inc. or its affiliates. All Rights Reserved.
/* eslint-disable prettier/prettier,max-len */
import * as cw from "aws-cdk-lib/aws-cloudwatch";
import { VpnConnectionBase } from "./vpn";

declare module "./vpn" {
  interface IVpnConnection {
    /**
     * Return the given named metric for this VPNConnection
     */
    metric(metricName: string, props?: cw.MetricOptions): cw.Metric;

    /**
     * The state of the tunnel. 0 indicates DOWN and 1 indicates UP.
     *
     * Average over 5 minutes
     */
    metricTunnelState(props?: cw.MetricOptions): cw.Metric;

    /**
     * The bytes received through the VPN tunnel.
     *
     * Sum over 5 minutes
     */
    metricTunnelDataIn(props?: cw.MetricOptions): cw.Metric;

    /**
     * The bytes sent through the VPN tunnel.
     *
     * Sum over 5 minutes
     */
    metricTunnelDataOut(props?: cw.MetricOptions): cw.Metric;
  }
}



declare module "./vpn" {
  interface VpnConnectionBase {
    /**
     * Return the given named metric for this VPNConnection
     */
    metric(metricName: string, props?: cw.MetricOptions): cw.Metric;

    /**
     * The state of the tunnel. 0 indicates DOWN and 1 indicates UP.
     *
     * Average over 5 minutes
     */
    metricTunnelState(props?: cw.MetricOptions): cw.Metric;

    /**
     * The bytes received through the VPN tunnel.
     *
     * Sum over 5 minutes
     */
    metricTunnelDataIn(props?: cw.MetricOptions): cw.Metric;

    /**
     * The bytes sent through the VPN tunnel.
     *
     * Sum over 5 minutes
     */
    metricTunnelDataOut(props?: cw.MetricOptions): cw.Metric;
  }
}

VpnConnectionBase.prototype.metric = function(metricName: string, props?: cw.MetricOptions) {
  return new cw.Metric({
    "namespace": "AWS/VPN",
    "metricName": metricName,
    "dimensionsMap": {
      "VpnId": this.vpnId
    },
    ...props
  }).attachTo(this);
};
VpnConnectionBase.prototype.metricTunnelState = function(props?: cw.MetricOptions) {
  return this.metric("TunnelState", {
    "statistic": "Average",
    ...props
  });
};
VpnConnectionBase.prototype.metricTunnelDataIn = function(props?: cw.MetricOptions) {
  return this.metric("TunnelDataIn", {
    "statistic": "Sum",
    ...props
  });
};
VpnConnectionBase.prototype.metricTunnelDataOut = function(props?: cw.MetricOptions) {
  return this.metric("TunnelDataOut", {
    "statistic": "Sum",
    ...props
  });
};",
  "metrics": "/* eslint-disable prettier/prettier,max-len */
export interface MetricWithDims<D> {
  readonly namespace: string;

  readonly metricName: string;

  readonly statistic: string;

  readonly dimensionsMap: D;
}

export class EC2CapacityReservationsMetrics {
  public static instanceUtilizationAverage(dimensions: { CapacityReservationId: string; }): MetricWithDims<{ CapacityReservationId: string; }> {
    return {
      "namespace": "AWS/EC2CapacityReservations",
      "metricName": "InstanceUtilization",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static usedInstanceCountAverage(dimensions: { CapacityReservationId: string; }): MetricWithDims<{ CapacityReservationId: string; }> {
    return {
      "namespace": "AWS/EC2CapacityReservations",
      "metricName": "UsedInstanceCount",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static availableInstanceCountAverage(dimensions: { CapacityReservationId: string; }): MetricWithDims<{ CapacityReservationId: string; }> {
    return {
      "namespace": "AWS/EC2CapacityReservations",
      "metricName": "AvailableInstanceCount",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static totalInstanceCountAverage(dimensions: { CapacityReservationId: string; }): MetricWithDims<{ CapacityReservationId: string; }> {
    return {
      "namespace": "AWS/EC2CapacityReservations",
      "metricName": "TotalInstanceCount",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }
}

export class EBSMetrics {
  public static volumeReadBytesSum(dimensions: { VolumeId: string; }): MetricWithDims<{ VolumeId: string; }> {
    return {
      "namespace": "AWS/EBS",
      "metricName": "VolumeReadBytes",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static volumeWriteBytesSum(dimensions: { VolumeId: string; }): MetricWithDims<{ VolumeId: string; }> {
    return {
      "namespace": "AWS/EBS",
      "metricName": "VolumeWriteBytes",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static volumeReadOpsSum(dimensions: { VolumeId: string; }): MetricWithDims<{ VolumeId: string; }> {
    return {
      "namespace": "AWS/EBS",
      "metricName": "VolumeReadOps",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static volumeTotalReadTimeAverage(dimensions: { VolumeId: string; }): MetricWithDims<{ VolumeId: string; }> {
    return {
      "namespace": "AWS/EBS",
      "metricName": "VolumeTotalReadTime",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static volumeWriteOpsSum(dimensions: { VolumeId: string; }): MetricWithDims<{ VolumeId: string; }> {
    return {
      "namespace": "AWS/EBS",
      "metricName": "VolumeWriteOps",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static volumeTotalWriteTimeAverage(dimensions: { VolumeId: string; }): MetricWithDims<{ VolumeId: string; }> {
    return {
      "namespace": "AWS/EBS",
      "metricName": "VolumeTotalWriteTime",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static volumeIdleTimeAverage(dimensions: { VolumeId: string; }): MetricWithDims<{ VolumeId: string; }> {
    return {
      "namespace": "AWS/EBS",
      "metricName": "VolumeIdleTime",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static volumeQueueLengthAverage(dimensions: { VolumeId: string; }): MetricWithDims<{ VolumeId: string; }> {
    return {
      "namespace": "AWS/EBS",
      "metricName": "VolumeQueueLength",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static burstBalanceAverage(dimensions: { VolumeId: string; }): MetricWithDims<{ VolumeId: string; }> {
    return {
      "namespace": "AWS/EBS",
      "metricName": "BurstBalance",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }
}

export class EC2Metrics {
  public static cpuCreditUsageAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "AWS/EC2",
      "metricName": "CPUCreditUsage",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static cpuCreditBalanceAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "AWS/EC2",
      "metricName": "CPUCreditBalance",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static cpuSurplusCreditBalanceAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "AWS/EC2",
      "metricName": "CPUSurplusCreditBalance",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static cpuSurplusCreditsChargedAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "AWS/EC2",
      "metricName": "CPUSurplusCreditsCharged",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static cpuUtilizationAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }>;

  public static cpuUtilizationAverage(dimensions: {  }): MetricWithDims<{  }>;

  public static cpuUtilizationAverage(dimensions: { AutoScalingGroupName: string; }): MetricWithDims<{ AutoScalingGroupName: string; }>;

  public static cpuUtilizationAverage(dimensions: { ImageId: string; }): MetricWithDims<{ ImageId: string; }>;

  public static cpuUtilizationAverage(dimensions: { InstanceType: string; }): MetricWithDims<{ InstanceType: string; }>;

  public static cpuUtilizationAverage(dimensions: any): MetricWithDims<any> {
    return {
      "namespace": "AWS/EC2",
      "metricName": "CPUUtilization",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static diskReadBytesAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }>;

  public static diskReadBytesAverage(dimensions: {  }): MetricWithDims<{  }>;

  public static diskReadBytesAverage(dimensions: { AutoScalingGroupName: string; }): MetricWithDims<{ AutoScalingGroupName: string; }>;

  public static diskReadBytesAverage(dimensions: { ImageId: string; }): MetricWithDims<{ ImageId: string; }>;

  public static diskReadBytesAverage(dimensions: { InstanceType: string; }): MetricWithDims<{ InstanceType: string; }>;

  public static diskReadBytesAverage(dimensions: any): MetricWithDims<any> {
    return {
      "namespace": "AWS/EC2",
      "metricName": "DiskReadBytes",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static diskReadOpsAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }>;

  public static diskReadOpsAverage(dimensions: {  }): MetricWithDims<{  }>;

  public static diskReadOpsAverage(dimensions: { AutoScalingGroupName: string; }): MetricWithDims<{ AutoScalingGroupName: string; }>;

  public static diskReadOpsAverage(dimensions: { ImageId: string; }): MetricWithDims<{ ImageId: string; }>;

  public static diskReadOpsAverage(dimensions: { InstanceType: string; }): MetricWithDims<{ InstanceType: string; }>;

  public static diskReadOpsAverage(dimensions: any): MetricWithDims<any> {
    return {
      "namespace": "AWS/EC2",
      "metricName": "DiskReadOps",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static diskWriteBytesAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }>;

  public static diskWriteBytesAverage(dimensions: {  }): MetricWithDims<{  }>;

  public static diskWriteBytesAverage(dimensions: { AutoScalingGroupName: string; }): MetricWithDims<{ AutoScalingGroupName: string; }>;

  public static diskWriteBytesAverage(dimensions: { ImageId: string; }): MetricWithDims<{ ImageId: string; }>;

  public static diskWriteBytesAverage(dimensions: { InstanceType: string; }): MetricWithDims<{ InstanceType: string; }>;

  public static diskWriteBytesAverage(dimensions: any): MetricWithDims<any> {
    return {
      "namespace": "AWS/EC2",
      "metricName": "DiskWriteBytes",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static diskWriteOpsAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }>;

  public static diskWriteOpsAverage(dimensions: {  }): MetricWithDims<{  }>;

  public static diskWriteOpsAverage(dimensions: { AutoScalingGroupName: string; }): MetricWithDims<{ AutoScalingGroupName: string; }>;

  public static diskWriteOpsAverage(dimensions: { ImageId: string; }): MetricWithDims<{ ImageId: string; }>;

  public static diskWriteOpsAverage(dimensions: { InstanceType: string; }): MetricWithDims<{ InstanceType: string; }>;

  public static diskWriteOpsAverage(dimensions: any): MetricWithDims<any> {
    return {
      "namespace": "AWS/EC2",
      "metricName": "DiskWriteOps",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static metadataNoTokenSum(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }>;

  public static metadataNoTokenSum(dimensions: {  }): MetricWithDims<{  }>;

  public static metadataNoTokenSum(dimensions: any): MetricWithDims<any> {
    return {
      "namespace": "AWS/EC2",
      "metricName": "MetadataNoToken",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static networkInAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }>;

  public static networkInAverage(dimensions: {  }): MetricWithDims<{  }>;

  public static networkInAverage(dimensions: { AutoScalingGroupName: string; }): MetricWithDims<{ AutoScalingGroupName: string; }>;

  public static networkInAverage(dimensions: { ImageId: string; }): MetricWithDims<{ ImageId: string; }>;

  public static networkInAverage(dimensions: { InstanceType: string; }): MetricWithDims<{ InstanceType: string; }>;

  public static networkInAverage(dimensions: any): MetricWithDims<any> {
    return {
      "namespace": "AWS/EC2",
      "metricName": "NetworkIn",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static networkOutAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }>;

  public static networkOutAverage(dimensions: {  }): MetricWithDims<{  }>;

  public static networkOutAverage(dimensions: { AutoScalingGroupName: string; }): MetricWithDims<{ AutoScalingGroupName: string; }>;

  public static networkOutAverage(dimensions: { ImageId: string; }): MetricWithDims<{ ImageId: string; }>;

  public static networkOutAverage(dimensions: { InstanceType: string; }): MetricWithDims<{ InstanceType: string; }>;

  public static networkOutAverage(dimensions: any): MetricWithDims<any> {
    return {
      "namespace": "AWS/EC2",
      "metricName": "NetworkOut",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static networkPacketsInAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }>;

  public static networkPacketsInAverage(dimensions: {  }): MetricWithDims<{  }>;

  public static networkPacketsInAverage(dimensions: { AutoScalingGroupName: string; }): MetricWithDims<{ AutoScalingGroupName: string; }>;

  public static networkPacketsInAverage(dimensions: any): MetricWithDims<any> {
    return {
      "namespace": "AWS/EC2",
      "metricName": "NetworkPacketsIn",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static networkPacketsOutAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }>;

  public static networkPacketsOutAverage(dimensions: {  }): MetricWithDims<{  }>;

  public static networkPacketsOutAverage(dimensions: { AutoScalingGroupName: string; }): MetricWithDims<{ AutoScalingGroupName: string; }>;

  public static networkPacketsOutAverage(dimensions: any): MetricWithDims<any> {
    return {
      "namespace": "AWS/EC2",
      "metricName": "NetworkPacketsOut",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static statusCheckFailedSum(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "AWS/EC2",
      "metricName": "StatusCheckFailed",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static statusCheckFailedInstanceSum(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "AWS/EC2",
      "metricName": "StatusCheckFailed_Instance",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static statusCheckFailedSystemSum(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "AWS/EC2",
      "metricName": "StatusCheckFailed_System",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }
}

export class CWAgentMetrics {
  public static cpuUsageIdleAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "CWAgent",
      "metricName": "cpu_usage_idle",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static cpuUsageIowaitAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "CWAgent",
      "metricName": "cpu_usage_iowait",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static cpuUsageStealAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "CWAgent",
      "metricName": "cpu_usage_steal",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static cpuUsageSystemAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "CWAgent",
      "metricName": "cpu_usage_system",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static cpuUsageUserAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "CWAgent",
      "metricName": "cpu_usage_user",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static diskInodesFreeSum(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "CWAgent",
      "metricName": "disk_inodes_free",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static diskInodesTotalSum(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "CWAgent",
      "metricName": "disk_inodes_total",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static diskInodesUsedSum(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "CWAgent",
      "metricName": "disk_inodes_used",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static diskUsedPercentAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "CWAgent",
      "metricName": "disk_used_percent",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static diskioIoTimeAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "CWAgent",
      "metricName": "diskio_io_time",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static diskioReadBytesAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "CWAgent",
      "metricName": "diskio_read_bytes",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static diskioReadsAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "CWAgent",
      "metricName": "diskio_reads",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static diskioWriteBytesAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "CWAgent",
      "metricName": "diskio_write_bytes",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static diskioWritesAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "CWAgent",
      "metricName": "diskio_writes",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static memCachedAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "CWAgent",
      "metricName": "mem_cached",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static memTotalAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "CWAgent",
      "metricName": "mem_total",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static memUsedAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "CWAgent",
      "metricName": "mem_used",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static memUsedPercentAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "CWAgent",
      "metricName": "mem_used_percent",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static netstatTcpEstablishedSum(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "CWAgent",
      "metricName": "netstat_tcp_established",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static netstatTcpTimeWaitSum(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "CWAgent",
      "metricName": "netstat_tcp_time_wait",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static swapUsedPercentAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "CWAgent",
      "metricName": "swap_used_percent",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static tcPv4ConnectionsEstablishedSum(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "CWAgent",
      "metricName": "TCPv4 Connections Established",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static tcPv6ConnectionsEstablishedSum(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "CWAgent",
      "metricName": "TCPv6 Connections Established",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static memoryCommittedBytesInUseAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "CWAgent",
      "metricName": "Memory % Committed Bytes In Use",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static processorIdleTimeAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "CWAgent",
      "metricName": "Processor % Idle Time",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static processorInterruptTimeAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "CWAgent",
      "metricName": "Processor % Interrupt Time",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static processorUserTimeAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "CWAgent",
      "metricName": "Processor % User Time",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static logicalDiskFreeSpaceAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "CWAgent",
      "metricName": "LogicalDisk % Free Space",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static pagingFileUsageAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "CWAgent",
      "metricName": "Paging File % Usage",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }
}

export class NATGatewayMetrics {
  public static activeConnectionCountMaximum(dimensions: { NatGatewayId: string; }): MetricWithDims<{ NatGatewayId: string; }> {
    return {
      "namespace": "AWS/NATGateway",
      "metricName": "ActiveConnectionCount",
      "dimensionsMap": dimensions,
      "statistic": "Maximum"
    };
  }

  public static packetsDropCountSum(dimensions: { NatGatewayId: string; }): MetricWithDims<{ NatGatewayId: string; }> {
    return {
      "namespace": "AWS/NATGateway",
      "metricName": "PacketsDropCount",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static bytesInFromDestinationSum(dimensions: { NatGatewayId: string; }): MetricWithDims<{ NatGatewayId: string; }> {
    return {
      "namespace": "AWS/NATGateway",
      "metricName": "BytesInFromDestination",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static bytesInFromSourceSum(dimensions: { NatGatewayId: string; }): MetricWithDims<{ NatGatewayId: string; }> {
    return {
      "namespace": "AWS/NATGateway",
      "metricName": "BytesInFromSource",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static bytesOutToDestinationSum(dimensions: { NatGatewayId: string; }): MetricWithDims<{ NatGatewayId: string; }> {
    return {
      "namespace": "AWS/NATGateway",
      "metricName": "BytesOutToDestination",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static bytesOutToSourceSum(dimensions: { NatGatewayId: string; }): MetricWithDims<{ NatGatewayId: string; }> {
    return {
      "namespace": "AWS/NATGateway",
      "metricName": "BytesOutToSource",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static connectionAttemptCountSum(dimensions: { NatGatewayId: string; }): MetricWithDims<{ NatGatewayId: string; }> {
    return {
      "namespace": "AWS/NATGateway",
      "metricName": "ConnectionAttemptCount",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static connectionEstablishedCountSum(dimensions: { NatGatewayId: string; }): MetricWithDims<{ NatGatewayId: string; }> {
    return {
      "namespace": "AWS/NATGateway",
      "metricName": "ConnectionEstablishedCount",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static errorPortAllocationSum(dimensions: { NatGatewayId: string; }): MetricWithDims<{ NatGatewayId: string; }> {
    return {
      "namespace": "AWS/NATGateway",
      "metricName": "ErrorPortAllocation",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static idleTimeoutCountSum(dimensions: { NatGatewayId: string; }): MetricWithDims<{ NatGatewayId: string; }> {
    return {
      "namespace": "AWS/NATGateway",
      "metricName": "IdleTimeoutCount",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static packetsInFromDestinationSum(dimensions: { NatGatewayId: string; }): MetricWithDims<{ NatGatewayId: string; }> {
    return {
      "namespace": "AWS/NATGateway",
      "metricName": "PacketsInFromDestination",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static packetsInFromSourceSum(dimensions: { NatGatewayId: string; }): MetricWithDims<{ NatGatewayId: string; }> {
    return {
      "namespace": "AWS/NATGateway",
      "metricName": "PacketsInFromSource",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static packetsOutToDestinationSum(dimensions: { NatGatewayId: string; }): MetricWithDims<{ NatGatewayId: string; }> {
    return {
      "namespace": "AWS/NATGateway",
      "metricName": "PacketsOutToDestination",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static packetsOutToSourceSum(dimensions: { NatGatewayId: string; }): MetricWithDims<{ NatGatewayId: string; }> {
    return {
      "namespace": "AWS/NATGateway",
      "metricName": "PacketsOutToSource",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }
}

export class TransitGatewayMetrics {
  public static bytesInSum(dimensions: { TransitGateway: string; }): MetricWithDims<{ TransitGateway: string; }> {
    return {
      "namespace": "AWS/TransitGateway",
      "metricName": "BytesIn",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static bytesOutSum(dimensions: { TransitGateway: string; }): MetricWithDims<{ TransitGateway: string; }> {
    return {
      "namespace": "AWS/TransitGateway",
      "metricName": "BytesOut",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static packetDropCountBlackholeSum(dimensions: { TransitGateway: string; }): MetricWithDims<{ TransitGateway: string; }> {
    return {
      "namespace": "AWS/TransitGateway",
      "metricName": "PacketDropCountBlackhole",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static packetDropCountNoRouteSum(dimensions: { TransitGateway: string; }): MetricWithDims<{ TransitGateway: string; }> {
    return {
      "namespace": "AWS/TransitGateway",
      "metricName": "PacketDropCountNoRoute",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static packetsInSum(dimensions: { TransitGateway: string; }): MetricWithDims<{ TransitGateway: string; }> {
    return {
      "namespace": "AWS/TransitGateway",
      "metricName": "PacketsIn",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static packetsOutSum(dimensions: { TransitGateway: string; }): MetricWithDims<{ TransitGateway: string; }> {
    return {
      "namespace": "AWS/TransitGateway",
      "metricName": "PacketsOut",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }
}

export class VPNMetrics {
  public static tunnelDataInSum(dimensions: { VpnId: string; }): MetricWithDims<{ VpnId: string; }> {
    return {
      "namespace": "AWS/VPN",
      "metricName": "TunnelDataIn",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static tunnelStateAverage(dimensions: { VpnId: string; }): MetricWithDims<{ VpnId: string; }> {
    return {
      "namespace": "AWS/VPN",
      "metricName": "TunnelState",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static tunnelDataOutSum(dimensions: { VpnId: string; }): MetricWithDims<{ VpnId: string; }> {
    return {
      "namespace": "AWS/VPN",
      "metricName": "TunnelDataOut",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }
}",
  "module": "/* eslint-disable prettier/prettier,max-len */
import * as cdk from "aws-cdk-lib";
import * as constructs from "constructs";
import * as cfn_parse from "aws-cdk-lib/core/lib/helpers-internal";

/**
 * Creates a new Capacity Reservation with the specified attributes.
 *
 * For more information, see [Capacity Reservations](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-capacity-reservations.html) in the *Amazon EC2 User Guide* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html
 */
export class CfnCapacityReservation extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::CapacityReservation";

  /**
   * Build a CfnCapacityReservation from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnCapacityReservation {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnCapacityReservationPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnCapacityReservation(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * Returns the Availability Zone in which the capacity is reserved. For example: \`us-east-1a\` .
   *
   * @cloudformationAttribute AvailabilityZone
   */
  public readonly attrAvailabilityZone: string;

  /**
   * Returns the remaining capacity, which indicates the number of instances that can be launched in the Capacity Reservation. For example: \`9\` .
   *
   * @cloudformationAttribute AvailableInstanceCount
   */
  public readonly attrAvailableInstanceCount: number;

  /**
   * The ID of the Capacity Reservation.
   *
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * Returns the type of instance for which the capacity is reserved. For example: \`m4.large\` .
   *
   * @cloudformationAttribute InstanceType
   */
  public readonly attrInstanceType: string;

  /**
   * Returns the tenancy of the Capacity Reservation. For example: \`dedicated\` .
   *
   * @cloudformationAttribute Tenancy
   */
  public readonly attrTenancy: string;

  /**
   * Returns the total number of instances for which the Capacity Reservation reserves capacity. For example: \`15\` .
   *
   * @cloudformationAttribute TotalInstanceCount
   */
  public readonly attrTotalInstanceCount: number;

  /**
   * The Availability Zone in which to create the Capacity Reservation.
   */
  public availabilityZone: string;

  /**
   * Indicates whether the Capacity Reservation supports EBS-optimized instances.
   */
  public ebsOptimized?: boolean | cdk.IResolvable;

  /**
   * The date and time at which the Capacity Reservation expires.
   */
  public endDate?: string;

  /**
   * Indicates the way in which the Capacity Reservation ends.
   */
  public endDateType?: string;

  /**
   * *Deprecated.*.
   */
  public ephemeralStorage?: boolean | cdk.IResolvable;

  /**
   * The number of instances for which to reserve capacity.
   */
  public instanceCount: number;

  /**
   * Indicates the type of instance launches that the Capacity Reservation accepts. The options include:.
   */
  public instanceMatchCriteria?: string;

  /**
   * The type of operating system for which to reserve capacity.
   */
  public instancePlatform: string;

  /**
   * The instance type for which to reserve capacity.
   */
  public instanceType: string;

  /**
   * The Amazon Resource Name (ARN) of the Outpost on which to create the Capacity Reservation.
   */
  public outPostArn?: string;

  /**
   * The Amazon Resource Name (ARN) of the cluster placement group in which to create the Capacity Reservation.
   */
  public placementGroupArn?: string;

  /**
   * The tags to apply to the Capacity Reservation during launch.
   */
  public tagSpecifications?: Array<cdk.IResolvable | CfnCapacityReservation.TagSpecificationProperty> | cdk.IResolvable;

  /**
   * Indicates the tenancy of the Capacity Reservation. A Capacity Reservation can have one of the following tenancy settings:.
   */
  public tenancy?: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnCapacityReservationProps) {
    super(scope, id, {
      "type": CfnCapacityReservation.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "availabilityZone", this);
    cdk.requireProperty(props, "instanceCount", this);
    cdk.requireProperty(props, "instancePlatform", this);
    cdk.requireProperty(props, "instanceType", this);

    this.attrAvailabilityZone = cdk.Token.asString(this.getAtt("AvailabilityZone", cdk.ResolutionTypeHint.STRING));
    this.attrAvailableInstanceCount = cdk.Token.asNumber(this.getAtt("AvailableInstanceCount", cdk.ResolutionTypeHint.NUMBER));
    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.attrInstanceType = cdk.Token.asString(this.getAtt("InstanceType", cdk.ResolutionTypeHint.STRING));
    this.attrTenancy = cdk.Token.asString(this.getAtt("Tenancy", cdk.ResolutionTypeHint.STRING));
    this.attrTotalInstanceCount = cdk.Token.asNumber(this.getAtt("TotalInstanceCount", cdk.ResolutionTypeHint.NUMBER));
    this.availabilityZone = props.availabilityZone;
    this.ebsOptimized = props.ebsOptimized;
    this.endDate = props.endDate;
    this.endDateType = props.endDateType;
    this.ephemeralStorage = props.ephemeralStorage;
    this.instanceCount = props.instanceCount;
    this.instanceMatchCriteria = props.instanceMatchCriteria;
    this.instancePlatform = props.instancePlatform;
    this.instanceType = props.instanceType;
    this.outPostArn = props.outPostArn;
    this.placementGroupArn = props.placementGroupArn;
    this.tagSpecifications = props.tagSpecifications;
    this.tenancy = props.tenancy;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "availabilityZone": this.availabilityZone,
      "ebsOptimized": this.ebsOptimized,
      "endDate": this.endDate,
      "endDateType": this.endDateType,
      "ephemeralStorage": this.ephemeralStorage,
      "instanceCount": this.instanceCount,
      "instanceMatchCriteria": this.instanceMatchCriteria,
      "instancePlatform": this.instancePlatform,
      "instanceType": this.instanceType,
      "outPostArn": this.outPostArn,
      "placementGroupArn": this.placementGroupArn,
      "tagSpecifications": this.tagSpecifications,
      "tenancy": this.tenancy
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnCapacityReservation.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnCapacityReservationPropsToCloudFormation(props);
  }
}

export namespace CfnCapacityReservation {
  /**
   * An array of key-value pairs to apply to this resource.
   *
   * For more information, see [Tag](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html) .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservation-tagspecification.html
   */
  export interface TagSpecificationProperty {
    /**
     * The type of resource to tag.
     *
     * Specify \`capacity-reservation\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservation-tagspecification.html#cfn-ec2-capacityreservation-tagspecification-resourcetype
     */
    readonly resourceType?: string;

    /**
     * The tags to apply to the resource.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservation-tagspecification.html#cfn-ec2-capacityreservation-tagspecification-tags
     */
    readonly tags?: Array<cdk.CfnTag>;
  }
}

/**
 * Properties for defining a \`CfnCapacityReservation\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html
 */
export interface CfnCapacityReservationProps {
  /**
   * The Availability Zone in which to create the Capacity Reservation.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-availabilityzone
   */
  readonly availabilityZone: string;

  /**
   * Indicates whether the Capacity Reservation supports EBS-optimized instances.
   *
   * This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS- optimized instance.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-ebsoptimized
   */
  readonly ebsOptimized?: boolean | cdk.IResolvable;

  /**
   * The date and time at which the Capacity Reservation expires.
   *
   * When a Capacity Reservation expires, the reserved capacity is released and you can no longer launch instances into it. The Capacity Reservation's state changes to \`expired\` when it reaches its end date and time.
   *
   * You must provide an \`EndDate\` value if \`EndDateType\` is \`limited\` . Omit \`EndDate\` if \`EndDateType\` is \`unlimited\` .
   *
   * If the \`EndDateType\` is \`limited\` , the Capacity Reservation is cancelled within an hour from the specified time. For example, if you specify 5/31/2019, 13:30:55, the Capacity Reservation is guaranteed to end between 13:30:55 and 14:30:55 on 5/31/2019.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-enddate
   */
  readonly endDate?: string;

  /**
   * Indicates the way in which the Capacity Reservation ends.
   *
   * A Capacity Reservation can have one of the following end types:
   *
   * - \`unlimited\` - The Capacity Reservation remains active until you explicitly cancel it. Do not provide an \`EndDate\` if the \`EndDateType\` is \`unlimited\` .
   * - \`limited\` - The Capacity Reservation expires automatically at a specified date and time. You must provide an \`EndDate\` value if the \`EndDateType\` value is \`limited\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-enddatetype
   */
  readonly endDateType?: string;

  /**
   * *Deprecated.*.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-ephemeralstorage
   */
  readonly ephemeralStorage?: boolean | cdk.IResolvable;

  /**
   * The number of instances for which to reserve capacity.
   *
   * Valid range: 1 - 1000
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-instancecount
   */
  readonly instanceCount: number;

  /**
   * Indicates the type of instance launches that the Capacity Reservation accepts. The options include:.
   *
   * - \`open\` - The Capacity Reservation automatically matches all instances that have matching attributes (instance type, platform, and Availability Zone). Instances that have matching attributes run in the Capacity Reservation automatically without specifying any additional parameters.
   * - \`targeted\` - The Capacity Reservation only accepts instances that have matching attributes (instance type, platform, and Availability Zone), and explicitly target the Capacity Reservation. This ensures that only permitted instances can use the reserved capacity.
   *
   * Default: \`open\`
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-instancematchcriteria
   */
  readonly instanceMatchCriteria?: string;

  /**
   * The type of operating system for which to reserve capacity.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-instanceplatform
   */
  readonly instancePlatform: string;

  /**
   * The instance type for which to reserve capacity.
   *
   * For more information, see [Instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the *Amazon EC2 User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-instancetype
   */
  readonly instanceType: string;

  /**
   * The Amazon Resource Name (ARN) of the Outpost on which to create the Capacity Reservation.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-outpostarn
   */
  readonly outPostArn?: string;

  /**
   * The Amazon Resource Name (ARN) of the cluster placement group in which to create the Capacity Reservation.
   *
   * For more information, see [Capacity Reservations for cluster placement groups](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/cr-cpg.html) in the *Amazon EC2 User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-placementgrouparn
   */
  readonly placementGroupArn?: string;

  /**
   * The tags to apply to the Capacity Reservation during launch.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-tagspecifications
   */
  readonly tagSpecifications?: Array<cdk.IResolvable | CfnCapacityReservation.TagSpecificationProperty> | cdk.IResolvable;

  /**
   * Indicates the tenancy of the Capacity Reservation. A Capacity Reservation can have one of the following tenancy settings:.
   *
   * - \`default\` - The Capacity Reservation is created on hardware that is shared with other AWS accounts .
   * - \`dedicated\` - The Capacity Reservation is created on single-tenant hardware that is dedicated to a single AWS account .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-tenancy
   */
  readonly tenancy?: string;
}

/**
 * Determine whether the given properties match those of a \`TagSpecificationProperty\`
 *
 * @param properties - the TypeScript properties of a \`TagSpecificationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnCapacityReservationTagSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("resourceType", cdk.validateString)(properties.resourceType));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"TagSpecificationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnCapacityReservationTagSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnCapacityReservationTagSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "ResourceType": cdk.stringToCloudFormation(properties.resourceType),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnCapacityReservationTagSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnCapacityReservation.TagSpecificationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnCapacityReservation.TagSpecificationProperty>();
  ret.addPropertyResult("resourceType", "ResourceType", (properties.ResourceType != null ? cfn_parse.FromCloudFormation.getString(properties.ResourceType) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnCapacityReservationProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnCapacityReservationProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnCapacityReservationPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("availabilityZone", cdk.requiredValidator)(properties.availabilityZone));
  errors.collect(cdk.propertyValidator("availabilityZone", cdk.validateString)(properties.availabilityZone));
  errors.collect(cdk.propertyValidator("ebsOptimized", cdk.validateBoolean)(properties.ebsOptimized));
  errors.collect(cdk.propertyValidator("endDate", cdk.validateString)(properties.endDate));
  errors.collect(cdk.propertyValidator("endDateType", cdk.validateString)(properties.endDateType));
  errors.collect(cdk.propertyValidator("ephemeralStorage", cdk.validateBoolean)(properties.ephemeralStorage));
  errors.collect(cdk.propertyValidator("instanceCount", cdk.requiredValidator)(properties.instanceCount));
  errors.collect(cdk.propertyValidator("instanceCount", cdk.validateNumber)(properties.instanceCount));
  errors.collect(cdk.propertyValidator("instanceMatchCriteria", cdk.validateString)(properties.instanceMatchCriteria));
  errors.collect(cdk.propertyValidator("instancePlatform", cdk.requiredValidator)(properties.instancePlatform));
  errors.collect(cdk.propertyValidator("instancePlatform", cdk.validateString)(properties.instancePlatform));
  errors.collect(cdk.propertyValidator("instanceType", cdk.requiredValidator)(properties.instanceType));
  errors.collect(cdk.propertyValidator("instanceType", cdk.validateString)(properties.instanceType));
  errors.collect(cdk.propertyValidator("outPostArn", cdk.validateString)(properties.outPostArn));
  errors.collect(cdk.propertyValidator("placementGroupArn", cdk.validateString)(properties.placementGroupArn));
  errors.collect(cdk.propertyValidator("tagSpecifications", cdk.listValidator(CfnCapacityReservationTagSpecificationPropertyValidator))(properties.tagSpecifications));
  errors.collect(cdk.propertyValidator("tenancy", cdk.validateString)(properties.tenancy));
  return errors.wrap("supplied properties not correct for \\"CfnCapacityReservationProps\\"");
}

// @ts-ignore TS6133
function convertCfnCapacityReservationPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnCapacityReservationPropsValidator(properties).assertSuccess();
  return {
    "AvailabilityZone": cdk.stringToCloudFormation(properties.availabilityZone),
    "EbsOptimized": cdk.booleanToCloudFormation(properties.ebsOptimized),
    "EndDate": cdk.stringToCloudFormation(properties.endDate),
    "EndDateType": cdk.stringToCloudFormation(properties.endDateType),
    "EphemeralStorage": cdk.booleanToCloudFormation(properties.ephemeralStorage),
    "InstanceCount": cdk.numberToCloudFormation(properties.instanceCount),
    "InstanceMatchCriteria": cdk.stringToCloudFormation(properties.instanceMatchCriteria),
    "InstancePlatform": cdk.stringToCloudFormation(properties.instancePlatform),
    "InstanceType": cdk.stringToCloudFormation(properties.instanceType),
    "OutPostArn": cdk.stringToCloudFormation(properties.outPostArn),
    "PlacementGroupArn": cdk.stringToCloudFormation(properties.placementGroupArn),
    "TagSpecifications": cdk.listMapper(convertCfnCapacityReservationTagSpecificationPropertyToCloudFormation)(properties.tagSpecifications),
    "Tenancy": cdk.stringToCloudFormation(properties.tenancy)
  };
}

// @ts-ignore TS6133
function CfnCapacityReservationPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnCapacityReservationProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnCapacityReservationProps>();
  ret.addPropertyResult("availabilityZone", "AvailabilityZone", (properties.AvailabilityZone != null ? cfn_parse.FromCloudFormation.getString(properties.AvailabilityZone) : undefined));
  ret.addPropertyResult("ebsOptimized", "EbsOptimized", (properties.EbsOptimized != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EbsOptimized) : undefined));
  ret.addPropertyResult("endDate", "EndDate", (properties.EndDate != null ? cfn_parse.FromCloudFormation.getString(properties.EndDate) : undefined));
  ret.addPropertyResult("endDateType", "EndDateType", (properties.EndDateType != null ? cfn_parse.FromCloudFormation.getString(properties.EndDateType) : undefined));
  ret.addPropertyResult("ephemeralStorage", "EphemeralStorage", (properties.EphemeralStorage != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EphemeralStorage) : undefined));
  ret.addPropertyResult("instanceCount", "InstanceCount", (properties.InstanceCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.InstanceCount) : undefined));
  ret.addPropertyResult("instanceMatchCriteria", "InstanceMatchCriteria", (properties.InstanceMatchCriteria != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceMatchCriteria) : undefined));
  ret.addPropertyResult("instancePlatform", "InstancePlatform", (properties.InstancePlatform != null ? cfn_parse.FromCloudFormation.getString(properties.InstancePlatform) : undefined));
  ret.addPropertyResult("instanceType", "InstanceType", (properties.InstanceType != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceType) : undefined));
  ret.addPropertyResult("outPostArn", "OutPostArn", (properties.OutPostArn != null ? cfn_parse.FromCloudFormation.getString(properties.OutPostArn) : undefined));
  ret.addPropertyResult("placementGroupArn", "PlacementGroupArn", (properties.PlacementGroupArn != null ? cfn_parse.FromCloudFormation.getString(properties.PlacementGroupArn) : undefined));
  ret.addPropertyResult("tagSpecifications", "TagSpecifications", (properties.TagSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnCapacityReservationTagSpecificationPropertyFromCloudFormation)(properties.TagSpecifications) : undefined));
  ret.addPropertyResult("tenancy", "Tenancy", (properties.Tenancy != null ? cfn_parse.FromCloudFormation.getString(properties.Tenancy) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Creates a new Capacity Reservation Fleet with the specified attributes.
 *
 * For more information, see [Capacity Reservation Fleets](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/cr-fleets.html) in the *Amazon EC2 User Guide* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html
 */
export class CfnCapacityReservationFleet extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::CapacityReservationFleet";

  /**
   * Build a CfnCapacityReservationFleet from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnCapacityReservationFleet {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnCapacityReservationFleetPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnCapacityReservationFleet(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the Capacity Reservation Fleet.
   *
   * @cloudformationAttribute CapacityReservationFleetId
   */
  public readonly attrCapacityReservationFleetId: string;

  /**
   * The strategy used by the Capacity Reservation Fleet to determine which of the specified instance types to use.
   */
  public allocationStrategy?: string;

  /**
   * The date and time at which the Capacity Reservation Fleet expires.
   */
  public endDate?: string;

  /**
   * Indicates the type of instance launches that the Capacity Reservation Fleet accepts.
   */
  public instanceMatchCriteria?: string;

  /**
   * Information about the instance types for which to reserve the capacity.
   */
  public instanceTypeSpecifications?: Array<CfnCapacityReservationFleet.InstanceTypeSpecificationProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * Used to add an end date to a Capacity Reservation Fleet that has no end date and time.
   */
  public noRemoveEndDate?: boolean | cdk.IResolvable;

  /**
   * Used to remove an end date from a Capacity Reservation Fleet that is configured to end automatically at a specific date and time.
   */
  public removeEndDate?: boolean | cdk.IResolvable;

  /**
   * The tags to assign to the Capacity Reservation Fleet.
   */
  public tagSpecifications?: Array<cdk.IResolvable | CfnCapacityReservationFleet.TagSpecificationProperty> | cdk.IResolvable;

  /**
   * Indicates the tenancy of the Capacity Reservation Fleet.
   */
  public tenancy?: string;

  /**
   * The total number of capacity units to be reserved by the Capacity Reservation Fleet.
   */
  public totalTargetCapacity?: number;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnCapacityReservationFleetProps = {}) {
    super(scope, id, {
      "type": CfnCapacityReservationFleet.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.attrCapacityReservationFleetId = cdk.Token.asString(this.getAtt("CapacityReservationFleetId", cdk.ResolutionTypeHint.STRING));
    this.allocationStrategy = props.allocationStrategy;
    this.endDate = props.endDate;
    this.instanceMatchCriteria = props.instanceMatchCriteria;
    this.instanceTypeSpecifications = props.instanceTypeSpecifications;
    this.noRemoveEndDate = props.noRemoveEndDate;
    this.removeEndDate = props.removeEndDate;
    this.tagSpecifications = props.tagSpecifications;
    this.tenancy = props.tenancy;
    this.totalTargetCapacity = props.totalTargetCapacity;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "allocationStrategy": this.allocationStrategy,
      "endDate": this.endDate,
      "instanceMatchCriteria": this.instanceMatchCriteria,
      "instanceTypeSpecifications": this.instanceTypeSpecifications,
      "noRemoveEndDate": this.noRemoveEndDate,
      "removeEndDate": this.removeEndDate,
      "tagSpecifications": this.tagSpecifications,
      "tenancy": this.tenancy,
      "totalTargetCapacity": this.totalTargetCapacity
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnCapacityReservationFleet.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnCapacityReservationFleetPropsToCloudFormation(props);
  }
}

export namespace CfnCapacityReservationFleet {
  /**
   * The tags to apply to a resource when the resource is being created.
   *
   * When you specify a tag, you must specify the resource type to tag, otherwise the request will fail.
   *
   * > The \`Valid Values\` lists all the resource types that can be tagged. However, the action you're using might not support tagging all of these resource types. If you try to tag a resource type that is unsupported for the action you're using, you'll get an error.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-tagspecification.html
   */
  export interface TagSpecificationProperty {
    /**
     * The type of resource to tag on creation. Specify \`capacity-reservation-fleet\` .
     *
     * To tag a resource after it has been created, see [CreateTags](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateTags.html) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-tagspecification.html#cfn-ec2-capacityreservationfleet-tagspecification-resourcetype
     */
    readonly resourceType?: string;

    /**
     * The tags to apply to the resource.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-tagspecification.html#cfn-ec2-capacityreservationfleet-tagspecification-tags
     */
    readonly tags?: Array<cdk.CfnTag>;
  }

  /**
   * Specifies information about an instance type to use in a Capacity Reservation Fleet.
   *
   * \`InstanceTypeSpecification\` is a property of the [AWS::EC2::CapacityReservationFleet](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html) resource.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-instancetypespecification.html
   */
  export interface InstanceTypeSpecificationProperty {
    /**
     * The Availability Zone in which the Capacity Reservation Fleet reserves the capacity.
     *
     * A Capacity Reservation Fleet can't span Availability Zones. All instance type specifications that you specify for the Fleet must use the same Availability Zone.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-instancetypespecification.html#cfn-ec2-capacityreservationfleet-instancetypespecification-availabilityzone
     */
    readonly availabilityZone?: string;

    /**
     * The ID of the Availability Zone in which the Capacity Reservation Fleet reserves the capacity.
     *
     * A Capacity Reservation Fleet can't span Availability Zones. All instance type specifications that you specify for the Fleet must use the same Availability Zone.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-instancetypespecification.html#cfn-ec2-capacityreservationfleet-instancetypespecification-availabilityzoneid
     */
    readonly availabilityZoneId?: string;

    /**
     * Indicates whether the Capacity Reservation Fleet supports EBS-optimized instances types.
     *
     * This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using EBS-optimized instance types.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-instancetypespecification.html#cfn-ec2-capacityreservationfleet-instancetypespecification-ebsoptimized
     */
    readonly ebsOptimized?: boolean | cdk.IResolvable;

    /**
     * The type of operating system for which the Capacity Reservation Fleet reserves capacity.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-instancetypespecification.html#cfn-ec2-capacityreservationfleet-instancetypespecification-instanceplatform
     */
    readonly instancePlatform?: string;

    /**
     * The instance type for which the Capacity Reservation Fleet reserves capacity.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-instancetypespecification.html#cfn-ec2-capacityreservationfleet-instancetypespecification-instancetype
     */
    readonly instanceType?: string;

    /**
     * The priority to assign to the instance type.
     *
     * This value is used to determine which of the instance types specified for the Fleet should be prioritized for use. A lower value indicates a high priority. For more information, see [Instance type priority](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/crfleet-concepts.html#instance-priority) in the Amazon EC2 User Guide.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-instancetypespecification.html#cfn-ec2-capacityreservationfleet-instancetypespecification-priority
     */
    readonly priority?: number;

    /**
     * The number of capacity units provided by the specified instance type.
     *
     * This value, together with the total target capacity that you specify for the Fleet determine the number of instances for which the Fleet reserves capacity. Both values are based on units that make sense for your workload. For more information, see [Total target capacity](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/crfleet-concepts.html#target-capacity) in the Amazon EC2 User Guide.
     *
     * Valid Range: Minimum value of \`0.001\` . Maximum value of \`99.999\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-instancetypespecification.html#cfn-ec2-capacityreservationfleet-instancetypespecification-weight
     */
    readonly weight?: number;
  }
}

/**
 * Properties for defining a \`CfnCapacityReservationFleet\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html
 */
export interface CfnCapacityReservationFleetProps {
  /**
   * The strategy used by the Capacity Reservation Fleet to determine which of the specified instance types to use.
   *
   * Currently, only the \`prioritized\` allocation strategy is supported. For more information, see [Allocation strategy](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/crfleet-concepts.html#allocation-strategy) in the Amazon EC2 User Guide.
   *
   * Valid values: \`prioritized\`
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-allocationstrategy
   */
  readonly allocationStrategy?: string;

  /**
   * The date and time at which the Capacity Reservation Fleet expires.
   *
   * When the Capacity Reservation Fleet expires, its state changes to \`expired\` and all of the Capacity Reservations in the Fleet expire.
   *
   * The Capacity Reservation Fleet expires within an hour after the specified time. For example, if you specify \`5/31/2019\` , \`13:30:55\` , the Capacity Reservation Fleet is guaranteed to expire between \`13:30:55\` and \`14:30:55\` on \`5/31/2019\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-enddate
   */
  readonly endDate?: string;

  /**
   * Indicates the type of instance launches that the Capacity Reservation Fleet accepts.
   *
   * All Capacity Reservations in the Fleet inherit this instance matching criteria.
   *
   * Currently, Capacity Reservation Fleets support \`open\` instance matching criteria only. This means that instances that have matching attributes (instance type, platform, and Availability Zone) run in the Capacity Reservations automatically. Instances do not need to explicitly target a Capacity Reservation Fleet to use its reserved capacity.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-instancematchcriteria
   */
  readonly instanceMatchCriteria?: string;

  /**
   * Information about the instance types for which to reserve the capacity.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-instancetypespecifications
   */
  readonly instanceTypeSpecifications?: Array<CfnCapacityReservationFleet.InstanceTypeSpecificationProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * Used to add an end date to a Capacity Reservation Fleet that has no end date and time.
   *
   * To add an end date to a Capacity Reservation Fleet, specify \`true\` for this paramater and specify the end date and time (in UTC time format) for the *EndDate* parameter.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-noremoveenddate
   */
  readonly noRemoveEndDate?: boolean | cdk.IResolvable;

  /**
   * Used to remove an end date from a Capacity Reservation Fleet that is configured to end automatically at a specific date and time.
   *
   * To remove the end date from a Capacity Reservation Fleet, specify \`true\` for this paramater and omit the *EndDate* parameter.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-removeenddate
   */
  readonly removeEndDate?: boolean | cdk.IResolvable;

  /**
   * The tags to assign to the Capacity Reservation Fleet.
   *
   * The tags are automatically assigned to the Capacity Reservations in the Fleet.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-tagspecifications
   */
  readonly tagSpecifications?: Array<cdk.IResolvable | CfnCapacityReservationFleet.TagSpecificationProperty> | cdk.IResolvable;

  /**
   * Indicates the tenancy of the Capacity Reservation Fleet.
   *
   * All Capacity Reservations in the Fleet inherit this tenancy. The Capacity Reservation Fleet can have one of the following tenancy settings:
   *
   * - \`default\` - The Capacity Reservation Fleet is created on hardware that is shared with other AWS accounts .
   * - \`dedicated\` - The Capacity Reservations are created on single-tenant hardware that is dedicated to a single AWS account .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-tenancy
   */
  readonly tenancy?: string;

  /**
   * The total number of capacity units to be reserved by the Capacity Reservation Fleet.
   *
   * This value, together with the instance type weights that you assign to each instance type used by the Fleet determine the number of instances for which the Fleet reserves capacity. Both values are based on units that make sense for your workload. For more information, see [Total target capacity](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/crfleet-concepts.html#target-capacity) in the Amazon EC2 User Guide.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-totaltargetcapacity
   */
  readonly totalTargetCapacity?: number;
}

/**
 * Determine whether the given properties match those of a \`TagSpecificationProperty\`
 *
 * @param properties - the TypeScript properties of a \`TagSpecificationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnCapacityReservationFleetTagSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("resourceType", cdk.validateString)(properties.resourceType));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"TagSpecificationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnCapacityReservationFleetTagSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnCapacityReservationFleetTagSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "ResourceType": cdk.stringToCloudFormation(properties.resourceType),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnCapacityReservationFleetTagSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnCapacityReservationFleet.TagSpecificationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnCapacityReservationFleet.TagSpecificationProperty>();
  ret.addPropertyResult("resourceType", "ResourceType", (properties.ResourceType != null ? cfn_parse.FromCloudFormation.getString(properties.ResourceType) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`InstanceTypeSpecificationProperty\`
 *
 * @param properties - the TypeScript properties of a \`InstanceTypeSpecificationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnCapacityReservationFleetInstanceTypeSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("availabilityZone", cdk.validateString)(properties.availabilityZone));
  errors.collect(cdk.propertyValidator("availabilityZoneId", cdk.validateString)(properties.availabilityZoneId));
  errors.collect(cdk.propertyValidator("ebsOptimized", cdk.validateBoolean)(properties.ebsOptimized));
  errors.collect(cdk.propertyValidator("instancePlatform", cdk.validateString)(properties.instancePlatform));
  errors.collect(cdk.propertyValidator("instanceType", cdk.validateString)(properties.instanceType));
  errors.collect(cdk.propertyValidator("priority", cdk.validateNumber)(properties.priority));
  errors.collect(cdk.propertyValidator("weight", cdk.validateNumber)(properties.weight));
  return errors.wrap("supplied properties not correct for \\"InstanceTypeSpecificationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnCapacityReservationFleetInstanceTypeSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnCapacityReservationFleetInstanceTypeSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "AvailabilityZone": cdk.stringToCloudFormation(properties.availabilityZone),
    "AvailabilityZoneId": cdk.stringToCloudFormation(properties.availabilityZoneId),
    "EbsOptimized": cdk.booleanToCloudFormation(properties.ebsOptimized),
    "InstancePlatform": cdk.stringToCloudFormation(properties.instancePlatform),
    "InstanceType": cdk.stringToCloudFormation(properties.instanceType),
    "Priority": cdk.numberToCloudFormation(properties.priority),
    "Weight": cdk.numberToCloudFormation(properties.weight)
  };
}

// @ts-ignore TS6133
function CfnCapacityReservationFleetInstanceTypeSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnCapacityReservationFleet.InstanceTypeSpecificationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnCapacityReservationFleet.InstanceTypeSpecificationProperty>();
  ret.addPropertyResult("availabilityZone", "AvailabilityZone", (properties.AvailabilityZone != null ? cfn_parse.FromCloudFormation.getString(properties.AvailabilityZone) : undefined));
  ret.addPropertyResult("availabilityZoneId", "AvailabilityZoneId", (properties.AvailabilityZoneId != null ? cfn_parse.FromCloudFormation.getString(properties.AvailabilityZoneId) : undefined));
  ret.addPropertyResult("ebsOptimized", "EbsOptimized", (properties.EbsOptimized != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EbsOptimized) : undefined));
  ret.addPropertyResult("instancePlatform", "InstancePlatform", (properties.InstancePlatform != null ? cfn_parse.FromCloudFormation.getString(properties.InstancePlatform) : undefined));
  ret.addPropertyResult("instanceType", "InstanceType", (properties.InstanceType != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceType) : undefined));
  ret.addPropertyResult("priority", "Priority", (properties.Priority != null ? cfn_parse.FromCloudFormation.getNumber(properties.Priority) : undefined));
  ret.addPropertyResult("weight", "Weight", (properties.Weight != null ? cfn_parse.FromCloudFormation.getNumber(properties.Weight) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnCapacityReservationFleetProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnCapacityReservationFleetProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnCapacityReservationFleetPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("allocationStrategy", cdk.validateString)(properties.allocationStrategy));
  errors.collect(cdk.propertyValidator("endDate", cdk.validateString)(properties.endDate));
  errors.collect(cdk.propertyValidator("instanceMatchCriteria", cdk.validateString)(properties.instanceMatchCriteria));
  errors.collect(cdk.propertyValidator("instanceTypeSpecifications", cdk.listValidator(CfnCapacityReservationFleetInstanceTypeSpecificationPropertyValidator))(properties.instanceTypeSpecifications));
  errors.collect(cdk.propertyValidator("noRemoveEndDate", cdk.validateBoolean)(properties.noRemoveEndDate));
  errors.collect(cdk.propertyValidator("removeEndDate", cdk.validateBoolean)(properties.removeEndDate));
  errors.collect(cdk.propertyValidator("tagSpecifications", cdk.listValidator(CfnCapacityReservationFleetTagSpecificationPropertyValidator))(properties.tagSpecifications));
  errors.collect(cdk.propertyValidator("tenancy", cdk.validateString)(properties.tenancy));
  errors.collect(cdk.propertyValidator("totalTargetCapacity", cdk.validateNumber)(properties.totalTargetCapacity));
  return errors.wrap("supplied properties not correct for \\"CfnCapacityReservationFleetProps\\"");
}

// @ts-ignore TS6133
function convertCfnCapacityReservationFleetPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnCapacityReservationFleetPropsValidator(properties).assertSuccess();
  return {
    "AllocationStrategy": cdk.stringToCloudFormation(properties.allocationStrategy),
    "EndDate": cdk.stringToCloudFormation(properties.endDate),
    "InstanceMatchCriteria": cdk.stringToCloudFormation(properties.instanceMatchCriteria),
    "InstanceTypeSpecifications": cdk.listMapper(convertCfnCapacityReservationFleetInstanceTypeSpecificationPropertyToCloudFormation)(properties.instanceTypeSpecifications),
    "NoRemoveEndDate": cdk.booleanToCloudFormation(properties.noRemoveEndDate),
    "RemoveEndDate": cdk.booleanToCloudFormation(properties.removeEndDate),
    "TagSpecifications": cdk.listMapper(convertCfnCapacityReservationFleetTagSpecificationPropertyToCloudFormation)(properties.tagSpecifications),
    "Tenancy": cdk.stringToCloudFormation(properties.tenancy),
    "TotalTargetCapacity": cdk.numberToCloudFormation(properties.totalTargetCapacity)
  };
}

// @ts-ignore TS6133
function CfnCapacityReservationFleetPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnCapacityReservationFleetProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnCapacityReservationFleetProps>();
  ret.addPropertyResult("allocationStrategy", "AllocationStrategy", (properties.AllocationStrategy != null ? cfn_parse.FromCloudFormation.getString(properties.AllocationStrategy) : undefined));
  ret.addPropertyResult("endDate", "EndDate", (properties.EndDate != null ? cfn_parse.FromCloudFormation.getString(properties.EndDate) : undefined));
  ret.addPropertyResult("instanceMatchCriteria", "InstanceMatchCriteria", (properties.InstanceMatchCriteria != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceMatchCriteria) : undefined));
  ret.addPropertyResult("instanceTypeSpecifications", "InstanceTypeSpecifications", (properties.InstanceTypeSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnCapacityReservationFleetInstanceTypeSpecificationPropertyFromCloudFormation)(properties.InstanceTypeSpecifications) : undefined));
  ret.addPropertyResult("noRemoveEndDate", "NoRemoveEndDate", (properties.NoRemoveEndDate != null ? cfn_parse.FromCloudFormation.getBoolean(properties.NoRemoveEndDate) : undefined));
  ret.addPropertyResult("removeEndDate", "RemoveEndDate", (properties.RemoveEndDate != null ? cfn_parse.FromCloudFormation.getBoolean(properties.RemoveEndDate) : undefined));
  ret.addPropertyResult("tagSpecifications", "TagSpecifications", (properties.TagSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnCapacityReservationFleetTagSpecificationPropertyFromCloudFormation)(properties.TagSpecifications) : undefined));
  ret.addPropertyResult("tenancy", "Tenancy", (properties.Tenancy != null ? cfn_parse.FromCloudFormation.getString(properties.Tenancy) : undefined));
  ret.addPropertyResult("totalTargetCapacity", "TotalTargetCapacity", (properties.TotalTargetCapacity != null ? cfn_parse.FromCloudFormation.getNumber(properties.TotalTargetCapacity) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Creates a carrier gateway.
 *
 * For more information about carrier gateways, see [Carrier gateways](https://docs.aws.amazon.com/wavelength/latest/developerguide/how-wavelengths-work.html#wavelength-carrier-gateway) in the *AWS Wavelength Developer Guide* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-carriergateway.html
 */
export class CfnCarrierGateway extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::CarrierGateway";

  /**
   * Build a CfnCarrierGateway from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnCarrierGateway {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnCarrierGatewayPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnCarrierGateway(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the carrier gateway.
   *
   * @cloudformationAttribute CarrierGatewayId
   */
  public readonly attrCarrierGatewayId: string;

  /**
   * The AWS account ID of the owner of the carrier gateway.
   *
   * @cloudformationAttribute OwnerId
   */
  public readonly attrOwnerId: string;

  /**
   * The state of the carrier gateway.
   *
   * @cloudformationAttribute State
   */
  public readonly attrState: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags assigned to the carrier gateway.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The ID of the VPC associated with the carrier gateway.
   */
  public vpcId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnCarrierGatewayProps) {
    super(scope, id, {
      "type": CfnCarrierGateway.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "vpcId", this);

    this.attrCarrierGatewayId = cdk.Token.asString(this.getAtt("CarrierGatewayId", cdk.ResolutionTypeHint.STRING));
    this.attrOwnerId = cdk.Token.asString(this.getAtt("OwnerId", cdk.ResolutionTypeHint.STRING));
    this.attrState = cdk.Token.asString(this.getAtt("State", cdk.ResolutionTypeHint.STRING));
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::CarrierGateway", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.vpcId = props.vpcId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "tags": this.tags.renderTags(),
      "vpcId": this.vpcId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnCarrierGateway.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnCarrierGatewayPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnCarrierGateway\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-carriergateway.html
 */
export interface CfnCarrierGatewayProps {
  /**
   * The tags assigned to the carrier gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-carriergateway.html#cfn-ec2-carriergateway-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The ID of the VPC associated with the carrier gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-carriergateway.html#cfn-ec2-carriergateway-vpcid
   */
  readonly vpcId: string;
}

/**
 * Determine whether the given properties match those of a \`CfnCarrierGatewayProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnCarrierGatewayProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnCarrierGatewayPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("vpcId", cdk.requiredValidator)(properties.vpcId));
  errors.collect(cdk.propertyValidator("vpcId", cdk.validateString)(properties.vpcId));
  return errors.wrap("supplied properties not correct for \\"CfnCarrierGatewayProps\\"");
}

// @ts-ignore TS6133
function convertCfnCarrierGatewayPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnCarrierGatewayPropsValidator(properties).assertSuccess();
  return {
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "VpcId": cdk.stringToCloudFormation(properties.vpcId)
  };
}

// @ts-ignore TS6133
function CfnCarrierGatewayPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnCarrierGatewayProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnCarrierGatewayProps>();
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("vpcId", "VpcId", (properties.VpcId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies an ingress authorization rule to add to a Client VPN endpoint.
 *
 * Ingress authorization rules act as firewall rules that grant access to networks. You must configure ingress authorization rules to enable clients to access resources in AWS or on-premises networks.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnauthorizationrule.html
 */
export class CfnClientVpnAuthorizationRule extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::ClientVpnAuthorizationRule";

  /**
   * Build a CfnClientVpnAuthorizationRule from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnClientVpnAuthorizationRule {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnClientVpnAuthorizationRulePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnClientVpnAuthorizationRule(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The ID of the group to grant access to, for example, the Active Directory group or identity provider (IdP) group.
   */
  public accessGroupId?: string;

  /**
   * Indicates whether to grant access to all clients.
   */
  public authorizeAllGroups?: boolean | cdk.IResolvable;

  /**
   * The ID of the Client VPN endpoint.
   */
  public clientVpnEndpointId: string;

  /**
   * A brief description of the authorization rule.
   */
  public description?: string;

  /**
   * The IPv4 address range, in CIDR notation, of the network for which access is being authorized.
   */
  public targetNetworkCidr: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnClientVpnAuthorizationRuleProps) {
    super(scope, id, {
      "type": CfnClientVpnAuthorizationRule.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "clientVpnEndpointId", this);
    cdk.requireProperty(props, "targetNetworkCidr", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.accessGroupId = props.accessGroupId;
    this.authorizeAllGroups = props.authorizeAllGroups;
    this.clientVpnEndpointId = props.clientVpnEndpointId;
    this.description = props.description;
    this.targetNetworkCidr = props.targetNetworkCidr;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "accessGroupId": this.accessGroupId,
      "authorizeAllGroups": this.authorizeAllGroups,
      "clientVpnEndpointId": this.clientVpnEndpointId,
      "description": this.description,
      "targetNetworkCidr": this.targetNetworkCidr
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnClientVpnAuthorizationRule.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnClientVpnAuthorizationRulePropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnClientVpnAuthorizationRule\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnauthorizationrule.html
 */
export interface CfnClientVpnAuthorizationRuleProps {
  /**
   * The ID of the group to grant access to, for example, the Active Directory group or identity provider (IdP) group.
   *
   * Required if \`AuthorizeAllGroups\` is \`false\` or not specified.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnauthorizationrule.html#cfn-ec2-clientvpnauthorizationrule-accessgroupid
   */
  readonly accessGroupId?: string;

  /**
   * Indicates whether to grant access to all clients.
   *
   * Specify \`true\` to grant all clients who successfully establish a VPN connection access to the network. Must be set to \`true\` if \`AccessGroupId\` is not specified.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnauthorizationrule.html#cfn-ec2-clientvpnauthorizationrule-authorizeallgroups
   */
  readonly authorizeAllGroups?: boolean | cdk.IResolvable;

  /**
   * The ID of the Client VPN endpoint.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnauthorizationrule.html#cfn-ec2-clientvpnauthorizationrule-clientvpnendpointid
   */
  readonly clientVpnEndpointId: string;

  /**
   * A brief description of the authorization rule.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnauthorizationrule.html#cfn-ec2-clientvpnauthorizationrule-description
   */
  readonly description?: string;

  /**
   * The IPv4 address range, in CIDR notation, of the network for which access is being authorized.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnauthorizationrule.html#cfn-ec2-clientvpnauthorizationrule-targetnetworkcidr
   */
  readonly targetNetworkCidr: string;
}

/**
 * Determine whether the given properties match those of a \`CfnClientVpnAuthorizationRuleProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnClientVpnAuthorizationRuleProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnClientVpnAuthorizationRulePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("accessGroupId", cdk.validateString)(properties.accessGroupId));
  errors.collect(cdk.propertyValidator("authorizeAllGroups", cdk.validateBoolean)(properties.authorizeAllGroups));
  errors.collect(cdk.propertyValidator("clientVpnEndpointId", cdk.requiredValidator)(properties.clientVpnEndpointId));
  errors.collect(cdk.propertyValidator("clientVpnEndpointId", cdk.validateString)(properties.clientVpnEndpointId));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("targetNetworkCidr", cdk.requiredValidator)(properties.targetNetworkCidr));
  errors.collect(cdk.propertyValidator("targetNetworkCidr", cdk.validateString)(properties.targetNetworkCidr));
  return errors.wrap("supplied properties not correct for \\"CfnClientVpnAuthorizationRuleProps\\"");
}

// @ts-ignore TS6133
function convertCfnClientVpnAuthorizationRulePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnClientVpnAuthorizationRulePropsValidator(properties).assertSuccess();
  return {
    "AccessGroupId": cdk.stringToCloudFormation(properties.accessGroupId),
    "AuthorizeAllGroups": cdk.booleanToCloudFormation(properties.authorizeAllGroups),
    "ClientVpnEndpointId": cdk.stringToCloudFormation(properties.clientVpnEndpointId),
    "Description": cdk.stringToCloudFormation(properties.description),
    "TargetNetworkCidr": cdk.stringToCloudFormation(properties.targetNetworkCidr)
  };
}

// @ts-ignore TS6133
function CfnClientVpnAuthorizationRulePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnClientVpnAuthorizationRuleProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnClientVpnAuthorizationRuleProps>();
  ret.addPropertyResult("accessGroupId", "AccessGroupId", (properties.AccessGroupId != null ? cfn_parse.FromCloudFormation.getString(properties.AccessGroupId) : undefined));
  ret.addPropertyResult("authorizeAllGroups", "AuthorizeAllGroups", (properties.AuthorizeAllGroups != null ? cfn_parse.FromCloudFormation.getBoolean(properties.AuthorizeAllGroups) : undefined));
  ret.addPropertyResult("clientVpnEndpointId", "ClientVpnEndpointId", (properties.ClientVpnEndpointId != null ? cfn_parse.FromCloudFormation.getString(properties.ClientVpnEndpointId) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("targetNetworkCidr", "TargetNetworkCidr", (properties.TargetNetworkCidr != null ? cfn_parse.FromCloudFormation.getString(properties.TargetNetworkCidr) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a Client VPN endpoint.
 *
 * A Client VPN endpoint is the resource you create and configure to enable and manage client VPN sessions. It is the destination endpoint at which all client VPN sessions are terminated.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html
 */
export class CfnClientVpnEndpoint extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::ClientVpnEndpoint";

  /**
   * Build a CfnClientVpnEndpoint from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnClientVpnEndpoint {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnClientVpnEndpointPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnClientVpnEndpoint(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * Information about the authentication method to be used to authenticate clients.
   */
  public authenticationOptions: Array<CfnClientVpnEndpoint.ClientAuthenticationRequestProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * The IPv4 address range, in CIDR notation, from which to assign client IP addresses.
   */
  public clientCidrBlock: string;

  /**
   * The options for managing connection authorization for new client connections.
   */
  public clientConnectOptions?: CfnClientVpnEndpoint.ClientConnectOptionsProperty | cdk.IResolvable;

  /**
   * Options for enabling a customizable text banner that will be displayed on AWS provided clients when a VPN session is established.
   */
  public clientLoginBannerOptions?: CfnClientVpnEndpoint.ClientLoginBannerOptionsProperty | cdk.IResolvable;

  /**
   * Information about the client connection logging options.
   */
  public connectionLogOptions: CfnClientVpnEndpoint.ConnectionLogOptionsProperty | cdk.IResolvable;

  /**
   * A brief description of the Client VPN endpoint.
   */
  public description?: string;

  /**
   * Information about the DNS servers to be used for DNS resolution.
   */
  public dnsServers?: Array<string>;

  /**
   * The IDs of one or more security groups to apply to the target network.
   */
  public securityGroupIds?: Array<string>;

  /**
   * Specify whether to enable the self-service portal for the Client VPN endpoint.
   */
  public selfServicePortal?: string;

  /**
   * The ARN of the server certificate.
   */
  public serverCertificateArn: string;

  /**
   * The maximum VPN session duration time in hours.
   */
  public sessionTimeoutHours?: number;

  /**
   * Indicates whether split-tunnel is enabled on the AWS Client VPN endpoint.
   */
  public splitTunnel?: boolean | cdk.IResolvable;

  /**
   * The tags to apply to the Client VPN endpoint during creation.
   */
  public tagSpecifications?: Array<cdk.IResolvable | CfnClientVpnEndpoint.TagSpecificationProperty> | cdk.IResolvable;

  /**
   * The transport protocol to be used by the VPN session.
   */
  public transportProtocol?: string;

  /**
   * The ID of the VPC to associate with the Client VPN endpoint.
   */
  public vpcId?: string;

  /**
   * The port number to assign to the Client VPN endpoint for TCP and UDP traffic.
   */
  public vpnPort?: number;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnClientVpnEndpointProps) {
    super(scope, id, {
      "type": CfnClientVpnEndpoint.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "authenticationOptions", this);
    cdk.requireProperty(props, "clientCidrBlock", this);
    cdk.requireProperty(props, "connectionLogOptions", this);
    cdk.requireProperty(props, "serverCertificateArn", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.authenticationOptions = props.authenticationOptions;
    this.clientCidrBlock = props.clientCidrBlock;
    this.clientConnectOptions = props.clientConnectOptions;
    this.clientLoginBannerOptions = props.clientLoginBannerOptions;
    this.connectionLogOptions = props.connectionLogOptions;
    this.description = props.description;
    this.dnsServers = props.dnsServers;
    this.securityGroupIds = props.securityGroupIds;
    this.selfServicePortal = props.selfServicePortal;
    this.serverCertificateArn = props.serverCertificateArn;
    this.sessionTimeoutHours = props.sessionTimeoutHours;
    this.splitTunnel = props.splitTunnel;
    this.tagSpecifications = props.tagSpecifications;
    this.transportProtocol = props.transportProtocol;
    this.vpcId = props.vpcId;
    this.vpnPort = props.vpnPort;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "authenticationOptions": this.authenticationOptions,
      "clientCidrBlock": this.clientCidrBlock,
      "clientConnectOptions": this.clientConnectOptions,
      "clientLoginBannerOptions": this.clientLoginBannerOptions,
      "connectionLogOptions": this.connectionLogOptions,
      "description": this.description,
      "dnsServers": this.dnsServers,
      "securityGroupIds": this.securityGroupIds,
      "selfServicePortal": this.selfServicePortal,
      "serverCertificateArn": this.serverCertificateArn,
      "sessionTimeoutHours": this.sessionTimeoutHours,
      "splitTunnel": this.splitTunnel,
      "tagSpecifications": this.tagSpecifications,
      "transportProtocol": this.transportProtocol,
      "vpcId": this.vpcId,
      "vpnPort": this.vpnPort
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnClientVpnEndpoint.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnClientVpnEndpointPropsToCloudFormation(props);
  }
}

export namespace CfnClientVpnEndpoint {
  /**
   * Indicates whether client connect options are enabled.
   *
   * The default is \`false\` (not enabled).
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientconnectoptions.html
   */
  export interface ClientConnectOptionsProperty {
    /**
     * Indicates whether client connect options are enabled.
     *
     * The default is \`false\` (not enabled).
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientconnectoptions.html#cfn-ec2-clientvpnendpoint-clientconnectoptions-enabled
     */
    readonly enabled: boolean | cdk.IResolvable;

    /**
     * The Amazon Resource Name (ARN) of the AWS Lambda function used for connection authorization.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientconnectoptions.html#cfn-ec2-clientvpnendpoint-clientconnectoptions-lambdafunctionarn
     */
    readonly lambdaFunctionArn?: string;
  }

  /**
   * The tags to apply to a resource when the resource is being created.
   *
   * When you specify a tag, you must specify the resource type to tag, otherwise the request will fail.
   *
   * > The \`Valid Values\` lists all the resource types that can be tagged. However, the action you're using might not support tagging all of these resource types. If you try to tag a resource type that is unsupported for the action you're using, you'll get an error.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-tagspecification.html
   */
  export interface TagSpecificationProperty {
    /**
     * The type of resource to tag.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-tagspecification.html#cfn-ec2-clientvpnendpoint-tagspecification-resourcetype
     */
    readonly resourceType: string;

    /**
     * The tags to apply to the resource.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-tagspecification.html#cfn-ec2-clientvpnendpoint-tagspecification-tags
     */
    readonly tags: Array<cdk.CfnTag>;
  }

  /**
   * Describes the authentication method to be used by a Client VPN endpoint.
   *
   * For more information, see [Authentication](https://docs.aws.amazon.com/vpn/latest/clientvpn-admin/authentication-authrization.html#client-authentication) in the *AWS Client VPN Administrator Guide* .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientauthenticationrequest.html
   */
  export interface ClientAuthenticationRequestProperty {
    /**
     * Information about the Active Directory to be used, if applicable.
     *
     * You must provide this information if *Type* is \`directory-service-authentication\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientauthenticationrequest.html#cfn-ec2-clientvpnendpoint-clientauthenticationrequest-activedirectory
     */
    readonly activeDirectory?: CfnClientVpnEndpoint.DirectoryServiceAuthenticationRequestProperty | cdk.IResolvable;

    /**
     * Information about the IAM SAML identity provider, if applicable.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientauthenticationrequest.html#cfn-ec2-clientvpnendpoint-clientauthenticationrequest-federatedauthentication
     */
    readonly federatedAuthentication?: CfnClientVpnEndpoint.FederatedAuthenticationRequestProperty | cdk.IResolvable;

    /**
     * Information about the authentication certificates to be used, if applicable.
     *
     * You must provide this information if *Type* is \`certificate-authentication\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientauthenticationrequest.html#cfn-ec2-clientvpnendpoint-clientauthenticationrequest-mutualauthentication
     */
    readonly mutualAuthentication?: CfnClientVpnEndpoint.CertificateAuthenticationRequestProperty | cdk.IResolvable;

    /**
     * The type of client authentication to be used.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientauthenticationrequest.html#cfn-ec2-clientvpnendpoint-clientauthenticationrequest-type
     */
    readonly type: string;
  }

  /**
   * Information about the client certificate to be used for authentication.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-certificateauthenticationrequest.html
   */
  export interface CertificateAuthenticationRequestProperty {
    /**
     * The ARN of the client certificate.
     *
     * The certificate must be signed by a certificate authority (CA) and it must be provisioned in AWS Certificate Manager (ACM).
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-certificateauthenticationrequest.html#cfn-ec2-clientvpnendpoint-certificateauthenticationrequest-clientrootcertificatechainarn
     */
    readonly clientRootCertificateChainArn: string;
  }

  /**
   * Describes the Active Directory to be used for client authentication.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-directoryserviceauthenticationrequest.html
   */
  export interface DirectoryServiceAuthenticationRequestProperty {
    /**
     * The ID of the Active Directory to be used for authentication.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-directoryserviceauthenticationrequest.html#cfn-ec2-clientvpnendpoint-directoryserviceauthenticationrequest-directoryid
     */
    readonly directoryId: string;
  }

  /**
   * The IAM SAML identity provider used for federated authentication.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-federatedauthenticationrequest.html
   */
  export interface FederatedAuthenticationRequestProperty {
    /**
     * The Amazon Resource Name (ARN) of the IAM SAML identity provider.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-federatedauthenticationrequest.html#cfn-ec2-clientvpnendpoint-federatedauthenticationrequest-samlproviderarn
     */
    readonly samlProviderArn: string;

    /**
     * The Amazon Resource Name (ARN) of the IAM SAML identity provider for the self-service portal.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-federatedauthenticationrequest.html#cfn-ec2-clientvpnendpoint-federatedauthenticationrequest-selfservicesamlproviderarn
     */
    readonly selfServiceSamlProviderArn?: string;
  }

  /**
   * Describes the client connection logging options for the Client VPN endpoint.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-connectionlogoptions.html
   */
  export interface ConnectionLogOptionsProperty {
    /**
     * The name of the CloudWatch Logs log group.
     *
     * Required if connection logging is enabled.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-connectionlogoptions.html#cfn-ec2-clientvpnendpoint-connectionlogoptions-cloudwatchloggroup
     */
    readonly cloudwatchLogGroup?: string;

    /**
     * The name of the CloudWatch Logs log stream to which the connection data is published.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-connectionlogoptions.html#cfn-ec2-clientvpnendpoint-connectionlogoptions-cloudwatchlogstream
     */
    readonly cloudwatchLogStream?: string;

    /**
     * Indicates whether connection logging is enabled.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-connectionlogoptions.html#cfn-ec2-clientvpnendpoint-connectionlogoptions-enabled
     */
    readonly enabled: boolean | cdk.IResolvable;
  }

  /**
   * Options for enabling a customizable text banner that will be displayed on AWS provided clients when a VPN session is established.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientloginbanneroptions.html
   */
  export interface ClientLoginBannerOptionsProperty {
    /**
     * Customizable text that will be displayed in a banner on AWS provided clients when a VPN session is established.
     *
     * UTF-8 encoded characters only. Maximum of 1400 characters.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientloginbanneroptions.html#cfn-ec2-clientvpnendpoint-clientloginbanneroptions-bannertext
     */
    readonly bannerText?: string;

    /**
     * Enable or disable a customizable text banner that will be displayed on AWS provided clients when a VPN session is established.
     *
     * Valid values: \`true | false\`
     *
     * Default value: \`false\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientloginbanneroptions.html#cfn-ec2-clientvpnendpoint-clientloginbanneroptions-enabled
     */
    readonly enabled: boolean | cdk.IResolvable;
  }
}

/**
 * Properties for defining a \`CfnClientVpnEndpoint\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html
 */
export interface CfnClientVpnEndpointProps {
  /**
   * Information about the authentication method to be used to authenticate clients.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-authenticationoptions
   */
  readonly authenticationOptions: Array<CfnClientVpnEndpoint.ClientAuthenticationRequestProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * The IPv4 address range, in CIDR notation, from which to assign client IP addresses.
   *
   * The address range cannot overlap with the local CIDR of the VPC in which the associated subnet is located, or the routes that you add manually. The address range cannot be changed after the Client VPN endpoint has been created. Client CIDR range must have a size of at least /22 and must not be greater than /12.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-clientcidrblock
   */
  readonly clientCidrBlock: string;

  /**
   * The options for managing connection authorization for new client connections.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-clientconnectoptions
   */
  readonly clientConnectOptions?: CfnClientVpnEndpoint.ClientConnectOptionsProperty | cdk.IResolvable;

  /**
   * Options for enabling a customizable text banner that will be displayed on AWS provided clients when a VPN session is established.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-clientloginbanneroptions
   */
  readonly clientLoginBannerOptions?: CfnClientVpnEndpoint.ClientLoginBannerOptionsProperty | cdk.IResolvable;

  /**
   * Information about the client connection logging options.
   *
   * If you enable client connection logging, data about client connections is sent to a Cloudwatch Logs log stream. The following information is logged:
   *
   * - Client connection requests
   * - Client connection results (successful and unsuccessful)
   * - Reasons for unsuccessful client connection requests
   * - Client connection termination time
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-connectionlogoptions
   */
  readonly connectionLogOptions: CfnClientVpnEndpoint.ConnectionLogOptionsProperty | cdk.IResolvable;

  /**
   * A brief description of the Client VPN endpoint.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-description
   */
  readonly description?: string;

  /**
   * Information about the DNS servers to be used for DNS resolution.
   *
   * A Client VPN endpoint can have up to two DNS servers. If no DNS server is specified, the DNS address configured on the device is used for the DNS server.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-dnsservers
   */
  readonly dnsServers?: Array<string>;

  /**
   * The IDs of one or more security groups to apply to the target network.
   *
   * You must also specify the ID of the VPC that contains the security groups.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-securitygroupids
   */
  readonly securityGroupIds?: Array<string>;

  /**
   * Specify whether to enable the self-service portal for the Client VPN endpoint.
   *
   * Default Value: \`enabled\`
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-selfserviceportal
   */
  readonly selfServicePortal?: string;

  /**
   * The ARN of the server certificate.
   *
   * For more information, see the [AWS Certificate Manager User Guide](https://docs.aws.amazon.com/acm/latest/userguide/) .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-servercertificatearn
   */
  readonly serverCertificateArn: string;

  /**
   * The maximum VPN session duration time in hours.
   *
   * Valid values: \`8 | 10 | 12 | 24\`
   *
   * Default value: \`24\`
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-sessiontimeouthours
   */
  readonly sessionTimeoutHours?: number;

  /**
   * Indicates whether split-tunnel is enabled on the AWS Client VPN endpoint.
   *
   * By default, split-tunnel on a VPN endpoint is disabled.
   *
   * For information about split-tunnel VPN endpoints, see [Split-tunnel AWS Client VPN endpoint](https://docs.aws.amazon.com/vpn/latest/clientvpn-admin/split-tunnel-vpn.html) in the *AWS Client VPN Administrator Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-splittunnel
   */
  readonly splitTunnel?: boolean | cdk.IResolvable;

  /**
   * The tags to apply to the Client VPN endpoint during creation.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-tagspecifications
   */
  readonly tagSpecifications?: Array<cdk.IResolvable | CfnClientVpnEndpoint.TagSpecificationProperty> | cdk.IResolvable;

  /**
   * The transport protocol to be used by the VPN session.
   *
   * Default value: \`udp\`
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-transportprotocol
   */
  readonly transportProtocol?: string;

  /**
   * The ID of the VPC to associate with the Client VPN endpoint.
   *
   * If no security group IDs are specified in the request, the default security group for the VPC is applied.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-vpcid
   */
  readonly vpcId?: string;

  /**
   * The port number to assign to the Client VPN endpoint for TCP and UDP traffic.
   *
   * Valid Values: \`443\` | \`1194\`
   *
   * Default Value: \`443\`
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-vpnport
   */
  readonly vpnPort?: number;
}

/**
 * Determine whether the given properties match those of a \`ClientConnectOptionsProperty\`
 *
 * @param properties - the TypeScript properties of a \`ClientConnectOptionsProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnClientVpnEndpointClientConnectOptionsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("enabled", cdk.requiredValidator)(properties.enabled));
  errors.collect(cdk.propertyValidator("enabled", cdk.validateBoolean)(properties.enabled));
  errors.collect(cdk.propertyValidator("lambdaFunctionArn", cdk.validateString)(properties.lambdaFunctionArn));
  return errors.wrap("supplied properties not correct for \\"ClientConnectOptionsProperty\\"");
}

// @ts-ignore TS6133
function convertCfnClientVpnEndpointClientConnectOptionsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnClientVpnEndpointClientConnectOptionsPropertyValidator(properties).assertSuccess();
  return {
    "Enabled": cdk.booleanToCloudFormation(properties.enabled),
    "LambdaFunctionArn": cdk.stringToCloudFormation(properties.lambdaFunctionArn)
  };
}

// @ts-ignore TS6133
function CfnClientVpnEndpointClientConnectOptionsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnClientVpnEndpoint.ClientConnectOptionsProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnClientVpnEndpoint.ClientConnectOptionsProperty>();
  ret.addPropertyResult("enabled", "Enabled", (properties.Enabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Enabled) : undefined));
  ret.addPropertyResult("lambdaFunctionArn", "LambdaFunctionArn", (properties.LambdaFunctionArn != null ? cfn_parse.FromCloudFormation.getString(properties.LambdaFunctionArn) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`TagSpecificationProperty\`
 *
 * @param properties - the TypeScript properties of a \`TagSpecificationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnClientVpnEndpointTagSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("resourceType", cdk.requiredValidator)(properties.resourceType));
  errors.collect(cdk.propertyValidator("resourceType", cdk.validateString)(properties.resourceType));
  errors.collect(cdk.propertyValidator("tags", cdk.requiredValidator)(properties.tags));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"TagSpecificationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnClientVpnEndpointTagSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnClientVpnEndpointTagSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "ResourceType": cdk.stringToCloudFormation(properties.resourceType),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnClientVpnEndpointTagSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnClientVpnEndpoint.TagSpecificationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnClientVpnEndpoint.TagSpecificationProperty>();
  ret.addPropertyResult("resourceType", "ResourceType", (properties.ResourceType != null ? cfn_parse.FromCloudFormation.getString(properties.ResourceType) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CertificateAuthenticationRequestProperty\`
 *
 * @param properties - the TypeScript properties of a \`CertificateAuthenticationRequestProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnClientVpnEndpointCertificateAuthenticationRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("clientRootCertificateChainArn", cdk.requiredValidator)(properties.clientRootCertificateChainArn));
  errors.collect(cdk.propertyValidator("clientRootCertificateChainArn", cdk.validateString)(properties.clientRootCertificateChainArn));
  return errors.wrap("supplied properties not correct for \\"CertificateAuthenticationRequestProperty\\"");
}

// @ts-ignore TS6133
function convertCfnClientVpnEndpointCertificateAuthenticationRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnClientVpnEndpointCertificateAuthenticationRequestPropertyValidator(properties).assertSuccess();
  return {
    "ClientRootCertificateChainArn": cdk.stringToCloudFormation(properties.clientRootCertificateChainArn)
  };
}

// @ts-ignore TS6133
function CfnClientVpnEndpointCertificateAuthenticationRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnClientVpnEndpoint.CertificateAuthenticationRequestProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnClientVpnEndpoint.CertificateAuthenticationRequestProperty>();
  ret.addPropertyResult("clientRootCertificateChainArn", "ClientRootCertificateChainArn", (properties.ClientRootCertificateChainArn != null ? cfn_parse.FromCloudFormation.getString(properties.ClientRootCertificateChainArn) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`DirectoryServiceAuthenticationRequestProperty\`
 *
 * @param properties - the TypeScript properties of a \`DirectoryServiceAuthenticationRequestProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnClientVpnEndpointDirectoryServiceAuthenticationRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("directoryId", cdk.requiredValidator)(properties.directoryId));
  errors.collect(cdk.propertyValidator("directoryId", cdk.validateString)(properties.directoryId));
  return errors.wrap("supplied properties not correct for \\"DirectoryServiceAuthenticationRequestProperty\\"");
}

// @ts-ignore TS6133
function convertCfnClientVpnEndpointDirectoryServiceAuthenticationRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnClientVpnEndpointDirectoryServiceAuthenticationRequestPropertyValidator(properties).assertSuccess();
  return {
    "DirectoryId": cdk.stringToCloudFormation(properties.directoryId)
  };
}

// @ts-ignore TS6133
function CfnClientVpnEndpointDirectoryServiceAuthenticationRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnClientVpnEndpoint.DirectoryServiceAuthenticationRequestProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnClientVpnEndpoint.DirectoryServiceAuthenticationRequestProperty>();
  ret.addPropertyResult("directoryId", "DirectoryId", (properties.DirectoryId != null ? cfn_parse.FromCloudFormation.getString(properties.DirectoryId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`FederatedAuthenticationRequestProperty\`
 *
 * @param properties - the TypeScript properties of a \`FederatedAuthenticationRequestProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnClientVpnEndpointFederatedAuthenticationRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("samlProviderArn", cdk.requiredValidator)(properties.samlProviderArn));
  errors.collect(cdk.propertyValidator("samlProviderArn", cdk.validateString)(properties.samlProviderArn));
  errors.collect(cdk.propertyValidator("selfServiceSamlProviderArn", cdk.validateString)(properties.selfServiceSamlProviderArn));
  return errors.wrap("supplied properties not correct for \\"FederatedAuthenticationRequestProperty\\"");
}

// @ts-ignore TS6133
function convertCfnClientVpnEndpointFederatedAuthenticationRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnClientVpnEndpointFederatedAuthenticationRequestPropertyValidator(properties).assertSuccess();
  return {
    "SAMLProviderArn": cdk.stringToCloudFormation(properties.samlProviderArn),
    "SelfServiceSAMLProviderArn": cdk.stringToCloudFormation(properties.selfServiceSamlProviderArn)
  };
}

// @ts-ignore TS6133
function CfnClientVpnEndpointFederatedAuthenticationRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnClientVpnEndpoint.FederatedAuthenticationRequestProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnClientVpnEndpoint.FederatedAuthenticationRequestProperty>();
  ret.addPropertyResult("samlProviderArn", "SAMLProviderArn", (properties.SAMLProviderArn != null ? cfn_parse.FromCloudFormation.getString(properties.SAMLProviderArn) : undefined));
  ret.addPropertyResult("selfServiceSamlProviderArn", "SelfServiceSAMLProviderArn", (properties.SelfServiceSAMLProviderArn != null ? cfn_parse.FromCloudFormation.getString(properties.SelfServiceSAMLProviderArn) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ClientAuthenticationRequestProperty\`
 *
 * @param properties - the TypeScript properties of a \`ClientAuthenticationRequestProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnClientVpnEndpointClientAuthenticationRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("activeDirectory", CfnClientVpnEndpointDirectoryServiceAuthenticationRequestPropertyValidator)(properties.activeDirectory));
  errors.collect(cdk.propertyValidator("federatedAuthentication", CfnClientVpnEndpointFederatedAuthenticationRequestPropertyValidator)(properties.federatedAuthentication));
  errors.collect(cdk.propertyValidator("mutualAuthentication", CfnClientVpnEndpointCertificateAuthenticationRequestPropertyValidator)(properties.mutualAuthentication));
  errors.collect(cdk.propertyValidator("type", cdk.requiredValidator)(properties.type));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  return errors.wrap("supplied properties not correct for \\"ClientAuthenticationRequestProperty\\"");
}

// @ts-ignore TS6133
function convertCfnClientVpnEndpointClientAuthenticationRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnClientVpnEndpointClientAuthenticationRequestPropertyValidator(properties).assertSuccess();
  return {
    "ActiveDirectory": convertCfnClientVpnEndpointDirectoryServiceAuthenticationRequestPropertyToCloudFormation(properties.activeDirectory),
    "FederatedAuthentication": convertCfnClientVpnEndpointFederatedAuthenticationRequestPropertyToCloudFormation(properties.federatedAuthentication),
    "MutualAuthentication": convertCfnClientVpnEndpointCertificateAuthenticationRequestPropertyToCloudFormation(properties.mutualAuthentication),
    "Type": cdk.stringToCloudFormation(properties.type)
  };
}

// @ts-ignore TS6133
function CfnClientVpnEndpointClientAuthenticationRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnClientVpnEndpoint.ClientAuthenticationRequestProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnClientVpnEndpoint.ClientAuthenticationRequestProperty>();
  ret.addPropertyResult("activeDirectory", "ActiveDirectory", (properties.ActiveDirectory != null ? CfnClientVpnEndpointDirectoryServiceAuthenticationRequestPropertyFromCloudFormation(properties.ActiveDirectory) : undefined));
  ret.addPropertyResult("federatedAuthentication", "FederatedAuthentication", (properties.FederatedAuthentication != null ? CfnClientVpnEndpointFederatedAuthenticationRequestPropertyFromCloudFormation(properties.FederatedAuthentication) : undefined));
  ret.addPropertyResult("mutualAuthentication", "MutualAuthentication", (properties.MutualAuthentication != null ? CfnClientVpnEndpointCertificateAuthenticationRequestPropertyFromCloudFormation(properties.MutualAuthentication) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ConnectionLogOptionsProperty\`
 *
 * @param properties - the TypeScript properties of a \`ConnectionLogOptionsProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnClientVpnEndpointConnectionLogOptionsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("cloudwatchLogGroup", cdk.validateString)(properties.cloudwatchLogGroup));
  errors.collect(cdk.propertyValidator("cloudwatchLogStream", cdk.validateString)(properties.cloudwatchLogStream));
  errors.collect(cdk.propertyValidator("enabled", cdk.requiredValidator)(properties.enabled));
  errors.collect(cdk.propertyValidator("enabled", cdk.validateBoolean)(properties.enabled));
  return errors.wrap("supplied properties not correct for \\"ConnectionLogOptionsProperty\\"");
}

// @ts-ignore TS6133
function convertCfnClientVpnEndpointConnectionLogOptionsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnClientVpnEndpointConnectionLogOptionsPropertyValidator(properties).assertSuccess();
  return {
    "CloudwatchLogGroup": cdk.stringToCloudFormation(properties.cloudwatchLogGroup),
    "CloudwatchLogStream": cdk.stringToCloudFormation(properties.cloudwatchLogStream),
    "Enabled": cdk.booleanToCloudFormation(properties.enabled)
  };
}

// @ts-ignore TS6133
function CfnClientVpnEndpointConnectionLogOptionsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnClientVpnEndpoint.ConnectionLogOptionsProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnClientVpnEndpoint.ConnectionLogOptionsProperty>();
  ret.addPropertyResult("cloudwatchLogGroup", "CloudwatchLogGroup", (properties.CloudwatchLogGroup != null ? cfn_parse.FromCloudFormation.getString(properties.CloudwatchLogGroup) : undefined));
  ret.addPropertyResult("cloudwatchLogStream", "CloudwatchLogStream", (properties.CloudwatchLogStream != null ? cfn_parse.FromCloudFormation.getString(properties.CloudwatchLogStream) : undefined));
  ret.addPropertyResult("enabled", "Enabled", (properties.Enabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Enabled) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ClientLoginBannerOptionsProperty\`
 *
 * @param properties - the TypeScript properties of a \`ClientLoginBannerOptionsProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnClientVpnEndpointClientLoginBannerOptionsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("bannerText", cdk.validateString)(properties.bannerText));
  errors.collect(cdk.propertyValidator("enabled", cdk.requiredValidator)(properties.enabled));
  errors.collect(cdk.propertyValidator("enabled", cdk.validateBoolean)(properties.enabled));
  return errors.wrap("supplied properties not correct for \\"ClientLoginBannerOptionsProperty\\"");
}

// @ts-ignore TS6133
function convertCfnClientVpnEndpointClientLoginBannerOptionsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnClientVpnEndpointClientLoginBannerOptionsPropertyValidator(properties).assertSuccess();
  return {
    "BannerText": cdk.stringToCloudFormation(properties.bannerText),
    "Enabled": cdk.booleanToCloudFormation(properties.enabled)
  };
}

// @ts-ignore TS6133
function CfnClientVpnEndpointClientLoginBannerOptionsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnClientVpnEndpoint.ClientLoginBannerOptionsProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnClientVpnEndpoint.ClientLoginBannerOptionsProperty>();
  ret.addPropertyResult("bannerText", "BannerText", (properties.BannerText != null ? cfn_parse.FromCloudFormation.getString(properties.BannerText) : undefined));
  ret.addPropertyResult("enabled", "Enabled", (properties.Enabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Enabled) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnClientVpnEndpointProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnClientVpnEndpointProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnClientVpnEndpointPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("authenticationOptions", cdk.requiredValidator)(properties.authenticationOptions));
  errors.collect(cdk.propertyValidator("authenticationOptions", cdk.listValidator(CfnClientVpnEndpointClientAuthenticationRequestPropertyValidator))(properties.authenticationOptions));
  errors.collect(cdk.propertyValidator("clientCidrBlock", cdk.requiredValidator)(properties.clientCidrBlock));
  errors.collect(cdk.propertyValidator("clientCidrBlock", cdk.validateString)(properties.clientCidrBlock));
  errors.collect(cdk.propertyValidator("clientConnectOptions", CfnClientVpnEndpointClientConnectOptionsPropertyValidator)(properties.clientConnectOptions));
  errors.collect(cdk.propertyValidator("clientLoginBannerOptions", CfnClientVpnEndpointClientLoginBannerOptionsPropertyValidator)(properties.clientLoginBannerOptions));
  errors.collect(cdk.propertyValidator("connectionLogOptions", cdk.requiredValidator)(properties.connectionLogOptions));
  errors.collect(cdk.propertyValidator("connectionLogOptions", CfnClientVpnEndpointConnectionLogOptionsPropertyValidator)(properties.connectionLogOptions));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("dnsServers", cdk.listValidator(cdk.validateString))(properties.dnsServers));
  errors.collect(cdk.propertyValidator("securityGroupIds", cdk.listValidator(cdk.validateString))(properties.securityGroupIds));
  errors.collect(cdk.propertyValidator("selfServicePortal", cdk.validateString)(properties.selfServicePortal));
  errors.collect(cdk.propertyValidator("serverCertificateArn", cdk.requiredValidator)(properties.serverCertificateArn));
  errors.collect(cdk.propertyValidator("serverCertificateArn", cdk.validateString)(properties.serverCertificateArn));
  errors.collect(cdk.propertyValidator("sessionTimeoutHours", cdk.validateNumber)(properties.sessionTimeoutHours));
  errors.collect(cdk.propertyValidator("splitTunnel", cdk.validateBoolean)(properties.splitTunnel));
  errors.collect(cdk.propertyValidator("tagSpecifications", cdk.listValidator(CfnClientVpnEndpointTagSpecificationPropertyValidator))(properties.tagSpecifications));
  errors.collect(cdk.propertyValidator("transportProtocol", cdk.validateString)(properties.transportProtocol));
  errors.collect(cdk.propertyValidator("vpcId", cdk.validateString)(properties.vpcId));
  errors.collect(cdk.propertyValidator("vpnPort", cdk.validateNumber)(properties.vpnPort));
  return errors.wrap("supplied properties not correct for \\"CfnClientVpnEndpointProps\\"");
}

// @ts-ignore TS6133
function convertCfnClientVpnEndpointPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnClientVpnEndpointPropsValidator(properties).assertSuccess();
  return {
    "AuthenticationOptions": cdk.listMapper(convertCfnClientVpnEndpointClientAuthenticationRequestPropertyToCloudFormation)(properties.authenticationOptions),
    "ClientCidrBlock": cdk.stringToCloudFormation(properties.clientCidrBlock),
    "ClientConnectOptions": convertCfnClientVpnEndpointClientConnectOptionsPropertyToCloudFormation(properties.clientConnectOptions),
    "ClientLoginBannerOptions": convertCfnClientVpnEndpointClientLoginBannerOptionsPropertyToCloudFormation(properties.clientLoginBannerOptions),
    "ConnectionLogOptions": convertCfnClientVpnEndpointConnectionLogOptionsPropertyToCloudFormation(properties.connectionLogOptions),
    "Description": cdk.stringToCloudFormation(properties.description),
    "DnsServers": cdk.listMapper(cdk.stringToCloudFormation)(properties.dnsServers),
    "SecurityGroupIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.securityGroupIds),
    "SelfServicePortal": cdk.stringToCloudFormation(properties.selfServicePortal),
    "ServerCertificateArn": cdk.stringToCloudFormation(properties.serverCertificateArn),
    "SessionTimeoutHours": cdk.numberToCloudFormation(properties.sessionTimeoutHours),
    "SplitTunnel": cdk.booleanToCloudFormation(properties.splitTunnel),
    "TagSpecifications": cdk.listMapper(convertCfnClientVpnEndpointTagSpecificationPropertyToCloudFormation)(properties.tagSpecifications),
    "TransportProtocol": cdk.stringToCloudFormation(properties.transportProtocol),
    "VpcId": cdk.stringToCloudFormation(properties.vpcId),
    "VpnPort": cdk.numberToCloudFormation(properties.vpnPort)
  };
}

// @ts-ignore TS6133
function CfnClientVpnEndpointPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnClientVpnEndpointProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnClientVpnEndpointProps>();
  ret.addPropertyResult("authenticationOptions", "AuthenticationOptions", (properties.AuthenticationOptions != null ? cfn_parse.FromCloudFormation.getArray(CfnClientVpnEndpointClientAuthenticationRequestPropertyFromCloudFormation)(properties.AuthenticationOptions) : undefined));
  ret.addPropertyResult("clientCidrBlock", "ClientCidrBlock", (properties.ClientCidrBlock != null ? cfn_parse.FromCloudFormation.getString(properties.ClientCidrBlock) : undefined));
  ret.addPropertyResult("clientConnectOptions", "ClientConnectOptions", (properties.ClientConnectOptions != null ? CfnClientVpnEndpointClientConnectOptionsPropertyFromCloudFormation(properties.ClientConnectOptions) : undefined));
  ret.addPropertyResult("clientLoginBannerOptions", "ClientLoginBannerOptions", (properties.ClientLoginBannerOptions != null ? CfnClientVpnEndpointClientLoginBannerOptionsPropertyFromCloudFormation(properties.ClientLoginBannerOptions) : undefined));
  ret.addPropertyResult("connectionLogOptions", "ConnectionLogOptions", (properties.ConnectionLogOptions != null ? CfnClientVpnEndpointConnectionLogOptionsPropertyFromCloudFormation(properties.ConnectionLogOptions) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("dnsServers", "DnsServers", (properties.DnsServers != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.DnsServers) : undefined));
  ret.addPropertyResult("securityGroupIds", "SecurityGroupIds", (properties.SecurityGroupIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecurityGroupIds) : undefined));
  ret.addPropertyResult("selfServicePortal", "SelfServicePortal", (properties.SelfServicePortal != null ? cfn_parse.FromCloudFormation.getString(properties.SelfServicePortal) : undefined));
  ret.addPropertyResult("serverCertificateArn", "ServerCertificateArn", (properties.ServerCertificateArn != null ? cfn_parse.FromCloudFormation.getString(properties.ServerCertificateArn) : undefined));
  ret.addPropertyResult("sessionTimeoutHours", "SessionTimeoutHours", (properties.SessionTimeoutHours != null ? cfn_parse.FromCloudFormation.getNumber(properties.SessionTimeoutHours) : undefined));
  ret.addPropertyResult("splitTunnel", "SplitTunnel", (properties.SplitTunnel != null ? cfn_parse.FromCloudFormation.getBoolean(properties.SplitTunnel) : undefined));
  ret.addPropertyResult("tagSpecifications", "TagSpecifications", (properties.TagSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnClientVpnEndpointTagSpecificationPropertyFromCloudFormation)(properties.TagSpecifications) : undefined));
  ret.addPropertyResult("transportProtocol", "TransportProtocol", (properties.TransportProtocol != null ? cfn_parse.FromCloudFormation.getString(properties.TransportProtocol) : undefined));
  ret.addPropertyResult("vpcId", "VpcId", (properties.VpcId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcId) : undefined));
  ret.addPropertyResult("vpnPort", "VpnPort", (properties.VpnPort != null ? cfn_parse.FromCloudFormation.getNumber(properties.VpnPort) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a network route to add to a Client VPN endpoint.
 *
 * Each Client VPN endpoint has a route table that describes the available destination network routes. Each route in the route table specifies the path for traffic to specific resources or networks.
 *
 * A target network association must be created before you can specify a route. If you're setting up all the components of a Client VPN endpoint at the same time, you must use the [DependsOn Attribute](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-dependson.html) to declare a dependency on the \`AWS::EC2::ClientVpnTargetNetworkAssociation\` resource.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnroute.html
 */
export class CfnClientVpnRoute extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::ClientVpnRoute";

  /**
   * Build a CfnClientVpnRoute from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnClientVpnRoute {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnClientVpnRoutePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnClientVpnRoute(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The ID of the Client VPN endpoint to which to add the route.
   */
  public clientVpnEndpointId: string;

  /**
   * A brief description of the route.
   */
  public description?: string;

  /**
   * The IPv4 address range, in CIDR notation, of the route destination. For example:.
   */
  public destinationCidrBlock: string;

  /**
   * The ID of the subnet through which you want to route traffic.
   */
  public targetVpcSubnetId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnClientVpnRouteProps) {
    super(scope, id, {
      "type": CfnClientVpnRoute.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "clientVpnEndpointId", this);
    cdk.requireProperty(props, "destinationCidrBlock", this);
    cdk.requireProperty(props, "targetVpcSubnetId", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.clientVpnEndpointId = props.clientVpnEndpointId;
    this.description = props.description;
    this.destinationCidrBlock = props.destinationCidrBlock;
    this.targetVpcSubnetId = props.targetVpcSubnetId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "clientVpnEndpointId": this.clientVpnEndpointId,
      "description": this.description,
      "destinationCidrBlock": this.destinationCidrBlock,
      "targetVpcSubnetId": this.targetVpcSubnetId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnClientVpnRoute.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnClientVpnRoutePropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnClientVpnRoute\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnroute.html
 */
export interface CfnClientVpnRouteProps {
  /**
   * The ID of the Client VPN endpoint to which to add the route.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnroute.html#cfn-ec2-clientvpnroute-clientvpnendpointid
   */
  readonly clientVpnEndpointId: string;

  /**
   * A brief description of the route.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnroute.html#cfn-ec2-clientvpnroute-description
   */
  readonly description?: string;

  /**
   * The IPv4 address range, in CIDR notation, of the route destination. For example:.
   *
   * - To add a route for Internet access, enter \`0.0.0.0/0\`
   * - To add a route for a peered VPC, enter the peered VPC's IPv4 CIDR range
   * - To add a route for an on-premises network, enter the AWS Site-to-Site VPN connection's IPv4 CIDR range
   * - To add a route for the local network, enter the client CIDR range
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnroute.html#cfn-ec2-clientvpnroute-destinationcidrblock
   */
  readonly destinationCidrBlock: string;

  /**
   * The ID of the subnet through which you want to route traffic.
   *
   * The specified subnet must be an existing target network of the Client VPN endpoint.
   *
   * Alternatively, if you're adding a route for the local network, specify \`local\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnroute.html#cfn-ec2-clientvpnroute-targetvpcsubnetid
   */
  readonly targetVpcSubnetId: string;
}

/**
 * Determine whether the given properties match those of a \`CfnClientVpnRouteProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnClientVpnRouteProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnClientVpnRoutePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("clientVpnEndpointId", cdk.requiredValidator)(properties.clientVpnEndpointId));
  errors.collect(cdk.propertyValidator("clientVpnEndpointId", cdk.validateString)(properties.clientVpnEndpointId));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("destinationCidrBlock", cdk.requiredValidator)(properties.destinationCidrBlock));
  errors.collect(cdk.propertyValidator("destinationCidrBlock", cdk.validateString)(properties.destinationCidrBlock));
  errors.collect(cdk.propertyValidator("targetVpcSubnetId", cdk.requiredValidator)(properties.targetVpcSubnetId));
  errors.collect(cdk.propertyValidator("targetVpcSubnetId", cdk.validateString)(properties.targetVpcSubnetId));
  return errors.wrap("supplied properties not correct for \\"CfnClientVpnRouteProps\\"");
}

// @ts-ignore TS6133
function convertCfnClientVpnRoutePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnClientVpnRoutePropsValidator(properties).assertSuccess();
  return {
    "ClientVpnEndpointId": cdk.stringToCloudFormation(properties.clientVpnEndpointId),
    "Description": cdk.stringToCloudFormation(properties.description),
    "DestinationCidrBlock": cdk.stringToCloudFormation(properties.destinationCidrBlock),
    "TargetVpcSubnetId": cdk.stringToCloudFormation(properties.targetVpcSubnetId)
  };
}

// @ts-ignore TS6133
function CfnClientVpnRoutePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnClientVpnRouteProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnClientVpnRouteProps>();
  ret.addPropertyResult("clientVpnEndpointId", "ClientVpnEndpointId", (properties.ClientVpnEndpointId != null ? cfn_parse.FromCloudFormation.getString(properties.ClientVpnEndpointId) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("destinationCidrBlock", "DestinationCidrBlock", (properties.DestinationCidrBlock != null ? cfn_parse.FromCloudFormation.getString(properties.DestinationCidrBlock) : undefined));
  ret.addPropertyResult("targetVpcSubnetId", "TargetVpcSubnetId", (properties.TargetVpcSubnetId != null ? cfn_parse.FromCloudFormation.getString(properties.TargetVpcSubnetId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a target network to associate with a Client VPN endpoint.
 *
 * A target network is a subnet in a VPC. You can associate multiple subnets from the same VPC with a Client VPN endpoint. You can associate only one subnet in each Availability Zone. We recommend that you associate at least two subnets to provide Availability Zone redundancy.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpntargetnetworkassociation.html
 */
export class CfnClientVpnTargetNetworkAssociation extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::ClientVpnTargetNetworkAssociation";

  /**
   * Build a CfnClientVpnTargetNetworkAssociation from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnClientVpnTargetNetworkAssociation {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnClientVpnTargetNetworkAssociationPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnClientVpnTargetNetworkAssociation(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The ID of the Client VPN endpoint.
   */
  public clientVpnEndpointId: string;

  /**
   * The ID of the subnet to associate with the Client VPN endpoint.
   */
  public subnetId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnClientVpnTargetNetworkAssociationProps) {
    super(scope, id, {
      "type": CfnClientVpnTargetNetworkAssociation.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "clientVpnEndpointId", this);
    cdk.requireProperty(props, "subnetId", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.clientVpnEndpointId = props.clientVpnEndpointId;
    this.subnetId = props.subnetId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "clientVpnEndpointId": this.clientVpnEndpointId,
      "subnetId": this.subnetId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnClientVpnTargetNetworkAssociation.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnClientVpnTargetNetworkAssociationPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnClientVpnTargetNetworkAssociation\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpntargetnetworkassociation.html
 */
export interface CfnClientVpnTargetNetworkAssociationProps {
  /**
   * The ID of the Client VPN endpoint.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpntargetnetworkassociation.html#cfn-ec2-clientvpntargetnetworkassociation-clientvpnendpointid
   */
  readonly clientVpnEndpointId: string;

  /**
   * The ID of the subnet to associate with the Client VPN endpoint.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpntargetnetworkassociation.html#cfn-ec2-clientvpntargetnetworkassociation-subnetid
   */
  readonly subnetId: string;
}

/**
 * Determine whether the given properties match those of a \`CfnClientVpnTargetNetworkAssociationProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnClientVpnTargetNetworkAssociationProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnClientVpnTargetNetworkAssociationPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("clientVpnEndpointId", cdk.requiredValidator)(properties.clientVpnEndpointId));
  errors.collect(cdk.propertyValidator("clientVpnEndpointId", cdk.validateString)(properties.clientVpnEndpointId));
  errors.collect(cdk.propertyValidator("subnetId", cdk.requiredValidator)(properties.subnetId));
  errors.collect(cdk.propertyValidator("subnetId", cdk.validateString)(properties.subnetId));
  return errors.wrap("supplied properties not correct for \\"CfnClientVpnTargetNetworkAssociationProps\\"");
}

// @ts-ignore TS6133
function convertCfnClientVpnTargetNetworkAssociationPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnClientVpnTargetNetworkAssociationPropsValidator(properties).assertSuccess();
  return {
    "ClientVpnEndpointId": cdk.stringToCloudFormation(properties.clientVpnEndpointId),
    "SubnetId": cdk.stringToCloudFormation(properties.subnetId)
  };
}

// @ts-ignore TS6133
function CfnClientVpnTargetNetworkAssociationPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnClientVpnTargetNetworkAssociationProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnClientVpnTargetNetworkAssociationProps>();
  ret.addPropertyResult("clientVpnEndpointId", "ClientVpnEndpointId", (properties.ClientVpnEndpointId != null ? cfn_parse.FromCloudFormation.getString(properties.ClientVpnEndpointId) : undefined));
  ret.addPropertyResult("subnetId", "SubnetId", (properties.SubnetId != null ? cfn_parse.FromCloudFormation.getString(properties.SubnetId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a customer gateway.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customergateway.html
 */
export class CfnCustomerGateway extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::CustomerGateway";

  /**
   * Build a CfnCustomerGateway from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnCustomerGateway {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnCustomerGatewayPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnCustomerGateway(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the customer gateway.
   *
   * @cloudformationAttribute CustomerGatewayId
   */
  public readonly attrCustomerGatewayId: string;

  /**
   * For devices that support BGP, the customer gateway's BGP ASN.
   */
  public bgpAsn: number;

  /**
   * The name of customer gateway device.
   */
  public deviceName?: string;

  /**
   * IPv4 address for the customer gateway device's outside interface.
   */
  public ipAddress: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * One or more tags for the customer gateway.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The type of VPN connection that this customer gateway supports ( \`ipsec.1\` ).
   */
  public type: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnCustomerGatewayProps) {
    super(scope, id, {
      "type": CfnCustomerGateway.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "bgpAsn", this);
    cdk.requireProperty(props, "ipAddress", this);
    cdk.requireProperty(props, "type", this);

    this.attrCustomerGatewayId = cdk.Token.asString(this.getAtt("CustomerGatewayId", cdk.ResolutionTypeHint.STRING));
    this.bgpAsn = props.bgpAsn;
    this.deviceName = props.deviceName;
    this.ipAddress = props.ipAddress;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::CustomerGateway", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.type = props.type;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "bgpAsn": this.bgpAsn,
      "deviceName": this.deviceName,
      "ipAddress": this.ipAddress,
      "tags": this.tags.renderTags(),
      "type": this.type
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnCustomerGateway.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnCustomerGatewayPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnCustomerGateway\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customergateway.html
 */
export interface CfnCustomerGatewayProps {
  /**
   * For devices that support BGP, the customer gateway's BGP ASN.
   *
   * Default: 65000
   *
   * @default - 65000
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customergateway.html#cfn-ec2-customergateway-bgpasn
   */
  readonly bgpAsn: number;

  /**
   * The name of customer gateway device.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customergateway.html#cfn-ec2-customergateway-devicename
   */
  readonly deviceName?: string;

  /**
   * IPv4 address for the customer gateway device's outside interface.
   *
   * The address must be static.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customergateway.html#cfn-ec2-customergateway-ipaddress
   */
  readonly ipAddress: string;

  /**
   * One or more tags for the customer gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customergateway.html#cfn-ec2-customergateway-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The type of VPN connection that this customer gateway supports ( \`ipsec.1\` ).
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customergateway.html#cfn-ec2-customergateway-type
   */
  readonly type: string;
}

/**
 * Determine whether the given properties match those of a \`CfnCustomerGatewayProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnCustomerGatewayProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnCustomerGatewayPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("bgpAsn", cdk.requiredValidator)(properties.bgpAsn));
  errors.collect(cdk.propertyValidator("bgpAsn", cdk.validateNumber)(properties.bgpAsn));
  errors.collect(cdk.propertyValidator("deviceName", cdk.validateString)(properties.deviceName));
  errors.collect(cdk.propertyValidator("ipAddress", cdk.requiredValidator)(properties.ipAddress));
  errors.collect(cdk.propertyValidator("ipAddress", cdk.validateString)(properties.ipAddress));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("type", cdk.requiredValidator)(properties.type));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  return errors.wrap("supplied properties not correct for \\"CfnCustomerGatewayProps\\"");
}

// @ts-ignore TS6133
function convertCfnCustomerGatewayPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnCustomerGatewayPropsValidator(properties).assertSuccess();
  return {
    "BgpAsn": cdk.numberToCloudFormation(properties.bgpAsn),
    "DeviceName": cdk.stringToCloudFormation(properties.deviceName),
    "IpAddress": cdk.stringToCloudFormation(properties.ipAddress),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "Type": cdk.stringToCloudFormation(properties.type)
  };
}

// @ts-ignore TS6133
function CfnCustomerGatewayPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnCustomerGatewayProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnCustomerGatewayProps>();
  ret.addPropertyResult("bgpAsn", "BgpAsn", (properties.BgpAsn != null ? cfn_parse.FromCloudFormation.getNumber(properties.BgpAsn) : undefined));
  ret.addPropertyResult("deviceName", "DeviceName", (properties.DeviceName != null ? cfn_parse.FromCloudFormation.getString(properties.DeviceName) : undefined));
  ret.addPropertyResult("ipAddress", "IpAddress", (properties.IpAddress != null ? cfn_parse.FromCloudFormation.getString(properties.IpAddress) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a set of DHCP options for your VPC.
 *
 * You must specify at least one of the following properties: \`DomainNameServers\` , \`NetbiosNameServers\` , \`NtpServers\` . If you specify \`NetbiosNameServers\` , you must specify \`NetbiosNodeType\` .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-dhcpoptions.html
 */
export class CfnDHCPOptions extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::DHCPOptions";

  /**
   * Build a CfnDHCPOptions from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnDHCPOptions {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnDHCPOptionsPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnDHCPOptions(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the DHCP options set.
   *
   * @cloudformationAttribute DhcpOptionsId
   */
  public readonly attrDhcpOptionsId: string;

  /**
   * This value is used to complete unqualified DNS hostnames.
   */
  public domainName?: string;

  /**
   * The IPv4 addresses of up to four domain name servers, or \`AmazonProvidedDNS\` .
   */
  public domainNameServers?: Array<string>;

  /**
   * The IPv4 addresses of up to four NetBIOS name servers.
   */
  public netbiosNameServers?: Array<string>;

  /**
   * The NetBIOS node type (1, 2, 4, or 8).
   */
  public netbiosNodeType?: number;

  /**
   * The IPv4 addresses of up to four Network Time Protocol (NTP) servers.
   */
  public ntpServers?: Array<string>;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * Any tags assigned to the DHCP options set.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnDHCPOptionsProps = {}) {
    super(scope, id, {
      "type": CfnDHCPOptions.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.attrDhcpOptionsId = cdk.Token.asString(this.getAtt("DhcpOptionsId", cdk.ResolutionTypeHint.STRING));
    this.domainName = props.domainName;
    this.domainNameServers = props.domainNameServers;
    this.netbiosNameServers = props.netbiosNameServers;
    this.netbiosNodeType = props.netbiosNodeType;
    this.ntpServers = props.ntpServers;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::DHCPOptions", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "domainName": this.domainName,
      "domainNameServers": this.domainNameServers,
      "netbiosNameServers": this.netbiosNameServers,
      "netbiosNodeType": this.netbiosNodeType,
      "ntpServers": this.ntpServers,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnDHCPOptions.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnDHCPOptionsPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnDHCPOptions\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-dhcpoptions.html
 */
export interface CfnDHCPOptionsProps {
  /**
   * This value is used to complete unqualified DNS hostnames.
   *
   * If you're using AmazonProvidedDNS in \`us-east-1\` , specify \`ec2.internal\` . If you're using AmazonProvidedDNS in another Region, specify *region* . \`compute.internal\` (for example, \`ap-northeast-1.compute.internal\` ). Otherwise, specify a domain name (for example, *MyCompany.com* ).
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-dhcpoptions.html#cfn-ec2-dhcpoptions-domainname
   */
  readonly domainName?: string;

  /**
   * The IPv4 addresses of up to four domain name servers, or \`AmazonProvidedDNS\` .
   *
   * The default is \`AmazonProvidedDNS\` . To have your instance receive a custom DNS hostname as specified in \`DomainName\` , you must set this property to a custom DNS server.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-dhcpoptions.html#cfn-ec2-dhcpoptions-domainnameservers
   */
  readonly domainNameServers?: Array<string>;

  /**
   * The IPv4 addresses of up to four NetBIOS name servers.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-dhcpoptions.html#cfn-ec2-dhcpoptions-netbiosnameservers
   */
  readonly netbiosNameServers?: Array<string>;

  /**
   * The NetBIOS node type (1, 2, 4, or 8).
   *
   * We recommend that you specify 2 (broadcast and multicast are not currently supported).
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-dhcpoptions.html#cfn-ec2-dhcpoptions-netbiosnodetype
   */
  readonly netbiosNodeType?: number;

  /**
   * The IPv4 addresses of up to four Network Time Protocol (NTP) servers.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-dhcpoptions.html#cfn-ec2-dhcpoptions-ntpservers
   */
  readonly ntpServers?: Array<string>;

  /**
   * Any tags assigned to the DHCP options set.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-dhcpoptions.html#cfn-ec2-dhcpoptions-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a \`CfnDHCPOptionsProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnDHCPOptionsProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnDHCPOptionsPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("domainName", cdk.validateString)(properties.domainName));
  errors.collect(cdk.propertyValidator("domainNameServers", cdk.listValidator(cdk.validateString))(properties.domainNameServers));
  errors.collect(cdk.propertyValidator("netbiosNameServers", cdk.listValidator(cdk.validateString))(properties.netbiosNameServers));
  errors.collect(cdk.propertyValidator("netbiosNodeType", cdk.validateNumber)(properties.netbiosNodeType));
  errors.collect(cdk.propertyValidator("ntpServers", cdk.listValidator(cdk.validateString))(properties.ntpServers));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnDHCPOptionsProps\\"");
}

// @ts-ignore TS6133
function convertCfnDHCPOptionsPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnDHCPOptionsPropsValidator(properties).assertSuccess();
  return {
    "DomainName": cdk.stringToCloudFormation(properties.domainName),
    "DomainNameServers": cdk.listMapper(cdk.stringToCloudFormation)(properties.domainNameServers),
    "NetbiosNameServers": cdk.listMapper(cdk.stringToCloudFormation)(properties.netbiosNameServers),
    "NetbiosNodeType": cdk.numberToCloudFormation(properties.netbiosNodeType),
    "NtpServers": cdk.listMapper(cdk.stringToCloudFormation)(properties.ntpServers),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnDHCPOptionsPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnDHCPOptionsProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnDHCPOptionsProps>();
  ret.addPropertyResult("domainName", "DomainName", (properties.DomainName != null ? cfn_parse.FromCloudFormation.getString(properties.DomainName) : undefined));
  ret.addPropertyResult("domainNameServers", "DomainNameServers", (properties.DomainNameServers != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.DomainNameServers) : undefined));
  ret.addPropertyResult("netbiosNameServers", "NetbiosNameServers", (properties.NetbiosNameServers != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.NetbiosNameServers) : undefined));
  ret.addPropertyResult("netbiosNodeType", "NetbiosNodeType", (properties.NetbiosNodeType != null ? cfn_parse.FromCloudFormation.getNumber(properties.NetbiosNodeType) : undefined));
  ret.addPropertyResult("ntpServers", "NtpServers", (properties.NtpServers != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.NtpServers) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies the configuration information to launch a fleet--or group--of instances.
 *
 * An EC2 Fleet can launch multiple instance types across multiple Availability Zones, using the On-Demand Instance, Reserved Instance, and Spot Instance purchasing models together. Using EC2 Fleet, you can define separate On-Demand and Spot capacity targets, specify the instance types that work best for your applications, and specify how Amazon EC2 should distribute your fleet capacity within each purchasing model. For more information, see [Launching an EC2 Fleet](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet.html) in the *Amazon EC2 User Guide for Linux Instances* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html
 */
export class CfnEC2Fleet extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::EC2Fleet";

  /**
   * Build a CfnEC2Fleet from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnEC2Fleet {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnEC2FleetPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnEC2Fleet(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the EC2 Fleet.
   *
   * @cloudformationAttribute FleetId
   */
  public readonly attrFleetId: string;

  /**
   * Reserved.
   */
  public context?: string;

  /**
   * Indicates whether running instances should be terminated if the total target capacity of the EC2 Fleet is decreased below the current size of the EC2 Fleet.
   */
  public excessCapacityTerminationPolicy?: string;

  /**
   * The configuration for the EC2 Fleet.
   */
  public launchTemplateConfigs: Array<CfnEC2Fleet.FleetLaunchTemplateConfigRequestProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * Describes the configuration of On-Demand Instances in an EC2 Fleet.
   */
  public onDemandOptions?: cdk.IResolvable | CfnEC2Fleet.OnDemandOptionsRequestProperty;

  /**
   * Indicates whether EC2 Fleet should replace unhealthy Spot Instances.
   */
  public replaceUnhealthyInstances?: boolean | cdk.IResolvable;

  /**
   * Describes the configuration of Spot Instances in an EC2 Fleet.
   */
  public spotOptions?: cdk.IResolvable | CfnEC2Fleet.SpotOptionsRequestProperty;

  /**
   * The key-value pair for tagging the EC2 Fleet request on creation. For more information, see [Tagging your resources](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html#tag-resources) .
   */
  public tagSpecifications?: Array<cdk.IResolvable | CfnEC2Fleet.TagSpecificationProperty> | cdk.IResolvable;

  /**
   * The number of units to request.
   */
  public targetCapacitySpecification: cdk.IResolvable | CfnEC2Fleet.TargetCapacitySpecificationRequestProperty;

  /**
   * Indicates whether running instances should be terminated when the EC2 Fleet expires.
   */
  public terminateInstancesWithExpiration?: boolean | cdk.IResolvable;

  /**
   * The fleet type. The default value is \`maintain\` .
   */
  public type?: string;

  /**
   * The start date and time of the request, in UTC format (for example, *YYYY* - *MM* - *DD* T *HH* : *MM* : *SS* Z).
   */
  public validFrom?: string;

  /**
   * The end date and time of the request, in UTC format (for example, *YYYY* - *MM* - *DD* T *HH* : *MM* : *SS* Z).
   */
  public validUntil?: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnEC2FleetProps) {
    super(scope, id, {
      "type": CfnEC2Fleet.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "launchTemplateConfigs", this);
    cdk.requireProperty(props, "targetCapacitySpecification", this);

    this.attrFleetId = cdk.Token.asString(this.getAtt("FleetId", cdk.ResolutionTypeHint.STRING));
    this.context = props.context;
    this.excessCapacityTerminationPolicy = props.excessCapacityTerminationPolicy;
    this.launchTemplateConfigs = props.launchTemplateConfigs;
    this.onDemandOptions = props.onDemandOptions;
    this.replaceUnhealthyInstances = props.replaceUnhealthyInstances;
    this.spotOptions = props.spotOptions;
    this.tagSpecifications = props.tagSpecifications;
    this.targetCapacitySpecification = props.targetCapacitySpecification;
    this.terminateInstancesWithExpiration = props.terminateInstancesWithExpiration;
    this.type = props.type;
    this.validFrom = props.validFrom;
    this.validUntil = props.validUntil;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "context": this.context,
      "excessCapacityTerminationPolicy": this.excessCapacityTerminationPolicy,
      "launchTemplateConfigs": this.launchTemplateConfigs,
      "onDemandOptions": this.onDemandOptions,
      "replaceUnhealthyInstances": this.replaceUnhealthyInstances,
      "spotOptions": this.spotOptions,
      "tagSpecifications": this.tagSpecifications,
      "targetCapacitySpecification": this.targetCapacitySpecification,
      "terminateInstancesWithExpiration": this.terminateInstancesWithExpiration,
      "type": this.type,
      "validFrom": this.validFrom,
      "validUntil": this.validUntil
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnEC2Fleet.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnEC2FleetPropsToCloudFormation(props);
  }
}

export namespace CfnEC2Fleet {
  /**
   * Specifies the number of units to request for an EC2 Fleet.
   *
   * You can choose to set the target capacity in terms of instances or a performance characteristic that is important to your application workload, such as vCPUs, memory, or I/O. If the request type is \`maintain\` , you can specify a target capacity of \`0\` and add capacity later.
   *
   * \`TargetCapacitySpecificationRequest\` is a property of the [AWS::EC2::EC2Fleet](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html) resource.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-targetcapacityspecificationrequest.html
   */
  export interface TargetCapacitySpecificationRequestProperty {
    /**
     * The default \`TotalTargetCapacity\` , which is either \`Spot\` or \`On-Demand\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-targetcapacityspecificationrequest.html#cfn-ec2-ec2fleet-targetcapacityspecificationrequest-defaulttargetcapacitytype
     */
    readonly defaultTargetCapacityType?: string;

    /**
     * The number of On-Demand units to request.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-targetcapacityspecificationrequest.html#cfn-ec2-ec2fleet-targetcapacityspecificationrequest-ondemandtargetcapacity
     */
    readonly onDemandTargetCapacity?: number;

    /**
     * The number of Spot units to request.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-targetcapacityspecificationrequest.html#cfn-ec2-ec2fleet-targetcapacityspecificationrequest-spottargetcapacity
     */
    readonly spotTargetCapacity?: number;

    /**
     * The unit for the target capacity. \`TargetCapacityUnitType\` can only be specified when \`InstanceRequirements\` is specified.
     *
     * Default: \`units\` (translates to number of instances)
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-targetcapacityspecificationrequest.html#cfn-ec2-ec2fleet-targetcapacityspecificationrequest-targetcapacityunittype
     */
    readonly targetCapacityUnitType?: string;

    /**
     * The number of units to request, filled using \`DefaultTargetCapacityType\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-targetcapacityspecificationrequest.html#cfn-ec2-ec2fleet-targetcapacityspecificationrequest-totaltargetcapacity
     */
    readonly totalTargetCapacity: number;
  }

  /**
   * Specifies the allocation strategy of On-Demand Instances in an EC2 Fleet.
   *
   * \`OnDemandOptionsRequest\` is a property of the [AWS::EC2::EC2Fleet](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html) resource.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-ondemandoptionsrequest.html
   */
  export interface OnDemandOptionsRequestProperty {
    /**
     * The strategy that determines the order of the launch template overrides to use in fulfilling On-Demand capacity.
     *
     * \`lowest-price\` - EC2 Fleet uses price to determine the order, launching the lowest price first.
     *
     * \`prioritized\` - EC2 Fleet uses the priority that you assigned to each launch template override, launching the highest priority first.
     *
     * Default: \`lowest-price\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-ondemandoptionsrequest.html#cfn-ec2-ec2fleet-ondemandoptionsrequest-allocationstrategy
     */
    readonly allocationStrategy?: string;

    /**
     * The strategy for using unused Capacity Reservations for fulfilling On-Demand capacity.
     *
     * Supported only for fleets of type \`instant\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-ondemandoptionsrequest.html#cfn-ec2-ec2fleet-ondemandoptionsrequest-capacityreservationoptions
     */
    readonly capacityReservationOptions?: CfnEC2Fleet.CapacityReservationOptionsRequestProperty | cdk.IResolvable;

    /**
     * The maximum amount per hour for On-Demand Instances that you're willing to pay.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-ondemandoptionsrequest.html#cfn-ec2-ec2fleet-ondemandoptionsrequest-maxtotalprice
     */
    readonly maxTotalPrice?: string;

    /**
     * The minimum target capacity for On-Demand Instances in the fleet.
     *
     * If the minimum target capacity is not reached, the fleet launches no instances.
     *
     * Supported only for fleets of type \`instant\` .
     *
     * At least one of the following must be specified: \`SingleAvailabilityZone\` | \`SingleInstanceType\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-ondemandoptionsrequest.html#cfn-ec2-ec2fleet-ondemandoptionsrequest-mintargetcapacity
     */
    readonly minTargetCapacity?: number;

    /**
     * Indicates that the fleet launches all On-Demand Instances into a single Availability Zone.
     *
     * Supported only for fleets of type \`instant\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-ondemandoptionsrequest.html#cfn-ec2-ec2fleet-ondemandoptionsrequest-singleavailabilityzone
     */
    readonly singleAvailabilityZone?: boolean | cdk.IResolvable;

    /**
     * Indicates that the fleet uses a single instance type to launch all On-Demand Instances in the fleet.
     *
     * Supported only for fleets of type \`instant\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-ondemandoptionsrequest.html#cfn-ec2-ec2fleet-ondemandoptionsrequest-singleinstancetype
     */
    readonly singleInstanceType?: boolean | cdk.IResolvable;
  }

  /**
   * Describes the strategy for using unused Capacity Reservations for fulfilling On-Demand capacity.
   *
   * > This strategy can only be used if the EC2 Fleet is of type \`instant\` .
   *
   * For more information about Capacity Reservations, see [On-Demand Capacity Reservations](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-capacity-reservations.html) in the *Amazon EC2 User Guide* . For examples of using Capacity Reservations in an EC2 Fleet, see [EC2 Fleet example configurations](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-examples.html) in the *Amazon EC2 User Guide* .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-capacityreservationoptionsrequest.html
   */
  export interface CapacityReservationOptionsRequestProperty {
    /**
     * Indicates whether to use unused Capacity Reservations for fulfilling On-Demand capacity.
     *
     * If you specify \`use-capacity-reservations-first\` , the fleet uses unused Capacity Reservations to fulfill On-Demand capacity up to the target On-Demand capacity. If multiple instance pools have unused Capacity Reservations, the On-Demand allocation strategy ( \`lowest-price\` or \`prioritized\` ) is applied. If the number of unused Capacity Reservations is less than the On-Demand target capacity, the remaining On-Demand target capacity is launched according to the On-Demand allocation strategy ( \`lowest-price\` or \`prioritized\` ).
     *
     * If you do not specify a value, the fleet fulfils the On-Demand capacity according to the chosen On-Demand allocation strategy.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-capacityreservationoptionsrequest.html#cfn-ec2-ec2fleet-capacityreservationoptionsrequest-usagestrategy
     */
    readonly usageStrategy?: string;
  }

  /**
   * Specifies the tags to apply to a resource when the resource is being created for an EC2 Fleet.
   *
   * \`TagSpecification\` is a property of the [AWS::EC2::EC2Fleet](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html) resource.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-tagspecification.html
   */
  export interface TagSpecificationProperty {
    /**
     * The type of resource to tag.
     *
     * \`ResourceType\` must be \`fleet\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-tagspecification.html#cfn-ec2-ec2fleet-tagspecification-resourcetype
     */
    readonly resourceType?: string;

    /**
     * The tags to apply to the resource.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-tagspecification.html#cfn-ec2-ec2fleet-tagspecification-tags
     */
    readonly tags?: Array<cdk.CfnTag>;
  }

  /**
   * Specifies the configuration of Spot Instances for an EC2 Fleet.
   *
   * \`SpotOptionsRequest\` is a property of the [AWS::EC2::EC2Fleet](https://docs.aws.amazon.com//AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html) resource.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-spotoptionsrequest.html
   */
  export interface SpotOptionsRequestProperty {
    /**
     * Indicates how to allocate the target Spot Instance capacity across the Spot Instance pools specified by the EC2 Fleet.
     *
     * If the allocation strategy is \`lowestPrice\` , EC2 Fleet launches instances from the Spot Instance pools with the lowest price. This is the default allocation strategy.
     *
     * If the allocation strategy is \`diversified\` , EC2 Fleet launches instances from all the Spot Instance pools that you specify.
     *
     * If the allocation strategy is \`capacityOptimized\` , EC2 Fleet launches instances from Spot Instance pools that are optimally chosen based on the available Spot Instance capacity.
     *
     * *Allowed Values* : \`lowestPrice\` | \`diversified\` | \`capacityOptimized\` | \`capacityOptimizedPrioritized\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-spotoptionsrequest.html#cfn-ec2-ec2fleet-spotoptionsrequest-allocationstrategy
     */
    readonly allocationStrategy?: string;

    /**
     * The behavior when a Spot Instance is interrupted.
     *
     * Default: \`terminate\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-spotoptionsrequest.html#cfn-ec2-ec2fleet-spotoptionsrequest-instanceinterruptionbehavior
     */
    readonly instanceInterruptionBehavior?: string;

    /**
     * The number of Spot pools across which to allocate your target Spot capacity.
     *
     * Supported only when Spot \`AllocationStrategy\` is set to \`lowest-price\` . EC2 Fleet selects the cheapest Spot pools and evenly allocates your target Spot capacity across the number of Spot pools that you specify.
     *
     * Note that EC2 Fleet attempts to draw Spot Instances from the number of pools that you specify on a best effort basis. If a pool runs out of Spot capacity before fulfilling your target capacity, EC2 Fleet will continue to fulfill your request by drawing from the next cheapest pool. To ensure that your target capacity is met, you might receive Spot Instances from more than the number of pools that you specified. Similarly, if most of the pools have no Spot capacity, you might receive your full target capacity from fewer than the number of pools that you specified.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-spotoptionsrequest.html#cfn-ec2-ec2fleet-spotoptionsrequest-instancepoolstousecount
     */
    readonly instancePoolsToUseCount?: number;

    /**
     * The strategies for managing your Spot Instances that are at an elevated risk of being interrupted.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-spotoptionsrequest.html#cfn-ec2-ec2fleet-spotoptionsrequest-maintenancestrategies
     */
    readonly maintenanceStrategies?: cdk.IResolvable | CfnEC2Fleet.MaintenanceStrategiesProperty;

    /**
     * The maximum amount per hour for Spot Instances that you're willing to pay.
     *
     * We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price.
     *
     * > If you specify a maximum price, your Spot Instances will be interrupted more frequently than if you do not specify this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-spotoptionsrequest.html#cfn-ec2-ec2fleet-spotoptionsrequest-maxtotalprice
     */
    readonly maxTotalPrice?: string;

    /**
     * The minimum target capacity for Spot Instances in the fleet.
     *
     * If the minimum target capacity is not reached, the fleet launches no instances.
     *
     * Supported only for fleets of type \`instant\` .
     *
     * At least one of the following must be specified: \`SingleAvailabilityZone\` | \`SingleInstanceType\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-spotoptionsrequest.html#cfn-ec2-ec2fleet-spotoptionsrequest-mintargetcapacity
     */
    readonly minTargetCapacity?: number;

    /**
     * Indicates that the fleet launches all Spot Instances into a single Availability Zone.
     *
     * Supported only for fleets of type \`instant\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-spotoptionsrequest.html#cfn-ec2-ec2fleet-spotoptionsrequest-singleavailabilityzone
     */
    readonly singleAvailabilityZone?: boolean | cdk.IResolvable;

    /**
     * Indicates that the fleet uses a single instance type to launch all Spot Instances in the fleet.
     *
     * Supported only for fleets of type \`instant\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-spotoptionsrequest.html#cfn-ec2-ec2fleet-spotoptionsrequest-singleinstancetype
     */
    readonly singleInstanceType?: boolean | cdk.IResolvable;
  }

  /**
   * The strategies for managing your Spot Instances that are at an elevated risk of being interrupted.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-maintenancestrategies.html
   */
  export interface MaintenanceStrategiesProperty {
    /**
     * The strategy to use when Amazon EC2 emits a signal that your Spot Instance is at an elevated risk of being interrupted.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-maintenancestrategies.html#cfn-ec2-ec2fleet-maintenancestrategies-capacityrebalance
     */
    readonly capacityRebalance?: CfnEC2Fleet.CapacityRebalanceProperty | cdk.IResolvable;
  }

  /**
   * The Spot Instance replacement strategy to use when Amazon EC2 emits a rebalance notification signal that your Spot Instance is at an elevated risk of being interrupted.
   *
   * For more information, see [Capacity rebalancing](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-capacity-rebalance.html) in the *Amazon EC2 User Guide* .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-capacityrebalance.html
   */
  export interface CapacityRebalanceProperty {
    /**
     * The replacement strategy to use. Only available for fleets of type \`maintain\` .
     *
     * \`launch\` - EC2 Fleet launches a replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet. EC2 Fleet does not terminate the instances that receive a rebalance notification. You can terminate the old instances, or you can leave them running. You are charged for all instances while they are running.
     *
     * \`launch-before-terminate\` - EC2 Fleet launches a replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet, and then, after a delay that you specify (in \`TerminationDelay\` ), terminates the instances that received a rebalance notification.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-capacityrebalance.html#cfn-ec2-ec2fleet-capacityrebalance-replacementstrategy
     */
    readonly replacementStrategy?: string;

    /**
     * The amount of time (in seconds) that Amazon EC2 waits before terminating the old Spot Instance after launching a new replacement Spot Instance.
     *
     * Required when \`ReplacementStrategy\` is set to \`launch-before-terminate\` .
     *
     * Not valid when \`ReplacementStrategy\` is set to \`launch\` .
     *
     * Valid values: Minimum value of \`120\` seconds. Maximum value of \`7200\` seconds.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-capacityrebalance.html#cfn-ec2-ec2fleet-capacityrebalance-terminationdelay
     */
    readonly terminationDelay?: number;
  }

  /**
   * Specifies a launch template and overrides for an EC2 Fleet.
   *
   * \`FleetLaunchTemplateConfigRequest\` is a property of the [AWS::EC2::EC2Fleet](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html) resource.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateconfigrequest.html
   */
  export interface FleetLaunchTemplateConfigRequestProperty {
    /**
     * The launch template to use.
     *
     * You must specify either the launch template ID or launch template name in the request.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateconfigrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplateconfigrequest-launchtemplatespecification
     */
    readonly launchTemplateSpecification?: CfnEC2Fleet.FleetLaunchTemplateSpecificationRequestProperty | cdk.IResolvable;

    /**
     * Any parameters that you specify override the same parameters in the launch template.
     *
     * For fleets of type \`request\` and \`maintain\` , a maximum of 300 items is allowed across all launch templates.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateconfigrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplateconfigrequest-overrides
     */
    readonly overrides?: Array<CfnEC2Fleet.FleetLaunchTemplateOverridesRequestProperty | cdk.IResolvable> | cdk.IResolvable;
  }

  /**
   * Specifies the launch template to be used by the EC2 Fleet for configuring Amazon EC2 instances.
   *
   * You must specify the following:
   *
   * - The ID or the name of the launch template, but not both.
   * - The version of the launch template.
   *
   * \`FleetLaunchTemplateSpecificationRequest\` is a property of the [FleetLaunchTemplateConfigRequest](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateconfigrequest.html) property type.
   *
   * For information about creating a launch template, see [AWS::EC2::LaunchTemplate](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html) and [Create a launch template](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-templates.html#create-launch-template) in the *Amazon EC2 User Guide* .
   *
   * For examples of launch templates, see [Examples](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#aws-resource-ec2-launchtemplate--examples) .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplatespecificationrequest.html
   */
  export interface FleetLaunchTemplateSpecificationRequestProperty {
    /**
     * The ID of the launch template.
     *
     * You must specify the \`LaunchTemplateId\` or the \`LaunchTemplateName\` , but not both.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplatespecificationrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplatespecificationrequest-launchtemplateid
     */
    readonly launchTemplateId?: string;

    /**
     * The name of the launch template.
     *
     * You must specify the \`LaunchTemplateName\` or the \`LaunchTemplateId\` , but not both.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplatespecificationrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplatespecificationrequest-launchtemplatename
     */
    readonly launchTemplateName?: string;

    /**
     * The launch template version number, \`$Latest\` , or \`$Default\` . You must specify a value, otherwise the request fails.
     *
     * If the value is \`$Latest\` , Amazon EC2 uses the latest version of the launch template.
     *
     * If the value is \`$Default\` , Amazon EC2 uses the default version of the launch template.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplatespecificationrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplatespecificationrequest-version
     */
    readonly version: string;
  }

  /**
   * Specifies overrides for a launch template for an EC2 Fleet.
   *
   * \`FleetLaunchTemplateOverridesRequest\` is a property of the [FleetLaunchTemplateConfigRequest](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateconfigrequest.html) property type.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest.html
   */
  export interface FleetLaunchTemplateOverridesRequestProperty {
    /**
     * The Availability Zone in which to launch the instances.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest-availabilityzone
     */
    readonly availabilityZone?: string;

    /**
     * The attributes for the instance types.
     *
     * When you specify instance attributes, Amazon EC2 will identify instance types with those attributes.
     *
     * > If you specify \`InstanceRequirements\` , you can't specify \`InstanceType\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest-instancerequirements
     */
    readonly instanceRequirements?: CfnEC2Fleet.InstanceRequirementsRequestProperty | cdk.IResolvable;

    /**
     * The instance type.
     *
     * \`mac1.metal\` is not supported as a launch template override.
     *
     * > If you specify \`InstanceType\` , you can't specify \`InstanceRequirements\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest-instancetype
     */
    readonly instanceType?: string;

    /**
     * The maximum price per unit hour that you are willing to pay for a Spot Instance.
     *
     * We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price.
     *
     * > If you specify a maximum price, your instances will be interrupted more frequently than if you do not specify this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest-maxprice
     */
    readonly maxPrice?: string;

    /**
     * The location where the instance launched, if applicable.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest-placement
     */
    readonly placement?: cdk.IResolvable | CfnEC2Fleet.PlacementProperty;

    /**
     * The priority for the launch template override. The highest priority is launched first.
     *
     * If the On-Demand \`AllocationStrategy\` is set to \`prioritized\` , EC2 Fleet uses priority to determine which launch template override to use first in fulfilling On-Demand capacity.
     *
     * If the Spot \`AllocationStrategy\` is set to \`capacity-optimized-prioritized\` , EC2 Fleet uses priority on a best-effort basis to determine which launch template override to use in fulfilling Spot capacity, but optimizes for capacity first.
     *
     * Valid values are whole numbers starting at \`0\` . The lower the number, the higher the priority. If no number is set, the launch template override has the lowest priority. You can set the same priority for different launch template overrides.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest-priority
     */
    readonly priority?: number;

    /**
     * The IDs of the subnets in which to launch the instances.
     *
     * Separate multiple subnet IDs using commas (for example, \`subnet-1234abcdeexample1, subnet-0987cdef6example2\` ). A request of type \`instant\` can have only one subnet ID.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest-subnetid
     */
    readonly subnetId?: string;

    /**
     * The number of units provided by the specified instance type.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest-weightedcapacity
     */
    readonly weightedCapacity?: number;
  }

  /**
   * Describes the placement of an instance.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-placement.html
   */
  export interface PlacementProperty {
    /**
     * The affinity setting for the instance on the Dedicated Host.
     *
     * This parameter is not supported for [CreateFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet) or [ImportInstance](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportInstance.html) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-placement.html#cfn-ec2-ec2fleet-placement-affinity
     */
    readonly affinity?: string;

    /**
     * The Availability Zone of the instance.
     *
     * If not specified, an Availability Zone will be automatically chosen for you based on the load balancing criteria for the Region.
     *
     * This parameter is not supported for [CreateFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-placement.html#cfn-ec2-ec2fleet-placement-availabilityzone
     */
    readonly availabilityZone?: string;

    /**
     * The name of the placement group that the instance is in.
     *
     * If you specify \`GroupName\` , you can't specify \`GroupId\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-placement.html#cfn-ec2-ec2fleet-placement-groupname
     */
    readonly groupName?: string;

    /**
     * The ID of the Dedicated Host on which the instance resides.
     *
     * This parameter is not supported for [CreateFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet) or [ImportInstance](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportInstance.html) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-placement.html#cfn-ec2-ec2fleet-placement-hostid
     */
    readonly hostId?: string;

    /**
     * The ARN of the host resource group in which to launch the instances.
     *
     * If you specify this parameter, either omit the *Tenancy* parameter or set it to \`host\` .
     *
     * This parameter is not supported for [CreateFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-placement.html#cfn-ec2-ec2fleet-placement-hostresourcegrouparn
     */
    readonly hostResourceGroupArn?: string;

    /**
     * The number of the partition that the instance is in.
     *
     * Valid only if the placement group strategy is set to \`partition\` .
     *
     * This parameter is not supported for [CreateFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-placement.html#cfn-ec2-ec2fleet-placement-partitionnumber
     */
    readonly partitionNumber?: number;

    /**
     * Reserved for future use.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-placement.html#cfn-ec2-ec2fleet-placement-spreaddomain
     */
    readonly spreadDomain?: string;

    /**
     * The tenancy of the instance. An instance with a tenancy of \`dedicated\` runs on single-tenant hardware.
     *
     * This parameter is not supported for [CreateFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet) . The \`host\` tenancy is not supported for [ImportInstance](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportInstance.html) or for T3 instances that are configured for the \`unlimited\` CPU credit option.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-placement.html#cfn-ec2-ec2fleet-placement-tenancy
     */
    readonly tenancy?: string;
  }

  /**
   * The attributes for the instance types.
   *
   * When you specify instance attributes, Amazon EC2 will identify instance types with these attributes.
   *
   * When you specify multiple attributes, you get instance types that satisfy all of the specified attributes. If you specify multiple values for an attribute, you get instance types that satisfy any of the specified values.
   *
   * To limit the list of instance types from which Amazon EC2 can identify matching instance types, you can use one of the following parameters, but not both in the same request:
   *
   * - \`AllowedInstanceTypes\` - The instance types to include in the list. All other instance types are ignored, even if they match your specified attributes.
   * - \`ExcludedInstanceTypes\` - The instance types to exclude from the list, even if they match your specified attributes.
   *
   * > You must specify \`VCpuCount\` and \`MemoryMiB\` . All other attributes are optional. Any unspecified optional attribute is set to its default.
   *
   * For more information, see [Attribute-based instance type selection for EC2 Fleet](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html) , [Attribute-based instance type selection for Spot Fleet](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-attribute-based-instance-type-selection.html) , and [Spot placement score](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-placement-score.html) in the *Amazon EC2 User Guide* .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html
   */
  export interface InstanceRequirementsRequestProperty {
    /**
     * The minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips) on an instance.
     *
     * To exclude accelerator-enabled instance types, set \`Max\` to \`0\` .
     *
     * Default: No minimum or maximum limits
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-acceleratorcount
     */
    readonly acceleratorCount?: CfnEC2Fleet.AcceleratorCountRequestProperty | cdk.IResolvable;

    /**
     * Indicates whether instance types must have accelerators by specific manufacturers.
     *
     * - For instance types with NVIDIA devices, specify \`nvidia\` .
     * - For instance types with AMD devices, specify \`amd\` .
     * - For instance types with AWS devices, specify \`amazon-web-services\` .
     * - For instance types with Xilinx devices, specify \`xilinx\` .
     *
     * Default: Any manufacturer
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-acceleratormanufacturers
     */
    readonly acceleratorManufacturers?: Array<string>;

    /**
     * The accelerators that must be on the instance type.
     *
     * - For instance types with NVIDIA A100 GPUs, specify \`a100\` .
     * - For instance types with NVIDIA V100 GPUs, specify \`v100\` .
     * - For instance types with NVIDIA K80 GPUs, specify \`k80\` .
     * - For instance types with NVIDIA T4 GPUs, specify \`t4\` .
     * - For instance types with NVIDIA M60 GPUs, specify \`m60\` .
     * - For instance types with AMD Radeon Pro V520 GPUs, specify \`radeon-pro-v520\` .
     * - For instance types with Xilinx VU9P FPGAs, specify \`vu9p\` .
     * - For instance types with AWS Inferentia chips, specify \`inferentia\` .
     * - For instance types with NVIDIA GRID K520 GPUs, specify \`k520\` .
     *
     * Default: Any accelerator
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-acceleratornames
     */
    readonly acceleratorNames?: Array<string>;

    /**
     * The minimum and maximum amount of total accelerator memory, in MiB.
     *
     * Default: No minimum or maximum limits
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-acceleratortotalmemorymib
     */
    readonly acceleratorTotalMemoryMiB?: CfnEC2Fleet.AcceleratorTotalMemoryMiBRequestProperty | cdk.IResolvable;

    /**
     * The accelerator types that must be on the instance type.
     *
     * - To include instance types with GPU hardware, specify \`gpu\` .
     * - To include instance types with FPGA hardware, specify \`fpga\` .
     * - To include instance types with inference hardware, specify \`inference\` .
     *
     * Default: Any accelerator type
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-acceleratortypes
     */
    readonly acceleratorTypes?: Array<string>;

    /**
     * The instance types to apply your specified attributes against.
     *
     * All other instance types are ignored, even if they match your specified attributes.
     *
     * You can use strings with one or more wild cards, represented by an asterisk ( \`*\` ), to allow an instance type, size, or generation. The following are examples: \`m5.8xlarge\` , \`c5*.*\` , \`m5a.*\` , \`r*\` , \`*3*\` .
     *
     * For example, if you specify \`c5*\` ,Amazon EC2 will allow the entire C5 instance family, which includes all C5a and C5n instance types. If you specify \`m5a.*\` , Amazon EC2 will allow all the M5a instance types, but not the M5n instance types.
     *
     * > If you specify \`AllowedInstanceTypes\` , you can't specify \`ExcludedInstanceTypes\` .
     *
     * Default: All instance types
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-allowedinstancetypes
     */
    readonly allowedInstanceTypes?: Array<string>;

    /**
     * Indicates whether bare metal instance types must be included, excluded, or required.
     *
     * - To include bare metal instance types, specify \`included\` .
     * - To require only bare metal instance types, specify \`required\` .
     * - To exclude bare metal instance types, specify \`excluded\` .
     *
     * Default: \`excluded\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-baremetal
     */
    readonly bareMetal?: string;

    /**
     * The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps.
     *
     * For more information, see [Amazon EBSoptimized instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html) in the *Amazon EC2 User Guide* .
     *
     * Default: No minimum or maximum limits
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-baselineebsbandwidthmbps
     */
    readonly baselineEbsBandwidthMbps?: CfnEC2Fleet.BaselineEbsBandwidthMbpsRequestProperty | cdk.IResolvable;

    /**
     * Indicates whether burstable performance T instance types are included, excluded, or required.
     *
     * For more information, see [Burstable performance instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html) .
     *
     * - To include burstable performance instance types, specify \`included\` .
     * - To require only burstable performance instance types, specify \`required\` .
     * - To exclude burstable performance instance types, specify \`excluded\` .
     *
     * Default: \`excluded\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-burstableperformance
     */
    readonly burstablePerformance?: string;

    /**
     * The CPU manufacturers to include.
     *
     * - For instance types with Intel CPUs, specify \`intel\` .
     * - For instance types with AMD CPUs, specify \`amd\` .
     * - For instance types with AWS CPUs, specify \`amazon-web-services\` .
     *
     * > Don't confuse the CPU manufacturer with the CPU architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template.
     *
     * Default: Any manufacturer
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-cpumanufacturers
     */
    readonly cpuManufacturers?: Array<string>;

    /**
     * The instance types to exclude.
     *
     * You can use strings with one or more wild cards, represented by an asterisk ( \`*\` ), to exclude an instance family, type, size, or generation. The following are examples: \`m5.8xlarge\` , \`c5*.*\` , \`m5a.*\` , \`r*\` , \`*3*\` .
     *
     * For example, if you specify \`c5*\` ,Amazon EC2 will exclude the entire C5 instance family, which includes all C5a and C5n instance types. If you specify \`m5a.*\` , Amazon EC2 will exclude all the M5a instance types, but not the M5n instance types.
     *
     * > If you specify \`ExcludedInstanceTypes\` , you can't specify \`AllowedInstanceTypes\` .
     *
     * Default: No excluded instance types
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-excludedinstancetypes
     */
    readonly excludedInstanceTypes?: Array<string>;

    /**
     * Indicates whether current or previous generation instance types are included.
     *
     * The current generation instance types are recommended for use. Current generation instance types are typically the latest two to three generations in each instance family. For more information, see [Instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the *Amazon EC2 User Guide* .
     *
     * For current generation instance types, specify \`current\` .
     *
     * For previous generation instance types, specify \`previous\` .
     *
     * Default: Current and previous generation instance types
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-instancegenerations
     */
    readonly instanceGenerations?: Array<string>;

    /**
     * Indicates whether instance types with instance store volumes are included, excluded, or required.
     *
     * For more information, [Amazon EC2 instance store](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html) in the *Amazon EC2 User Guide* .
     *
     * - To include instance types with instance store volumes, specify \`included\` .
     * - To require only instance types with instance store volumes, specify \`required\` .
     * - To exclude instance types with instance store volumes, specify \`excluded\` .
     *
     * Default: \`included\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-localstorage
     */
    readonly localStorage?: string;

    /**
     * The type of local storage that is required.
     *
     * - For instance types with hard disk drive (HDD) storage, specify \`hdd\` .
     * - For instance types with solid state drive (SSD) storage, specify \`ssd\` .
     *
     * Default: \`hdd\` and \`ssd\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-localstoragetypes
     */
    readonly localStorageTypes?: Array<string>;

    /**
     * The minimum and maximum amount of memory per vCPU, in GiB.
     *
     * Default: No minimum or maximum limits
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-memorygibpervcpu
     */
    readonly memoryGiBPerVCpu?: cdk.IResolvable | CfnEC2Fleet.MemoryGiBPerVCpuRequestProperty;

    /**
     * The minimum and maximum amount of memory, in MiB.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-memorymib
     */
    readonly memoryMiB?: cdk.IResolvable | CfnEC2Fleet.MemoryMiBRequestProperty;

    /**
     * The minimum and maximum amount of network bandwidth, in gigabits per second (Gbps).
     *
     * Default: No minimum or maximum limits
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-networkbandwidthgbps
     */
    readonly networkBandwidthGbps?: cdk.IResolvable | CfnEC2Fleet.NetworkBandwidthGbpsRequestProperty;

    /**
     * The minimum and maximum number of network interfaces.
     *
     * Default: No minimum or maximum limits
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-networkinterfacecount
     */
    readonly networkInterfaceCount?: cdk.IResolvable | CfnEC2Fleet.NetworkInterfaceCountRequestProperty;

    /**
     * The price protection threshold for On-Demand Instances.
     *
     * This is the maximum youll pay for an On-Demand Instance, expressed as a percentage above the least expensive current generation M, C, or R instance type with your specified attributes. When Amazon EC2 selects instance types with your attributes, it excludes instance types priced above your threshold.
     *
     * The parameter accepts an integer, which Amazon EC2 interprets as a percentage.
     *
     * To turn off price protection, specify a high value, such as \`999999\` .
     *
     * This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) and [GetInstanceTypesFromInstanceRequirements](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html) .
     *
     * > If you set \`TargetCapacityUnitType\` to \`vcpu\` or \`memory-mib\` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price.
     *
     * Default: \`20\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-ondemandmaxpricepercentageoverlowestprice
     */
    readonly onDemandMaxPricePercentageOverLowestPrice?: number;

    /**
     * Indicates whether instance types must support hibernation for On-Demand Instances.
     *
     * This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) .
     *
     * Default: \`false\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-requirehibernatesupport
     */
    readonly requireHibernateSupport?: boolean | cdk.IResolvable;

    /**
     * The price protection threshold for Spot Instance.
     *
     * This is the maximum youll pay for an Spot Instance, expressed as a percentage above the least expensive current generation M, C, or R instance type with your specified attributes. When Amazon EC2 selects instance types with your attributes, it excludes instance types priced above your threshold.
     *
     * The parameter accepts an integer, which Amazon EC2 interprets as a percentage.
     *
     * To turn off price protection, specify a high value, such as \`999999\` .
     *
     * This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) and [GetInstanceTypesFromInstanceRequirements](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html) .
     *
     * > If you set \`TargetCapacityUnitType\` to \`vcpu\` or \`memory-mib\` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price.
     *
     * Default: \`100\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-spotmaxpricepercentageoverlowestprice
     */
    readonly spotMaxPricePercentageOverLowestPrice?: number;

    /**
     * The minimum and maximum amount of total local storage, in GB.
     *
     * Default: No minimum or maximum limits
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-totallocalstoragegb
     */
    readonly totalLocalStorageGb?: cdk.IResolvable | CfnEC2Fleet.TotalLocalStorageGBRequestProperty;

    /**
     * The minimum and maximum number of vCPUs.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-vcpucount
     */
    readonly vCpuCount?: cdk.IResolvable | CfnEC2Fleet.VCpuCountRangeRequestProperty;
  }

  /**
   * The minimum and maximum number of vCPUs.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-vcpucountrangerequest.html
   */
  export interface VCpuCountRangeRequestProperty {
    /**
     * The maximum number of vCPUs.
     *
     * To specify no maximum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-vcpucountrangerequest.html#cfn-ec2-ec2fleet-vcpucountrangerequest-max
     */
    readonly max?: number;

    /**
     * The minimum number of vCPUs.
     *
     * To specify no minimum limit, specify \`0\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-vcpucountrangerequest.html#cfn-ec2-ec2fleet-vcpucountrangerequest-min
     */
    readonly min?: number;
  }

  /**
   * The minimum and maximum amount of memory, in MiB.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-memorymibrequest.html
   */
  export interface MemoryMiBRequestProperty {
    /**
     * The maximum amount of memory, in MiB.
     *
     * To specify no maximum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-memorymibrequest.html#cfn-ec2-ec2fleet-memorymibrequest-max
     */
    readonly max?: number;

    /**
     * The minimum amount of memory, in MiB.
     *
     * To specify no minimum limit, specify \`0\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-memorymibrequest.html#cfn-ec2-ec2fleet-memorymibrequest-min
     */
    readonly min?: number;
  }

  /**
   * The minimum and maximum amount of memory per vCPU, in GiB.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-memorygibpervcpurequest.html
   */
  export interface MemoryGiBPerVCpuRequestProperty {
    /**
     * The maximum amount of memory per vCPU, in GiB.
     *
     * To specify no maximum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-memorygibpervcpurequest.html#cfn-ec2-ec2fleet-memorygibpervcpurequest-max
     */
    readonly max?: number;

    /**
     * The minimum amount of memory per vCPU, in GiB.
     *
     * To specify no minimum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-memorygibpervcpurequest.html#cfn-ec2-ec2fleet-memorygibpervcpurequest-min
     */
    readonly min?: number;
  }

  /**
   * The minimum and maximum amount of network bandwidth, in gigabits per second (Gbps).
   *
   * > Setting the minimum bandwidth does not guarantee that your instance will achieve the minimum bandwidth. Amazon EC2 will identify instance types that support the specified minimum bandwidth, but the actual bandwidth of your instance might go below the specified minimum at times. For more information, see [Available instance bandwidth](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-network-bandwidth.html#available-instance-bandwidth) in the *Amazon EC2 User Guide* .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-networkbandwidthgbpsrequest.html
   */
  export interface NetworkBandwidthGbpsRequestProperty {
    /**
     * The maximum amount of network bandwidth, in Gbps.
     *
     * To specify no maximum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-networkbandwidthgbpsrequest.html#cfn-ec2-ec2fleet-networkbandwidthgbpsrequest-max
     */
    readonly max?: number;

    /**
     * The minimum amount of network bandwidth, in Gbps.
     *
     * To specify no minimum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-networkbandwidthgbpsrequest.html#cfn-ec2-ec2fleet-networkbandwidthgbpsrequest-min
     */
    readonly min?: number;
  }

  /**
   * The minimum and maximum number of network interfaces.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-networkinterfacecountrequest.html
   */
  export interface NetworkInterfaceCountRequestProperty {
    /**
     * The maximum number of network interfaces.
     *
     * To specify no maximum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-networkinterfacecountrequest.html#cfn-ec2-ec2fleet-networkinterfacecountrequest-max
     */
    readonly max?: number;

    /**
     * The minimum number of network interfaces.
     *
     * To specify no minimum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-networkinterfacecountrequest.html#cfn-ec2-ec2fleet-networkinterfacecountrequest-min
     */
    readonly min?: number;
  }

  /**
   * The minimum and maximum amount of total local storage, in GB.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-totallocalstoragegbrequest.html
   */
  export interface TotalLocalStorageGBRequestProperty {
    /**
     * The maximum amount of total local storage, in GB.
     *
     * To specify no maximum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-totallocalstoragegbrequest.html#cfn-ec2-ec2fleet-totallocalstoragegbrequest-max
     */
    readonly max?: number;

    /**
     * The minimum amount of total local storage, in GB.
     *
     * To specify no minimum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-totallocalstoragegbrequest.html#cfn-ec2-ec2fleet-totallocalstoragegbrequest-min
     */
    readonly min?: number;
  }

  /**
   * The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps.
   *
   * For more information, see [Amazon EBSoptimized instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html) in the *Amazon EC2 User Guide* .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-baselineebsbandwidthmbpsrequest.html
   */
  export interface BaselineEbsBandwidthMbpsRequestProperty {
    /**
     * The maximum baseline bandwidth, in Mbps.
     *
     * To specify no maximum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-baselineebsbandwidthmbpsrequest.html#cfn-ec2-ec2fleet-baselineebsbandwidthmbpsrequest-max
     */
    readonly max?: number;

    /**
     * The minimum baseline bandwidth, in Mbps.
     *
     * To specify no minimum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-baselineebsbandwidthmbpsrequest.html#cfn-ec2-ec2fleet-baselineebsbandwidthmbpsrequest-min
     */
    readonly min?: number;
  }

  /**
   * The minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips) on an instance.
   *
   * To exclude accelerator-enabled instance types, set \`Max\` to \`0\` .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-acceleratorcountrequest.html
   */
  export interface AcceleratorCountRequestProperty {
    /**
     * The maximum number of accelerators.
     *
     * To specify no maximum limit, omit this parameter. To exclude accelerator-enabled instance types, set \`Max\` to \`0\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-acceleratorcountrequest.html#cfn-ec2-ec2fleet-acceleratorcountrequest-max
     */
    readonly max?: number;

    /**
     * The minimum number of accelerators.
     *
     * To specify no minimum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-acceleratorcountrequest.html#cfn-ec2-ec2fleet-acceleratorcountrequest-min
     */
    readonly min?: number;
  }

  /**
   * The minimum and maximum amount of total accelerator memory, in MiB.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-acceleratortotalmemorymibrequest.html
   */
  export interface AcceleratorTotalMemoryMiBRequestProperty {
    /**
     * The maximum amount of accelerator memory, in MiB.
     *
     * To specify no maximum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-acceleratortotalmemorymibrequest.html#cfn-ec2-ec2fleet-acceleratortotalmemorymibrequest-max
     */
    readonly max?: number;

    /**
     * The minimum amount of accelerator memory, in MiB.
     *
     * To specify no minimum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-acceleratortotalmemorymibrequest.html#cfn-ec2-ec2fleet-acceleratortotalmemorymibrequest-min
     */
    readonly min?: number;
  }
}

/**
 * Properties for defining a \`CfnEC2Fleet\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html
 */
export interface CfnEC2FleetProps {
  /**
   * Reserved.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-context
   */
  readonly context?: string;

  /**
   * Indicates whether running instances should be terminated if the total target capacity of the EC2 Fleet is decreased below the current size of the EC2 Fleet.
   *
   * Supported only for fleets of type \`maintain\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-excesscapacityterminationpolicy
   */
  readonly excessCapacityTerminationPolicy?: string;

  /**
   * The configuration for the EC2 Fleet.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-launchtemplateconfigs
   */
  readonly launchTemplateConfigs: Array<CfnEC2Fleet.FleetLaunchTemplateConfigRequestProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * Describes the configuration of On-Demand Instances in an EC2 Fleet.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-ondemandoptions
   */
  readonly onDemandOptions?: cdk.IResolvable | CfnEC2Fleet.OnDemandOptionsRequestProperty;

  /**
   * Indicates whether EC2 Fleet should replace unhealthy Spot Instances.
   *
   * Supported only for fleets of type \`maintain\` . For more information, see [EC2 Fleet health checks](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/manage-ec2-fleet.html#ec2-fleet-health-checks) in the *Amazon EC2 User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-replaceunhealthyinstances
   */
  readonly replaceUnhealthyInstances?: boolean | cdk.IResolvable;

  /**
   * Describes the configuration of Spot Instances in an EC2 Fleet.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-spotoptions
   */
  readonly spotOptions?: cdk.IResolvable | CfnEC2Fleet.SpotOptionsRequestProperty;

  /**
   * The key-value pair for tagging the EC2 Fleet request on creation. For more information, see [Tagging your resources](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html#tag-resources) .
   *
   * If the fleet type is \`instant\` , specify a resource type of \`fleet\` to tag the fleet or \`instance\` to tag the instances at launch.
   *
   * If the fleet type is \`maintain\` or \`request\` , specify a resource type of \`fleet\` to tag the fleet. You cannot specify a resource type of \`instance\` . To tag instances at launch, specify the tags in a [launch template](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-templates.html#create-launch-template) .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-tagspecifications
   */
  readonly tagSpecifications?: Array<cdk.IResolvable | CfnEC2Fleet.TagSpecificationProperty> | cdk.IResolvable;

  /**
   * The number of units to request.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-targetcapacityspecification
   */
  readonly targetCapacitySpecification: cdk.IResolvable | CfnEC2Fleet.TargetCapacitySpecificationRequestProperty;

  /**
   * Indicates whether running instances should be terminated when the EC2 Fleet expires.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-terminateinstanceswithexpiration
   */
  readonly terminateInstancesWithExpiration?: boolean | cdk.IResolvable;

  /**
   * The fleet type. The default value is \`maintain\` .
   *
   * - \`maintain\` - The EC2 Fleet places an asynchronous request for your desired capacity, and continues to maintain your desired Spot capacity by replenishing interrupted Spot Instances.
   * - \`request\` - The EC2 Fleet places an asynchronous one-time request for your desired capacity, but does submit Spot requests in alternative capacity pools if Spot capacity is unavailable, and does not maintain Spot capacity if Spot Instances are interrupted.
   * - \`instant\` - The EC2 Fleet places a synchronous one-time request for your desired capacity, and returns errors for any instances that could not be launched.
   *
   * For more information, see [EC2 Fleet request types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-request-type.html) in the *Amazon EC2 User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-type
   */
  readonly type?: string;

  /**
   * The start date and time of the request, in UTC format (for example, *YYYY* - *MM* - *DD* T *HH* : *MM* : *SS* Z).
   *
   * The default is to start fulfilling the request immediately.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-validfrom
   */
  readonly validFrom?: string;

  /**
   * The end date and time of the request, in UTC format (for example, *YYYY* - *MM* - *DD* T *HH* : *MM* : *SS* Z).
   *
   * At this point, no new EC2 Fleet requests are placed or able to fulfill the request. If no value is specified, the request remains until you cancel it.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-validuntil
   */
  readonly validUntil?: string;
}

/**
 * Determine whether the given properties match those of a \`TargetCapacitySpecificationRequestProperty\`
 *
 * @param properties - the TypeScript properties of a \`TargetCapacitySpecificationRequestProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnEC2FleetTargetCapacitySpecificationRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("defaultTargetCapacityType", cdk.validateString)(properties.defaultTargetCapacityType));
  errors.collect(cdk.propertyValidator("onDemandTargetCapacity", cdk.validateNumber)(properties.onDemandTargetCapacity));
  errors.collect(cdk.propertyValidator("spotTargetCapacity", cdk.validateNumber)(properties.spotTargetCapacity));
  errors.collect(cdk.propertyValidator("targetCapacityUnitType", cdk.validateString)(properties.targetCapacityUnitType));
  errors.collect(cdk.propertyValidator("totalTargetCapacity", cdk.requiredValidator)(properties.totalTargetCapacity));
  errors.collect(cdk.propertyValidator("totalTargetCapacity", cdk.validateNumber)(properties.totalTargetCapacity));
  return errors.wrap("supplied properties not correct for \\"TargetCapacitySpecificationRequestProperty\\"");
}

// @ts-ignore TS6133
function convertCfnEC2FleetTargetCapacitySpecificationRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnEC2FleetTargetCapacitySpecificationRequestPropertyValidator(properties).assertSuccess();
  return {
    "DefaultTargetCapacityType": cdk.stringToCloudFormation(properties.defaultTargetCapacityType),
    "OnDemandTargetCapacity": cdk.numberToCloudFormation(properties.onDemandTargetCapacity),
    "SpotTargetCapacity": cdk.numberToCloudFormation(properties.spotTargetCapacity),
    "TargetCapacityUnitType": cdk.stringToCloudFormation(properties.targetCapacityUnitType),
    "TotalTargetCapacity": cdk.numberToCloudFormation(properties.totalTargetCapacity)
  };
}

// @ts-ignore TS6133
function CfnEC2FleetTargetCapacitySpecificationRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnEC2Fleet.TargetCapacitySpecificationRequestProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnEC2Fleet.TargetCapacitySpecificationRequestProperty>();
  ret.addPropertyResult("defaultTargetCapacityType", "DefaultTargetCapacityType", (properties.DefaultTargetCapacityType != null ? cfn_parse.FromCloudFormation.getString(properties.DefaultTargetCapacityType) : undefined));
  ret.addPropertyResult("onDemandTargetCapacity", "OnDemandTargetCapacity", (properties.OnDemandTargetCapacity != null ? cfn_parse.FromCloudFormation.getNumber(properties.OnDemandTargetCapacity) : undefined));
  ret.addPropertyResult("spotTargetCapacity", "SpotTargetCapacity", (properties.SpotTargetCapacity != null ? cfn_parse.FromCloudFormation.getNumber(properties.SpotTargetCapacity) : undefined));
  ret.addPropertyResult("targetCapacityUnitType", "TargetCapacityUnitType", (properties.TargetCapacityUnitType != null ? cfn_parse.FromCloudFormation.getString(properties.TargetCapacityUnitType) : undefined));
  ret.addPropertyResult("totalTargetCapacity", "TotalTargetCapacity", (properties.TotalTargetCapacity != null ? cfn_parse.FromCloudFormation.getNumber(properties.TotalTargetCapacity) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CapacityReservationOptionsRequestProperty\`
 *
 * @param properties - the TypeScript properties of a \`CapacityReservationOptionsRequestProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnEC2FleetCapacityReservationOptionsRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("usageStrategy", cdk.validateString)(properties.usageStrategy));
  return errors.wrap("supplied properties not correct for \\"CapacityReservationOptionsRequestProperty\\"");
}

// @ts-ignore TS6133
function convertCfnEC2FleetCapacityReservationOptionsRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnEC2FleetCapacityReservationOptionsRequestPropertyValidator(properties).assertSuccess();
  return {
    "UsageStrategy": cdk.stringToCloudFormation(properties.usageStrategy)
  };
}

// @ts-ignore TS6133
function CfnEC2FleetCapacityReservationOptionsRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnEC2Fleet.CapacityReservationOptionsRequestProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnEC2Fleet.CapacityReservationOptionsRequestProperty>();
  ret.addPropertyResult("usageStrategy", "UsageStrategy", (properties.UsageStrategy != null ? cfn_parse.FromCloudFormation.getString(properties.UsageStrategy) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`OnDemandOptionsRequestProperty\`
 *
 * @param properties - the TypeScript properties of a \`OnDemandOptionsRequestProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnEC2FleetOnDemandOptionsRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("allocationStrategy", cdk.validateString)(properties.allocationStrategy));
  errors.collect(cdk.propertyValidator("capacityReservationOptions", CfnEC2FleetCapacityReservationOptionsRequestPropertyValidator)(properties.capacityReservationOptions));
  errors.collect(cdk.propertyValidator("maxTotalPrice", cdk.validateString)(properties.maxTotalPrice));
  errors.collect(cdk.propertyValidator("minTargetCapacity", cdk.validateNumber)(properties.minTargetCapacity));
  errors.collect(cdk.propertyValidator("singleAvailabilityZone", cdk.validateBoolean)(properties.singleAvailabilityZone));
  errors.collect(cdk.propertyValidator("singleInstanceType", cdk.validateBoolean)(properties.singleInstanceType));
  return errors.wrap("supplied properties not correct for \\"OnDemandOptionsRequestProperty\\"");
}

// @ts-ignore TS6133
function convertCfnEC2FleetOnDemandOptionsRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnEC2FleetOnDemandOptionsRequestPropertyValidator(properties).assertSuccess();
  return {
    "AllocationStrategy": cdk.stringToCloudFormation(properties.allocationStrategy),
    "CapacityReservationOptions": convertCfnEC2FleetCapacityReservationOptionsRequestPropertyToCloudFormation(properties.capacityReservationOptions),
    "MaxTotalPrice": cdk.stringToCloudFormation(properties.maxTotalPrice),
    "MinTargetCapacity": cdk.numberToCloudFormation(properties.minTargetCapacity),
    "SingleAvailabilityZone": cdk.booleanToCloudFormation(properties.singleAvailabilityZone),
    "SingleInstanceType": cdk.booleanToCloudFormation(properties.singleInstanceType)
  };
}

// @ts-ignore TS6133
function CfnEC2FleetOnDemandOptionsRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnEC2Fleet.OnDemandOptionsRequestProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnEC2Fleet.OnDemandOptionsRequestProperty>();
  ret.addPropertyResult("allocationStrategy", "AllocationStrategy", (properties.AllocationStrategy != null ? cfn_parse.FromCloudFormation.getString(properties.AllocationStrategy) : undefined));
  ret.addPropertyResult("capacityReservationOptions", "CapacityReservationOptions", (properties.CapacityReservationOptions != null ? CfnEC2FleetCapacityReservationOptionsRequestPropertyFromCloudFormation(properties.CapacityReservationOptions) : undefined));
  ret.addPropertyResult("maxTotalPrice", "MaxTotalPrice", (properties.MaxTotalPrice != null ? cfn_parse.FromCloudFormation.getString(properties.MaxTotalPrice) : undefined));
  ret.addPropertyResult("minTargetCapacity", "MinTargetCapacity", (properties.MinTargetCapacity != null ? cfn_parse.FromCloudFormation.getNumber(properties.MinTargetCapacity) : undefined));
  ret.addPropertyResult("singleAvailabilityZone", "SingleAvailabilityZone", (properties.SingleAvailabilityZone != null ? cfn_parse.FromCloudFormation.getBoolean(properties.SingleAvailabilityZone) : undefined));
  ret.addPropertyResult("singleInstanceType", "SingleInstanceType", (properties.SingleInstanceType != null ? cfn_parse.FromCloudFormation.getBoolean(properties.SingleInstanceType) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`TagSpecificationProperty\`
 *
 * @param properties - the TypeScript properties of a \`TagSpecificationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnEC2FleetTagSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("resourceType", cdk.validateString)(properties.resourceType));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"TagSpecificationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnEC2FleetTagSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnEC2FleetTagSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "ResourceType": cdk.stringToCloudFormation(properties.resourceType),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnEC2FleetTagSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnEC2Fleet.TagSpecificationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnEC2Fleet.TagSpecificationProperty>();
  ret.addPropertyResult("resourceType", "ResourceType", (properties.ResourceType != null ? cfn_parse.FromCloudFormation.getString(properties.ResourceType) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CapacityRebalanceProperty\`
 *
 * @param properties - the TypeScript properties of a \`CapacityRebalanceProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnEC2FleetCapacityRebalancePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("replacementStrategy", cdk.validateString)(properties.replacementStrategy));
  errors.collect(cdk.propertyValidator("terminationDelay", cdk.validateNumber)(properties.terminationDelay));
  return errors.wrap("supplied properties not correct for \\"CapacityRebalanceProperty\\"");
}

// @ts-ignore TS6133
function convertCfnEC2FleetCapacityRebalancePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnEC2FleetCapacityRebalancePropertyValidator(properties).assertSuccess();
  return {
    "ReplacementStrategy": cdk.stringToCloudFormation(properties.replacementStrategy),
    "TerminationDelay": cdk.numberToCloudFormation(properties.terminationDelay)
  };
}

// @ts-ignore TS6133
function CfnEC2FleetCapacityRebalancePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnEC2Fleet.CapacityRebalanceProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnEC2Fleet.CapacityRebalanceProperty>();
  ret.addPropertyResult("replacementStrategy", "ReplacementStrategy", (properties.ReplacementStrategy != null ? cfn_parse.FromCloudFormation.getString(properties.ReplacementStrategy) : undefined));
  ret.addPropertyResult("terminationDelay", "TerminationDelay", (properties.TerminationDelay != null ? cfn_parse.FromCloudFormation.getNumber(properties.TerminationDelay) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`MaintenanceStrategiesProperty\`
 *
 * @param properties - the TypeScript properties of a \`MaintenanceStrategiesProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnEC2FleetMaintenanceStrategiesPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("capacityRebalance", CfnEC2FleetCapacityRebalancePropertyValidator)(properties.capacityRebalance));
  return errors.wrap("supplied properties not correct for \\"MaintenanceStrategiesProperty\\"");
}

// @ts-ignore TS6133
function convertCfnEC2FleetMaintenanceStrategiesPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnEC2FleetMaintenanceStrategiesPropertyValidator(properties).assertSuccess();
  return {
    "CapacityRebalance": convertCfnEC2FleetCapacityRebalancePropertyToCloudFormation(properties.capacityRebalance)
  };
}

// @ts-ignore TS6133
function CfnEC2FleetMaintenanceStrategiesPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnEC2Fleet.MaintenanceStrategiesProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnEC2Fleet.MaintenanceStrategiesProperty>();
  ret.addPropertyResult("capacityRebalance", "CapacityRebalance", (properties.CapacityRebalance != null ? CfnEC2FleetCapacityRebalancePropertyFromCloudFormation(properties.CapacityRebalance) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`SpotOptionsRequestProperty\`
 *
 * @param properties - the TypeScript properties of a \`SpotOptionsRequestProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnEC2FleetSpotOptionsRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("allocationStrategy", cdk.validateString)(properties.allocationStrategy));
  errors.collect(cdk.propertyValidator("instanceInterruptionBehavior", cdk.validateString)(properties.instanceInterruptionBehavior));
  errors.collect(cdk.propertyValidator("instancePoolsToUseCount", cdk.validateNumber)(properties.instancePoolsToUseCount));
  errors.collect(cdk.propertyValidator("maintenanceStrategies", CfnEC2FleetMaintenanceStrategiesPropertyValidator)(properties.maintenanceStrategies));
  errors.collect(cdk.propertyValidator("maxTotalPrice", cdk.validateString)(properties.maxTotalPrice));
  errors.collect(cdk.propertyValidator("minTargetCapacity", cdk.validateNumber)(properties.minTargetCapacity));
  errors.collect(cdk.propertyValidator("singleAvailabilityZone", cdk.validateBoolean)(properties.singleAvailabilityZone));
  errors.collect(cdk.propertyValidator("singleInstanceType", cdk.validateBoolean)(properties.singleInstanceType));
  return errors.wrap("supplied properties not correct for \\"SpotOptionsRequestProperty\\"");
}

// @ts-ignore TS6133
function convertCfnEC2FleetSpotOptionsRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnEC2FleetSpotOptionsRequestPropertyValidator(properties).assertSuccess();
  return {
    "AllocationStrategy": cdk.stringToCloudFormation(properties.allocationStrategy),
    "InstanceInterruptionBehavior": cdk.stringToCloudFormation(properties.instanceInterruptionBehavior),
    "InstancePoolsToUseCount": cdk.numberToCloudFormation(properties.instancePoolsToUseCount),
    "MaintenanceStrategies": convertCfnEC2FleetMaintenanceStrategiesPropertyToCloudFormation(properties.maintenanceStrategies),
    "MaxTotalPrice": cdk.stringToCloudFormation(properties.maxTotalPrice),
    "MinTargetCapacity": cdk.numberToCloudFormation(properties.minTargetCapacity),
    "SingleAvailabilityZone": cdk.booleanToCloudFormation(properties.singleAvailabilityZone),
    "SingleInstanceType": cdk.booleanToCloudFormation(properties.singleInstanceType)
  };
}

// @ts-ignore TS6133
function CfnEC2FleetSpotOptionsRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnEC2Fleet.SpotOptionsRequestProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnEC2Fleet.SpotOptionsRequestProperty>();
  ret.addPropertyResult("allocationStrategy", "AllocationStrategy", (properties.AllocationStrategy != null ? cfn_parse.FromCloudFormation.getString(properties.AllocationStrategy) : undefined));
  ret.addPropertyResult("instanceInterruptionBehavior", "InstanceInterruptionBehavior", (properties.InstanceInterruptionBehavior != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceInterruptionBehavior) : undefined));
  ret.addPropertyResult("instancePoolsToUseCount", "InstancePoolsToUseCount", (properties.InstancePoolsToUseCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.InstancePoolsToUseCount) : undefined));
  ret.addPropertyResult("maintenanceStrategies", "MaintenanceStrategies", (properties.MaintenanceStrategies != null ? CfnEC2FleetMaintenanceStrategiesPropertyFromCloudFormation(properties.MaintenanceStrategies) : undefined));
  ret.addPropertyResult("maxTotalPrice", "MaxTotalPrice", (properties.MaxTotalPrice != null ? cfn_parse.FromCloudFormation.getString(properties.MaxTotalPrice) : undefined));
  ret.addPropertyResult("minTargetCapacity", "MinTargetCapacity", (properties.MinTargetCapacity != null ? cfn_parse.FromCloudFormation.getNumber(properties.MinTargetCapacity) : undefined));
  ret.addPropertyResult("singleAvailabilityZone", "SingleAvailabilityZone", (properties.SingleAvailabilityZone != null ? cfn_parse.FromCloudFormation.getBoolean(properties.SingleAvailabilityZone) : undefined));
  ret.addPropertyResult("singleInstanceType", "SingleInstanceType", (properties.SingleInstanceType != null ? cfn_parse.FromCloudFormation.getBoolean(properties.SingleInstanceType) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`FleetLaunchTemplateSpecificationRequestProperty\`
 *
 * @param properties - the TypeScript properties of a \`FleetLaunchTemplateSpecificationRequestProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnEC2FleetFleetLaunchTemplateSpecificationRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("launchTemplateId", cdk.validateString)(properties.launchTemplateId));
  errors.collect(cdk.propertyValidator("launchTemplateName", cdk.validateString)(properties.launchTemplateName));
  errors.collect(cdk.propertyValidator("version", cdk.requiredValidator)(properties.version));
  errors.collect(cdk.propertyValidator("version", cdk.validateString)(properties.version));
  return errors.wrap("supplied properties not correct for \\"FleetLaunchTemplateSpecificationRequestProperty\\"");
}

// @ts-ignore TS6133
function convertCfnEC2FleetFleetLaunchTemplateSpecificationRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnEC2FleetFleetLaunchTemplateSpecificationRequestPropertyValidator(properties).assertSuccess();
  return {
    "LaunchTemplateId": cdk.stringToCloudFormation(properties.launchTemplateId),
    "LaunchTemplateName": cdk.stringToCloudFormation(properties.launchTemplateName),
    "Version": cdk.stringToCloudFormation(properties.version)
  };
}

// @ts-ignore TS6133
function CfnEC2FleetFleetLaunchTemplateSpecificationRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnEC2Fleet.FleetLaunchTemplateSpecificationRequestProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnEC2Fleet.FleetLaunchTemplateSpecificationRequestProperty>();
  ret.addPropertyResult("launchTemplateId", "LaunchTemplateId", (properties.LaunchTemplateId != null ? cfn_parse.FromCloudFormation.getString(properties.LaunchTemplateId) : undefined));
  ret.addPropertyResult("launchTemplateName", "LaunchTemplateName", (properties.LaunchTemplateName != null ? cfn_parse.FromCloudFormation.getString(properties.LaunchTemplateName) : undefined));
  ret.addPropertyResult("version", "Version", (properties.Version != null ? cfn_parse.FromCloudFormation.getString(properties.Version) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`PlacementProperty\`
 *
 * @param properties - the TypeScript properties of a \`PlacementProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnEC2FleetPlacementPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("affinity", cdk.validateString)(properties.affinity));
  errors.collect(cdk.propertyValidator("availabilityZone", cdk.validateString)(properties.availabilityZone));
  errors.collect(cdk.propertyValidator("groupName", cdk.validateString)(properties.groupName));
  errors.collect(cdk.propertyValidator("hostId", cdk.validateString)(properties.hostId));
  errors.collect(cdk.propertyValidator("hostResourceGroupArn", cdk.validateString)(properties.hostResourceGroupArn));
  errors.collect(cdk.propertyValidator("partitionNumber", cdk.validateNumber)(properties.partitionNumber));
  errors.collect(cdk.propertyValidator("spreadDomain", cdk.validateString)(properties.spreadDomain));
  errors.collect(cdk.propertyValidator("tenancy", cdk.validateString)(properties.tenancy));
  return errors.wrap("supplied properties not correct for \\"PlacementProperty\\"");
}

// @ts-ignore TS6133
function convertCfnEC2FleetPlacementPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnEC2FleetPlacementPropertyValidator(properties).assertSuccess();
  return {
    "Affinity": cdk.stringToCloudFormation(properties.affinity),
    "AvailabilityZone": cdk.stringToCloudFormation(properties.availabilityZone),
    "GroupName": cdk.stringToCloudFormation(properties.groupName),
    "HostId": cdk.stringToCloudFormation(properties.hostId),
    "HostResourceGroupArn": cdk.stringToCloudFormation(properties.hostResourceGroupArn),
    "PartitionNumber": cdk.numberToCloudFormation(properties.partitionNumber),
    "SpreadDomain": cdk.stringToCloudFormation(properties.spreadDomain),
    "Tenancy": cdk.stringToCloudFormation(properties.tenancy)
  };
}

// @ts-ignore TS6133
function CfnEC2FleetPlacementPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnEC2Fleet.PlacementProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnEC2Fleet.PlacementProperty>();
  ret.addPropertyResult("affinity", "Affinity", (properties.Affinity != null ? cfn_parse.FromCloudFormation.getString(properties.Affinity) : undefined));
  ret.addPropertyResult("availabilityZone", "AvailabilityZone", (properties.AvailabilityZone != null ? cfn_parse.FromCloudFormation.getString(properties.AvailabilityZone) : undefined));
  ret.addPropertyResult("groupName", "GroupName", (properties.GroupName != null ? cfn_parse.FromCloudFormation.getString(properties.GroupName) : undefined));
  ret.addPropertyResult("hostId", "HostId", (properties.HostId != null ? cfn_parse.FromCloudFormation.getString(properties.HostId) : undefined));
  ret.addPropertyResult("hostResourceGroupArn", "HostResourceGroupArn", (properties.HostResourceGroupArn != null ? cfn_parse.FromCloudFormation.getString(properties.HostResourceGroupArn) : undefined));
  ret.addPropertyResult("partitionNumber", "PartitionNumber", (properties.PartitionNumber != null ? cfn_parse.FromCloudFormation.getNumber(properties.PartitionNumber) : undefined));
  ret.addPropertyResult("spreadDomain", "SpreadDomain", (properties.SpreadDomain != null ? cfn_parse.FromCloudFormation.getString(properties.SpreadDomain) : undefined));
  ret.addPropertyResult("tenancy", "Tenancy", (properties.Tenancy != null ? cfn_parse.FromCloudFormation.getString(properties.Tenancy) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`VCpuCountRangeRequestProperty\`
 *
 * @param properties - the TypeScript properties of a \`VCpuCountRangeRequestProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnEC2FleetVCpuCountRangeRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("max", cdk.validateNumber)(properties.max));
  errors.collect(cdk.propertyValidator("min", cdk.validateNumber)(properties.min));
  return errors.wrap("supplied properties not correct for \\"VCpuCountRangeRequestProperty\\"");
}

// @ts-ignore TS6133
function convertCfnEC2FleetVCpuCountRangeRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnEC2FleetVCpuCountRangeRequestPropertyValidator(properties).assertSuccess();
  return {
    "Max": cdk.numberToCloudFormation(properties.max),
    "Min": cdk.numberToCloudFormation(properties.min)
  };
}

// @ts-ignore TS6133
function CfnEC2FleetVCpuCountRangeRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnEC2Fleet.VCpuCountRangeRequestProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnEC2Fleet.VCpuCountRangeRequestProperty>();
  ret.addPropertyResult("max", "Max", (properties.Max != null ? cfn_parse.FromCloudFormation.getNumber(properties.Max) : undefined));
  ret.addPropertyResult("min", "Min", (properties.Min != null ? cfn_parse.FromCloudFormation.getNumber(properties.Min) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`MemoryMiBRequestProperty\`
 *
 * @param properties - the TypeScript properties of a \`MemoryMiBRequestProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnEC2FleetMemoryMiBRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("max", cdk.validateNumber)(properties.max));
  errors.collect(cdk.propertyValidator("min", cdk.validateNumber)(properties.min));
  return errors.wrap("supplied properties not correct for \\"MemoryMiBRequestProperty\\"");
}

// @ts-ignore TS6133
function convertCfnEC2FleetMemoryMiBRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnEC2FleetMemoryMiBRequestPropertyValidator(properties).assertSuccess();
  return {
    "Max": cdk.numberToCloudFormation(properties.max),
    "Min": cdk.numberToCloudFormation(properties.min)
  };
}

// @ts-ignore TS6133
function CfnEC2FleetMemoryMiBRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnEC2Fleet.MemoryMiBRequestProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnEC2Fleet.MemoryMiBRequestProperty>();
  ret.addPropertyResult("max", "Max", (properties.Max != null ? cfn_parse.FromCloudFormation.getNumber(properties.Max) : undefined));
  ret.addPropertyResult("min", "Min", (properties.Min != null ? cfn_parse.FromCloudFormation.getNumber(properties.Min) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`MemoryGiBPerVCpuRequestProperty\`
 *
 * @param properties - the TypeScript properties of a \`MemoryGiBPerVCpuRequestProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnEC2FleetMemoryGiBPerVCpuRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("max", cdk.validateNumber)(properties.max));
  errors.collect(cdk.propertyValidator("min", cdk.validateNumber)(properties.min));
  return errors.wrap("supplied properties not correct for \\"MemoryGiBPerVCpuRequestProperty\\"");
}

// @ts-ignore TS6133
function convertCfnEC2FleetMemoryGiBPerVCpuRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnEC2FleetMemoryGiBPerVCpuRequestPropertyValidator(properties).assertSuccess();
  return {
    "Max": cdk.numberToCloudFormation(properties.max),
    "Min": cdk.numberToCloudFormation(properties.min)
  };
}

// @ts-ignore TS6133
function CfnEC2FleetMemoryGiBPerVCpuRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnEC2Fleet.MemoryGiBPerVCpuRequestProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnEC2Fleet.MemoryGiBPerVCpuRequestProperty>();
  ret.addPropertyResult("max", "Max", (properties.Max != null ? cfn_parse.FromCloudFormation.getNumber(properties.Max) : undefined));
  ret.addPropertyResult("min", "Min", (properties.Min != null ? cfn_parse.FromCloudFormation.getNumber(properties.Min) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`NetworkBandwidthGbpsRequestProperty\`
 *
 * @param properties - the TypeScript properties of a \`NetworkBandwidthGbpsRequestProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnEC2FleetNetworkBandwidthGbpsRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("max", cdk.validateNumber)(properties.max));
  errors.collect(cdk.propertyValidator("min", cdk.validateNumber)(properties.min));
  return errors.wrap("supplied properties not correct for \\"NetworkBandwidthGbpsRequestProperty\\"");
}

// @ts-ignore TS6133
function convertCfnEC2FleetNetworkBandwidthGbpsRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnEC2FleetNetworkBandwidthGbpsRequestPropertyValidator(properties).assertSuccess();
  return {
    "Max": cdk.numberToCloudFormation(properties.max),
    "Min": cdk.numberToCloudFormation(properties.min)
  };
}

// @ts-ignore TS6133
function CfnEC2FleetNetworkBandwidthGbpsRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnEC2Fleet.NetworkBandwidthGbpsRequestProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnEC2Fleet.NetworkBandwidthGbpsRequestProperty>();
  ret.addPropertyResult("max", "Max", (properties.Max != null ? cfn_parse.FromCloudFormation.getNumber(properties.Max) : undefined));
  ret.addPropertyResult("min", "Min", (properties.Min != null ? cfn_parse.FromCloudFormation.getNumber(properties.Min) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`NetworkInterfaceCountRequestProperty\`
 *
 * @param properties - the TypeScript properties of a \`NetworkInterfaceCountRequestProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnEC2FleetNetworkInterfaceCountRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("max", cdk.validateNumber)(properties.max));
  errors.collect(cdk.propertyValidator("min", cdk.validateNumber)(properties.min));
  return errors.wrap("supplied properties not correct for \\"NetworkInterfaceCountRequestProperty\\"");
}

// @ts-ignore TS6133
function convertCfnEC2FleetNetworkInterfaceCountRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnEC2FleetNetworkInterfaceCountRequestPropertyValidator(properties).assertSuccess();
  return {
    "Max": cdk.numberToCloudFormation(properties.max),
    "Min": cdk.numberToCloudFormation(properties.min)
  };
}

// @ts-ignore TS6133
function CfnEC2FleetNetworkInterfaceCountRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnEC2Fleet.NetworkInterfaceCountRequestProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnEC2Fleet.NetworkInterfaceCountRequestProperty>();
  ret.addPropertyResult("max", "Max", (properties.Max != null ? cfn_parse.FromCloudFormation.getNumber(properties.Max) : undefined));
  ret.addPropertyResult("min", "Min", (properties.Min != null ? cfn_parse.FromCloudFormation.getNumber(properties.Min) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`TotalLocalStorageGBRequestProperty\`
 *
 * @param properties - the TypeScript properties of a \`TotalLocalStorageGBRequestProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnEC2FleetTotalLocalStorageGBRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("max", cdk.validateNumber)(properties.max));
  errors.collect(cdk.propertyValidator("min", cdk.validateNumber)(properties.min));
  return errors.wrap("supplied properties not correct for \\"TotalLocalStorageGBRequestProperty\\"");
}

// @ts-ignore TS6133
function convertCfnEC2FleetTotalLocalStorageGBRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnEC2FleetTotalLocalStorageGBRequestPropertyValidator(properties).assertSuccess();
  return {
    "Max": cdk.numberToCloudFormation(properties.max),
    "Min": cdk.numberToCloudFormation(properties.min)
  };
}

// @ts-ignore TS6133
function CfnEC2FleetTotalLocalStorageGBRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnEC2Fleet.TotalLocalStorageGBRequestProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnEC2Fleet.TotalLocalStorageGBRequestProperty>();
  ret.addPropertyResult("max", "Max", (properties.Max != null ? cfn_parse.FromCloudFormation.getNumber(properties.Max) : undefined));
  ret.addPropertyResult("min", "Min", (properties.Min != null ? cfn_parse.FromCloudFormation.getNumber(properties.Min) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`BaselineEbsBandwidthMbpsRequestProperty\`
 *
 * @param properties - the TypeScript properties of a \`BaselineEbsBandwidthMbpsRequestProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnEC2FleetBaselineEbsBandwidthMbpsRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("max", cdk.validateNumber)(properties.max));
  errors.collect(cdk.propertyValidator("min", cdk.validateNumber)(properties.min));
  return errors.wrap("supplied properties not correct for \\"BaselineEbsBandwidthMbpsRequestProperty\\"");
}

// @ts-ignore TS6133
function convertCfnEC2FleetBaselineEbsBandwidthMbpsRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnEC2FleetBaselineEbsBandwidthMbpsRequestPropertyValidator(properties).assertSuccess();
  return {
    "Max": cdk.numberToCloudFormation(properties.max),
    "Min": cdk.numberToCloudFormation(properties.min)
  };
}

// @ts-ignore TS6133
function CfnEC2FleetBaselineEbsBandwidthMbpsRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnEC2Fleet.BaselineEbsBandwidthMbpsRequestProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnEC2Fleet.BaselineEbsBandwidthMbpsRequestProperty>();
  ret.addPropertyResult("max", "Max", (properties.Max != null ? cfn_parse.FromCloudFormation.getNumber(properties.Max) : undefined));
  ret.addPropertyResult("min", "Min", (properties.Min != null ? cfn_parse.FromCloudFormation.getNumber(properties.Min) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`AcceleratorCountRequestProperty\`
 *
 * @param properties - the TypeScript properties of a \`AcceleratorCountRequestProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnEC2FleetAcceleratorCountRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("max", cdk.validateNumber)(properties.max));
  errors.collect(cdk.propertyValidator("min", cdk.validateNumber)(properties.min));
  return errors.wrap("supplied properties not correct for \\"AcceleratorCountRequestProperty\\"");
}

// @ts-ignore TS6133
function convertCfnEC2FleetAcceleratorCountRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnEC2FleetAcceleratorCountRequestPropertyValidator(properties).assertSuccess();
  return {
    "Max": cdk.numberToCloudFormation(properties.max),
    "Min": cdk.numberToCloudFormation(properties.min)
  };
}

// @ts-ignore TS6133
function CfnEC2FleetAcceleratorCountRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnEC2Fleet.AcceleratorCountRequestProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnEC2Fleet.AcceleratorCountRequestProperty>();
  ret.addPropertyResult("max", "Max", (properties.Max != null ? cfn_parse.FromCloudFormation.getNumber(properties.Max) : undefined));
  ret.addPropertyResult("min", "Min", (properties.Min != null ? cfn_parse.FromCloudFormation.getNumber(properties.Min) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`AcceleratorTotalMemoryMiBRequestProperty\`
 *
 * @param properties - the TypeScript properties of a \`AcceleratorTotalMemoryMiBRequestProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnEC2FleetAcceleratorTotalMemoryMiBRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("max", cdk.validateNumber)(properties.max));
  errors.collect(cdk.propertyValidator("min", cdk.validateNumber)(properties.min));
  return errors.wrap("supplied properties not correct for \\"AcceleratorTotalMemoryMiBRequestProperty\\"");
}

// @ts-ignore TS6133
function convertCfnEC2FleetAcceleratorTotalMemoryMiBRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnEC2FleetAcceleratorTotalMemoryMiBRequestPropertyValidator(properties).assertSuccess();
  return {
    "Max": cdk.numberToCloudFormation(properties.max),
    "Min": cdk.numberToCloudFormation(properties.min)
  };
}

// @ts-ignore TS6133
function CfnEC2FleetAcceleratorTotalMemoryMiBRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnEC2Fleet.AcceleratorTotalMemoryMiBRequestProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnEC2Fleet.AcceleratorTotalMemoryMiBRequestProperty>();
  ret.addPropertyResult("max", "Max", (properties.Max != null ? cfn_parse.FromCloudFormation.getNumber(properties.Max) : undefined));
  ret.addPropertyResult("min", "Min", (properties.Min != null ? cfn_parse.FromCloudFormation.getNumber(properties.Min) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`InstanceRequirementsRequestProperty\`
 *
 * @param properties - the TypeScript properties of a \`InstanceRequirementsRequestProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnEC2FleetInstanceRequirementsRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("acceleratorCount", CfnEC2FleetAcceleratorCountRequestPropertyValidator)(properties.acceleratorCount));
  errors.collect(cdk.propertyValidator("acceleratorManufacturers", cdk.listValidator(cdk.validateString))(properties.acceleratorManufacturers));
  errors.collect(cdk.propertyValidator("acceleratorNames", cdk.listValidator(cdk.validateString))(properties.acceleratorNames));
  errors.collect(cdk.propertyValidator("acceleratorTotalMemoryMiB", CfnEC2FleetAcceleratorTotalMemoryMiBRequestPropertyValidator)(properties.acceleratorTotalMemoryMiB));
  errors.collect(cdk.propertyValidator("acceleratorTypes", cdk.listValidator(cdk.validateString))(properties.acceleratorTypes));
  errors.collect(cdk.propertyValidator("allowedInstanceTypes", cdk.listValidator(cdk.validateString))(properties.allowedInstanceTypes));
  errors.collect(cdk.propertyValidator("bareMetal", cdk.validateString)(properties.bareMetal));
  errors.collect(cdk.propertyValidator("baselineEbsBandwidthMbps", CfnEC2FleetBaselineEbsBandwidthMbpsRequestPropertyValidator)(properties.baselineEbsBandwidthMbps));
  errors.collect(cdk.propertyValidator("burstablePerformance", cdk.validateString)(properties.burstablePerformance));
  errors.collect(cdk.propertyValidator("cpuManufacturers", cdk.listValidator(cdk.validateString))(properties.cpuManufacturers));
  errors.collect(cdk.propertyValidator("excludedInstanceTypes", cdk.listValidator(cdk.validateString))(properties.excludedInstanceTypes));
  errors.collect(cdk.propertyValidator("instanceGenerations", cdk.listValidator(cdk.validateString))(properties.instanceGenerations));
  errors.collect(cdk.propertyValidator("localStorage", cdk.validateString)(properties.localStorage));
  errors.collect(cdk.propertyValidator("localStorageTypes", cdk.listValidator(cdk.validateString))(properties.localStorageTypes));
  errors.collect(cdk.propertyValidator("memoryGiBPerVCpu", CfnEC2FleetMemoryGiBPerVCpuRequestPropertyValidator)(properties.memoryGiBPerVCpu));
  errors.collect(cdk.propertyValidator("memoryMiB", CfnEC2FleetMemoryMiBRequestPropertyValidator)(properties.memoryMiB));
  errors.collect(cdk.propertyValidator("networkBandwidthGbps", CfnEC2FleetNetworkBandwidthGbpsRequestPropertyValidator)(properties.networkBandwidthGbps));
  errors.collect(cdk.propertyValidator("networkInterfaceCount", CfnEC2FleetNetworkInterfaceCountRequestPropertyValidator)(properties.networkInterfaceCount));
  errors.collect(cdk.propertyValidator("onDemandMaxPricePercentageOverLowestPrice", cdk.validateNumber)(properties.onDemandMaxPricePercentageOverLowestPrice));
  errors.collect(cdk.propertyValidator("requireHibernateSupport", cdk.validateBoolean)(properties.requireHibernateSupport));
  errors.collect(cdk.propertyValidator("spotMaxPricePercentageOverLowestPrice", cdk.validateNumber)(properties.spotMaxPricePercentageOverLowestPrice));
  errors.collect(cdk.propertyValidator("totalLocalStorageGb", CfnEC2FleetTotalLocalStorageGBRequestPropertyValidator)(properties.totalLocalStorageGb));
  errors.collect(cdk.propertyValidator("vCpuCount", CfnEC2FleetVCpuCountRangeRequestPropertyValidator)(properties.vCpuCount));
  return errors.wrap("supplied properties not correct for \\"InstanceRequirementsRequestProperty\\"");
}

// @ts-ignore TS6133
function convertCfnEC2FleetInstanceRequirementsRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnEC2FleetInstanceRequirementsRequestPropertyValidator(properties).assertSuccess();
  return {
    "AcceleratorCount": convertCfnEC2FleetAcceleratorCountRequestPropertyToCloudFormation(properties.acceleratorCount),
    "AcceleratorManufacturers": cdk.listMapper(cdk.stringToCloudFormation)(properties.acceleratorManufacturers),
    "AcceleratorNames": cdk.listMapper(cdk.stringToCloudFormation)(properties.acceleratorNames),
    "AcceleratorTotalMemoryMiB": convertCfnEC2FleetAcceleratorTotalMemoryMiBRequestPropertyToCloudFormation(properties.acceleratorTotalMemoryMiB),
    "AcceleratorTypes": cdk.listMapper(cdk.stringToCloudFormation)(properties.acceleratorTypes),
    "AllowedInstanceTypes": cdk.listMapper(cdk.stringToCloudFormation)(properties.allowedInstanceTypes),
    "BareMetal": cdk.stringToCloudFormation(properties.bareMetal),
    "BaselineEbsBandwidthMbps": convertCfnEC2FleetBaselineEbsBandwidthMbpsRequestPropertyToCloudFormation(properties.baselineEbsBandwidthMbps),
    "BurstablePerformance": cdk.stringToCloudFormation(properties.burstablePerformance),
    "CpuManufacturers": cdk.listMapper(cdk.stringToCloudFormation)(properties.cpuManufacturers),
    "ExcludedInstanceTypes": cdk.listMapper(cdk.stringToCloudFormation)(properties.excludedInstanceTypes),
    "InstanceGenerations": cdk.listMapper(cdk.stringToCloudFormation)(properties.instanceGenerations),
    "LocalStorage": cdk.stringToCloudFormation(properties.localStorage),
    "LocalStorageTypes": cdk.listMapper(cdk.stringToCloudFormation)(properties.localStorageTypes),
    "MemoryGiBPerVCpu": convertCfnEC2FleetMemoryGiBPerVCpuRequestPropertyToCloudFormation(properties.memoryGiBPerVCpu),
    "MemoryMiB": convertCfnEC2FleetMemoryMiBRequestPropertyToCloudFormation(properties.memoryMiB),
    "NetworkBandwidthGbps": convertCfnEC2FleetNetworkBandwidthGbpsRequestPropertyToCloudFormation(properties.networkBandwidthGbps),
    "NetworkInterfaceCount": convertCfnEC2FleetNetworkInterfaceCountRequestPropertyToCloudFormation(properties.networkInterfaceCount),
    "OnDemandMaxPricePercentageOverLowestPrice": cdk.numberToCloudFormation(properties.onDemandMaxPricePercentageOverLowestPrice),
    "RequireHibernateSupport": cdk.booleanToCloudFormation(properties.requireHibernateSupport),
    "SpotMaxPricePercentageOverLowestPrice": cdk.numberToCloudFormation(properties.spotMaxPricePercentageOverLowestPrice),
    "TotalLocalStorageGB": convertCfnEC2FleetTotalLocalStorageGBRequestPropertyToCloudFormation(properties.totalLocalStorageGb),
    "VCpuCount": convertCfnEC2FleetVCpuCountRangeRequestPropertyToCloudFormation(properties.vCpuCount)
  };
}

// @ts-ignore TS6133
function CfnEC2FleetInstanceRequirementsRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnEC2Fleet.InstanceRequirementsRequestProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnEC2Fleet.InstanceRequirementsRequestProperty>();
  ret.addPropertyResult("acceleratorCount", "AcceleratorCount", (properties.AcceleratorCount != null ? CfnEC2FleetAcceleratorCountRequestPropertyFromCloudFormation(properties.AcceleratorCount) : undefined));
  ret.addPropertyResult("acceleratorManufacturers", "AcceleratorManufacturers", (properties.AcceleratorManufacturers != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.AcceleratorManufacturers) : undefined));
  ret.addPropertyResult("acceleratorNames", "AcceleratorNames", (properties.AcceleratorNames != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.AcceleratorNames) : undefined));
  ret.addPropertyResult("acceleratorTotalMemoryMiB", "AcceleratorTotalMemoryMiB", (properties.AcceleratorTotalMemoryMiB != null ? CfnEC2FleetAcceleratorTotalMemoryMiBRequestPropertyFromCloudFormation(properties.AcceleratorTotalMemoryMiB) : undefined));
  ret.addPropertyResult("acceleratorTypes", "AcceleratorTypes", (properties.AcceleratorTypes != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.AcceleratorTypes) : undefined));
  ret.addPropertyResult("allowedInstanceTypes", "AllowedInstanceTypes", (properties.AllowedInstanceTypes != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.AllowedInstanceTypes) : undefined));
  ret.addPropertyResult("bareMetal", "BareMetal", (properties.BareMetal != null ? cfn_parse.FromCloudFormation.getString(properties.BareMetal) : undefined));
  ret.addPropertyResult("baselineEbsBandwidthMbps", "BaselineEbsBandwidthMbps", (properties.BaselineEbsBandwidthMbps != null ? CfnEC2FleetBaselineEbsBandwidthMbpsRequestPropertyFromCloudFormation(properties.BaselineEbsBandwidthMbps) : undefined));
  ret.addPropertyResult("burstablePerformance", "BurstablePerformance", (properties.BurstablePerformance != null ? cfn_parse.FromCloudFormation.getString(properties.BurstablePerformance) : undefined));
  ret.addPropertyResult("cpuManufacturers", "CpuManufacturers", (properties.CpuManufacturers != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.CpuManufacturers) : undefined));
  ret.addPropertyResult("excludedInstanceTypes", "ExcludedInstanceTypes", (properties.ExcludedInstanceTypes != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.ExcludedInstanceTypes) : undefined));
  ret.addPropertyResult("instanceGenerations", "InstanceGenerations", (properties.InstanceGenerations != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.InstanceGenerations) : undefined));
  ret.addPropertyResult("localStorage", "LocalStorage", (properties.LocalStorage != null ? cfn_parse.FromCloudFormation.getString(properties.LocalStorage) : undefined));
  ret.addPropertyResult("localStorageTypes", "LocalStorageTypes", (properties.LocalStorageTypes != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.LocalStorageTypes) : undefined));
  ret.addPropertyResult("memoryGiBPerVCpu", "MemoryGiBPerVCpu", (properties.MemoryGiBPerVCpu != null ? CfnEC2FleetMemoryGiBPerVCpuRequestPropertyFromCloudFormation(properties.MemoryGiBPerVCpu) : undefined));
  ret.addPropertyResult("memoryMiB", "MemoryMiB", (properties.MemoryMiB != null ? CfnEC2FleetMemoryMiBRequestPropertyFromCloudFormation(properties.MemoryMiB) : undefined));
  ret.addPropertyResult("networkBandwidthGbps", "NetworkBandwidthGbps", (properties.NetworkBandwidthGbps != null ? CfnEC2FleetNetworkBandwidthGbpsRequestPropertyFromCloudFormation(properties.NetworkBandwidthGbps) : undefined));
  ret.addPropertyResult("networkInterfaceCount", "NetworkInterfaceCount", (properties.NetworkInterfaceCount != null ? CfnEC2FleetNetworkInterfaceCountRequestPropertyFromCloudFormation(properties.NetworkInterfaceCount) : undefined));
  ret.addPropertyResult("onDemandMaxPricePercentageOverLowestPrice", "OnDemandMaxPricePercentageOverLowestPrice", (properties.OnDemandMaxPricePercentageOverLowestPrice != null ? cfn_parse.FromCloudFormation.getNumber(properties.OnDemandMaxPricePercentageOverLowestPrice) : undefined));
  ret.addPropertyResult("requireHibernateSupport", "RequireHibernateSupport", (properties.RequireHibernateSupport != null ? cfn_parse.FromCloudFormation.getBoolean(properties.RequireHibernateSupport) : undefined));
  ret.addPropertyResult("spotMaxPricePercentageOverLowestPrice", "SpotMaxPricePercentageOverLowestPrice", (properties.SpotMaxPricePercentageOverLowestPrice != null ? cfn_parse.FromCloudFormation.getNumber(properties.SpotMaxPricePercentageOverLowestPrice) : undefined));
  ret.addPropertyResult("totalLocalStorageGb", "TotalLocalStorageGB", (properties.TotalLocalStorageGB != null ? CfnEC2FleetTotalLocalStorageGBRequestPropertyFromCloudFormation(properties.TotalLocalStorageGB) : undefined));
  ret.addPropertyResult("vCpuCount", "VCpuCount", (properties.VCpuCount != null ? CfnEC2FleetVCpuCountRangeRequestPropertyFromCloudFormation(properties.VCpuCount) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`FleetLaunchTemplateOverridesRequestProperty\`
 *
 * @param properties - the TypeScript properties of a \`FleetLaunchTemplateOverridesRequestProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnEC2FleetFleetLaunchTemplateOverridesRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("availabilityZone", cdk.validateString)(properties.availabilityZone));
  errors.collect(cdk.propertyValidator("instanceRequirements", CfnEC2FleetInstanceRequirementsRequestPropertyValidator)(properties.instanceRequirements));
  errors.collect(cdk.propertyValidator("instanceType", cdk.validateString)(properties.instanceType));
  errors.collect(cdk.propertyValidator("maxPrice", cdk.validateString)(properties.maxPrice));
  errors.collect(cdk.propertyValidator("placement", CfnEC2FleetPlacementPropertyValidator)(properties.placement));
  errors.collect(cdk.propertyValidator("priority", cdk.validateNumber)(properties.priority));
  errors.collect(cdk.propertyValidator("subnetId", cdk.validateString)(properties.subnetId));
  errors.collect(cdk.propertyValidator("weightedCapacity", cdk.validateNumber)(properties.weightedCapacity));
  return errors.wrap("supplied properties not correct for \\"FleetLaunchTemplateOverridesRequestProperty\\"");
}

// @ts-ignore TS6133
function convertCfnEC2FleetFleetLaunchTemplateOverridesRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnEC2FleetFleetLaunchTemplateOverridesRequestPropertyValidator(properties).assertSuccess();
  return {
    "AvailabilityZone": cdk.stringToCloudFormation(properties.availabilityZone),
    "InstanceRequirements": convertCfnEC2FleetInstanceRequirementsRequestPropertyToCloudFormation(properties.instanceRequirements),
    "InstanceType": cdk.stringToCloudFormation(properties.instanceType),
    "MaxPrice": cdk.stringToCloudFormation(properties.maxPrice),
    "Placement": convertCfnEC2FleetPlacementPropertyToCloudFormation(properties.placement),
    "Priority": cdk.numberToCloudFormation(properties.priority),
    "SubnetId": cdk.stringToCloudFormation(properties.subnetId),
    "WeightedCapacity": cdk.numberToCloudFormation(properties.weightedCapacity)
  };
}

// @ts-ignore TS6133
function CfnEC2FleetFleetLaunchTemplateOverridesRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnEC2Fleet.FleetLaunchTemplateOverridesRequestProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnEC2Fleet.FleetLaunchTemplateOverridesRequestProperty>();
  ret.addPropertyResult("availabilityZone", "AvailabilityZone", (properties.AvailabilityZone != null ? cfn_parse.FromCloudFormation.getString(properties.AvailabilityZone) : undefined));
  ret.addPropertyResult("instanceRequirements", "InstanceRequirements", (properties.InstanceRequirements != null ? CfnEC2FleetInstanceRequirementsRequestPropertyFromCloudFormation(properties.InstanceRequirements) : undefined));
  ret.addPropertyResult("instanceType", "InstanceType", (properties.InstanceType != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceType) : undefined));
  ret.addPropertyResult("maxPrice", "MaxPrice", (properties.MaxPrice != null ? cfn_parse.FromCloudFormation.getString(properties.MaxPrice) : undefined));
  ret.addPropertyResult("placement", "Placement", (properties.Placement != null ? CfnEC2FleetPlacementPropertyFromCloudFormation(properties.Placement) : undefined));
  ret.addPropertyResult("priority", "Priority", (properties.Priority != null ? cfn_parse.FromCloudFormation.getNumber(properties.Priority) : undefined));
  ret.addPropertyResult("subnetId", "SubnetId", (properties.SubnetId != null ? cfn_parse.FromCloudFormation.getString(properties.SubnetId) : undefined));
  ret.addPropertyResult("weightedCapacity", "WeightedCapacity", (properties.WeightedCapacity != null ? cfn_parse.FromCloudFormation.getNumber(properties.WeightedCapacity) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`FleetLaunchTemplateConfigRequestProperty\`
 *
 * @param properties - the TypeScript properties of a \`FleetLaunchTemplateConfigRequestProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnEC2FleetFleetLaunchTemplateConfigRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("launchTemplateSpecification", CfnEC2FleetFleetLaunchTemplateSpecificationRequestPropertyValidator)(properties.launchTemplateSpecification));
  errors.collect(cdk.propertyValidator("overrides", cdk.listValidator(CfnEC2FleetFleetLaunchTemplateOverridesRequestPropertyValidator))(properties.overrides));
  return errors.wrap("supplied properties not correct for \\"FleetLaunchTemplateConfigRequestProperty\\"");
}

// @ts-ignore TS6133
function convertCfnEC2FleetFleetLaunchTemplateConfigRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnEC2FleetFleetLaunchTemplateConfigRequestPropertyValidator(properties).assertSuccess();
  return {
    "LaunchTemplateSpecification": convertCfnEC2FleetFleetLaunchTemplateSpecificationRequestPropertyToCloudFormation(properties.launchTemplateSpecification),
    "Overrides": cdk.listMapper(convertCfnEC2FleetFleetLaunchTemplateOverridesRequestPropertyToCloudFormation)(properties.overrides)
  };
}

// @ts-ignore TS6133
function CfnEC2FleetFleetLaunchTemplateConfigRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnEC2Fleet.FleetLaunchTemplateConfigRequestProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnEC2Fleet.FleetLaunchTemplateConfigRequestProperty>();
  ret.addPropertyResult("launchTemplateSpecification", "LaunchTemplateSpecification", (properties.LaunchTemplateSpecification != null ? CfnEC2FleetFleetLaunchTemplateSpecificationRequestPropertyFromCloudFormation(properties.LaunchTemplateSpecification) : undefined));
  ret.addPropertyResult("overrides", "Overrides", (properties.Overrides != null ? cfn_parse.FromCloudFormation.getArray(CfnEC2FleetFleetLaunchTemplateOverridesRequestPropertyFromCloudFormation)(properties.Overrides) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnEC2FleetProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnEC2FleetProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnEC2FleetPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("context", cdk.validateString)(properties.context));
  errors.collect(cdk.propertyValidator("excessCapacityTerminationPolicy", cdk.validateString)(properties.excessCapacityTerminationPolicy));
  errors.collect(cdk.propertyValidator("launchTemplateConfigs", cdk.requiredValidator)(properties.launchTemplateConfigs));
  errors.collect(cdk.propertyValidator("launchTemplateConfigs", cdk.listValidator(CfnEC2FleetFleetLaunchTemplateConfigRequestPropertyValidator))(properties.launchTemplateConfigs));
  errors.collect(cdk.propertyValidator("onDemandOptions", CfnEC2FleetOnDemandOptionsRequestPropertyValidator)(properties.onDemandOptions));
  errors.collect(cdk.propertyValidator("replaceUnhealthyInstances", cdk.validateBoolean)(properties.replaceUnhealthyInstances));
  errors.collect(cdk.propertyValidator("spotOptions", CfnEC2FleetSpotOptionsRequestPropertyValidator)(properties.spotOptions));
  errors.collect(cdk.propertyValidator("tagSpecifications", cdk.listValidator(CfnEC2FleetTagSpecificationPropertyValidator))(properties.tagSpecifications));
  errors.collect(cdk.propertyValidator("targetCapacitySpecification", cdk.requiredValidator)(properties.targetCapacitySpecification));
  errors.collect(cdk.propertyValidator("targetCapacitySpecification", CfnEC2FleetTargetCapacitySpecificationRequestPropertyValidator)(properties.targetCapacitySpecification));
  errors.collect(cdk.propertyValidator("terminateInstancesWithExpiration", cdk.validateBoolean)(properties.terminateInstancesWithExpiration));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  errors.collect(cdk.propertyValidator("validFrom", cdk.validateString)(properties.validFrom));
  errors.collect(cdk.propertyValidator("validUntil", cdk.validateString)(properties.validUntil));
  return errors.wrap("supplied properties not correct for \\"CfnEC2FleetProps\\"");
}

// @ts-ignore TS6133
function convertCfnEC2FleetPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnEC2FleetPropsValidator(properties).assertSuccess();
  return {
    "Context": cdk.stringToCloudFormation(properties.context),
    "ExcessCapacityTerminationPolicy": cdk.stringToCloudFormation(properties.excessCapacityTerminationPolicy),
    "LaunchTemplateConfigs": cdk.listMapper(convertCfnEC2FleetFleetLaunchTemplateConfigRequestPropertyToCloudFormation)(properties.launchTemplateConfigs),
    "OnDemandOptions": convertCfnEC2FleetOnDemandOptionsRequestPropertyToCloudFormation(properties.onDemandOptions),
    "ReplaceUnhealthyInstances": cdk.booleanToCloudFormation(properties.replaceUnhealthyInstances),
    "SpotOptions": convertCfnEC2FleetSpotOptionsRequestPropertyToCloudFormation(properties.spotOptions),
    "TagSpecifications": cdk.listMapper(convertCfnEC2FleetTagSpecificationPropertyToCloudFormation)(properties.tagSpecifications),
    "TargetCapacitySpecification": convertCfnEC2FleetTargetCapacitySpecificationRequestPropertyToCloudFormation(properties.targetCapacitySpecification),
    "TerminateInstancesWithExpiration": cdk.booleanToCloudFormation(properties.terminateInstancesWithExpiration),
    "Type": cdk.stringToCloudFormation(properties.type),
    "ValidFrom": cdk.stringToCloudFormation(properties.validFrom),
    "ValidUntil": cdk.stringToCloudFormation(properties.validUntil)
  };
}

// @ts-ignore TS6133
function CfnEC2FleetPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnEC2FleetProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnEC2FleetProps>();
  ret.addPropertyResult("context", "Context", (properties.Context != null ? cfn_parse.FromCloudFormation.getString(properties.Context) : undefined));
  ret.addPropertyResult("excessCapacityTerminationPolicy", "ExcessCapacityTerminationPolicy", (properties.ExcessCapacityTerminationPolicy != null ? cfn_parse.FromCloudFormation.getString(properties.ExcessCapacityTerminationPolicy) : undefined));
  ret.addPropertyResult("launchTemplateConfigs", "LaunchTemplateConfigs", (properties.LaunchTemplateConfigs != null ? cfn_parse.FromCloudFormation.getArray(CfnEC2FleetFleetLaunchTemplateConfigRequestPropertyFromCloudFormation)(properties.LaunchTemplateConfigs) : undefined));
  ret.addPropertyResult("onDemandOptions", "OnDemandOptions", (properties.OnDemandOptions != null ? CfnEC2FleetOnDemandOptionsRequestPropertyFromCloudFormation(properties.OnDemandOptions) : undefined));
  ret.addPropertyResult("replaceUnhealthyInstances", "ReplaceUnhealthyInstances", (properties.ReplaceUnhealthyInstances != null ? cfn_parse.FromCloudFormation.getBoolean(properties.ReplaceUnhealthyInstances) : undefined));
  ret.addPropertyResult("spotOptions", "SpotOptions", (properties.SpotOptions != null ? CfnEC2FleetSpotOptionsRequestPropertyFromCloudFormation(properties.SpotOptions) : undefined));
  ret.addPropertyResult("tagSpecifications", "TagSpecifications", (properties.TagSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnEC2FleetTagSpecificationPropertyFromCloudFormation)(properties.TagSpecifications) : undefined));
  ret.addPropertyResult("targetCapacitySpecification", "TargetCapacitySpecification", (properties.TargetCapacitySpecification != null ? CfnEC2FleetTargetCapacitySpecificationRequestPropertyFromCloudFormation(properties.TargetCapacitySpecification) : undefined));
  ret.addPropertyResult("terminateInstancesWithExpiration", "TerminateInstancesWithExpiration", (properties.TerminateInstancesWithExpiration != null ? cfn_parse.FromCloudFormation.getBoolean(properties.TerminateInstancesWithExpiration) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addPropertyResult("validFrom", "ValidFrom", (properties.ValidFrom != null ? cfn_parse.FromCloudFormation.getString(properties.ValidFrom) : undefined));
  ret.addPropertyResult("validUntil", "ValidUntil", (properties.ValidUntil != null ? cfn_parse.FromCloudFormation.getString(properties.ValidUntil) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * [IPv6 only] Specifies an egress-only internet gateway for your VPC.
 *
 * An egress-only internet gateway is used to enable outbound communication over IPv6 from instances in your VPC to the internet, and prevents hosts outside of your VPC from initiating an IPv6 connection with your instance.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-egressonlyinternetgateway.html
 */
export class CfnEgressOnlyInternetGateway extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::EgressOnlyInternetGateway";

  /**
   * Build a CfnEgressOnlyInternetGateway from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnEgressOnlyInternetGateway {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnEgressOnlyInternetGatewayPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnEgressOnlyInternetGateway(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the egress-only internet gateway.
   *
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The ID of the VPC for which to create the egress-only internet gateway.
   */
  public vpcId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnEgressOnlyInternetGatewayProps) {
    super(scope, id, {
      "type": CfnEgressOnlyInternetGateway.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "vpcId", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.vpcId = props.vpcId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "vpcId": this.vpcId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnEgressOnlyInternetGateway.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnEgressOnlyInternetGatewayPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnEgressOnlyInternetGateway\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-egressonlyinternetgateway.html
 */
export interface CfnEgressOnlyInternetGatewayProps {
  /**
   * The ID of the VPC for which to create the egress-only internet gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-egressonlyinternetgateway.html#cfn-ec2-egressonlyinternetgateway-vpcid
   */
  readonly vpcId: string;
}

/**
 * Determine whether the given properties match those of a \`CfnEgressOnlyInternetGatewayProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnEgressOnlyInternetGatewayProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnEgressOnlyInternetGatewayPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("vpcId", cdk.requiredValidator)(properties.vpcId));
  errors.collect(cdk.propertyValidator("vpcId", cdk.validateString)(properties.vpcId));
  return errors.wrap("supplied properties not correct for \\"CfnEgressOnlyInternetGatewayProps\\"");
}

// @ts-ignore TS6133
function convertCfnEgressOnlyInternetGatewayPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnEgressOnlyInternetGatewayPropsValidator(properties).assertSuccess();
  return {
    "VpcId": cdk.stringToCloudFormation(properties.vpcId)
  };
}

// @ts-ignore TS6133
function CfnEgressOnlyInternetGatewayPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnEgressOnlyInternetGatewayProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnEgressOnlyInternetGatewayProps>();
  ret.addPropertyResult("vpcId", "VpcId", (properties.VpcId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies an Elastic IP (EIP) address and can, optionally, associate it with an Amazon EC2 instance.
 *
 * You can allocate an Elastic IP address from an address pool owned by AWS or from an address pool created from a public IPv4 address range that you have brought to AWS for use with your AWS resources using bring your own IP addresses (BYOIP). For more information, see [Bring Your Own IP Addresses (BYOIP)](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-byoip.html) in the *Amazon EC2 User Guide* .
 *
 * For more information, see [Elastic IP Addresses](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/elastic-ip-addresses-eip.html) in the *Amazon EC2 User Guide* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eip.html
 */
export class CfnEIP extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::EIP";

  /**
   * Build a CfnEIP from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnEIP {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnEIPPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnEIP(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID that AWS assigns to represent the allocation of the address for use with Amazon VPC. This is returned only for VPC elastic IP addresses. For example, \`eipalloc-5723d13e\` .
   *
   * @cloudformationAttribute AllocationId
   */
  public readonly attrAllocationId: string;

  /**
   * The Elastic IP address.
   *
   * @cloudformationAttribute PublicIp
   */
  public readonly attrPublicIp: string;

  /**
   * The network ( \`vpc\` ).
   */
  public domain?: string;

  /**
   * The ID of the instance.
   */
  public instanceId?: string;

  /**
   * A unique set of Availability Zones, Local Zones, or Wavelength Zones from which AWS advertises IP addresses.
   */
  public networkBorderGroup?: string;

  /**
   * The ID of an address pool that you own.
   */
  public publicIpv4Pool?: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * Any tags assigned to the Elastic IP address.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The Elastic IP address you are accepting for transfer.
   */
  public transferAddress?: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnEIPProps = {}) {
    super(scope, id, {
      "type": CfnEIP.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.attrAllocationId = cdk.Token.asString(this.getAtt("AllocationId", cdk.ResolutionTypeHint.STRING));
    this.attrPublicIp = cdk.Token.asString(this.getAtt("PublicIp", cdk.ResolutionTypeHint.STRING));
    this.domain = props.domain;
    this.instanceId = props.instanceId;
    this.networkBorderGroup = props.networkBorderGroup;
    this.publicIpv4Pool = props.publicIpv4Pool;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::EIP", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.transferAddress = props.transferAddress;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "domain": this.domain,
      "instanceId": this.instanceId,
      "networkBorderGroup": this.networkBorderGroup,
      "publicIpv4Pool": this.publicIpv4Pool,
      "tags": this.tags.renderTags(),
      "transferAddress": this.transferAddress
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnEIP.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnEIPPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnEIP\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eip.html
 */
export interface CfnEIPProps {
  /**
   * The network ( \`vpc\` ).
   *
   * If you define an Elastic IP address and associate it with a VPC that is defined in the same template, you must declare a dependency on the VPC-gateway attachment by using the [DependsOn Attribute](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-dependson.html) on this resource.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eip.html#cfn-ec2-eip-domain
   */
  readonly domain?: string;

  /**
   * The ID of the instance.
   *
   * > Updates to the \`InstanceId\` property may require *some interruptions* . Updates on an EIP reassociates the address on its associated resource.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eip.html#cfn-ec2-eip-instanceid
   */
  readonly instanceId?: string;

  /**
   * A unique set of Availability Zones, Local Zones, or Wavelength Zones from which AWS advertises IP addresses.
   *
   * Use this parameter to limit the IP address to this location. IP addresses cannot move between network border groups.
   *
   * Use [DescribeAvailabilityZones](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeAvailabilityZones.html) to view the network border groups.
   *
   * You cannot use a network border group with EC2 Classic. If you attempt this operation on EC2 Classic, you receive an \`InvalidParameterCombination\` error.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eip.html#cfn-ec2-eip-networkbordergroup
   */
  readonly networkBorderGroup?: string;

  /**
   * The ID of an address pool that you own.
   *
   * Use this parameter to let Amazon EC2 select an address from the address pool.
   *
   * > Updates to the \`PublicIpv4Pool\` property may require *some interruptions* . Updates on an EIP reassociates the address on its associated resource.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eip.html#cfn-ec2-eip-publicipv4pool
   */
  readonly publicIpv4Pool?: string;

  /**
   * Any tags assigned to the Elastic IP address.
   *
   * > Updates to the \`Tags\` property may require *some interruptions* . Updates on an EIP reassociates the address on its associated resource.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eip.html#cfn-ec2-eip-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The Elastic IP address you are accepting for transfer.
   *
   * You can only accept one transferred address. For more information on Elastic IP address transfers, see [Transfer Elastic IP addresses](https://docs.aws.amazon.com/vpc/latest/userguide/vpc-eips.html#transfer-EIPs-intro) in the *Amazon Virtual Private Cloud User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eip.html#cfn-ec2-eip-transferaddress
   */
  readonly transferAddress?: string;
}

/**
 * Determine whether the given properties match those of a \`CfnEIPProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnEIPProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnEIPPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("domain", cdk.validateString)(properties.domain));
  errors.collect(cdk.propertyValidator("instanceId", cdk.validateString)(properties.instanceId));
  errors.collect(cdk.propertyValidator("networkBorderGroup", cdk.validateString)(properties.networkBorderGroup));
  errors.collect(cdk.propertyValidator("publicIpv4Pool", cdk.validateString)(properties.publicIpv4Pool));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("transferAddress", cdk.validateString)(properties.transferAddress));
  return errors.wrap("supplied properties not correct for \\"CfnEIPProps\\"");
}

// @ts-ignore TS6133
function convertCfnEIPPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnEIPPropsValidator(properties).assertSuccess();
  return {
    "Domain": cdk.stringToCloudFormation(properties.domain),
    "InstanceId": cdk.stringToCloudFormation(properties.instanceId),
    "NetworkBorderGroup": cdk.stringToCloudFormation(properties.networkBorderGroup),
    "PublicIpv4Pool": cdk.stringToCloudFormation(properties.publicIpv4Pool),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "TransferAddress": cdk.stringToCloudFormation(properties.transferAddress)
  };
}

// @ts-ignore TS6133
function CfnEIPPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnEIPProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnEIPProps>();
  ret.addPropertyResult("domain", "Domain", (properties.Domain != null ? cfn_parse.FromCloudFormation.getString(properties.Domain) : undefined));
  ret.addPropertyResult("instanceId", "InstanceId", (properties.InstanceId != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceId) : undefined));
  ret.addPropertyResult("networkBorderGroup", "NetworkBorderGroup", (properties.NetworkBorderGroup != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkBorderGroup) : undefined));
  ret.addPropertyResult("publicIpv4Pool", "PublicIpv4Pool", (properties.PublicIpv4Pool != null ? cfn_parse.FromCloudFormation.getString(properties.PublicIpv4Pool) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("transferAddress", "TransferAddress", (properties.TransferAddress != null ? cfn_parse.FromCloudFormation.getString(properties.TransferAddress) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Associates an Elastic IP address with an instance or a network interface.
 *
 * Before you can use an Elastic IP address, you must allocate it to your account. For more information about working with Elastic IP addresses, see [Elastic IP address concepts and rules](https://docs.aws.amazon.com/vpc/latest/userguide/vpc-eips.html#vpc-eip-overview) .
 *
 * You must specify \`AllocationId\` and either \`InstanceId\` , \`NetworkInterfaceId\` , or \`PrivateIpAddress\` .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eipassociation.html
 */
export class CfnEIPAssociation extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::EIPAssociation";

  /**
   * Build a CfnEIPAssociation from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnEIPAssociation {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnEIPAssociationPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnEIPAssociation(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The allocation ID.
   */
  public allocationId?: string;

  /**
   * Deprecated.
   */
  public eip?: string;

  /**
   * The ID of the instance.
   */
  public instanceId?: string;

  /**
   * The ID of the network interface.
   */
  public networkInterfaceId?: string;

  /**
   * The primary or secondary private IP address to associate with the Elastic IP address.
   */
  public privateIpAddress?: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnEIPAssociationProps = {}) {
    super(scope, id, {
      "type": CfnEIPAssociation.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.allocationId = props.allocationId;
    this.eip = props.eip;
    this.instanceId = props.instanceId;
    this.networkInterfaceId = props.networkInterfaceId;
    this.privateIpAddress = props.privateIpAddress;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "allocationId": this.allocationId,
      "eip": this.eip,
      "instanceId": this.instanceId,
      "networkInterfaceId": this.networkInterfaceId,
      "privateIpAddress": this.privateIpAddress
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnEIPAssociation.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnEIPAssociationPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnEIPAssociation\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eipassociation.html
 */
export interface CfnEIPAssociationProps {
  /**
   * The allocation ID.
   *
   * This is required.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eipassociation.html#cfn-ec2-eipassociation-allocationid
   */
  readonly allocationId?: string;

  /**
   * Deprecated.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eipassociation.html#cfn-ec2-eipassociation-eip
   */
  readonly eip?: string;

  /**
   * The ID of the instance.
   *
   * The instance must have exactly one attached network interface. You can specify either the instance ID or the network interface ID, but not both.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eipassociation.html#cfn-ec2-eipassociation-instanceid
   */
  readonly instanceId?: string;

  /**
   * The ID of the network interface.
   *
   * If the instance has more than one network interface, you must specify a network interface ID.
   *
   * You can specify either the instance ID or the network interface ID, but not both.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eipassociation.html#cfn-ec2-eipassociation-networkinterfaceid
   */
  readonly networkInterfaceId?: string;

  /**
   * The primary or secondary private IP address to associate with the Elastic IP address.
   *
   * If no private IP address is specified, the Elastic IP address is associated with the primary private IP address.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eipassociation.html#cfn-ec2-eipassociation-privateipaddress
   */
  readonly privateIpAddress?: string;
}

/**
 * Determine whether the given properties match those of a \`CfnEIPAssociationProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnEIPAssociationProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnEIPAssociationPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("allocationId", cdk.validateString)(properties.allocationId));
  errors.collect(cdk.propertyValidator("eip", cdk.validateString)(properties.eip));
  errors.collect(cdk.propertyValidator("instanceId", cdk.validateString)(properties.instanceId));
  errors.collect(cdk.propertyValidator("networkInterfaceId", cdk.validateString)(properties.networkInterfaceId));
  errors.collect(cdk.propertyValidator("privateIpAddress", cdk.validateString)(properties.privateIpAddress));
  return errors.wrap("supplied properties not correct for \\"CfnEIPAssociationProps\\"");
}

// @ts-ignore TS6133
function convertCfnEIPAssociationPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnEIPAssociationPropsValidator(properties).assertSuccess();
  return {
    "AllocationId": cdk.stringToCloudFormation(properties.allocationId),
    "EIP": cdk.stringToCloudFormation(properties.eip),
    "InstanceId": cdk.stringToCloudFormation(properties.instanceId),
    "NetworkInterfaceId": cdk.stringToCloudFormation(properties.networkInterfaceId),
    "PrivateIpAddress": cdk.stringToCloudFormation(properties.privateIpAddress)
  };
}

// @ts-ignore TS6133
function CfnEIPAssociationPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnEIPAssociationProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnEIPAssociationProps>();
  ret.addPropertyResult("allocationId", "AllocationId", (properties.AllocationId != null ? cfn_parse.FromCloudFormation.getString(properties.AllocationId) : undefined));
  ret.addPropertyResult("eip", "EIP", (properties.EIP != null ? cfn_parse.FromCloudFormation.getString(properties.EIP) : undefined));
  ret.addPropertyResult("instanceId", "InstanceId", (properties.InstanceId != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceId) : undefined));
  ret.addPropertyResult("networkInterfaceId", "NetworkInterfaceId", (properties.NetworkInterfaceId != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkInterfaceId) : undefined));
  ret.addPropertyResult("privateIpAddress", "PrivateIpAddress", (properties.PrivateIpAddress != null ? cfn_parse.FromCloudFormation.getString(properties.PrivateIpAddress) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Associates an AWS Identity and Access Management (IAM) role with an AWS Certificate Manager (ACM) certificate.
 *
 * This enables the certificate to be used by the ACM for Nitro Enclaves application inside an enclave. For more information, see [AWS Certificate Manager for Nitro Enclaves](https://docs.aws.amazon.com/enclaves/latest/user/nitro-enclave-refapp.html) in the *AWS Nitro Enclaves User Guide* .
 *
 * When the IAM role is associated with the ACM certificate, the certificate, certificate chain, and encrypted private key are placed in an Amazon S3 location that only the associated IAM role can access. The private key of the certificate is encrypted with an AWS managed key that has an attached attestation-based key policy.
 *
 * To enable the IAM role to access the Amazon S3 object, you must grant it permission to call \`s3:GetObject\` on the Amazon S3 bucket returned by the command. To enable the IAM role to access the KMS key, you must grant it permission to call \`kms:Decrypt\` on the KMS key returned by the command. For more information, see [Grant the role permission to access the certificate and encryption key](https://docs.aws.amazon.com/enclaves/latest/user/nitro-enclave-refapp.html#add-policy) in the *AWS Nitro Enclaves User Guide* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-enclavecertificateiamroleassociation.html
 */
export class CfnEnclaveCertificateIamRoleAssociation extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::EnclaveCertificateIamRoleAssociation";

  /**
   * Build a CfnEnclaveCertificateIamRoleAssociation from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnEnclaveCertificateIamRoleAssociation {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnEnclaveCertificateIamRoleAssociationPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnEnclaveCertificateIamRoleAssociation(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The name of the Amazon S3 bucket to which the certificate was uploaded.
   *
   * @cloudformationAttribute CertificateS3BucketName
   */
  public readonly attrCertificateS3BucketName: string;

  /**
   * The Amazon S3 object key where the certificate, certificate chain, and encrypted private key bundle are stored. The object key is formatted as follows: \`role_arn\` / \`certificate_arn\` .
   *
   * @cloudformationAttribute CertificateS3ObjectKey
   */
  public readonly attrCertificateS3ObjectKey: string;

  /**
   * The ID of the AWS KMS key used to encrypt the private key of the certificate.
   *
   * @cloudformationAttribute EncryptionKmsKeyId
   */
  public readonly attrEncryptionKmsKeyId: string;

  /**
   * The ARN of the ACM certificate with which to associate the IAM role.
   */
  public certificateArn: string;

  /**
   * The ARN of the IAM role to associate with the ACM certificate.
   */
  public roleArn: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnEnclaveCertificateIamRoleAssociationProps) {
    super(scope, id, {
      "type": CfnEnclaveCertificateIamRoleAssociation.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "certificateArn", this);
    cdk.requireProperty(props, "roleArn", this);

    this.attrCertificateS3BucketName = cdk.Token.asString(this.getAtt("CertificateS3BucketName", cdk.ResolutionTypeHint.STRING));
    this.attrCertificateS3ObjectKey = cdk.Token.asString(this.getAtt("CertificateS3ObjectKey", cdk.ResolutionTypeHint.STRING));
    this.attrEncryptionKmsKeyId = cdk.Token.asString(this.getAtt("EncryptionKmsKeyId", cdk.ResolutionTypeHint.STRING));
    this.certificateArn = props.certificateArn;
    this.roleArn = props.roleArn;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "certificateArn": this.certificateArn,
      "roleArn": this.roleArn
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnEnclaveCertificateIamRoleAssociation.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnEnclaveCertificateIamRoleAssociationPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnEnclaveCertificateIamRoleAssociation\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-enclavecertificateiamroleassociation.html
 */
export interface CfnEnclaveCertificateIamRoleAssociationProps {
  /**
   * The ARN of the ACM certificate with which to associate the IAM role.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-enclavecertificateiamroleassociation.html#cfn-ec2-enclavecertificateiamroleassociation-certificatearn
   */
  readonly certificateArn: string;

  /**
   * The ARN of the IAM role to associate with the ACM certificate.
   *
   * You can associate up to 16 IAM roles with an ACM certificate.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-enclavecertificateiamroleassociation.html#cfn-ec2-enclavecertificateiamroleassociation-rolearn
   */
  readonly roleArn: string;
}

/**
 * Determine whether the given properties match those of a \`CfnEnclaveCertificateIamRoleAssociationProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnEnclaveCertificateIamRoleAssociationProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnEnclaveCertificateIamRoleAssociationPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("certificateArn", cdk.requiredValidator)(properties.certificateArn));
  errors.collect(cdk.propertyValidator("certificateArn", cdk.validateString)(properties.certificateArn));
  errors.collect(cdk.propertyValidator("roleArn", cdk.requiredValidator)(properties.roleArn));
  errors.collect(cdk.propertyValidator("roleArn", cdk.validateString)(properties.roleArn));
  return errors.wrap("supplied properties not correct for \\"CfnEnclaveCertificateIamRoleAssociationProps\\"");
}

// @ts-ignore TS6133
function convertCfnEnclaveCertificateIamRoleAssociationPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnEnclaveCertificateIamRoleAssociationPropsValidator(properties).assertSuccess();
  return {
    "CertificateArn": cdk.stringToCloudFormation(properties.certificateArn),
    "RoleArn": cdk.stringToCloudFormation(properties.roleArn)
  };
}

// @ts-ignore TS6133
function CfnEnclaveCertificateIamRoleAssociationPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnEnclaveCertificateIamRoleAssociationProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnEnclaveCertificateIamRoleAssociationProps>();
  ret.addPropertyResult("certificateArn", "CertificateArn", (properties.CertificateArn != null ? cfn_parse.FromCloudFormation.getString(properties.CertificateArn) : undefined));
  ret.addPropertyResult("roleArn", "RoleArn", (properties.RoleArn != null ? cfn_parse.FromCloudFormation.getString(properties.RoleArn) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a VPC flow log that captures IP traffic for a specified network interface, subnet, or VPC.
 *
 * To view the log data, use Amazon CloudWatch Logs (CloudWatch Logs) to help troubleshoot connection issues. For example, you can use a flow log to investigate why certain traffic isn't reaching an instance, which can help you diagnose overly restrictive security group rules. For more information, see [VPC Flow Logs](https://docs.aws.amazon.com/vpc/latest/userguide/flow-logs.html) in the *Amazon VPC User Guide* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html
 */
export class CfnFlowLog extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::FlowLog";

  /**
   * Build a CfnFlowLog from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnFlowLog {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnFlowLogPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnFlowLog(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the flow log. For example, \`fl-123456abc123abc1\` .
   *
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The ARN of the IAM role that allows Amazon EC2 to publish flow logs to a CloudWatch Logs log group in your account.
   */
  public deliverLogsPermissionArn?: string;

  /**
   * The destination options. The following options are supported:.
   */
  public destinationOptions?: any | cdk.IResolvable;

  /**
   * The destination for the flow log data. The meaning of this parameter depends on the destination type.
   */
  public logDestination?: string;

  /**
   * The type of destination for the flow log data.
   */
  public logDestinationType?: string;

  /**
   * The fields to include in the flow log record, in the order in which they should appear.
   */
  public logFormat?: string;

  /**
   * The name of a new or existing CloudWatch Logs log group where Amazon EC2 publishes your flow logs.
   */
  public logGroupName?: string;

  /**
   * The maximum interval of time during which a flow of packets is captured and aggregated into a flow log record.
   */
  public maxAggregationInterval?: number;

  /**
   * The ID of the resource to monitor.
   */
  public resourceId: string;

  /**
   * The type of resource to monitor.
   */
  public resourceType: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags to apply to the flow logs.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The type of traffic to monitor (accepted traffic, rejected traffic, or all traffic).
   */
  public trafficType?: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnFlowLogProps) {
    super(scope, id, {
      "type": CfnFlowLog.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "resourceId", this);
    cdk.requireProperty(props, "resourceType", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.deliverLogsPermissionArn = props.deliverLogsPermissionArn;
    this.destinationOptions = props.destinationOptions;
    this.logDestination = props.logDestination;
    this.logDestinationType = props.logDestinationType;
    this.logFormat = props.logFormat;
    this.logGroupName = props.logGroupName;
    this.maxAggregationInterval = props.maxAggregationInterval;
    this.resourceId = props.resourceId;
    this.resourceType = props.resourceType;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::FlowLog", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.trafficType = props.trafficType;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "deliverLogsPermissionArn": this.deliverLogsPermissionArn,
      "destinationOptions": this.destinationOptions,
      "logDestination": this.logDestination,
      "logDestinationType": this.logDestinationType,
      "logFormat": this.logFormat,
      "logGroupName": this.logGroupName,
      "maxAggregationInterval": this.maxAggregationInterval,
      "resourceId": this.resourceId,
      "resourceType": this.resourceType,
      "tags": this.tags.renderTags(),
      "trafficType": this.trafficType
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnFlowLog.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnFlowLogPropsToCloudFormation(props);
  }
}

export namespace CfnFlowLog {
  /**
   * Describes the destination options for a flow log.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-flowlog-destinationoptions.html
   */
  export interface DestinationOptionsProperty {
    /**
     * The format for the flow log.
     *
     * The default is \`plain-text\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-flowlog-destinationoptions.html#cfn-ec2-flowlog-destinationoptions-fileformat
     */
    readonly fileFormat: string;

    /**
     * Indicates whether to use Hive-compatible prefixes for flow logs stored in Amazon S3.
     *
     * The default is \`false\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-flowlog-destinationoptions.html#cfn-ec2-flowlog-destinationoptions-hivecompatiblepartitions
     */
    readonly hiveCompatiblePartitions: boolean | cdk.IResolvable;

    /**
     * Indicates whether to partition the flow log per hour.
     *
     * This reduces the cost and response time for queries. The default is \`false\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-flowlog-destinationoptions.html#cfn-ec2-flowlog-destinationoptions-perhourpartition
     */
    readonly perHourPartition: boolean | cdk.IResolvable;
  }
}

/**
 * Properties for defining a \`CfnFlowLog\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html
 */
export interface CfnFlowLogProps {
  /**
   * The ARN of the IAM role that allows Amazon EC2 to publish flow logs to a CloudWatch Logs log group in your account.
   *
   * This parameter is required if the destination type is \`cloud-watch-logs\` and unsupported otherwise.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-deliverlogspermissionarn
   */
  readonly deliverLogsPermissionArn?: string;

  /**
   * The destination options. The following options are supported:.
   *
   * - \`FileFormat\` - The format for the flow log ( \`plain-text\` | \`parquet\` ). The default is \`plain-text\` .
   * - \`HiveCompatiblePartitions\` - Indicates whether to use Hive-compatible prefixes for flow logs stored in Amazon S3 ( \`true\` | \`false\` ). The default is \`false\` .
   * - \`PerHourPartition\` - Indicates whether to partition the flow log per hour ( \`true\` | \`false\` ). The default is \`false\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-destinationoptions
   */
  readonly destinationOptions?: any | cdk.IResolvable;

  /**
   * The destination for the flow log data. The meaning of this parameter depends on the destination type.
   *
   * - If the destination type is \`cloud-watch-logs\` , specify the ARN of a CloudWatch Logs log group. For example:
   *
   * arn:aws:logs: *region* : *account_id* :log-group: *my_group*
   *
   * Alternatively, use the \`LogGroupName\` parameter.
   * - If the destination type is \`s3\` , specify the ARN of an S3 bucket. For example:
   *
   * arn:aws:s3::: *my_bucket* / *my_subfolder* /
   *
   * The subfolder is optional. Note that you can't use \`AWSLogs\` as a subfolder name.
   * - If the destination type is \`kinesis-data-firehose\` , specify the ARN of a Kinesis Data Firehose delivery stream. For example:
   *
   * arn:aws:firehose: *region* : *account_id* :deliverystream: *my_stream*
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-logdestination
   */
  readonly logDestination?: string;

  /**
   * The type of destination for the flow log data.
   *
   * Default: \`cloud-watch-logs\`
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-logdestinationtype
   */
  readonly logDestinationType?: string;

  /**
   * The fields to include in the flow log record, in the order in which they should appear.
   *
   * If you omit this parameter, the flow log is created using the default format. If you specify this parameter, you must include at least one field. For more information about the available fields, see [Flow log records](https://docs.aws.amazon.com/vpc/latest/userguide/flow-logs.html#flow-log-records) in the *Amazon VPC User Guide* or [Transit Gateway Flow Log records](https://docs.aws.amazon.com/vpc/latest/tgw/tgw-flow-logs.html#flow-log-records) in the *AWS Transit Gateway Guide* .
   *
   * Specify the fields using the \`\${field-id}\` format, separated by spaces.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-logformat
   */
  readonly logFormat?: string;

  /**
   * The name of a new or existing CloudWatch Logs log group where Amazon EC2 publishes your flow logs.
   *
   * This parameter is valid only if the destination type is \`cloud-watch-logs\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-loggroupname
   */
  readonly logGroupName?: string;

  /**
   * The maximum interval of time during which a flow of packets is captured and aggregated into a flow log record.
   *
   * The possible values are 60 seconds (1 minute) or 600 seconds (10 minutes). This parameter must be 60 seconds for transit gateway resource types.
   *
   * When a network interface is attached to a [Nitro-based instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances) , the aggregation interval is always 60 seconds or less, regardless of the value that you specify.
   *
   * Default: 600
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-maxaggregationinterval
   */
  readonly maxAggregationInterval?: number;

  /**
   * The ID of the resource to monitor.
   *
   * For example, if the resource type is \`VPC\` , specify the ID of the VPC.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-resourceid
   */
  readonly resourceId: string;

  /**
   * The type of resource to monitor.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-resourcetype
   */
  readonly resourceType: string;

  /**
   * The tags to apply to the flow logs.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The type of traffic to monitor (accepted traffic, rejected traffic, or all traffic).
   *
   * This parameter is not supported for transit gateway resource types. It is required for the other resource types.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-traffictype
   */
  readonly trafficType?: string;
}

/**
 * Determine whether the given properties match those of a \`DestinationOptionsProperty\`
 *
 * @param properties - the TypeScript properties of a \`DestinationOptionsProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFlowLogDestinationOptionsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("fileFormat", cdk.requiredValidator)(properties.fileFormat));
  errors.collect(cdk.propertyValidator("fileFormat", cdk.validateString)(properties.fileFormat));
  errors.collect(cdk.propertyValidator("hiveCompatiblePartitions", cdk.requiredValidator)(properties.hiveCompatiblePartitions));
  errors.collect(cdk.propertyValidator("hiveCompatiblePartitions", cdk.validateBoolean)(properties.hiveCompatiblePartitions));
  errors.collect(cdk.propertyValidator("perHourPartition", cdk.requiredValidator)(properties.perHourPartition));
  errors.collect(cdk.propertyValidator("perHourPartition", cdk.validateBoolean)(properties.perHourPartition));
  return errors.wrap("supplied properties not correct for \\"DestinationOptionsProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFlowLogDestinationOptionsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFlowLogDestinationOptionsPropertyValidator(properties).assertSuccess();
  return {
    "FileFormat": cdk.stringToCloudFormation(properties.fileFormat),
    "HiveCompatiblePartitions": cdk.booleanToCloudFormation(properties.hiveCompatiblePartitions),
    "PerHourPartition": cdk.booleanToCloudFormation(properties.perHourPartition)
  };
}

// @ts-ignore TS6133
function CfnFlowLogDestinationOptionsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnFlowLog.DestinationOptionsProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFlowLog.DestinationOptionsProperty>();
  ret.addPropertyResult("fileFormat", "FileFormat", (properties.FileFormat != null ? cfn_parse.FromCloudFormation.getString(properties.FileFormat) : undefined));
  ret.addPropertyResult("hiveCompatiblePartitions", "HiveCompatiblePartitions", (properties.HiveCompatiblePartitions != null ? cfn_parse.FromCloudFormation.getBoolean(properties.HiveCompatiblePartitions) : undefined));
  ret.addPropertyResult("perHourPartition", "PerHourPartition", (properties.PerHourPartition != null ? cfn_parse.FromCloudFormation.getBoolean(properties.PerHourPartition) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnFlowLogProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnFlowLogProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFlowLogPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("deliverLogsPermissionArn", cdk.validateString)(properties.deliverLogsPermissionArn));
  errors.collect(cdk.propertyValidator("destinationOptions", cdk.validateObject)(properties.destinationOptions));
  errors.collect(cdk.propertyValidator("logDestination", cdk.validateString)(properties.logDestination));
  errors.collect(cdk.propertyValidator("logDestinationType", cdk.validateString)(properties.logDestinationType));
  errors.collect(cdk.propertyValidator("logFormat", cdk.validateString)(properties.logFormat));
  errors.collect(cdk.propertyValidator("logGroupName", cdk.validateString)(properties.logGroupName));
  errors.collect(cdk.propertyValidator("maxAggregationInterval", cdk.validateNumber)(properties.maxAggregationInterval));
  errors.collect(cdk.propertyValidator("resourceId", cdk.requiredValidator)(properties.resourceId));
  errors.collect(cdk.propertyValidator("resourceId", cdk.validateString)(properties.resourceId));
  errors.collect(cdk.propertyValidator("resourceType", cdk.requiredValidator)(properties.resourceType));
  errors.collect(cdk.propertyValidator("resourceType", cdk.validateString)(properties.resourceType));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("trafficType", cdk.validateString)(properties.trafficType));
  return errors.wrap("supplied properties not correct for \\"CfnFlowLogProps\\"");
}

// @ts-ignore TS6133
function convertCfnFlowLogPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFlowLogPropsValidator(properties).assertSuccess();
  return {
    "DeliverLogsPermissionArn": cdk.stringToCloudFormation(properties.deliverLogsPermissionArn),
    "DestinationOptions": cdk.objectToCloudFormation(properties.destinationOptions),
    "LogDestination": cdk.stringToCloudFormation(properties.logDestination),
    "LogDestinationType": cdk.stringToCloudFormation(properties.logDestinationType),
    "LogFormat": cdk.stringToCloudFormation(properties.logFormat),
    "LogGroupName": cdk.stringToCloudFormation(properties.logGroupName),
    "MaxAggregationInterval": cdk.numberToCloudFormation(properties.maxAggregationInterval),
    "ResourceId": cdk.stringToCloudFormation(properties.resourceId),
    "ResourceType": cdk.stringToCloudFormation(properties.resourceType),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "TrafficType": cdk.stringToCloudFormation(properties.trafficType)
  };
}

// @ts-ignore TS6133
function CfnFlowLogPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnFlowLogProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFlowLogProps>();
  ret.addPropertyResult("deliverLogsPermissionArn", "DeliverLogsPermissionArn", (properties.DeliverLogsPermissionArn != null ? cfn_parse.FromCloudFormation.getString(properties.DeliverLogsPermissionArn) : undefined));
  ret.addPropertyResult("destinationOptions", "DestinationOptions", (properties.DestinationOptions != null ? cfn_parse.FromCloudFormation.getAny(properties.DestinationOptions) : undefined));
  ret.addPropertyResult("logDestination", "LogDestination", (properties.LogDestination != null ? cfn_parse.FromCloudFormation.getString(properties.LogDestination) : undefined));
  ret.addPropertyResult("logDestinationType", "LogDestinationType", (properties.LogDestinationType != null ? cfn_parse.FromCloudFormation.getString(properties.LogDestinationType) : undefined));
  ret.addPropertyResult("logFormat", "LogFormat", (properties.LogFormat != null ? cfn_parse.FromCloudFormation.getString(properties.LogFormat) : undefined));
  ret.addPropertyResult("logGroupName", "LogGroupName", (properties.LogGroupName != null ? cfn_parse.FromCloudFormation.getString(properties.LogGroupName) : undefined));
  ret.addPropertyResult("maxAggregationInterval", "MaxAggregationInterval", (properties.MaxAggregationInterval != null ? cfn_parse.FromCloudFormation.getNumber(properties.MaxAggregationInterval) : undefined));
  ret.addPropertyResult("resourceId", "ResourceId", (properties.ResourceId != null ? cfn_parse.FromCloudFormation.getString(properties.ResourceId) : undefined));
  ret.addPropertyResult("resourceType", "ResourceType", (properties.ResourceType != null ? cfn_parse.FromCloudFormation.getString(properties.ResourceType) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("trafficType", "TrafficType", (properties.TrafficType != null ? cfn_parse.FromCloudFormation.getString(properties.TrafficType) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Associates a virtual private gateway or internet gateway with a route table.
 *
 * The gateway and route table must be in the same VPC. This association causes the incoming traffic to the gateway to be routed according to the routes in the route table.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-gatewayroutetableassociation.html
 */
export class CfnGatewayRouteTableAssociation extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::GatewayRouteTableAssociation";

  /**
   * Build a CfnGatewayRouteTableAssociation from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnGatewayRouteTableAssociation {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnGatewayRouteTableAssociationPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnGatewayRouteTableAssociation(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the route table association.
   *
   * @cloudformationAttribute AssociationId
   */
  public readonly attrAssociationId: string;

  /**
   * The ID of the gateway.
   */
  public gatewayId: string;

  /**
   * The ID of the route table.
   */
  public routeTableId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnGatewayRouteTableAssociationProps) {
    super(scope, id, {
      "type": CfnGatewayRouteTableAssociation.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "gatewayId", this);
    cdk.requireProperty(props, "routeTableId", this);

    this.attrAssociationId = cdk.Token.asString(this.getAtt("AssociationId", cdk.ResolutionTypeHint.STRING));
    this.gatewayId = props.gatewayId;
    this.routeTableId = props.routeTableId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "gatewayId": this.gatewayId,
      "routeTableId": this.routeTableId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnGatewayRouteTableAssociation.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnGatewayRouteTableAssociationPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnGatewayRouteTableAssociation\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-gatewayroutetableassociation.html
 */
export interface CfnGatewayRouteTableAssociationProps {
  /**
   * The ID of the gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-gatewayroutetableassociation.html#cfn-ec2-gatewayroutetableassociation-gatewayid
   */
  readonly gatewayId: string;

  /**
   * The ID of the route table.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-gatewayroutetableassociation.html#cfn-ec2-gatewayroutetableassociation-routetableid
   */
  readonly routeTableId: string;
}

/**
 * Determine whether the given properties match those of a \`CfnGatewayRouteTableAssociationProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnGatewayRouteTableAssociationProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnGatewayRouteTableAssociationPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("gatewayId", cdk.requiredValidator)(properties.gatewayId));
  errors.collect(cdk.propertyValidator("gatewayId", cdk.validateString)(properties.gatewayId));
  errors.collect(cdk.propertyValidator("routeTableId", cdk.requiredValidator)(properties.routeTableId));
  errors.collect(cdk.propertyValidator("routeTableId", cdk.validateString)(properties.routeTableId));
  return errors.wrap("supplied properties not correct for \\"CfnGatewayRouteTableAssociationProps\\"");
}

// @ts-ignore TS6133
function convertCfnGatewayRouteTableAssociationPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnGatewayRouteTableAssociationPropsValidator(properties).assertSuccess();
  return {
    "GatewayId": cdk.stringToCloudFormation(properties.gatewayId),
    "RouteTableId": cdk.stringToCloudFormation(properties.routeTableId)
  };
}

// @ts-ignore TS6133
function CfnGatewayRouteTableAssociationPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnGatewayRouteTableAssociationProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnGatewayRouteTableAssociationProps>();
  ret.addPropertyResult("gatewayId", "GatewayId", (properties.GatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.GatewayId) : undefined));
  ret.addPropertyResult("routeTableId", "RouteTableId", (properties.RouteTableId != null ? cfn_parse.FromCloudFormation.getString(properties.RouteTableId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Allocates a fully dedicated physical server for launching EC2 instances.
 *
 * Because the host is fully dedicated for your use, it can help you address compliance requirements and reduce costs by allowing you to use your existing server-bound software licenses. For more information, see [Dedicated Hosts](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/dedicated-hosts-overview.html) in the *Amazon EC2 User Guide for Linux Instances* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-host.html
 */
export class CfnHost extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::Host";

  /**
   * Build a CfnHost from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnHost {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnHostPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnHost(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the host.
   *
   * @cloudformationAttribute HostId
   */
  public readonly attrHostId: string;

  /**
   * Indicates whether the host accepts any untargeted instance launches that match its instance type configuration, or if it only accepts Host tenancy instance launches that specify its unique host ID.
   */
  public autoPlacement?: string;

  /**
   * The Availability Zone in which to allocate the Dedicated Host.
   */
  public availabilityZone: string;

  /**
   * Indicates whether host maintenance is enabled or disabled for the Dedicated Host.
   */
  public hostMaintenance?: string;

  /**
   * Indicates whether to enable or disable host recovery for the Dedicated Host.
   */
  public hostRecovery?: string;

  /**
   * The instance family supported by the Dedicated Host.
   */
  public instanceFamily?: string;

  /**
   * Specifies the instance type to be supported by the Dedicated Hosts.
   */
  public instanceType?: string;

  /**
   * The Amazon Resource Name (ARN) of the AWS Outpost on which the Dedicated Host is allocated.
   */
  public outpostArn?: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnHostProps) {
    super(scope, id, {
      "type": CfnHost.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "availabilityZone", this);

    this.attrHostId = cdk.Token.asString(this.getAtt("HostId", cdk.ResolutionTypeHint.STRING));
    this.autoPlacement = props.autoPlacement;
    this.availabilityZone = props.availabilityZone;
    this.hostMaintenance = props.hostMaintenance;
    this.hostRecovery = props.hostRecovery;
    this.instanceFamily = props.instanceFamily;
    this.instanceType = props.instanceType;
    this.outpostArn = props.outpostArn;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "autoPlacement": this.autoPlacement,
      "availabilityZone": this.availabilityZone,
      "hostMaintenance": this.hostMaintenance,
      "hostRecovery": this.hostRecovery,
      "instanceFamily": this.instanceFamily,
      "instanceType": this.instanceType,
      "outpostArn": this.outpostArn
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnHost.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnHostPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnHost\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-host.html
 */
export interface CfnHostProps {
  /**
   * Indicates whether the host accepts any untargeted instance launches that match its instance type configuration, or if it only accepts Host tenancy instance launches that specify its unique host ID.
   *
   * For more information, see [Understanding auto-placement and affinity](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/how-dedicated-hosts-work.html#dedicated-hosts-understanding) in the *Amazon EC2 User Guide* .
   *
   * Default: \`on\`
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-host.html#cfn-ec2-host-autoplacement
   */
  readonly autoPlacement?: string;

  /**
   * The Availability Zone in which to allocate the Dedicated Host.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-host.html#cfn-ec2-host-availabilityzone
   */
  readonly availabilityZone: string;

  /**
   * Indicates whether host maintenance is enabled or disabled for the Dedicated Host.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-host.html#cfn-ec2-host-hostmaintenance
   */
  readonly hostMaintenance?: string;

  /**
   * Indicates whether to enable or disable host recovery for the Dedicated Host.
   *
   * Host recovery is disabled by default. For more information, see [Host recovery](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/dedicated-hosts-recovery.html) in the *Amazon EC2 User Guide* .
   *
   * Default: \`off\`
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-host.html#cfn-ec2-host-hostrecovery
   */
  readonly hostRecovery?: string;

  /**
   * The instance family supported by the Dedicated Host.
   *
   * For example, \`m5\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-host.html#cfn-ec2-host-instancefamily
   */
  readonly instanceFamily?: string;

  /**
   * Specifies the instance type to be supported by the Dedicated Hosts.
   *
   * If you specify an instance type, the Dedicated Hosts support instances of the specified instance type only.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-host.html#cfn-ec2-host-instancetype
   */
  readonly instanceType?: string;

  /**
   * The Amazon Resource Name (ARN) of the AWS Outpost on which the Dedicated Host is allocated.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-host.html#cfn-ec2-host-outpostarn
   */
  readonly outpostArn?: string;
}

/**
 * Determine whether the given properties match those of a \`CfnHostProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnHostProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnHostPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("autoPlacement", cdk.validateString)(properties.autoPlacement));
  errors.collect(cdk.propertyValidator("availabilityZone", cdk.requiredValidator)(properties.availabilityZone));
  errors.collect(cdk.propertyValidator("availabilityZone", cdk.validateString)(properties.availabilityZone));
  errors.collect(cdk.propertyValidator("hostMaintenance", cdk.validateString)(properties.hostMaintenance));
  errors.collect(cdk.propertyValidator("hostRecovery", cdk.validateString)(properties.hostRecovery));
  errors.collect(cdk.propertyValidator("instanceFamily", cdk.validateString)(properties.instanceFamily));
  errors.collect(cdk.propertyValidator("instanceType", cdk.validateString)(properties.instanceType));
  errors.collect(cdk.propertyValidator("outpostArn", cdk.validateString)(properties.outpostArn));
  return errors.wrap("supplied properties not correct for \\"CfnHostProps\\"");
}

// @ts-ignore TS6133
function convertCfnHostPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnHostPropsValidator(properties).assertSuccess();
  return {
    "AutoPlacement": cdk.stringToCloudFormation(properties.autoPlacement),
    "AvailabilityZone": cdk.stringToCloudFormation(properties.availabilityZone),
    "HostMaintenance": cdk.stringToCloudFormation(properties.hostMaintenance),
    "HostRecovery": cdk.stringToCloudFormation(properties.hostRecovery),
    "InstanceFamily": cdk.stringToCloudFormation(properties.instanceFamily),
    "InstanceType": cdk.stringToCloudFormation(properties.instanceType),
    "OutpostArn": cdk.stringToCloudFormation(properties.outpostArn)
  };
}

// @ts-ignore TS6133
function CfnHostPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnHostProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnHostProps>();
  ret.addPropertyResult("autoPlacement", "AutoPlacement", (properties.AutoPlacement != null ? cfn_parse.FromCloudFormation.getString(properties.AutoPlacement) : undefined));
  ret.addPropertyResult("availabilityZone", "AvailabilityZone", (properties.AvailabilityZone != null ? cfn_parse.FromCloudFormation.getString(properties.AvailabilityZone) : undefined));
  ret.addPropertyResult("hostMaintenance", "HostMaintenance", (properties.HostMaintenance != null ? cfn_parse.FromCloudFormation.getString(properties.HostMaintenance) : undefined));
  ret.addPropertyResult("hostRecovery", "HostRecovery", (properties.HostRecovery != null ? cfn_parse.FromCloudFormation.getString(properties.HostRecovery) : undefined));
  ret.addPropertyResult("instanceFamily", "InstanceFamily", (properties.InstanceFamily != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceFamily) : undefined));
  ret.addPropertyResult("instanceType", "InstanceType", (properties.InstanceType != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceType) : undefined));
  ret.addPropertyResult("outpostArn", "OutpostArn", (properties.OutpostArn != null ? cfn_parse.FromCloudFormation.getString(properties.OutpostArn) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies an EC2 instance.
 *
 * If an Elastic IP address is attached to your instance, AWS CloudFormation reattaches the Elastic IP address after it updates the instance. For more information about updating stacks, see [AWS CloudFormation Stacks Updates](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks.html) .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html
 */
export class CfnInstance extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::Instance";

  /**
   * Build a CfnInstance from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnInstance {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnInstancePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnInstance(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The Availability Zone where the specified instance is launched. For example: \`us-east-1b\` .
   *
   * You can retrieve a list of all Availability Zones for a Region by using the [Fn::GetAZs](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference-getavailabilityzones.html) intrinsic function.
   *
   * @cloudformationAttribute AvailabilityZone
   */
  public readonly attrAvailabilityZone: string;

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The private DNS name of the specified instance. For example: \`ip-10-24-34-0.ec2.internal\` .
   *
   * @cloudformationAttribute PrivateDnsName
   */
  public readonly attrPrivateDnsName: string;

  /**
   * The private IP address of the specified instance. For example: \`10.24.34.0\` .
   *
   * @cloudformationAttribute PrivateIp
   */
  public readonly attrPrivateIp: string;

  /**
   * The public DNS name of the specified instance. For example: \`ec2-107-20-50-45.compute-1.amazonaws.com\` .
   *
   * @cloudformationAttribute PublicDnsName
   */
  public readonly attrPublicDnsName: string;

  /**
   * The public IP address of the specified instance. For example: \`192.0.2.0\` .
   *
   * @cloudformationAttribute PublicIp
   */
  public readonly attrPublicIp: string;

  /**
   * This property is reserved for internal use.
   */
  public additionalInfo?: string;

  /**
   * Indicates whether the instance is associated with a dedicated host.
   */
  public affinity?: string;

  /**
   * The Availability Zone of the instance.
   */
  public availabilityZone?: string;

  /**
   * The block device mapping entries that defines the block devices to attach to the instance at launch.
   */
  public blockDeviceMappings?: Array<CfnInstance.BlockDeviceMappingProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * The CPU options for the instance.
   */
  public cpuOptions?: CfnInstance.CpuOptionsProperty | cdk.IResolvable;

  /**
   * The credit option for CPU usage of the burstable performance instance.
   */
  public creditSpecification?: CfnInstance.CreditSpecificationProperty | cdk.IResolvable;

  /**
   * If you set this parameter to \`true\` , you can't terminate the instance using the Amazon EC2 console, CLI, or API;
   */
  public disableApiTermination?: boolean | cdk.IResolvable;

  /**
   * Indicates whether the instance is optimized for Amazon EBS I/O.
   */
  public ebsOptimized?: boolean | cdk.IResolvable;

  /**
   * An elastic GPU to associate with the instance.
   */
  public elasticGpuSpecifications?: Array<CfnInstance.ElasticGpuSpecificationProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * An elastic inference accelerator to associate with the instance.
   */
  public elasticInferenceAccelerators?: Array<CfnInstance.ElasticInferenceAcceleratorProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * Indicates whether the instance is enabled for AWS Nitro Enclaves.
   */
  public enclaveOptions?: CfnInstance.EnclaveOptionsProperty | cdk.IResolvable;

  /**
   * Indicates whether an instance is enabled for hibernation.
   */
  public hibernationOptions?: CfnInstance.HibernationOptionsProperty | cdk.IResolvable;

  /**
   * If you specify host for the \`Affinity\` property, the ID of a dedicated host that the instance is associated with.
   */
  public hostId?: string;

  /**
   * The ARN of the host resource group in which to launch the instances.
   */
  public hostResourceGroupArn?: string;

  /**
   * The name of an IAM instance profile.
   */
  public iamInstanceProfile?: string;

  /**
   * The ID of the AMI.
   */
  public imageId?: string;

  /**
   * Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).
   */
  public instanceInitiatedShutdownBehavior?: string;

  /**
   * The instance type. For more information, see [Instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the *Amazon EC2 User Guide* .
   */
  public instanceType?: string;

  /**
   * The number of IPv6 addresses to associate with the primary network interface.
   */
  public ipv6AddressCount?: number;

  /**
   * The IPv6 addresses from the range of the subnet to associate with the primary network interface.
   */
  public ipv6Addresses?: Array<CfnInstance.InstanceIpv6AddressProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * The ID of the kernel.
   */
  public kernelId?: string;

  /**
   * The name of the key pair. You can create a key pair using [CreateKeyPair](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateKeyPair.html) or [ImportKeyPair](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportKeyPair.html) .
   */
  public keyName?: string;

  /**
   * The launch template to use to launch the instances.
   */
  public launchTemplate?: cdk.IResolvable | CfnInstance.LaunchTemplateSpecificationProperty;

  /**
   * The license configurations.
   */
  public licenseSpecifications?: Array<cdk.IResolvable | CfnInstance.LicenseSpecificationProperty> | cdk.IResolvable;

  /**
   * Specifies whether detailed monitoring is enabled for the instance.
   */
  public monitoring?: boolean | cdk.IResolvable;

  /**
   * The network interfaces to associate with the instance.
   */
  public networkInterfaces?: Array<cdk.IResolvable | CfnInstance.NetworkInterfaceProperty> | cdk.IResolvable;

  /**
   * The name of an existing placement group that you want to launch the instance into (cluster | partition | spread).
   */
  public placementGroupName?: string;

  /**
   * The options for the instance hostname.
   */
  public privateDnsNameOptions?: cdk.IResolvable | CfnInstance.PrivateDnsNameOptionsProperty;

  /**
   * The primary IPv4 address. You must specify a value from the IPv4 address range of the subnet.
   */
  public privateIpAddress?: string;

  /**
   * Indicates whether to assign the tags from the instance to all of the volumes attached to the instance at launch.
   */
  public propagateTagsToVolumeOnCreation?: boolean | cdk.IResolvable;

  /**
   * The ID of the RAM disk to select.
   */
  public ramdiskId?: string;

  /**
   * The IDs of the security groups.
   */
  public securityGroupIds?: Array<string>;

  /**
   * [Default VPC] The names of the security groups. For a nondefault VPC, you must use security group IDs instead.
   */
  public securityGroups?: Array<string>;

  /**
   * Enable or disable source/destination checks, which ensure that the instance is either the source or the destination of any traffic that it receives.
   */
  public sourceDestCheck?: boolean | cdk.IResolvable;

  /**
   * The SSM [document](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssm-document.html) and parameter values in AWS Systems Manager to associate with this instance. To use this property, you must specify an IAM instance profile role for the instance. For more information, see [Create an IAM instance profile for Systems Manager](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-configuring-access-role.html) in the *AWS Systems Manager User Guide* .
   */
  public ssmAssociations?: Array<cdk.IResolvable | CfnInstance.SsmAssociationProperty> | cdk.IResolvable;

  /**
   * The ID of the subnet to launch the instance into.
   */
  public subnetId?: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags to add to the instance.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The tenancy of the instance.
   */
  public tenancy?: string;

  /**
   * The user data script to make available to the instance.
   */
  public userData?: string;

  /**
   * The volumes to attach to the instance.
   */
  public volumes?: Array<cdk.IResolvable | CfnInstance.VolumeProperty> | cdk.IResolvable;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnInstanceProps = {}) {
    super(scope, id, {
      "type": CfnInstance.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.attrAvailabilityZone = cdk.Token.asString(this.getAtt("AvailabilityZone", cdk.ResolutionTypeHint.STRING));
    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.attrPrivateDnsName = cdk.Token.asString(this.getAtt("PrivateDnsName", cdk.ResolutionTypeHint.STRING));
    this.attrPrivateIp = cdk.Token.asString(this.getAtt("PrivateIp", cdk.ResolutionTypeHint.STRING));
    this.attrPublicDnsName = cdk.Token.asString(this.getAtt("PublicDnsName", cdk.ResolutionTypeHint.STRING));
    this.attrPublicIp = cdk.Token.asString(this.getAtt("PublicIp", cdk.ResolutionTypeHint.STRING));
    this.additionalInfo = props.additionalInfo;
    this.affinity = props.affinity;
    this.availabilityZone = props.availabilityZone;
    this.blockDeviceMappings = props.blockDeviceMappings;
    this.cpuOptions = props.cpuOptions;
    this.creditSpecification = props.creditSpecification;
    this.disableApiTermination = props.disableApiTermination;
    this.ebsOptimized = props.ebsOptimized;
    this.elasticGpuSpecifications = props.elasticGpuSpecifications;
    this.elasticInferenceAccelerators = props.elasticInferenceAccelerators;
    this.enclaveOptions = props.enclaveOptions;
    this.hibernationOptions = props.hibernationOptions;
    this.hostId = props.hostId;
    this.hostResourceGroupArn = props.hostResourceGroupArn;
    this.iamInstanceProfile = props.iamInstanceProfile;
    this.imageId = props.imageId;
    this.instanceInitiatedShutdownBehavior = props.instanceInitiatedShutdownBehavior;
    this.instanceType = props.instanceType;
    this.ipv6AddressCount = props.ipv6AddressCount;
    this.ipv6Addresses = props.ipv6Addresses;
    this.kernelId = props.kernelId;
    this.keyName = props.keyName;
    this.launchTemplate = props.launchTemplate;
    this.licenseSpecifications = props.licenseSpecifications;
    this.monitoring = props.monitoring;
    this.networkInterfaces = props.networkInterfaces;
    this.placementGroupName = props.placementGroupName;
    this.privateDnsNameOptions = props.privateDnsNameOptions;
    this.privateIpAddress = props.privateIpAddress;
    this.propagateTagsToVolumeOnCreation = props.propagateTagsToVolumeOnCreation;
    this.ramdiskId = props.ramdiskId;
    this.securityGroupIds = props.securityGroupIds;
    this.securityGroups = props.securityGroups;
    this.sourceDestCheck = props.sourceDestCheck;
    this.ssmAssociations = props.ssmAssociations;
    this.subnetId = props.subnetId;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::Instance", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.tenancy = props.tenancy;
    this.userData = props.userData;
    this.volumes = props.volumes;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "additionalInfo": this.additionalInfo,
      "affinity": this.affinity,
      "availabilityZone": this.availabilityZone,
      "blockDeviceMappings": this.blockDeviceMappings,
      "cpuOptions": this.cpuOptions,
      "creditSpecification": this.creditSpecification,
      "disableApiTermination": this.disableApiTermination,
      "ebsOptimized": this.ebsOptimized,
      "elasticGpuSpecifications": this.elasticGpuSpecifications,
      "elasticInferenceAccelerators": this.elasticInferenceAccelerators,
      "enclaveOptions": this.enclaveOptions,
      "hibernationOptions": this.hibernationOptions,
      "hostId": this.hostId,
      "hostResourceGroupArn": this.hostResourceGroupArn,
      "iamInstanceProfile": this.iamInstanceProfile,
      "imageId": this.imageId,
      "instanceInitiatedShutdownBehavior": this.instanceInitiatedShutdownBehavior,
      "instanceType": this.instanceType,
      "ipv6AddressCount": this.ipv6AddressCount,
      "ipv6Addresses": this.ipv6Addresses,
      "kernelId": this.kernelId,
      "keyName": this.keyName,
      "launchTemplate": this.launchTemplate,
      "licenseSpecifications": this.licenseSpecifications,
      "monitoring": this.monitoring,
      "networkInterfaces": this.networkInterfaces,
      "placementGroupName": this.placementGroupName,
      "privateDnsNameOptions": this.privateDnsNameOptions,
      "privateIpAddress": this.privateIpAddress,
      "propagateTagsToVolumeOnCreation": this.propagateTagsToVolumeOnCreation,
      "ramdiskId": this.ramdiskId,
      "securityGroupIds": this.securityGroupIds,
      "securityGroups": this.securityGroups,
      "sourceDestCheck": this.sourceDestCheck,
      "ssmAssociations": this.ssmAssociations,
      "subnetId": this.subnetId,
      "tags": this.tags.renderTags(),
      "tenancy": this.tenancy,
      "userData": this.userData,
      "volumes": this.volumes
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnInstance.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnInstancePropsToCloudFormation(props);
  }
}

export namespace CfnInstance {
  /**
   * Specifies a block device mapping for an instance.
   *
   * You must specify exactly one of the following properties: \`VirtualName\` , \`Ebs\` , or \`NoDevice\` .
   *
   * \`BlockDeviceMapping\` is a property of the [AWS::EC2::Instance](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html) resource.
   *
   * > After the instance is running, you can modify only the \`DeleteOnTermination\` parameter for the attached volumes without interrupting the instance. Modifying any other parameter results in instance [replacement](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement) .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-blockdevicemapping.html
   */
  export interface BlockDeviceMappingProperty {
    /**
     * The device name (for example, \`/dev/sdh\` or \`xvdh\` ).
     *
     * > After the instance is running, this parameter is used to specify the device name of the block device mapping to update.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-blockdevicemapping.html#cfn-ec2-instance-blockdevicemapping-devicename
     */
    readonly deviceName: string;

    /**
     * Parameters used to automatically set up EBS volumes when the instance is launched.
     *
     * > After the instance is running, you can modify only the \`DeleteOnTermination\` parameter for the attached volumes without interrupting the instance. Modifying any other parameter results in instance [replacement](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-no-interrupt) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-blockdevicemapping.html#cfn-ec2-instance-blockdevicemapping-ebs
     */
    readonly ebs?: CfnInstance.EbsProperty | cdk.IResolvable;

    /**
     * To omit the device from the block device mapping, specify an empty string.
     *
     * > After the instance is running, modifying this parameter results in instance [replacement](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-blockdevicemapping.html#cfn-ec2-instance-blockdevicemapping-nodevice
     */
    readonly noDevice?: cdk.IResolvable | CfnInstance.NoDeviceProperty;

    /**
     * The virtual device name ( \`ephemeral\` N).
     *
     * The name must be in the form \`ephemeral\` *X* where *X* is a number starting from zero (0). For example, an instance type with 2 available instance store volumes can specify mappings for \`ephemeral0\` and \`ephemeral1\` . The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume.
     *
     * NVMe instance store volumes are automatically enumerated and assigned a device name. Including them in your block device mapping has no effect.
     *
     * *Constraints* : For M3 instances, you must specify instance store volumes in the block device mapping for the instance. When you launch an M3 instance, we ignore any instance store volumes specified in the block device mapping for the AMI.
     *
     * > After the instance is running, modifying this parameter results in instance [replacement](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-blockdevicemapping.html#cfn-ec2-instance-blockdevicemapping-virtualname
     */
    readonly virtualName?: string;
  }

  /**
   * Suppresses the specified device included in the block device mapping of the AMI.
   *
   * To suppress a device, specify an empty string.
   *
   * \`NoDevice\` is a property of the [Amazon EC2 BlockDeviceMapping](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-blockdev-mapping.html) property.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-nodevice.html
   */
  export interface NoDeviceProperty {

  }

  /**
   * Specifies a block device for an EBS volume.
   *
   * \`Ebs\` is a property of the [Amazon EC2 BlockDeviceMapping](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-blockdev-mapping.html) property.
   *
   * > After the instance is running, you can modify only the \`DeleteOnTermination\` parameters for the attached volumes without interrupting the instance. Modifying any other parameter results in instance [replacement](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement) .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ebs.html
   */
  export interface EbsProperty {
    /**
     * Indicates whether the EBS volume is deleted on instance termination.
     *
     * For more information, see [Preserving Amazon EBS volumes on instance termination](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/terminating-instances.html#preserving-volumes-on-termination) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ebs.html#cfn-ec2-instance-ebs-deleteontermination
     */
    readonly deleteOnTermination?: boolean | cdk.IResolvable;

    /**
     * Indicates whether the volume should be encrypted.
     *
     * The effect of setting the encryption state to \`true\` depends on the volume origin (new or from a snapshot), starting encryption state, ownership, and whether encryption by default is enabled. For more information, see [Encryption by default](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#encryption-by-default) in the *Amazon Elastic Compute Cloud User Guide* .
     *
     * Encrypted Amazon EBS volumes must be attached to instances that support Amazon EBS encryption. For more information, see [Supported instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#EBSEncryption_supported_instances) .
     *
     * > After the instance is running, modifying this parameter results in instance [replacement](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ebs.html#cfn-ec2-instance-ebs-encrypted
     */
    readonly encrypted?: boolean | cdk.IResolvable;

    /**
     * The number of I/O operations per second (IOPS).
     *
     * For \`gp3\` , \`io1\` , and \`io2\` volumes, this represents the number of IOPS that are provisioned for the volume. For \`gp2\` volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting.
     *
     * The following are the supported values for each volume type:
     *
     * - \`gp3\` : 3,000-16,000 IOPS
     * - \`io1\` : 100-64,000 IOPS
     * - \`io2\` : 100-64,000 IOPS
     *
     * For \`io1\` and \`io2\` volumes, we guarantee 64,000 IOPS only for [Instances built on the Nitro System](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances) . Other instance families guarantee performance up to 32,000 IOPS.
     *
     * This parameter is required for \`io1\` and \`io2\` volumes. The default for \`gp3\` volumes is 3,000 IOPS. This parameter is not supported for \`gp2\` , \`st1\` , \`sc1\` , or \`standard\` volumes.
     *
     * > After the instance is running, modifying this parameter results in instance [replacement](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ebs.html#cfn-ec2-instance-ebs-iops
     */
    readonly iops?: number;

    /**
     * The identifier of the AWS KMS key to use for Amazon EBS encryption.
     *
     * If \`KmsKeyId\` is specified, the encrypted state must be \`true\` . If the encrypted state is \`true\` but you do not specify \`KmsKeyId\` , your KMS key for EBS is used.
     *
     * You can specify the KMS key using any of the following:
     *
     * - Key ID. For example, 1234abcd-12ab-34cd-56ef-1234567890ab.
     * - Key alias. For example, alias/ExampleAlias.
     * - Key ARN. For example, arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab.
     * - Alias ARN. For example, arn:aws:kms:us-west-2:111122223333:alias/ExampleAlias.
     *
     * > After the instance is running, modifying this parameter results in instance [replacement](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ebs.html#cfn-ec2-instance-ebs-kmskeyid
     */
    readonly kmsKeyId?: string;

    /**
     * The ID of the snapshot.
     *
     * If you specify both \`SnapshotId\` and \`VolumeSize\` , \`VolumeSize\` must be equal or greater than the size of the snapshot.
     *
     * > After the instance is running, modifying this parameter results in instance [replacement](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ebs.html#cfn-ec2-instance-ebs-snapshotid
     */
    readonly snapshotId?: string;

    /**
     * The size of the volume, in GiBs.
     *
     * You must specify either a snapshot ID or a volume size. If you specify a snapshot, the default is the snapshot size. You can specify a volume size that is equal to or larger than the snapshot size.
     *
     * The following are the supported volumes sizes for each volume type:
     *
     * - \`gp2\` and \`gp3\` :1-16,384
     * - \`io1\` and \`io2\` : 4-16,384
     * - \`st1\` and \`sc1\` : 125-16,384
     * - \`standard\` : 1-1,024
     *
     * > After the instance is running, modifying this parameter results in instance [replacement](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ebs.html#cfn-ec2-instance-ebs-volumesize
     */
    readonly volumeSize?: number;

    /**
     * The volume type.
     *
     * For more information, see [Amazon EBS volume types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html) in the *Amazon EC2 User Guide* . If the volume type is \`io1\` or \`io2\` , you must specify the IOPS that the volume supports.
     *
     * > After the instance is running, modifying this parameter results in instance [replacement](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ebs.html#cfn-ec2-instance-ebs-volumetype
     */
    readonly volumeType?: string;
  }

  /**
   * Specifies the IPv6 address for the instance.
   *
   * \`InstanceIpv6Address\` is a property of the [AWS::EC2::Instance](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html) resource.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-instanceipv6address.html
   */
  export interface InstanceIpv6AddressProperty {
    /**
     * The IPv6 address.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-instanceipv6address.html#cfn-ec2-instance-instanceipv6address-ipv6address
     */
    readonly ipv6Address: string;
  }

  /**
   * Specifies the type of Elastic GPU.
   *
   * An Elastic GPU is a GPU resource that you can attach to your Amazon EC2 instance to accelerate the graphics performance of your applications. For more information, see [Amazon EC2 Elastic GPUs](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/elastic-graphics.html) in the *Amazon EC2 User Guide for Windows Instances* .
   *
   * \`ElasticGpuSpecification\` is a property of the [AWS::EC2::Instance](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html) resource.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticgpuspecification.html
   */
  export interface ElasticGpuSpecificationProperty {
    /**
     * The type of Elastic Graphics accelerator.
     *
     * For more information about the values to specify for \`Type\` , see [Elastic Graphics Basics](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/elastic-graphics.html#elastic-graphics-basics) , specifically the Elastic Graphics accelerator column, in the *Amazon Elastic Compute Cloud User Guide for Windows Instances* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticgpuspecification.html#cfn-ec2-instance-elasticgpuspecification-type
     */
    readonly type: string;
  }

  /**
   * Specifies the Elastic Inference Accelerator for the instance.
   *
   * \`ElasticInferenceAccelerator\` is a property of the [AWS::EC2::Instance](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html) resource.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticinferenceaccelerator.html
   */
  export interface ElasticInferenceAcceleratorProperty {
    /**
     * The number of elastic inference accelerators to attach to the instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticinferenceaccelerator.html#cfn-ec2-instance-elasticinferenceaccelerator-count
     */
    readonly count?: number;

    /**
     * The type of elastic inference accelerator.
     *
     * The possible values are \`eia1.medium\` , \`eia1.large\` , \`eia1.xlarge\` , \`eia2.medium\` , \`eia2.large\` , and \`eia2.xlarge\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticinferenceaccelerator.html#cfn-ec2-instance-elasticinferenceaccelerator-type
     */
    readonly type: string;
  }

  /**
   * Specifies a volume to attach to an instance.
   *
   * \`Volume\` is an embedded property of the [AWS::EC2::Instance](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html) resource.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-volume.html
   */
  export interface VolumeProperty {
    /**
     * The device name (for example, \`/dev/sdh\` or \`xvdh\` ).
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-volume.html#cfn-ec2-instance-volume-device
     */
    readonly device: string;

    /**
     * The ID of the EBS volume.
     *
     * The volume and instance must be within the same Availability Zone.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-volume.html#cfn-ec2-instance-volume-volumeid
     */
    readonly volumeId: string;
  }

  /**
   * Specifies a launch template to use when launching an Amazon EC2 instance.
   *
   * You must specify the following:
   *
   * - The ID or the name of the launch template, but not both.
   * - The version of the launch template.
   *
   * \`LaunchTemplateSpecification\` is a property of the [AWS::EC2::Instance](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html) resource.
   *
   * For information about creating a launch template, see [AWS::EC2::LaunchTemplate](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html) and [Create a launch template](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-templates.html#create-launch-template) in the *Amazon EC2 User Guide* .
   *
   * For examples of launch templates, see [Examples](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#aws-resource-ec2-launchtemplate--examples) .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-launchtemplatespecification.html
   */
  export interface LaunchTemplateSpecificationProperty {
    /**
     * The ID of the launch template.
     *
     * You must specify the \`LaunchTemplateId\` or the \`LaunchTemplateName\` , but not both.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-launchtemplatespecification.html#cfn-ec2-instance-launchtemplatespecification-launchtemplateid
     */
    readonly launchTemplateId?: string;

    /**
     * The name of the launch template.
     *
     * You must specify the \`LaunchTemplateName\` or the \`LaunchTemplateId\` , but not both.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-launchtemplatespecification.html#cfn-ec2-instance-launchtemplatespecification-launchtemplatename
     */
    readonly launchTemplateName?: string;

    /**
     * The version number of the launch template.
     *
     * Specifying \`$Latest\` or \`$Default\` for the template version number is not supported. However, you can specify \`LatestVersionNumber\` or \`DefaultVersionNumber\` using the \`Fn::GetAtt\` intrinsic function. For more information, see [Fn::GetAtt](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#aws-resource-ec2-launchtemplate-return-values-fn--getatt) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-launchtemplatespecification.html#cfn-ec2-instance-launchtemplatespecification-version
     */
    readonly version: string;
  }

  /**
   * Indicates whether the instance is enabled for AWS Nitro Enclaves.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-enclaveoptions.html
   */
  export interface EnclaveOptionsProperty {
    /**
     * If this parameter is set to \`true\` , the instance is enabled for AWS Nitro Enclaves;
     *
     * otherwise, it is not enabled for AWS Nitro Enclaves.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-enclaveoptions.html#cfn-ec2-instance-enclaveoptions-enabled
     */
    readonly enabled?: boolean | cdk.IResolvable;
  }

  /**
   * Specifies a network interface that is to be attached to an instance.
   *
   * You can create a network interface when launching an instance. For an example, see the [AWS::EC2::Instance examples](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#aws-properties-ec2-instance--examples--Automatically_assign_a_public_IP_address) .
   *
   * Alternatively, you can attach an existing network interface when launching an instance. For an example, see the [AWS::EC2:NetworkInterface examples](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#aws-resource-ec2-networkinterface--examples) .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html
   */
  export interface NetworkInterfaceProperty {
    /**
     * Indicates whether to assign a carrier IP address to the network interface.
     *
     * You can only assign a carrier IP address to a network interface that is in a subnet in a Wavelength Zone. For more information about carrier IP addresses, see [Carrier IP address](https://docs.aws.amazon.com/wavelength/latest/developerguide/how-wavelengths-work.html#provider-owned-ip) in the *AWS Wavelength Developer Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-associatecarrieripaddress
     */
    readonly associateCarrierIpAddress?: boolean | cdk.IResolvable;

    /**
     * Indicates whether to assign a public IPv4 address to an instance.
     *
     * Applies only if creating a network interface when launching an instance. The network interface must be the primary network interface. If launching into a default subnet, the default value is \`true\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-associatepublicipaddress
     */
    readonly associatePublicIpAddress?: boolean | cdk.IResolvable;

    /**
     * Indicates whether the network interface is deleted when the instance is terminated.
     *
     * Applies only if creating a network interface when launching an instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-deleteontermination
     */
    readonly deleteOnTermination?: boolean | cdk.IResolvable;

    /**
     * The description of the network interface.
     *
     * Applies only if creating a network interface when launching an instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-description
     */
    readonly description?: string;

    /**
     * The position of the network interface in the attachment order.
     *
     * A primary network interface has a device index of 0.
     *
     * If you create a network interface when launching an instance, you must specify the device index.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-deviceindex
     */
    readonly deviceIndex: string;

    /**
     * The IDs of the security groups for the network interface.
     *
     * Applies only if creating a network interface when launching an instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-groupset
     */
    readonly groupSet?: Array<string>;

    /**
     * A number of IPv6 addresses to assign to the network interface.
     *
     * Amazon EC2 chooses the IPv6 addresses from the range of the subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-ipv6addresscount
     */
    readonly ipv6AddressCount?: number;

    /**
     * The IPv6 addresses to assign to the network interface.
     *
     * You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-ipv6addresses
     */
    readonly ipv6Addresses?: Array<CfnInstance.InstanceIpv6AddressProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The ID of the network interface, when attaching an existing network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-networkinterfaceid
     */
    readonly networkInterfaceId?: string;

    /**
     * The private IPv4 address of the network interface.
     *
     * Applies only if creating a network interface when launching an instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-privateipaddress
     */
    readonly privateIpAddress?: string;

    /**
     * One or more private IPv4 addresses to assign to the network interface.
     *
     * Only one private IPv4 address can be designated as primary.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-privateipaddresses
     */
    readonly privateIpAddresses?: Array<cdk.IResolvable | CfnInstance.PrivateIpAddressSpecificationProperty> | cdk.IResolvable;

    /**
     * The number of secondary private IPv4 addresses.
     *
     * You can't specify this option and specify more than one private IP address using the private IP addresses option.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-secondaryprivateipaddresscount
     */
    readonly secondaryPrivateIpAddressCount?: number;

    /**
     * The ID of the subnet associated with the network interface.
     *
     * Applies only if creating a network interface when launching an instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-subnetid
     */
    readonly subnetId?: string;
  }

  /**
   * Specifies a secondary private IPv4 address for a network interface.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privateipaddressspecification.html
   */
  export interface PrivateIpAddressSpecificationProperty {
    /**
     * Indicates whether the private IPv4 address is the primary private IPv4 address.
     *
     * Only one IPv4 address can be designated as primary.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privateipaddressspecification.html#cfn-ec2-instance-privateipaddressspecification-primary
     */
    readonly primary: boolean | cdk.IResolvable;

    /**
     * The private IPv4 address.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privateipaddressspecification.html#cfn-ec2-instance-privateipaddressspecification-privateipaddress
     */
    readonly privateIpAddress: string;
  }

  /**
   * Specifies the hibernation options for the instance.
   *
   * \`HibernationOptions\` is a property of the [AWS::EC2::Instance](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html) resource.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-hibernationoptions.html
   */
  export interface HibernationOptionsProperty {
    /**
     * Set to \`true\` to enable your instance for hibernation.
     *
     * Default: \`false\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-hibernationoptions.html#cfn-ec2-instance-hibernationoptions-configured
     */
    readonly configured?: boolean | cdk.IResolvable;
  }

  /**
   * Specifies the license configuration to use.
   *
   * \`LicenseSpecification\` is a property of the [AWS::EC2::Instance](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html) resource.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-licensespecification.html
   */
  export interface LicenseSpecificationProperty {
    /**
     * The Amazon Resource Name (ARN) of the license configuration.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-licensespecification.html#cfn-ec2-instance-licensespecification-licenseconfigurationarn
     */
    readonly licenseConfigurationArn: string;
  }

  /**
   * Specifies the CPU options for the instance.
   *
   * When you specify CPU options, you must specify both the number of CPU cores and threads per core.
   *
   * For more information, see [Optimize CPU options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html) in the *Amazon Elastic Compute Cloud User Guide* .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-cpuoptions.html
   */
  export interface CpuOptionsProperty {
    /**
     * The number of CPU cores for the instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-cpuoptions.html#cfn-ec2-instance-cpuoptions-corecount
     */
    readonly coreCount?: number;

    /**
     * The number of threads per CPU core.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-cpuoptions.html#cfn-ec2-instance-cpuoptions-threadspercore
     */
    readonly threadsPerCore?: number;
  }

  /**
   * The type of hostnames to assign to instances in the subnet at launch.
   *
   * For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 only subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID. For more information, see [Amazon EC2 instance hostname types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html) in the *Amazon Elastic Compute Cloud User Guide* .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privatednsnameoptions.html
   */
  export interface PrivateDnsNameOptionsProperty {
    /**
     * Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records.
     *
     * For more information, see [Amazon EC2 instance hostname types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html) in the *Amazon Elastic Compute Cloud User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privatednsnameoptions.html#cfn-ec2-instance-privatednsnameoptions-enableresourcenamednsaaaarecord
     */
    readonly enableResourceNameDnsAaaaRecord?: boolean | cdk.IResolvable;

    /**
     * Indicates whether to respond to DNS queries for instance hostnames with DNS A records.
     *
     * For more information, see [Amazon EC2 instance hostname types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html) in the *Amazon Elastic Compute Cloud User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privatednsnameoptions.html#cfn-ec2-instance-privatednsnameoptions-enableresourcenamednsarecord
     */
    readonly enableResourceNameDnsARecord?: boolean | cdk.IResolvable;

    /**
     * The type of hostnames to assign to instances in the subnet at launch.
     *
     * For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 only subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID. For more information, see [Amazon EC2 instance hostname types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html) in the *Amazon Elastic Compute Cloud User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privatednsnameoptions.html#cfn-ec2-instance-privatednsnameoptions-hostnametype
     */
    readonly hostnameType?: string;
  }

  /**
   * Specifies the SSM document and parameter values in AWS Systems Manager to associate with an instance.
   *
   * \`SsmAssociations\` is a property of the [AWS::EC2::Instance](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html) resource.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociation.html
   */
  export interface SsmAssociationProperty {
    /**
     * The input parameter values to use with the associated SSM document.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociation.html#cfn-ec2-instance-ssmassociation-associationparameters
     */
    readonly associationParameters?: Array<CfnInstance.AssociationParameterProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The name of an SSM document to associate with the instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociation.html#cfn-ec2-instance-ssmassociation-documentname
     */
    readonly documentName: string;
  }

  /**
   * Specifies input parameter values for an SSM document in AWS Systems Manager .
   *
   * \`AssociationParameter\` is a property of the [Amazon EC2 Instance SsmAssociation](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociations.html) property.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-associationparameter.html
   */
  export interface AssociationParameterProperty {
    /**
     * The name of an input parameter that is in the associated SSM document.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-associationparameter.html#cfn-ec2-instance-associationparameter-key
     */
    readonly key: string;

    /**
     * The value of an input parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-associationparameter.html#cfn-ec2-instance-associationparameter-value
     */
    readonly value: Array<string>;
  }

  /**
   * Specifies the credit option for CPU usage of a T instance.
   *
   * \`CreditSpecification\` is a property of the [AWS::EC2::Instance](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html) resource.
   *
   * For more information, see [Burstable performance instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html) in the *Amazon EC2 User Guide* .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-creditspecification.html
   */
  export interface CreditSpecificationProperty {
    /**
     * The credit option for CPU usage of the instance.
     *
     * Valid values: \`standard\` | \`unlimited\`
     *
     * T3 instances with \`host\` tenancy do not support the \`unlimited\` CPU credit option.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-creditspecification.html#cfn-ec2-instance-creditspecification-cpucredits
     */
    readonly cpuCredits?: string;
  }
}

/**
 * Properties for defining a \`CfnInstance\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html
 */
export interface CfnInstanceProps {
  /**
   * This property is reserved for internal use.
   *
   * If you use it, the stack fails with this error: \`Bad property set: [Testing this property] (Service: AmazonEC2; Status Code: 400; Error Code: InvalidParameterCombination; Request ID: 0XXXXXX-49c7-4b40-8bcc-76885dcXXXXX)\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-additionalinfo
   */
  readonly additionalInfo?: string;

  /**
   * Indicates whether the instance is associated with a dedicated host.
   *
   * If you want the instance to always restart on the same host on which it was launched, specify \`host\` . If you want the instance to restart on any available host, but try to launch onto the last host it ran on (on a best-effort basis), specify \`default\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-affinity
   */
  readonly affinity?: string;

  /**
   * The Availability Zone of the instance.
   *
   * If not specified, an Availability Zone will be automatically chosen for you based on the load balancing criteria for the Region.
   *
   * This parameter is not supported by [DescribeImageAttribute](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeImageAttribute.html) .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-availabilityzone
   */
  readonly availabilityZone?: string;

  /**
   * The block device mapping entries that defines the block devices to attach to the instance at launch.
   *
   * By default, the block devices specified in the block device mapping for the AMI are used. You can override the AMI block device mapping using the instance block device mapping. For the root volume, you can override only the volume size, volume type, volume encryption settings, and the \`DeleteOnTermination\` setting.
   *
   * > After the instance is running, you can modify only the \`DeleteOnTermination\` parameter for the attached volumes without interrupting the instance. Modifying any other parameter results in instance [replacement](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement) .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-blockdevicemappings
   */
  readonly blockDeviceMappings?: Array<CfnInstance.BlockDeviceMappingProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * The CPU options for the instance.
   *
   * For more information, see [Optimize CPU options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html) in the *Amazon Elastic Compute Cloud User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-cpuoptions
   */
  readonly cpuOptions?: CfnInstance.CpuOptionsProperty | cdk.IResolvable;

  /**
   * The credit option for CPU usage of the burstable performance instance.
   *
   * Valid values are \`standard\` and \`unlimited\` . To change this attribute after launch, use [ModifyInstanceCreditSpecification](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceCreditSpecification.html) . For more information, see [Burstable performance instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html) in the *Amazon EC2 User Guide* .
   *
   * Default: \`standard\` (T2 instances) or \`unlimited\` (T3/T3a/T4g instances)
   *
   * For T3 instances with \`host\` tenancy, only \`standard\` is supported.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-creditspecification
   */
  readonly creditSpecification?: CfnInstance.CreditSpecificationProperty | cdk.IResolvable;

  /**
   * If you set this parameter to \`true\` , you can't terminate the instance using the Amazon EC2 console, CLI, or API;
   *
   * otherwise, you can. To change this attribute after launch, use [ModifyInstanceAttribute](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceAttribute.html) . Alternatively, if you set \`InstanceInitiatedShutdownBehavior\` to \`terminate\` , you can terminate the instance by running the shutdown command from the instance.
   *
   * Default: \`false\`
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-disableapitermination
   */
  readonly disableApiTermination?: boolean | cdk.IResolvable;

  /**
   * Indicates whether the instance is optimized for Amazon EBS I/O.
   *
   * This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal Amazon EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance.
   *
   * Default: \`false\`
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-ebsoptimized
   */
  readonly ebsOptimized?: boolean | cdk.IResolvable;

  /**
   * An elastic GPU to associate with the instance.
   *
   * An Elastic GPU is a GPU resource that you can attach to your Windows instance to accelerate the graphics performance of your applications. For more information, see [Amazon EC2 Elastic GPUs](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/elastic-graphics.html) in the *Amazon EC2 User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-elasticgpuspecifications
   */
  readonly elasticGpuSpecifications?: Array<CfnInstance.ElasticGpuSpecificationProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * An elastic inference accelerator to associate with the instance.
   *
   * Elastic inference accelerators are a resource you can attach to your Amazon EC2 instances to accelerate your Deep Learning (DL) inference workloads.
   *
   * You cannot specify accelerators from different generations in the same request.
   *
   * > Starting April 15, 2023, AWS will not onboard new customers to Amazon Elastic Inference (EI), and will help current customers migrate their workloads to options that offer better price and performance. After April 15, 2023, new customers will not be able to launch instances with Amazon EI accelerators in Amazon SageMaker, Amazon ECS, or Amazon EC2. However, customers who have used Amazon EI at least once during the past 30-day period are considered current customers and will be able to continue using the service.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-elasticinferenceaccelerators
   */
  readonly elasticInferenceAccelerators?: Array<CfnInstance.ElasticInferenceAcceleratorProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * Indicates whether the instance is enabled for AWS Nitro Enclaves.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-enclaveoptions
   */
  readonly enclaveOptions?: CfnInstance.EnclaveOptionsProperty | cdk.IResolvable;

  /**
   * Indicates whether an instance is enabled for hibernation.
   *
   * This parameter is valid only if the instance meets the [hibernation prerequisites](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/hibernating-prerequisites.html) . For more information, see [Hibernate your instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html) in the *Amazon EC2 User Guide* .
   *
   * You can't enable hibernation and AWS Nitro Enclaves on the same instance.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-hibernationoptions
   */
  readonly hibernationOptions?: CfnInstance.HibernationOptionsProperty | cdk.IResolvable;

  /**
   * If you specify host for the \`Affinity\` property, the ID of a dedicated host that the instance is associated with.
   *
   * If you don't specify an ID, Amazon EC2 launches the instance onto any available, compatible dedicated host in your account. This type of launch is called an untargeted launch. Note that for untargeted launches, you must have a compatible, dedicated host available to successfully launch instances.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-hostid
   */
  readonly hostId?: string;

  /**
   * The ARN of the host resource group in which to launch the instances.
   *
   * If you specify a host resource group ARN, omit the *Tenancy* parameter or set it to \`host\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-hostresourcegrouparn
   */
  readonly hostResourceGroupArn?: string;

  /**
   * The name of an IAM instance profile.
   *
   * To create a new IAM instance profile, use the [AWS::IAM::InstanceProfile](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-instanceprofile.html) resource.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-iaminstanceprofile
   */
  readonly iamInstanceProfile?: string;

  /**
   * The ID of the AMI.
   *
   * An AMI ID is required to launch an instance and must be specified here or in a launch template.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-imageid
   */
  readonly imageId?: string;

  /**
   * Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).
   *
   * Default: \`stop\`
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-instanceinitiatedshutdownbehavior
   */
  readonly instanceInitiatedShutdownBehavior?: string;

  /**
   * The instance type. For more information, see [Instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the *Amazon EC2 User Guide* .
   *
   * When you change your EBS-backed instance type, instance restart or replacement behavior depends on the instance type compatibility between the old and new types. An instance that's backed by an instance store volume is always replaced. For more information, see [Change the instance type](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-resize.html) in the *Amazon EC2 User Guide* .
   *
   * Default: \`m1.small\`
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-instancetype
   */
  readonly instanceType?: string;

  /**
   * The number of IPv6 addresses to associate with the primary network interface.
   *
   * Amazon EC2 chooses the IPv6 addresses from the range of your subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch.
   *
   * You cannot specify this option and the network interfaces option in the same request.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-ipv6addresscount
   */
  readonly ipv6AddressCount?: number;

  /**
   * The IPv6 addresses from the range of the subnet to associate with the primary network interface.
   *
   * You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch.
   *
   * You cannot specify this option and the network interfaces option in the same request.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-ipv6addresses
   */
  readonly ipv6Addresses?: Array<CfnInstance.InstanceIpv6AddressProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * The ID of the kernel.
   *
   * > We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see [PV-GRUB](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html) in the *Amazon EC2 User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-kernelid
   */
  readonly kernelId?: string;

  /**
   * The name of the key pair. You can create a key pair using [CreateKeyPair](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateKeyPair.html) or [ImportKeyPair](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportKeyPair.html) .
   *
   * > If you do not specify a key pair, you can't connect to the instance unless you choose an AMI that is configured to allow users another way to log in.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-keyname
   */
  readonly keyName?: string;

  /**
   * The launch template to use to launch the instances.
   *
   * Any parameters that you specify in the AWS CloudFormation template override the same parameters in the launch template. You can specify either the name or ID of a launch template, but not both.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-launchtemplate
   */
  readonly launchTemplate?: cdk.IResolvable | CfnInstance.LaunchTemplateSpecificationProperty;

  /**
   * The license configurations.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-licensespecifications
   */
  readonly licenseSpecifications?: Array<cdk.IResolvable | CfnInstance.LicenseSpecificationProperty> | cdk.IResolvable;

  /**
   * Specifies whether detailed monitoring is enabled for the instance.
   *
   * Specify \`true\` to enable detailed monitoring. Otherwise, basic monitoring is enabled. For more information about detailed monitoring, see [Enable or turn off detailed monitoring for your instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-cloudwatch-new.html) in the *Amazon EC2 User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-monitoring
   */
  readonly monitoring?: boolean | cdk.IResolvable;

  /**
   * The network interfaces to associate with the instance.
   *
   * > If you use this property to point to a network interface, you must terminate the original interface before attaching a new one to allow the update of the instance to succeed.
   * >
   * > If this resource has a public IP address and is also in a VPC that is defined in the same template, you must use the [DependsOn Attribute](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-dependson.html) to declare a dependency on the VPC-gateway attachment.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-networkinterfaces
   */
  readonly networkInterfaces?: Array<cdk.IResolvable | CfnInstance.NetworkInterfaceProperty> | cdk.IResolvable;

  /**
   * The name of an existing placement group that you want to launch the instance into (cluster | partition | spread).
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-placementgroupname
   */
  readonly placementGroupName?: string;

  /**
   * The options for the instance hostname.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-privatednsnameoptions
   */
  readonly privateDnsNameOptions?: cdk.IResolvable | CfnInstance.PrivateDnsNameOptionsProperty;

  /**
   * The primary IPv4 address. You must specify a value from the IPv4 address range of the subnet.
   *
   * Only one private IP address can be designated as primary. You can't specify this option if you've specified the option to designate a private IP address as the primary IP address in a network interface specification. You cannot specify this option if you're launching more than one instance in the request.
   *
   * You cannot specify this option and the network interfaces option in the same request.
   *
   * If you make an update to an instance that requires replacement, you must assign a new private IP address. During a replacement, AWS CloudFormation creates a new instance but doesn't delete the old instance until the stack has successfully updated. If the stack update fails, AWS CloudFormation uses the old instance to roll back the stack to the previous working state. The old and new instances cannot have the same private IP address.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-privateipaddress
   */
  readonly privateIpAddress?: string;

  /**
   * Indicates whether to assign the tags from the instance to all of the volumes attached to the instance at launch.
   *
   * If you specify \`true\` and you assign tags to the instance, those tags are automatically assigned to all of the volumes that you attach to the instance at launch. If you specify \`false\` , those tags are not assigned to the attached volumes.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-propagatetagstovolumeoncreation
   */
  readonly propagateTagsToVolumeOnCreation?: boolean | cdk.IResolvable;

  /**
   * The ID of the RAM disk to select.
   *
   * Some kernels require additional drivers at launch. Check the kernel requirements for information about whether you need to specify a RAM disk. To find kernel requirements, go to the AWS Resource Center and search for the kernel ID.
   *
   * > We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see [PV-GRUB](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html) in the *Amazon EC2 User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-ramdiskid
   */
  readonly ramdiskId?: string;

  /**
   * The IDs of the security groups.
   *
   * You can specify the IDs of existing security groups and references to resources created by the stack template.
   *
   * If you specify a network interface, you must specify any security groups as part of the network interface.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-securitygroupids
   */
  readonly securityGroupIds?: Array<string>;

  /**
   * [Default VPC] The names of the security groups. For a nondefault VPC, you must use security group IDs instead.
   *
   * You cannot specify this option and the network interfaces option in the same request. The list can contain both the name of existing Amazon EC2 security groups or references to AWS::EC2::SecurityGroup resources created in the template.
   *
   * Default: Amazon EC2 uses the default security group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-securitygroups
   */
  readonly securityGroups?: Array<string>;

  /**
   * Enable or disable source/destination checks, which ensure that the instance is either the source or the destination of any traffic that it receives.
   *
   * If the value is \`true\` , source/destination checks are enabled; otherwise, they are disabled. The default value is \`true\` . You must disable source/destination checks if the instance runs services such as network address translation, routing, or firewalls.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-sourcedestcheck
   */
  readonly sourceDestCheck?: boolean | cdk.IResolvable;

  /**
   * The SSM [document](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssm-document.html) and parameter values in AWS Systems Manager to associate with this instance. To use this property, you must specify an IAM instance profile role for the instance. For more information, see [Create an IAM instance profile for Systems Manager](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-configuring-access-role.html) in the *AWS Systems Manager User Guide* .
   *
   * > You can currently associate only one document with an instance.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-ssmassociations
   */
  readonly ssmAssociations?: Array<cdk.IResolvable | CfnInstance.SsmAssociationProperty> | cdk.IResolvable;

  /**
   * The ID of the subnet to launch the instance into.
   *
   * If you specify a network interface, you must specify any subnets as part of the network interface.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-subnetid
   */
  readonly subnetId?: string;

  /**
   * The tags to add to the instance.
   *
   * These tags are not applied to the EBS volumes, such as the root volume, unless [PropagateTagsToVolumeOnCreation](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-propagatetagstovolumeoncreation) is \`true\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The tenancy of the instance.
   *
   * An instance with a tenancy of \`dedicated\` runs on single-tenant hardware.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-tenancy
   */
  readonly tenancy?: string;

  /**
   * The user data script to make available to the instance.
   *
   * User data is limited to 16 KB. You must provide base64-encoded text. For more information, see [Fn::Base64](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference-base64.html) .
   *
   * User data runs only at instance launch. For more information, see [Run commands on your Linux instance at launch](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html) and [Run commands on your Windows instance at launch](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/ec2-windows-user-data.html) .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-userdata
   */
  readonly userData?: string;

  /**
   * The volumes to attach to the instance.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-volumes
   */
  readonly volumes?: Array<cdk.IResolvable | CfnInstance.VolumeProperty> | cdk.IResolvable;
}

/**
 * Determine whether the given properties match those of a \`NoDeviceProperty\`
 *
 * @param properties - the TypeScript properties of a \`NoDeviceProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnInstanceNoDevicePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  return errors.wrap("supplied properties not correct for \\"NoDeviceProperty\\"");
}

// @ts-ignore TS6133
function convertCfnInstanceNoDevicePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnInstanceNoDevicePropertyValidator(properties).assertSuccess();
  return {};
}

// @ts-ignore TS6133
function CfnInstanceNoDevicePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnInstance.NoDeviceProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnInstance.NoDeviceProperty>();
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`EbsProperty\`
 *
 * @param properties - the TypeScript properties of a \`EbsProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnInstanceEbsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("deleteOnTermination", cdk.validateBoolean)(properties.deleteOnTermination));
  errors.collect(cdk.propertyValidator("encrypted", cdk.validateBoolean)(properties.encrypted));
  errors.collect(cdk.propertyValidator("iops", cdk.validateNumber)(properties.iops));
  errors.collect(cdk.propertyValidator("kmsKeyId", cdk.validateString)(properties.kmsKeyId));
  errors.collect(cdk.propertyValidator("snapshotId", cdk.validateString)(properties.snapshotId));
  errors.collect(cdk.propertyValidator("volumeSize", cdk.validateNumber)(properties.volumeSize));
  errors.collect(cdk.propertyValidator("volumeType", cdk.validateString)(properties.volumeType));
  return errors.wrap("supplied properties not correct for \\"EbsProperty\\"");
}

// @ts-ignore TS6133
function convertCfnInstanceEbsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnInstanceEbsPropertyValidator(properties).assertSuccess();
  return {
    "DeleteOnTermination": cdk.booleanToCloudFormation(properties.deleteOnTermination),
    "Encrypted": cdk.booleanToCloudFormation(properties.encrypted),
    "Iops": cdk.numberToCloudFormation(properties.iops),
    "KmsKeyId": cdk.stringToCloudFormation(properties.kmsKeyId),
    "SnapshotId": cdk.stringToCloudFormation(properties.snapshotId),
    "VolumeSize": cdk.numberToCloudFormation(properties.volumeSize),
    "VolumeType": cdk.stringToCloudFormation(properties.volumeType)
  };
}

// @ts-ignore TS6133
function CfnInstanceEbsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnInstance.EbsProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnInstance.EbsProperty>();
  ret.addPropertyResult("deleteOnTermination", "DeleteOnTermination", (properties.DeleteOnTermination != null ? cfn_parse.FromCloudFormation.getBoolean(properties.DeleteOnTermination) : undefined));
  ret.addPropertyResult("encrypted", "Encrypted", (properties.Encrypted != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Encrypted) : undefined));
  ret.addPropertyResult("iops", "Iops", (properties.Iops != null ? cfn_parse.FromCloudFormation.getNumber(properties.Iops) : undefined));
  ret.addPropertyResult("kmsKeyId", "KmsKeyId", (properties.KmsKeyId != null ? cfn_parse.FromCloudFormation.getString(properties.KmsKeyId) : undefined));
  ret.addPropertyResult("snapshotId", "SnapshotId", (properties.SnapshotId != null ? cfn_parse.FromCloudFormation.getString(properties.SnapshotId) : undefined));
  ret.addPropertyResult("volumeSize", "VolumeSize", (properties.VolumeSize != null ? cfn_parse.FromCloudFormation.getNumber(properties.VolumeSize) : undefined));
  ret.addPropertyResult("volumeType", "VolumeType", (properties.VolumeType != null ? cfn_parse.FromCloudFormation.getString(properties.VolumeType) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`BlockDeviceMappingProperty\`
 *
 * @param properties - the TypeScript properties of a \`BlockDeviceMappingProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnInstanceBlockDeviceMappingPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("deviceName", cdk.requiredValidator)(properties.deviceName));
  errors.collect(cdk.propertyValidator("deviceName", cdk.validateString)(properties.deviceName));
  errors.collect(cdk.propertyValidator("ebs", CfnInstanceEbsPropertyValidator)(properties.ebs));
  errors.collect(cdk.propertyValidator("noDevice", CfnInstanceNoDevicePropertyValidator)(properties.noDevice));
  errors.collect(cdk.propertyValidator("virtualName", cdk.validateString)(properties.virtualName));
  return errors.wrap("supplied properties not correct for \\"BlockDeviceMappingProperty\\"");
}

// @ts-ignore TS6133
function convertCfnInstanceBlockDeviceMappingPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnInstanceBlockDeviceMappingPropertyValidator(properties).assertSuccess();
  return {
    "DeviceName": cdk.stringToCloudFormation(properties.deviceName),
    "Ebs": convertCfnInstanceEbsPropertyToCloudFormation(properties.ebs),
    "NoDevice": convertCfnInstanceNoDevicePropertyToCloudFormation(properties.noDevice),
    "VirtualName": cdk.stringToCloudFormation(properties.virtualName)
  };
}

// @ts-ignore TS6133
function CfnInstanceBlockDeviceMappingPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnInstance.BlockDeviceMappingProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnInstance.BlockDeviceMappingProperty>();
  ret.addPropertyResult("deviceName", "DeviceName", (properties.DeviceName != null ? cfn_parse.FromCloudFormation.getString(properties.DeviceName) : undefined));
  ret.addPropertyResult("ebs", "Ebs", (properties.Ebs != null ? CfnInstanceEbsPropertyFromCloudFormation(properties.Ebs) : undefined));
  ret.addPropertyResult("noDevice", "NoDevice", (properties.NoDevice != null ? CfnInstanceNoDevicePropertyFromCloudFormation(properties.NoDevice) : undefined));
  ret.addPropertyResult("virtualName", "VirtualName", (properties.VirtualName != null ? cfn_parse.FromCloudFormation.getString(properties.VirtualName) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`InstanceIpv6AddressProperty\`
 *
 * @param properties - the TypeScript properties of a \`InstanceIpv6AddressProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnInstanceInstanceIpv6AddressPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("ipv6Address", cdk.requiredValidator)(properties.ipv6Address));
  errors.collect(cdk.propertyValidator("ipv6Address", cdk.validateString)(properties.ipv6Address));
  return errors.wrap("supplied properties not correct for \\"InstanceIpv6AddressProperty\\"");
}

// @ts-ignore TS6133
function convertCfnInstanceInstanceIpv6AddressPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnInstanceInstanceIpv6AddressPropertyValidator(properties).assertSuccess();
  return {
    "Ipv6Address": cdk.stringToCloudFormation(properties.ipv6Address)
  };
}

// @ts-ignore TS6133
function CfnInstanceInstanceIpv6AddressPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnInstance.InstanceIpv6AddressProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnInstance.InstanceIpv6AddressProperty>();
  ret.addPropertyResult("ipv6Address", "Ipv6Address", (properties.Ipv6Address != null ? cfn_parse.FromCloudFormation.getString(properties.Ipv6Address) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ElasticGpuSpecificationProperty\`
 *
 * @param properties - the TypeScript properties of a \`ElasticGpuSpecificationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnInstanceElasticGpuSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("type", cdk.requiredValidator)(properties.type));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  return errors.wrap("supplied properties not correct for \\"ElasticGpuSpecificationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnInstanceElasticGpuSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnInstanceElasticGpuSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "Type": cdk.stringToCloudFormation(properties.type)
  };
}

// @ts-ignore TS6133
function CfnInstanceElasticGpuSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnInstance.ElasticGpuSpecificationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnInstance.ElasticGpuSpecificationProperty>();
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ElasticInferenceAcceleratorProperty\`
 *
 * @param properties - the TypeScript properties of a \`ElasticInferenceAcceleratorProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnInstanceElasticInferenceAcceleratorPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("count", cdk.validateNumber)(properties.count));
  errors.collect(cdk.propertyValidator("type", cdk.requiredValidator)(properties.type));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  return errors.wrap("supplied properties not correct for \\"ElasticInferenceAcceleratorProperty\\"");
}

// @ts-ignore TS6133
function convertCfnInstanceElasticInferenceAcceleratorPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnInstanceElasticInferenceAcceleratorPropertyValidator(properties).assertSuccess();
  return {
    "Count": cdk.numberToCloudFormation(properties.count),
    "Type": cdk.stringToCloudFormation(properties.type)
  };
}

// @ts-ignore TS6133
function CfnInstanceElasticInferenceAcceleratorPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnInstance.ElasticInferenceAcceleratorProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnInstance.ElasticInferenceAcceleratorProperty>();
  ret.addPropertyResult("count", "Count", (properties.Count != null ? cfn_parse.FromCloudFormation.getNumber(properties.Count) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`VolumeProperty\`
 *
 * @param properties - the TypeScript properties of a \`VolumeProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnInstanceVolumePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("device", cdk.requiredValidator)(properties.device));
  errors.collect(cdk.propertyValidator("device", cdk.validateString)(properties.device));
  errors.collect(cdk.propertyValidator("volumeId", cdk.requiredValidator)(properties.volumeId));
  errors.collect(cdk.propertyValidator("volumeId", cdk.validateString)(properties.volumeId));
  return errors.wrap("supplied properties not correct for \\"VolumeProperty\\"");
}

// @ts-ignore TS6133
function convertCfnInstanceVolumePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnInstanceVolumePropertyValidator(properties).assertSuccess();
  return {
    "Device": cdk.stringToCloudFormation(properties.device),
    "VolumeId": cdk.stringToCloudFormation(properties.volumeId)
  };
}

// @ts-ignore TS6133
function CfnInstanceVolumePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnInstance.VolumeProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnInstance.VolumeProperty>();
  ret.addPropertyResult("device", "Device", (properties.Device != null ? cfn_parse.FromCloudFormation.getString(properties.Device) : undefined));
  ret.addPropertyResult("volumeId", "VolumeId", (properties.VolumeId != null ? cfn_parse.FromCloudFormation.getString(properties.VolumeId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`LaunchTemplateSpecificationProperty\`
 *
 * @param properties - the TypeScript properties of a \`LaunchTemplateSpecificationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnInstanceLaunchTemplateSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("launchTemplateId", cdk.validateString)(properties.launchTemplateId));
  errors.collect(cdk.propertyValidator("launchTemplateName", cdk.validateString)(properties.launchTemplateName));
  errors.collect(cdk.propertyValidator("version", cdk.requiredValidator)(properties.version));
  errors.collect(cdk.propertyValidator("version", cdk.validateString)(properties.version));
  return errors.wrap("supplied properties not correct for \\"LaunchTemplateSpecificationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnInstanceLaunchTemplateSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnInstanceLaunchTemplateSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "LaunchTemplateId": cdk.stringToCloudFormation(properties.launchTemplateId),
    "LaunchTemplateName": cdk.stringToCloudFormation(properties.launchTemplateName),
    "Version": cdk.stringToCloudFormation(properties.version)
  };
}

// @ts-ignore TS6133
function CfnInstanceLaunchTemplateSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnInstance.LaunchTemplateSpecificationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnInstance.LaunchTemplateSpecificationProperty>();
  ret.addPropertyResult("launchTemplateId", "LaunchTemplateId", (properties.LaunchTemplateId != null ? cfn_parse.FromCloudFormation.getString(properties.LaunchTemplateId) : undefined));
  ret.addPropertyResult("launchTemplateName", "LaunchTemplateName", (properties.LaunchTemplateName != null ? cfn_parse.FromCloudFormation.getString(properties.LaunchTemplateName) : undefined));
  ret.addPropertyResult("version", "Version", (properties.Version != null ? cfn_parse.FromCloudFormation.getString(properties.Version) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`EnclaveOptionsProperty\`
 *
 * @param properties - the TypeScript properties of a \`EnclaveOptionsProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnInstanceEnclaveOptionsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("enabled", cdk.validateBoolean)(properties.enabled));
  return errors.wrap("supplied properties not correct for \\"EnclaveOptionsProperty\\"");
}

// @ts-ignore TS6133
function convertCfnInstanceEnclaveOptionsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnInstanceEnclaveOptionsPropertyValidator(properties).assertSuccess();
  return {
    "Enabled": cdk.booleanToCloudFormation(properties.enabled)
  };
}

// @ts-ignore TS6133
function CfnInstanceEnclaveOptionsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnInstance.EnclaveOptionsProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnInstance.EnclaveOptionsProperty>();
  ret.addPropertyResult("enabled", "Enabled", (properties.Enabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Enabled) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`PrivateIpAddressSpecificationProperty\`
 *
 * @param properties - the TypeScript properties of a \`PrivateIpAddressSpecificationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnInstancePrivateIpAddressSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("primary", cdk.requiredValidator)(properties.primary));
  errors.collect(cdk.propertyValidator("primary", cdk.validateBoolean)(properties.primary));
  errors.collect(cdk.propertyValidator("privateIpAddress", cdk.requiredValidator)(properties.privateIpAddress));
  errors.collect(cdk.propertyValidator("privateIpAddress", cdk.validateString)(properties.privateIpAddress));
  return errors.wrap("supplied properties not correct for \\"PrivateIpAddressSpecificationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnInstancePrivateIpAddressSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnInstancePrivateIpAddressSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "Primary": cdk.booleanToCloudFormation(properties.primary),
    "PrivateIpAddress": cdk.stringToCloudFormation(properties.privateIpAddress)
  };
}

// @ts-ignore TS6133
function CfnInstancePrivateIpAddressSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnInstance.PrivateIpAddressSpecificationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnInstance.PrivateIpAddressSpecificationProperty>();
  ret.addPropertyResult("primary", "Primary", (properties.Primary != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Primary) : undefined));
  ret.addPropertyResult("privateIpAddress", "PrivateIpAddress", (properties.PrivateIpAddress != null ? cfn_parse.FromCloudFormation.getString(properties.PrivateIpAddress) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`NetworkInterfaceProperty\`
 *
 * @param properties - the TypeScript properties of a \`NetworkInterfaceProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnInstanceNetworkInterfacePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("associateCarrierIpAddress", cdk.validateBoolean)(properties.associateCarrierIpAddress));
  errors.collect(cdk.propertyValidator("associatePublicIpAddress", cdk.validateBoolean)(properties.associatePublicIpAddress));
  errors.collect(cdk.propertyValidator("deleteOnTermination", cdk.validateBoolean)(properties.deleteOnTermination));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("deviceIndex", cdk.requiredValidator)(properties.deviceIndex));
  errors.collect(cdk.propertyValidator("deviceIndex", cdk.validateString)(properties.deviceIndex));
  errors.collect(cdk.propertyValidator("groupSet", cdk.listValidator(cdk.validateString))(properties.groupSet));
  errors.collect(cdk.propertyValidator("ipv6AddressCount", cdk.validateNumber)(properties.ipv6AddressCount));
  errors.collect(cdk.propertyValidator("ipv6Addresses", cdk.listValidator(CfnInstanceInstanceIpv6AddressPropertyValidator))(properties.ipv6Addresses));
  errors.collect(cdk.propertyValidator("networkInterfaceId", cdk.validateString)(properties.networkInterfaceId));
  errors.collect(cdk.propertyValidator("privateIpAddress", cdk.validateString)(properties.privateIpAddress));
  errors.collect(cdk.propertyValidator("privateIpAddresses", cdk.listValidator(CfnInstancePrivateIpAddressSpecificationPropertyValidator))(properties.privateIpAddresses));
  errors.collect(cdk.propertyValidator("secondaryPrivateIpAddressCount", cdk.validateNumber)(properties.secondaryPrivateIpAddressCount));
  errors.collect(cdk.propertyValidator("subnetId", cdk.validateString)(properties.subnetId));
  return errors.wrap("supplied properties not correct for \\"NetworkInterfaceProperty\\"");
}

// @ts-ignore TS6133
function convertCfnInstanceNetworkInterfacePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnInstanceNetworkInterfacePropertyValidator(properties).assertSuccess();
  return {
    "AssociateCarrierIpAddress": cdk.booleanToCloudFormation(properties.associateCarrierIpAddress),
    "AssociatePublicIpAddress": cdk.booleanToCloudFormation(properties.associatePublicIpAddress),
    "DeleteOnTermination": cdk.booleanToCloudFormation(properties.deleteOnTermination),
    "Description": cdk.stringToCloudFormation(properties.description),
    "DeviceIndex": cdk.stringToCloudFormation(properties.deviceIndex),
    "GroupSet": cdk.listMapper(cdk.stringToCloudFormation)(properties.groupSet),
    "Ipv6AddressCount": cdk.numberToCloudFormation(properties.ipv6AddressCount),
    "Ipv6Addresses": cdk.listMapper(convertCfnInstanceInstanceIpv6AddressPropertyToCloudFormation)(properties.ipv6Addresses),
    "NetworkInterfaceId": cdk.stringToCloudFormation(properties.networkInterfaceId),
    "PrivateIpAddress": cdk.stringToCloudFormation(properties.privateIpAddress),
    "PrivateIpAddresses": cdk.listMapper(convertCfnInstancePrivateIpAddressSpecificationPropertyToCloudFormation)(properties.privateIpAddresses),
    "SecondaryPrivateIpAddressCount": cdk.numberToCloudFormation(properties.secondaryPrivateIpAddressCount),
    "SubnetId": cdk.stringToCloudFormation(properties.subnetId)
  };
}

// @ts-ignore TS6133
function CfnInstanceNetworkInterfacePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnInstance.NetworkInterfaceProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnInstance.NetworkInterfaceProperty>();
  ret.addPropertyResult("associateCarrierIpAddress", "AssociateCarrierIpAddress", (properties.AssociateCarrierIpAddress != null ? cfn_parse.FromCloudFormation.getBoolean(properties.AssociateCarrierIpAddress) : undefined));
  ret.addPropertyResult("associatePublicIpAddress", "AssociatePublicIpAddress", (properties.AssociatePublicIpAddress != null ? cfn_parse.FromCloudFormation.getBoolean(properties.AssociatePublicIpAddress) : undefined));
  ret.addPropertyResult("deleteOnTermination", "DeleteOnTermination", (properties.DeleteOnTermination != null ? cfn_parse.FromCloudFormation.getBoolean(properties.DeleteOnTermination) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("deviceIndex", "DeviceIndex", (properties.DeviceIndex != null ? cfn_parse.FromCloudFormation.getString(properties.DeviceIndex) : undefined));
  ret.addPropertyResult("groupSet", "GroupSet", (properties.GroupSet != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.GroupSet) : undefined));
  ret.addPropertyResult("ipv6AddressCount", "Ipv6AddressCount", (properties.Ipv6AddressCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.Ipv6AddressCount) : undefined));
  ret.addPropertyResult("ipv6Addresses", "Ipv6Addresses", (properties.Ipv6Addresses != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceInstanceIpv6AddressPropertyFromCloudFormation)(properties.Ipv6Addresses) : undefined));
  ret.addPropertyResult("networkInterfaceId", "NetworkInterfaceId", (properties.NetworkInterfaceId != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkInterfaceId) : undefined));
  ret.addPropertyResult("privateIpAddress", "PrivateIpAddress", (properties.PrivateIpAddress != null ? cfn_parse.FromCloudFormation.getString(properties.PrivateIpAddress) : undefined));
  ret.addPropertyResult("privateIpAddresses", "PrivateIpAddresses", (properties.PrivateIpAddresses != null ? cfn_parse.FromCloudFormation.getArray(CfnInstancePrivateIpAddressSpecificationPropertyFromCloudFormation)(properties.PrivateIpAddresses) : undefined));
  ret.addPropertyResult("secondaryPrivateIpAddressCount", "SecondaryPrivateIpAddressCount", (properties.SecondaryPrivateIpAddressCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.SecondaryPrivateIpAddressCount) : undefined));
  ret.addPropertyResult("subnetId", "SubnetId", (properties.SubnetId != null ? cfn_parse.FromCloudFormation.getString(properties.SubnetId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`HibernationOptionsProperty\`
 *
 * @param properties - the TypeScript properties of a \`HibernationOptionsProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnInstanceHibernationOptionsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("configured", cdk.validateBoolean)(properties.configured));
  return errors.wrap("supplied properties not correct for \\"HibernationOptionsProperty\\"");
}

// @ts-ignore TS6133
function convertCfnInstanceHibernationOptionsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnInstanceHibernationOptionsPropertyValidator(properties).assertSuccess();
  return {
    "Configured": cdk.booleanToCloudFormation(properties.configured)
  };
}

// @ts-ignore TS6133
function CfnInstanceHibernationOptionsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnInstance.HibernationOptionsProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnInstance.HibernationOptionsProperty>();
  ret.addPropertyResult("configured", "Configured", (properties.Configured != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Configured) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`LicenseSpecificationProperty\`
 *
 * @param properties - the TypeScript properties of a \`LicenseSpecificationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnInstanceLicenseSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("licenseConfigurationArn", cdk.requiredValidator)(properties.licenseConfigurationArn));
  errors.collect(cdk.propertyValidator("licenseConfigurationArn", cdk.validateString)(properties.licenseConfigurationArn));
  return errors.wrap("supplied properties not correct for \\"LicenseSpecificationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnInstanceLicenseSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnInstanceLicenseSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "LicenseConfigurationArn": cdk.stringToCloudFormation(properties.licenseConfigurationArn)
  };
}

// @ts-ignore TS6133
function CfnInstanceLicenseSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnInstance.LicenseSpecificationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnInstance.LicenseSpecificationProperty>();
  ret.addPropertyResult("licenseConfigurationArn", "LicenseConfigurationArn", (properties.LicenseConfigurationArn != null ? cfn_parse.FromCloudFormation.getString(properties.LicenseConfigurationArn) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CpuOptionsProperty\`
 *
 * @param properties - the TypeScript properties of a \`CpuOptionsProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnInstanceCpuOptionsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("coreCount", cdk.validateNumber)(properties.coreCount));
  errors.collect(cdk.propertyValidator("threadsPerCore", cdk.validateNumber)(properties.threadsPerCore));
  return errors.wrap("supplied properties not correct for \\"CpuOptionsProperty\\"");
}

// @ts-ignore TS6133
function convertCfnInstanceCpuOptionsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnInstanceCpuOptionsPropertyValidator(properties).assertSuccess();
  return {
    "CoreCount": cdk.numberToCloudFormation(properties.coreCount),
    "ThreadsPerCore": cdk.numberToCloudFormation(properties.threadsPerCore)
  };
}

// @ts-ignore TS6133
function CfnInstanceCpuOptionsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnInstance.CpuOptionsProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnInstance.CpuOptionsProperty>();
  ret.addPropertyResult("coreCount", "CoreCount", (properties.CoreCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.CoreCount) : undefined));
  ret.addPropertyResult("threadsPerCore", "ThreadsPerCore", (properties.ThreadsPerCore != null ? cfn_parse.FromCloudFormation.getNumber(properties.ThreadsPerCore) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`PrivateDnsNameOptionsProperty\`
 *
 * @param properties - the TypeScript properties of a \`PrivateDnsNameOptionsProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnInstancePrivateDnsNameOptionsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("enableResourceNameDnsAaaaRecord", cdk.validateBoolean)(properties.enableResourceNameDnsAaaaRecord));
  errors.collect(cdk.propertyValidator("enableResourceNameDnsARecord", cdk.validateBoolean)(properties.enableResourceNameDnsARecord));
  errors.collect(cdk.propertyValidator("hostnameType", cdk.validateString)(properties.hostnameType));
  return errors.wrap("supplied properties not correct for \\"PrivateDnsNameOptionsProperty\\"");
}

// @ts-ignore TS6133
function convertCfnInstancePrivateDnsNameOptionsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnInstancePrivateDnsNameOptionsPropertyValidator(properties).assertSuccess();
  return {
    "EnableResourceNameDnsAAAARecord": cdk.booleanToCloudFormation(properties.enableResourceNameDnsAaaaRecord),
    "EnableResourceNameDnsARecord": cdk.booleanToCloudFormation(properties.enableResourceNameDnsARecord),
    "HostnameType": cdk.stringToCloudFormation(properties.hostnameType)
  };
}

// @ts-ignore TS6133
function CfnInstancePrivateDnsNameOptionsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnInstance.PrivateDnsNameOptionsProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnInstance.PrivateDnsNameOptionsProperty>();
  ret.addPropertyResult("enableResourceNameDnsAaaaRecord", "EnableResourceNameDnsAAAARecord", (properties.EnableResourceNameDnsAAAARecord != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EnableResourceNameDnsAAAARecord) : undefined));
  ret.addPropertyResult("enableResourceNameDnsARecord", "EnableResourceNameDnsARecord", (properties.EnableResourceNameDnsARecord != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EnableResourceNameDnsARecord) : undefined));
  ret.addPropertyResult("hostnameType", "HostnameType", (properties.HostnameType != null ? cfn_parse.FromCloudFormation.getString(properties.HostnameType) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`AssociationParameterProperty\`
 *
 * @param properties - the TypeScript properties of a \`AssociationParameterProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnInstanceAssociationParameterPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("key", cdk.requiredValidator)(properties.key));
  errors.collect(cdk.propertyValidator("key", cdk.validateString)(properties.key));
  errors.collect(cdk.propertyValidator("value", cdk.requiredValidator)(properties.value));
  errors.collect(cdk.propertyValidator("value", cdk.listValidator(cdk.validateString))(properties.value));
  return errors.wrap("supplied properties not correct for \\"AssociationParameterProperty\\"");
}

// @ts-ignore TS6133
function convertCfnInstanceAssociationParameterPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnInstanceAssociationParameterPropertyValidator(properties).assertSuccess();
  return {
    "Key": cdk.stringToCloudFormation(properties.key),
    "Value": cdk.listMapper(cdk.stringToCloudFormation)(properties.value)
  };
}

// @ts-ignore TS6133
function CfnInstanceAssociationParameterPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnInstance.AssociationParameterProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnInstance.AssociationParameterProperty>();
  ret.addPropertyResult("key", "Key", (properties.Key != null ? cfn_parse.FromCloudFormation.getString(properties.Key) : undefined));
  ret.addPropertyResult("value", "Value", (properties.Value != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.Value) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`SsmAssociationProperty\`
 *
 * @param properties - the TypeScript properties of a \`SsmAssociationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnInstanceSsmAssociationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("associationParameters", cdk.listValidator(CfnInstanceAssociationParameterPropertyValidator))(properties.associationParameters));
  errors.collect(cdk.propertyValidator("documentName", cdk.requiredValidator)(properties.documentName));
  errors.collect(cdk.propertyValidator("documentName", cdk.validateString)(properties.documentName));
  return errors.wrap("supplied properties not correct for \\"SsmAssociationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnInstanceSsmAssociationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnInstanceSsmAssociationPropertyValidator(properties).assertSuccess();
  return {
    "AssociationParameters": cdk.listMapper(convertCfnInstanceAssociationParameterPropertyToCloudFormation)(properties.associationParameters),
    "DocumentName": cdk.stringToCloudFormation(properties.documentName)
  };
}

// @ts-ignore TS6133
function CfnInstanceSsmAssociationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnInstance.SsmAssociationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnInstance.SsmAssociationProperty>();
  ret.addPropertyResult("associationParameters", "AssociationParameters", (properties.AssociationParameters != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceAssociationParameterPropertyFromCloudFormation)(properties.AssociationParameters) : undefined));
  ret.addPropertyResult("documentName", "DocumentName", (properties.DocumentName != null ? cfn_parse.FromCloudFormation.getString(properties.DocumentName) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CreditSpecificationProperty\`
 *
 * @param properties - the TypeScript properties of a \`CreditSpecificationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnInstanceCreditSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("cpuCredits", cdk.validateString)(properties.cpuCredits));
  return errors.wrap("supplied properties not correct for \\"CreditSpecificationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnInstanceCreditSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnInstanceCreditSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "CPUCredits": cdk.stringToCloudFormation(properties.cpuCredits)
  };
}

// @ts-ignore TS6133
function CfnInstanceCreditSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnInstance.CreditSpecificationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnInstance.CreditSpecificationProperty>();
  ret.addPropertyResult("cpuCredits", "CPUCredits", (properties.CPUCredits != null ? cfn_parse.FromCloudFormation.getString(properties.CPUCredits) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnInstanceProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnInstanceProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnInstancePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("additionalInfo", cdk.validateString)(properties.additionalInfo));
  errors.collect(cdk.propertyValidator("affinity", cdk.validateString)(properties.affinity));
  errors.collect(cdk.propertyValidator("availabilityZone", cdk.validateString)(properties.availabilityZone));
  errors.collect(cdk.propertyValidator("blockDeviceMappings", cdk.listValidator(CfnInstanceBlockDeviceMappingPropertyValidator))(properties.blockDeviceMappings));
  errors.collect(cdk.propertyValidator("cpuOptions", CfnInstanceCpuOptionsPropertyValidator)(properties.cpuOptions));
  errors.collect(cdk.propertyValidator("creditSpecification", CfnInstanceCreditSpecificationPropertyValidator)(properties.creditSpecification));
  errors.collect(cdk.propertyValidator("disableApiTermination", cdk.validateBoolean)(properties.disableApiTermination));
  errors.collect(cdk.propertyValidator("ebsOptimized", cdk.validateBoolean)(properties.ebsOptimized));
  errors.collect(cdk.propertyValidator("elasticGpuSpecifications", cdk.listValidator(CfnInstanceElasticGpuSpecificationPropertyValidator))(properties.elasticGpuSpecifications));
  errors.collect(cdk.propertyValidator("elasticInferenceAccelerators", cdk.listValidator(CfnInstanceElasticInferenceAcceleratorPropertyValidator))(properties.elasticInferenceAccelerators));
  errors.collect(cdk.propertyValidator("enclaveOptions", CfnInstanceEnclaveOptionsPropertyValidator)(properties.enclaveOptions));
  errors.collect(cdk.propertyValidator("hibernationOptions", CfnInstanceHibernationOptionsPropertyValidator)(properties.hibernationOptions));
  errors.collect(cdk.propertyValidator("hostId", cdk.validateString)(properties.hostId));
  errors.collect(cdk.propertyValidator("hostResourceGroupArn", cdk.validateString)(properties.hostResourceGroupArn));
  errors.collect(cdk.propertyValidator("iamInstanceProfile", cdk.validateString)(properties.iamInstanceProfile));
  errors.collect(cdk.propertyValidator("imageId", cdk.validateString)(properties.imageId));
  errors.collect(cdk.propertyValidator("instanceInitiatedShutdownBehavior", cdk.validateString)(properties.instanceInitiatedShutdownBehavior));
  errors.collect(cdk.propertyValidator("instanceType", cdk.validateString)(properties.instanceType));
  errors.collect(cdk.propertyValidator("ipv6AddressCount", cdk.validateNumber)(properties.ipv6AddressCount));
  errors.collect(cdk.propertyValidator("ipv6Addresses", cdk.listValidator(CfnInstanceInstanceIpv6AddressPropertyValidator))(properties.ipv6Addresses));
  errors.collect(cdk.propertyValidator("kernelId", cdk.validateString)(properties.kernelId));
  errors.collect(cdk.propertyValidator("keyName", cdk.validateString)(properties.keyName));
  errors.collect(cdk.propertyValidator("launchTemplate", CfnInstanceLaunchTemplateSpecificationPropertyValidator)(properties.launchTemplate));
  errors.collect(cdk.propertyValidator("licenseSpecifications", cdk.listValidator(CfnInstanceLicenseSpecificationPropertyValidator))(properties.licenseSpecifications));
  errors.collect(cdk.propertyValidator("monitoring", cdk.validateBoolean)(properties.monitoring));
  errors.collect(cdk.propertyValidator("networkInterfaces", cdk.listValidator(CfnInstanceNetworkInterfacePropertyValidator))(properties.networkInterfaces));
  errors.collect(cdk.propertyValidator("placementGroupName", cdk.validateString)(properties.placementGroupName));
  errors.collect(cdk.propertyValidator("privateDnsNameOptions", CfnInstancePrivateDnsNameOptionsPropertyValidator)(properties.privateDnsNameOptions));
  errors.collect(cdk.propertyValidator("privateIpAddress", cdk.validateString)(properties.privateIpAddress));
  errors.collect(cdk.propertyValidator("propagateTagsToVolumeOnCreation", cdk.validateBoolean)(properties.propagateTagsToVolumeOnCreation));
  errors.collect(cdk.propertyValidator("ramdiskId", cdk.validateString)(properties.ramdiskId));
  errors.collect(cdk.propertyValidator("securityGroupIds", cdk.listValidator(cdk.validateString))(properties.securityGroupIds));
  errors.collect(cdk.propertyValidator("securityGroups", cdk.listValidator(cdk.validateString))(properties.securityGroups));
  errors.collect(cdk.propertyValidator("sourceDestCheck", cdk.validateBoolean)(properties.sourceDestCheck));
  errors.collect(cdk.propertyValidator("ssmAssociations", cdk.listValidator(CfnInstanceSsmAssociationPropertyValidator))(properties.ssmAssociations));
  errors.collect(cdk.propertyValidator("subnetId", cdk.validateString)(properties.subnetId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("tenancy", cdk.validateString)(properties.tenancy));
  errors.collect(cdk.propertyValidator("userData", cdk.validateString)(properties.userData));
  errors.collect(cdk.propertyValidator("volumes", cdk.listValidator(CfnInstanceVolumePropertyValidator))(properties.volumes));
  return errors.wrap("supplied properties not correct for \\"CfnInstanceProps\\"");
}

// @ts-ignore TS6133
function convertCfnInstancePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnInstancePropsValidator(properties).assertSuccess();
  return {
    "AdditionalInfo": cdk.stringToCloudFormation(properties.additionalInfo),
    "Affinity": cdk.stringToCloudFormation(properties.affinity),
    "AvailabilityZone": cdk.stringToCloudFormation(properties.availabilityZone),
    "BlockDeviceMappings": cdk.listMapper(convertCfnInstanceBlockDeviceMappingPropertyToCloudFormation)(properties.blockDeviceMappings),
    "CpuOptions": convertCfnInstanceCpuOptionsPropertyToCloudFormation(properties.cpuOptions),
    "CreditSpecification": convertCfnInstanceCreditSpecificationPropertyToCloudFormation(properties.creditSpecification),
    "DisableApiTermination": cdk.booleanToCloudFormation(properties.disableApiTermination),
    "EbsOptimized": cdk.booleanToCloudFormation(properties.ebsOptimized),
    "ElasticGpuSpecifications": cdk.listMapper(convertCfnInstanceElasticGpuSpecificationPropertyToCloudFormation)(properties.elasticGpuSpecifications),
    "ElasticInferenceAccelerators": cdk.listMapper(convertCfnInstanceElasticInferenceAcceleratorPropertyToCloudFormation)(properties.elasticInferenceAccelerators),
    "EnclaveOptions": convertCfnInstanceEnclaveOptionsPropertyToCloudFormation(properties.enclaveOptions),
    "HibernationOptions": convertCfnInstanceHibernationOptionsPropertyToCloudFormation(properties.hibernationOptions),
    "HostId": cdk.stringToCloudFormation(properties.hostId),
    "HostResourceGroupArn": cdk.stringToCloudFormation(properties.hostResourceGroupArn),
    "IamInstanceProfile": cdk.stringToCloudFormation(properties.iamInstanceProfile),
    "ImageId": cdk.stringToCloudFormation(properties.imageId),
    "InstanceInitiatedShutdownBehavior": cdk.stringToCloudFormation(properties.instanceInitiatedShutdownBehavior),
    "InstanceType": cdk.stringToCloudFormation(properties.instanceType),
    "Ipv6AddressCount": cdk.numberToCloudFormation(properties.ipv6AddressCount),
    "Ipv6Addresses": cdk.listMapper(convertCfnInstanceInstanceIpv6AddressPropertyToCloudFormation)(properties.ipv6Addresses),
    "KernelId": cdk.stringToCloudFormation(properties.kernelId),
    "KeyName": cdk.stringToCloudFormation(properties.keyName),
    "LaunchTemplate": convertCfnInstanceLaunchTemplateSpecificationPropertyToCloudFormation(properties.launchTemplate),
    "LicenseSpecifications": cdk.listMapper(convertCfnInstanceLicenseSpecificationPropertyToCloudFormation)(properties.licenseSpecifications),
    "Monitoring": cdk.booleanToCloudFormation(properties.monitoring),
    "NetworkInterfaces": cdk.listMapper(convertCfnInstanceNetworkInterfacePropertyToCloudFormation)(properties.networkInterfaces),
    "PlacementGroupName": cdk.stringToCloudFormation(properties.placementGroupName),
    "PrivateDnsNameOptions": convertCfnInstancePrivateDnsNameOptionsPropertyToCloudFormation(properties.privateDnsNameOptions),
    "PrivateIpAddress": cdk.stringToCloudFormation(properties.privateIpAddress),
    "PropagateTagsToVolumeOnCreation": cdk.booleanToCloudFormation(properties.propagateTagsToVolumeOnCreation),
    "RamdiskId": cdk.stringToCloudFormation(properties.ramdiskId),
    "SecurityGroupIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.securityGroupIds),
    "SecurityGroups": cdk.listMapper(cdk.stringToCloudFormation)(properties.securityGroups),
    "SourceDestCheck": cdk.booleanToCloudFormation(properties.sourceDestCheck),
    "SsmAssociations": cdk.listMapper(convertCfnInstanceSsmAssociationPropertyToCloudFormation)(properties.ssmAssociations),
    "SubnetId": cdk.stringToCloudFormation(properties.subnetId),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "Tenancy": cdk.stringToCloudFormation(properties.tenancy),
    "UserData": cdk.stringToCloudFormation(properties.userData),
    "Volumes": cdk.listMapper(convertCfnInstanceVolumePropertyToCloudFormation)(properties.volumes)
  };
}

// @ts-ignore TS6133
function CfnInstancePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnInstanceProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnInstanceProps>();
  ret.addPropertyResult("additionalInfo", "AdditionalInfo", (properties.AdditionalInfo != null ? cfn_parse.FromCloudFormation.getString(properties.AdditionalInfo) : undefined));
  ret.addPropertyResult("affinity", "Affinity", (properties.Affinity != null ? cfn_parse.FromCloudFormation.getString(properties.Affinity) : undefined));
  ret.addPropertyResult("availabilityZone", "AvailabilityZone", (properties.AvailabilityZone != null ? cfn_parse.FromCloudFormation.getString(properties.AvailabilityZone) : undefined));
  ret.addPropertyResult("blockDeviceMappings", "BlockDeviceMappings", (properties.BlockDeviceMappings != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceBlockDeviceMappingPropertyFromCloudFormation)(properties.BlockDeviceMappings) : undefined));
  ret.addPropertyResult("cpuOptions", "CpuOptions", (properties.CpuOptions != null ? CfnInstanceCpuOptionsPropertyFromCloudFormation(properties.CpuOptions) : undefined));
  ret.addPropertyResult("creditSpecification", "CreditSpecification", (properties.CreditSpecification != null ? CfnInstanceCreditSpecificationPropertyFromCloudFormation(properties.CreditSpecification) : undefined));
  ret.addPropertyResult("disableApiTermination", "DisableApiTermination", (properties.DisableApiTermination != null ? cfn_parse.FromCloudFormation.getBoolean(properties.DisableApiTermination) : undefined));
  ret.addPropertyResult("ebsOptimized", "EbsOptimized", (properties.EbsOptimized != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EbsOptimized) : undefined));
  ret.addPropertyResult("elasticGpuSpecifications", "ElasticGpuSpecifications", (properties.ElasticGpuSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceElasticGpuSpecificationPropertyFromCloudFormation)(properties.ElasticGpuSpecifications) : undefined));
  ret.addPropertyResult("elasticInferenceAccelerators", "ElasticInferenceAccelerators", (properties.ElasticInferenceAccelerators != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceElasticInferenceAcceleratorPropertyFromCloudFormation)(properties.ElasticInferenceAccelerators) : undefined));
  ret.addPropertyResult("enclaveOptions", "EnclaveOptions", (properties.EnclaveOptions != null ? CfnInstanceEnclaveOptionsPropertyFromCloudFormation(properties.EnclaveOptions) : undefined));
  ret.addPropertyResult("hibernationOptions", "HibernationOptions", (properties.HibernationOptions != null ? CfnInstanceHibernationOptionsPropertyFromCloudFormation(properties.HibernationOptions) : undefined));
  ret.addPropertyResult("hostId", "HostId", (properties.HostId != null ? cfn_parse.FromCloudFormation.getString(properties.HostId) : undefined));
  ret.addPropertyResult("hostResourceGroupArn", "HostResourceGroupArn", (properties.HostResourceGroupArn != null ? cfn_parse.FromCloudFormation.getString(properties.HostResourceGroupArn) : undefined));
  ret.addPropertyResult("iamInstanceProfile", "IamInstanceProfile", (properties.IamInstanceProfile != null ? cfn_parse.FromCloudFormation.getString(properties.IamInstanceProfile) : undefined));
  ret.addPropertyResult("imageId", "ImageId", (properties.ImageId != null ? cfn_parse.FromCloudFormation.getString(properties.ImageId) : undefined));
  ret.addPropertyResult("instanceInitiatedShutdownBehavior", "InstanceInitiatedShutdownBehavior", (properties.InstanceInitiatedShutdownBehavior != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceInitiatedShutdownBehavior) : undefined));
  ret.addPropertyResult("instanceType", "InstanceType", (properties.InstanceType != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceType) : undefined));
  ret.addPropertyResult("ipv6AddressCount", "Ipv6AddressCount", (properties.Ipv6AddressCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.Ipv6AddressCount) : undefined));
  ret.addPropertyResult("ipv6Addresses", "Ipv6Addresses", (properties.Ipv6Addresses != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceInstanceIpv6AddressPropertyFromCloudFormation)(properties.Ipv6Addresses) : undefined));
  ret.addPropertyResult("kernelId", "KernelId", (properties.KernelId != null ? cfn_parse.FromCloudFormation.getString(properties.KernelId) : undefined));
  ret.addPropertyResult("keyName", "KeyName", (properties.KeyName != null ? cfn_parse.FromCloudFormation.getString(properties.KeyName) : undefined));
  ret.addPropertyResult("launchTemplate", "LaunchTemplate", (properties.LaunchTemplate != null ? CfnInstanceLaunchTemplateSpecificationPropertyFromCloudFormation(properties.LaunchTemplate) : undefined));
  ret.addPropertyResult("licenseSpecifications", "LicenseSpecifications", (properties.LicenseSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceLicenseSpecificationPropertyFromCloudFormation)(properties.LicenseSpecifications) : undefined));
  ret.addPropertyResult("monitoring", "Monitoring", (properties.Monitoring != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Monitoring) : undefined));
  ret.addPropertyResult("networkInterfaces", "NetworkInterfaces", (properties.NetworkInterfaces != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceNetworkInterfacePropertyFromCloudFormation)(properties.NetworkInterfaces) : undefined));
  ret.addPropertyResult("placementGroupName", "PlacementGroupName", (properties.PlacementGroupName != null ? cfn_parse.FromCloudFormation.getString(properties.PlacementGroupName) : undefined));
  ret.addPropertyResult("privateDnsNameOptions", "PrivateDnsNameOptions", (properties.PrivateDnsNameOptions != null ? CfnInstancePrivateDnsNameOptionsPropertyFromCloudFormation(properties.PrivateDnsNameOptions) : undefined));
  ret.addPropertyResult("privateIpAddress", "PrivateIpAddress", (properties.PrivateIpAddress != null ? cfn_parse.FromCloudFormation.getString(properties.PrivateIpAddress) : undefined));
  ret.addPropertyResult("propagateTagsToVolumeOnCreation", "PropagateTagsToVolumeOnCreation", (properties.PropagateTagsToVolumeOnCreation != null ? cfn_parse.FromCloudFormation.getBoolean(properties.PropagateTagsToVolumeOnCreation) : undefined));
  ret.addPropertyResult("ramdiskId", "RamdiskId", (properties.RamdiskId != null ? cfn_parse.FromCloudFormation.getString(properties.RamdiskId) : undefined));
  ret.addPropertyResult("securityGroupIds", "SecurityGroupIds", (properties.SecurityGroupIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecurityGroupIds) : undefined));
  ret.addPropertyResult("securityGroups", "SecurityGroups", (properties.SecurityGroups != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecurityGroups) : undefined));
  ret.addPropertyResult("sourceDestCheck", "SourceDestCheck", (properties.SourceDestCheck != null ? cfn_parse.FromCloudFormation.getBoolean(properties.SourceDestCheck) : undefined));
  ret.addPropertyResult("ssmAssociations", "SsmAssociations", (properties.SsmAssociations != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceSsmAssociationPropertyFromCloudFormation)(properties.SsmAssociations) : undefined));
  ret.addPropertyResult("subnetId", "SubnetId", (properties.SubnetId != null ? cfn_parse.FromCloudFormation.getString(properties.SubnetId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("tenancy", "Tenancy", (properties.Tenancy != null ? cfn_parse.FromCloudFormation.getString(properties.Tenancy) : undefined));
  ret.addPropertyResult("userData", "UserData", (properties.UserData != null ? cfn_parse.FromCloudFormation.getString(properties.UserData) : undefined));
  ret.addPropertyResult("volumes", "Volumes", (properties.Volumes != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceVolumePropertyFromCloudFormation)(properties.Volumes) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Allocates an internet gateway for use with a VPC.
 *
 * After creating the Internet gateway, you then attach it to a VPC.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-internetgateway.html
 */
export class CfnInternetGateway extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::InternetGateway";

  /**
   * Build a CfnInternetGateway from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnInternetGateway {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnInternetGatewayPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnInternetGateway(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the internet gateway.
   *
   * @cloudformationAttribute InternetGatewayId
   */
  public readonly attrInternetGatewayId: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * Any tags to assign to the internet gateway.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnInternetGatewayProps = {}) {
    super(scope, id, {
      "type": CfnInternetGateway.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.attrInternetGatewayId = cdk.Token.asString(this.getAtt("InternetGatewayId", cdk.ResolutionTypeHint.STRING));
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::InternetGateway", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnInternetGateway.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnInternetGatewayPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnInternetGateway\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-internetgateway.html
 */
export interface CfnInternetGatewayProps {
  /**
   * Any tags to assign to the internet gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-internetgateway.html#cfn-ec2-internetgateway-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a \`CfnInternetGatewayProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnInternetGatewayProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnInternetGatewayPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnInternetGatewayProps\\"");
}

// @ts-ignore TS6133
function convertCfnInternetGatewayPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnInternetGatewayPropsValidator(properties).assertSuccess();
  return {
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnInternetGatewayPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnInternetGatewayProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnInternetGatewayProps>();
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * IPAM is a VPC feature that you can use to automate your IP address management workflows including assigning, tracking, troubleshooting, and auditing IP addresses across AWS Regions and accounts throughout your AWS Organization.
 *
 * For more information, see [What is IPAM?](https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html) in the *Amazon VPC IPAM User Guide* .
 *
 * There are AWS Identity and Access Management (IAM) permissions required to fully manage an IPAM in CloudFormation. For more information, see [Example policy](https://docs.aws.amazon.com//vpc/latest/ipam/iam-ipam-policy-examples.html) in the *Amazon VPC IPAM User Guide* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipam.html
 */
export class CfnIPAM extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::IPAM";

  /**
   * Build a CfnIPAM from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnIPAM {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnIPAMPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnIPAM(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ARN of the IPAM.
   *
   * @cloudformationAttribute Arn
   */
  public readonly attrArn: string;

  /**
   * The ID of the IPAM.
   *
   * @cloudformationAttribute IpamId
   */
  public readonly attrIpamId: string;

  /**
   * The ID of the default private scope.
   *
   * @cloudformationAttribute PrivateDefaultScopeId
   */
  public readonly attrPrivateDefaultScopeId: string;

  /**
   * The ID of the default public scope.
   *
   * @cloudformationAttribute PublicDefaultScopeId
   */
  public readonly attrPublicDefaultScopeId: string;

  /**
   * The number of resource discovery associations.
   *
   * @cloudformationAttribute ResourceDiscoveryAssociationCount
   */
  public readonly attrResourceDiscoveryAssociationCount: number;

  /**
   * The number of scopes.
   *
   * @cloudformationAttribute ScopeCount
   */
  public readonly attrScopeCount: number;

  /**
   * The IPAM's default resource discovery association ID.
   */
  public defaultResourceDiscoveryAssociationId?: string;

  /**
   * The IPAM's default resource discovery ID.
   */
  public defaultResourceDiscoveryId?: string;

  /**
   * The description for the IPAM.
   */
  public description?: string;

  /**
   * The operating Regions for an IPAM.
   */
  public operatingRegions?: Array<CfnIPAM.IpamOperatingRegionProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The key/value combination of a tag assigned to the resource.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnIPAMProps = {}) {
    super(scope, id, {
      "type": CfnIPAM.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.attrArn = cdk.Token.asString(this.getAtt("Arn", cdk.ResolutionTypeHint.STRING));
    this.attrIpamId = cdk.Token.asString(this.getAtt("IpamId", cdk.ResolutionTypeHint.STRING));
    this.attrPrivateDefaultScopeId = cdk.Token.asString(this.getAtt("PrivateDefaultScopeId", cdk.ResolutionTypeHint.STRING));
    this.attrPublicDefaultScopeId = cdk.Token.asString(this.getAtt("PublicDefaultScopeId", cdk.ResolutionTypeHint.STRING));
    this.attrResourceDiscoveryAssociationCount = cdk.Token.asNumber(this.getAtt("ResourceDiscoveryAssociationCount", cdk.ResolutionTypeHint.NUMBER));
    this.attrScopeCount = cdk.Token.asNumber(this.getAtt("ScopeCount", cdk.ResolutionTypeHint.NUMBER));
    this.defaultResourceDiscoveryAssociationId = props.defaultResourceDiscoveryAssociationId;
    this.defaultResourceDiscoveryId = props.defaultResourceDiscoveryId;
    this.description = props.description;
    this.operatingRegions = props.operatingRegions;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::IPAM", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "defaultResourceDiscoveryAssociationId": this.defaultResourceDiscoveryAssociationId,
      "defaultResourceDiscoveryId": this.defaultResourceDiscoveryId,
      "description": this.description,
      "operatingRegions": this.operatingRegions,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnIPAM.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnIPAMPropsToCloudFormation(props);
  }
}

export namespace CfnIPAM {
  /**
   * The operating Regions for an IPAM.
   *
   * Operating Regions are AWS Regions where the IPAM is allowed to manage IP address CIDRs. IPAM only discovers and monitors resources in the AWS Regions you select as operating Regions.
   *
   * For more information about operating Regions, see [Create an IPAM](https://docs.aws.amazon.com//vpc/latest/ipam/create-ipam.html) in the *Amazon VPC IPAM User Guide* .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipam-ipamoperatingregion.html
   */
  export interface IpamOperatingRegionProperty {
    /**
     * The name of the operating Region.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipam-ipamoperatingregion.html#cfn-ec2-ipam-ipamoperatingregion-regionname
     */
    readonly regionName: string;
  }
}

/**
 * Properties for defining a \`CfnIPAM\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipam.html
 */
export interface CfnIPAMProps {
  /**
   * The IPAM's default resource discovery association ID.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipam.html#cfn-ec2-ipam-defaultresourcediscoveryassociationid
   */
  readonly defaultResourceDiscoveryAssociationId?: string;

  /**
   * The IPAM's default resource discovery ID.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipam.html#cfn-ec2-ipam-defaultresourcediscoveryid
   */
  readonly defaultResourceDiscoveryId?: string;

  /**
   * The description for the IPAM.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipam.html#cfn-ec2-ipam-description
   */
  readonly description?: string;

  /**
   * The operating Regions for an IPAM.
   *
   * Operating Regions are AWS Regions where the IPAM is allowed to manage IP address CIDRs. IPAM only discovers and monitors resources in the AWS Regions you select as operating Regions.
   *
   * For more information about operating Regions, see [Create an IPAM](https://docs.aws.amazon.com//vpc/latest/ipam/create-ipam.html) in the *Amazon VPC IPAM User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipam.html#cfn-ec2-ipam-operatingregions
   */
  readonly operatingRegions?: Array<CfnIPAM.IpamOperatingRegionProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * The key/value combination of a tag assigned to the resource.
   *
   * Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key \`Owner\` and the value \`TeamA\` , specify \`tag:Owner\` for the filter name and \`TeamA\` for the filter value.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipam.html#cfn-ec2-ipam-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a \`IpamOperatingRegionProperty\`
 *
 * @param properties - the TypeScript properties of a \`IpamOperatingRegionProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnIPAMIpamOperatingRegionPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("regionName", cdk.requiredValidator)(properties.regionName));
  errors.collect(cdk.propertyValidator("regionName", cdk.validateString)(properties.regionName));
  return errors.wrap("supplied properties not correct for \\"IpamOperatingRegionProperty\\"");
}

// @ts-ignore TS6133
function convertCfnIPAMIpamOperatingRegionPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnIPAMIpamOperatingRegionPropertyValidator(properties).assertSuccess();
  return {
    "RegionName": cdk.stringToCloudFormation(properties.regionName)
  };
}

// @ts-ignore TS6133
function CfnIPAMIpamOperatingRegionPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnIPAM.IpamOperatingRegionProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnIPAM.IpamOperatingRegionProperty>();
  ret.addPropertyResult("regionName", "RegionName", (properties.RegionName != null ? cfn_parse.FromCloudFormation.getString(properties.RegionName) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnIPAMProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnIPAMProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnIPAMPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("defaultResourceDiscoveryAssociationId", cdk.validateString)(properties.defaultResourceDiscoveryAssociationId));
  errors.collect(cdk.propertyValidator("defaultResourceDiscoveryId", cdk.validateString)(properties.defaultResourceDiscoveryId));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("operatingRegions", cdk.listValidator(CfnIPAMIpamOperatingRegionPropertyValidator))(properties.operatingRegions));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnIPAMProps\\"");
}

// @ts-ignore TS6133
function convertCfnIPAMPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnIPAMPropsValidator(properties).assertSuccess();
  return {
    "DefaultResourceDiscoveryAssociationId": cdk.stringToCloudFormation(properties.defaultResourceDiscoveryAssociationId),
    "DefaultResourceDiscoveryId": cdk.stringToCloudFormation(properties.defaultResourceDiscoveryId),
    "Description": cdk.stringToCloudFormation(properties.description),
    "OperatingRegions": cdk.listMapper(convertCfnIPAMIpamOperatingRegionPropertyToCloudFormation)(properties.operatingRegions),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnIPAMPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnIPAMProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnIPAMProps>();
  ret.addPropertyResult("defaultResourceDiscoveryAssociationId", "DefaultResourceDiscoveryAssociationId", (properties.DefaultResourceDiscoveryAssociationId != null ? cfn_parse.FromCloudFormation.getString(properties.DefaultResourceDiscoveryAssociationId) : undefined));
  ret.addPropertyResult("defaultResourceDiscoveryId", "DefaultResourceDiscoveryId", (properties.DefaultResourceDiscoveryId != null ? cfn_parse.FromCloudFormation.getString(properties.DefaultResourceDiscoveryId) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("operatingRegions", "OperatingRegions", (properties.OperatingRegions != null ? cfn_parse.FromCloudFormation.getArray(CfnIPAMIpamOperatingRegionPropertyFromCloudFormation)(properties.OperatingRegions) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * In IPAM, an allocation is a CIDR assignment from an IPAM pool to another IPAM pool or to a resource.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamallocation.html
 */
export class CfnIPAMAllocation extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::IPAMAllocation";

  /**
   * Build a CfnIPAMAllocation from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnIPAMAllocation {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnIPAMAllocationPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnIPAMAllocation(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of an allocation.
   *
   * @cloudformationAttribute IpamPoolAllocationId
   */
  public readonly attrIpamPoolAllocationId: string;

  /**
   * The CIDR you would like to allocate from the IPAM pool. Note the following:.
   */
  public cidr?: string;

  /**
   * A description for the allocation.
   */
  public description?: string;

  /**
   * The ID of the IPAM pool from which you would like to allocate a CIDR.
   */
  public ipamPoolId: string;

  /**
   * The netmask length of the CIDR you would like to allocate from the IPAM pool. Note the following:.
   */
  public netmaskLength?: number;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnIPAMAllocationProps) {
    super(scope, id, {
      "type": CfnIPAMAllocation.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "ipamPoolId", this);

    this.attrIpamPoolAllocationId = cdk.Token.asString(this.getAtt("IpamPoolAllocationId", cdk.ResolutionTypeHint.STRING));
    this.cidr = props.cidr;
    this.description = props.description;
    this.ipamPoolId = props.ipamPoolId;
    this.netmaskLength = props.netmaskLength;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "cidr": this.cidr,
      "description": this.description,
      "ipamPoolId": this.ipamPoolId,
      "netmaskLength": this.netmaskLength
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnIPAMAllocation.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnIPAMAllocationPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnIPAMAllocation\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamallocation.html
 */
export interface CfnIPAMAllocationProps {
  /**
   * The CIDR you would like to allocate from the IPAM pool. Note the following:.
   *
   * - If there is no DefaultNetmaskLength allocation rule set on the pool, you must specify either the NetmaskLength or the CIDR.
   * - If the DefaultNetmaskLength allocation rule is set on the pool, you can specify either the NetmaskLength or the CIDR and the DefaultNetmaskLength allocation rule will be ignored.
   *
   * Possible values: Any available IPv4 or IPv6 CIDR.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamallocation.html#cfn-ec2-ipamallocation-cidr
   */
  readonly cidr?: string;

  /**
   * A description for the allocation.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamallocation.html#cfn-ec2-ipamallocation-description
   */
  readonly description?: string;

  /**
   * The ID of the IPAM pool from which you would like to allocate a CIDR.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamallocation.html#cfn-ec2-ipamallocation-ipampoolid
   */
  readonly ipamPoolId: string;

  /**
   * The netmask length of the CIDR you would like to allocate from the IPAM pool. Note the following:.
   *
   * - If there is no DefaultNetmaskLength allocation rule set on the pool, you must specify either the NetmaskLength or the CIDR.
   * - If the DefaultNetmaskLength allocation rule is set on the pool, you can specify either the NetmaskLength or the CIDR and the DefaultNetmaskLength allocation rule will be ignored.
   *
   * Possible netmask lengths for IPv4 addresses are 0 - 32. Possible netmask lengths for IPv6 addresses are 0 - 128.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamallocation.html#cfn-ec2-ipamallocation-netmasklength
   */
  readonly netmaskLength?: number;
}

/**
 * Determine whether the given properties match those of a \`CfnIPAMAllocationProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnIPAMAllocationProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnIPAMAllocationPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("cidr", cdk.validateString)(properties.cidr));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("ipamPoolId", cdk.requiredValidator)(properties.ipamPoolId));
  errors.collect(cdk.propertyValidator("ipamPoolId", cdk.validateString)(properties.ipamPoolId));
  errors.collect(cdk.propertyValidator("netmaskLength", cdk.validateNumber)(properties.netmaskLength));
  return errors.wrap("supplied properties not correct for \\"CfnIPAMAllocationProps\\"");
}

// @ts-ignore TS6133
function convertCfnIPAMAllocationPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnIPAMAllocationPropsValidator(properties).assertSuccess();
  return {
    "Cidr": cdk.stringToCloudFormation(properties.cidr),
    "Description": cdk.stringToCloudFormation(properties.description),
    "IpamPoolId": cdk.stringToCloudFormation(properties.ipamPoolId),
    "NetmaskLength": cdk.numberToCloudFormation(properties.netmaskLength)
  };
}

// @ts-ignore TS6133
function CfnIPAMAllocationPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnIPAMAllocationProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnIPAMAllocationProps>();
  ret.addPropertyResult("cidr", "Cidr", (properties.Cidr != null ? cfn_parse.FromCloudFormation.getString(properties.Cidr) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("ipamPoolId", "IpamPoolId", (properties.IpamPoolId != null ? cfn_parse.FromCloudFormation.getString(properties.IpamPoolId) : undefined));
  ret.addPropertyResult("netmaskLength", "NetmaskLength", (properties.NetmaskLength != null ? cfn_parse.FromCloudFormation.getNumber(properties.NetmaskLength) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * In IPAM, a pool is a collection of contiguous IP addresses CIDRs.
 *
 * Pools enable you to organize your IP addresses according to your routing and security needs. For example, if you have separate routing and security needs for development and production applications, you can create a pool for each.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html
 */
export class CfnIPAMPool extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::IPAMPool";

  /**
   * Build a CfnIPAMPool from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnIPAMPool {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnIPAMPoolPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnIPAMPool(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ARN of the IPAM pool.
   *
   * @cloudformationAttribute Arn
   */
  public readonly attrArn: string;

  /**
   * The ARN of the IPAM.
   *
   * @cloudformationAttribute IpamArn
   */
  public readonly attrIpamArn: string;

  /**
   * The ID of the IPAM pool.
   *
   * @cloudformationAttribute IpamPoolId
   */
  public readonly attrIpamPoolId: string;

  /**
   * The ARN of the scope of the IPAM pool.
   *
   * @cloudformationAttribute IpamScopeArn
   */
  public readonly attrIpamScopeArn: string;

  /**
   * The scope of the IPAM.
   *
   * @cloudformationAttribute IpamScopeType
   */
  public readonly attrIpamScopeType: string;

  /**
   * The depth of pools in your IPAM pool. The pool depth quota is 10.
   *
   * @cloudformationAttribute PoolDepth
   */
  public readonly attrPoolDepth: number;

  /**
   * The state of the IPAM pool.
   *
   * @cloudformationAttribute State
   */
  public readonly attrState: string;

  /**
   * A message related to the failed creation of an IPAM pool.
   *
   * @cloudformationAttribute StateMessage
   */
  public readonly attrStateMessage: string;

  /**
   * The address family of the pool.
   */
  public addressFamily: string;

  /**
   * The default netmask length for allocations added to this pool.
   */
  public allocationDefaultNetmaskLength?: number;

  /**
   * The maximum netmask length possible for CIDR allocations in this IPAM pool to be compliant.
   */
  public allocationMaxNetmaskLength?: number;

  /**
   * The minimum netmask length required for CIDR allocations in this IPAM pool to be compliant.
   */
  public allocationMinNetmaskLength?: number;

  /**
   * Tags that are required for resources that use CIDRs from this IPAM pool.
   */
  public allocationResourceTags?: Array<cdk.CfnTag | cdk.IResolvable> | cdk.IResolvable;

  /**
   * If selected, IPAM will continuously look for resources within the CIDR range of this pool and automatically import them as allocations into your IPAM.
   */
  public autoImport?: boolean | cdk.IResolvable;

  /**
   * Limits which service in AWS that the pool can be used in.
   */
  public awsService?: string;

  /**
   * The description of the IPAM pool.
   */
  public description?: string;

  /**
   * The ID of the scope in which you would like to create the IPAM pool.
   */
  public ipamScopeId: string;

  /**
   * The locale of the IPAM pool.
   */
  public locale?: string;

  /**
   * Information about the CIDRs provisioned to an IPAM pool.
   */
  public provisionedCidrs?: Array<cdk.IResolvable | CfnIPAMPool.ProvisionedCidrProperty> | cdk.IResolvable;

  /**
   * The IP address source for pools in the public scope.
   */
  public publicIpSource?: string;

  /**
   * Determines if a pool is publicly advertisable.
   */
  public publiclyAdvertisable?: boolean | cdk.IResolvable;

  /**
   * The ID of the source IPAM pool.
   */
  public sourceIpamPoolId?: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The key/value combination of a tag assigned to the resource.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnIPAMPoolProps) {
    super(scope, id, {
      "type": CfnIPAMPool.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "addressFamily", this);
    cdk.requireProperty(props, "ipamScopeId", this);

    this.attrArn = cdk.Token.asString(this.getAtt("Arn", cdk.ResolutionTypeHint.STRING));
    this.attrIpamArn = cdk.Token.asString(this.getAtt("IpamArn", cdk.ResolutionTypeHint.STRING));
    this.attrIpamPoolId = cdk.Token.asString(this.getAtt("IpamPoolId", cdk.ResolutionTypeHint.STRING));
    this.attrIpamScopeArn = cdk.Token.asString(this.getAtt("IpamScopeArn", cdk.ResolutionTypeHint.STRING));
    this.attrIpamScopeType = cdk.Token.asString(this.getAtt("IpamScopeType", cdk.ResolutionTypeHint.STRING));
    this.attrPoolDepth = cdk.Token.asNumber(this.getAtt("PoolDepth", cdk.ResolutionTypeHint.NUMBER));
    this.attrState = cdk.Token.asString(this.getAtt("State", cdk.ResolutionTypeHint.STRING));
    this.attrStateMessage = cdk.Token.asString(this.getAtt("StateMessage", cdk.ResolutionTypeHint.STRING));
    this.addressFamily = props.addressFamily;
    this.allocationDefaultNetmaskLength = props.allocationDefaultNetmaskLength;
    this.allocationMaxNetmaskLength = props.allocationMaxNetmaskLength;
    this.allocationMinNetmaskLength = props.allocationMinNetmaskLength;
    this.allocationResourceTags = props.allocationResourceTags;
    this.autoImport = props.autoImport;
    this.awsService = props.awsService;
    this.description = props.description;
    this.ipamScopeId = props.ipamScopeId;
    this.locale = props.locale;
    this.provisionedCidrs = props.provisionedCidrs;
    this.publicIpSource = props.publicIpSource;
    this.publiclyAdvertisable = props.publiclyAdvertisable;
    this.sourceIpamPoolId = props.sourceIpamPoolId;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::IPAMPool", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "addressFamily": this.addressFamily,
      "allocationDefaultNetmaskLength": this.allocationDefaultNetmaskLength,
      "allocationMaxNetmaskLength": this.allocationMaxNetmaskLength,
      "allocationMinNetmaskLength": this.allocationMinNetmaskLength,
      "allocationResourceTags": this.allocationResourceTags,
      "autoImport": this.autoImport,
      "awsService": this.awsService,
      "description": this.description,
      "ipamScopeId": this.ipamScopeId,
      "locale": this.locale,
      "provisionedCidrs": this.provisionedCidrs,
      "publicIpSource": this.publicIpSource,
      "publiclyAdvertisable": this.publiclyAdvertisable,
      "sourceIpamPoolId": this.sourceIpamPoolId,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnIPAMPool.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnIPAMPoolPropsToCloudFormation(props);
  }
}

export namespace CfnIPAMPool {
  /**
   * The CIDR provisioned to the IPAM pool.
   *
   * A CIDR is a representation of an IP address and its associated network mask (or netmask) and refers to a range of IP addresses. An IPv4 CIDR example is \`10.24.34.0/23\` . An IPv6 CIDR example is \`2001:DB8::/32\` .
   *
   * > This resource type does not allow you to provision a CIDR using the netmask length. To provision a CIDR using netmask length, use [AWS::EC2::IPAMPoolCidr](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampoolcidr.html) .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipampool-provisionedcidr.html
   */
  export interface ProvisionedCidrProperty {
    /**
     * The CIDR provisioned to the IPAM pool.
     *
     * A CIDR is a representation of an IP address and its associated network mask (or netmask) and refers to a range of IP addresses. An IPv4 CIDR example is \`10.24.34.0/23\` . An IPv6 CIDR example is \`2001:DB8::/32\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipampool-provisionedcidr.html#cfn-ec2-ipampool-provisionedcidr-cidr
     */
    readonly cidr: string;
  }
}

/**
 * Properties for defining a \`CfnIPAMPool\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html
 */
export interface CfnIPAMPoolProps {
  /**
   * The address family of the pool.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-addressfamily
   */
  readonly addressFamily: string;

  /**
   * The default netmask length for allocations added to this pool.
   *
   * If, for example, the CIDR assigned to this pool is 10.0.0.0/8 and you enter 16 here, new allocations will default to 10.0.0.0/16.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-allocationdefaultnetmasklength
   */
  readonly allocationDefaultNetmaskLength?: number;

  /**
   * The maximum netmask length possible for CIDR allocations in this IPAM pool to be compliant.
   *
   * The maximum netmask length must be greater than the minimum netmask length. Possible netmask lengths for IPv4 addresses are 0 - 32. Possible netmask lengths for IPv6 addresses are 0 - 128.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-allocationmaxnetmasklength
   */
  readonly allocationMaxNetmaskLength?: number;

  /**
   * The minimum netmask length required for CIDR allocations in this IPAM pool to be compliant.
   *
   * The minimum netmask length must be less than the maximum netmask length. Possible netmask lengths for IPv4 addresses are 0 - 32. Possible netmask lengths for IPv6 addresses are 0 - 128.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-allocationminnetmasklength
   */
  readonly allocationMinNetmaskLength?: number;

  /**
   * Tags that are required for resources that use CIDRs from this IPAM pool.
   *
   * Resources that do not have these tags will not be allowed to allocate space from the pool. If the resources have their tags changed after they have allocated space or if the allocation tagging requirements are changed on the pool, the resource may be marked as noncompliant.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-allocationresourcetags
   */
  readonly allocationResourceTags?: Array<cdk.CfnTag | cdk.IResolvable> | cdk.IResolvable;

  /**
   * If selected, IPAM will continuously look for resources within the CIDR range of this pool and automatically import them as allocations into your IPAM.
   *
   * The CIDRs that will be allocated for these resources must not already be allocated to other resources in order for the import to succeed. IPAM will import a CIDR regardless of its compliance with the pool's allocation rules, so a resource might be imported and subsequently marked as noncompliant. If IPAM discovers multiple CIDRs that overlap, IPAM will import the largest CIDR only. If IPAM discovers multiple CIDRs with matching CIDRs, IPAM will randomly import one of them only.
   *
   * A locale must be set on the pool for this feature to work.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-autoimport
   */
  readonly autoImport?: boolean | cdk.IResolvable;

  /**
   * Limits which service in AWS that the pool can be used in.
   *
   * "ec2", for example, allows users to use space for Elastic IP addresses and VPCs.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-awsservice
   */
  readonly awsService?: string;

  /**
   * The description of the IPAM pool.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-description
   */
  readonly description?: string;

  /**
   * The ID of the scope in which you would like to create the IPAM pool.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-ipamscopeid
   */
  readonly ipamScopeId: string;

  /**
   * The locale of the IPAM pool.
   *
   * In IPAM, the locale is the AWS Region where you want to make an IPAM pool available for allocations. Only resources in the same Region as the locale of the pool can get IP address allocations from the pool. You can only allocate a CIDR for a VPC, for example, from an IPAM pool that shares a locale with the VPCs Region. Note that once you choose a Locale for a pool, you cannot modify it. If you choose an AWS Region for locale that has not been configured as an operating Region for the IPAM, you'll get an error.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-locale
   */
  readonly locale?: string;

  /**
   * Information about the CIDRs provisioned to an IPAM pool.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-provisionedcidrs
   */
  readonly provisionedCidrs?: Array<cdk.IResolvable | CfnIPAMPool.ProvisionedCidrProperty> | cdk.IResolvable;

  /**
   * The IP address source for pools in the public scope.
   *
   * Only used for provisioning IP address CIDRs to pools in the public scope. Default is \`BYOIP\` . For more information, see [Create IPv6 pools](https://docs.aws.amazon.com//vpc/latest/ipam/intro-create-ipv6-pools.html) in the *Amazon VPC IPAM User Guide* . By default, you can add only one Amazon-provided IPv6 CIDR block to a top-level IPv6 pool. For information on increasing the default limit, see [Quotas for your IPAM](https://docs.aws.amazon.com//vpc/latest/ipam/quotas-ipam.html) in the *Amazon VPC IPAM User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-publicipsource
   */
  readonly publicIpSource?: string;

  /**
   * Determines if a pool is publicly advertisable.
   *
   * This option is not available for pools with AddressFamily set to \`ipv4\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-publiclyadvertisable
   */
  readonly publiclyAdvertisable?: boolean | cdk.IResolvable;

  /**
   * The ID of the source IPAM pool.
   *
   * You can use this option to create an IPAM pool within an existing source pool.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-sourceipampoolid
   */
  readonly sourceIpamPoolId?: string;

  /**
   * The key/value combination of a tag assigned to the resource.
   *
   * Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key \`Owner\` and the value \`TeamA\` , specify \`tag:Owner\` for the filter name and \`TeamA\` for the filter value.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a \`ProvisionedCidrProperty\`
 *
 * @param properties - the TypeScript properties of a \`ProvisionedCidrProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnIPAMPoolProvisionedCidrPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("cidr", cdk.requiredValidator)(properties.cidr));
  errors.collect(cdk.propertyValidator("cidr", cdk.validateString)(properties.cidr));
  return errors.wrap("supplied properties not correct for \\"ProvisionedCidrProperty\\"");
}

// @ts-ignore TS6133
function convertCfnIPAMPoolProvisionedCidrPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnIPAMPoolProvisionedCidrPropertyValidator(properties).assertSuccess();
  return {
    "Cidr": cdk.stringToCloudFormation(properties.cidr)
  };
}

// @ts-ignore TS6133
function CfnIPAMPoolProvisionedCidrPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnIPAMPool.ProvisionedCidrProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnIPAMPool.ProvisionedCidrProperty>();
  ret.addPropertyResult("cidr", "Cidr", (properties.Cidr != null ? cfn_parse.FromCloudFormation.getString(properties.Cidr) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnIPAMPoolProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnIPAMPoolProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnIPAMPoolPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("addressFamily", cdk.requiredValidator)(properties.addressFamily));
  errors.collect(cdk.propertyValidator("addressFamily", cdk.validateString)(properties.addressFamily));
  errors.collect(cdk.propertyValidator("allocationDefaultNetmaskLength", cdk.validateNumber)(properties.allocationDefaultNetmaskLength));
  errors.collect(cdk.propertyValidator("allocationMaxNetmaskLength", cdk.validateNumber)(properties.allocationMaxNetmaskLength));
  errors.collect(cdk.propertyValidator("allocationMinNetmaskLength", cdk.validateNumber)(properties.allocationMinNetmaskLength));
  errors.collect(cdk.propertyValidator("allocationResourceTags", cdk.listValidator(cdk.validateCfnTag))(properties.allocationResourceTags));
  errors.collect(cdk.propertyValidator("autoImport", cdk.validateBoolean)(properties.autoImport));
  errors.collect(cdk.propertyValidator("awsService", cdk.validateString)(properties.awsService));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("ipamScopeId", cdk.requiredValidator)(properties.ipamScopeId));
  errors.collect(cdk.propertyValidator("ipamScopeId", cdk.validateString)(properties.ipamScopeId));
  errors.collect(cdk.propertyValidator("locale", cdk.validateString)(properties.locale));
  errors.collect(cdk.propertyValidator("provisionedCidrs", cdk.listValidator(CfnIPAMPoolProvisionedCidrPropertyValidator))(properties.provisionedCidrs));
  errors.collect(cdk.propertyValidator("publicIpSource", cdk.validateString)(properties.publicIpSource));
  errors.collect(cdk.propertyValidator("publiclyAdvertisable", cdk.validateBoolean)(properties.publiclyAdvertisable));
  errors.collect(cdk.propertyValidator("sourceIpamPoolId", cdk.validateString)(properties.sourceIpamPoolId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnIPAMPoolProps\\"");
}

// @ts-ignore TS6133
function convertCfnIPAMPoolPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnIPAMPoolPropsValidator(properties).assertSuccess();
  return {
    "AddressFamily": cdk.stringToCloudFormation(properties.addressFamily),
    "AllocationDefaultNetmaskLength": cdk.numberToCloudFormation(properties.allocationDefaultNetmaskLength),
    "AllocationMaxNetmaskLength": cdk.numberToCloudFormation(properties.allocationMaxNetmaskLength),
    "AllocationMinNetmaskLength": cdk.numberToCloudFormation(properties.allocationMinNetmaskLength),
    "AllocationResourceTags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.allocationResourceTags),
    "AutoImport": cdk.booleanToCloudFormation(properties.autoImport),
    "AwsService": cdk.stringToCloudFormation(properties.awsService),
    "Description": cdk.stringToCloudFormation(properties.description),
    "IpamScopeId": cdk.stringToCloudFormation(properties.ipamScopeId),
    "Locale": cdk.stringToCloudFormation(properties.locale),
    "ProvisionedCidrs": cdk.listMapper(convertCfnIPAMPoolProvisionedCidrPropertyToCloudFormation)(properties.provisionedCidrs),
    "PublicIpSource": cdk.stringToCloudFormation(properties.publicIpSource),
    "PubliclyAdvertisable": cdk.booleanToCloudFormation(properties.publiclyAdvertisable),
    "SourceIpamPoolId": cdk.stringToCloudFormation(properties.sourceIpamPoolId),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnIPAMPoolPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnIPAMPoolProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnIPAMPoolProps>();
  ret.addPropertyResult("addressFamily", "AddressFamily", (properties.AddressFamily != null ? cfn_parse.FromCloudFormation.getString(properties.AddressFamily) : undefined));
  ret.addPropertyResult("allocationDefaultNetmaskLength", "AllocationDefaultNetmaskLength", (properties.AllocationDefaultNetmaskLength != null ? cfn_parse.FromCloudFormation.getNumber(properties.AllocationDefaultNetmaskLength) : undefined));
  ret.addPropertyResult("allocationMaxNetmaskLength", "AllocationMaxNetmaskLength", (properties.AllocationMaxNetmaskLength != null ? cfn_parse.FromCloudFormation.getNumber(properties.AllocationMaxNetmaskLength) : undefined));
  ret.addPropertyResult("allocationMinNetmaskLength", "AllocationMinNetmaskLength", (properties.AllocationMinNetmaskLength != null ? cfn_parse.FromCloudFormation.getNumber(properties.AllocationMinNetmaskLength) : undefined));
  ret.addPropertyResult("allocationResourceTags", "AllocationResourceTags", (properties.AllocationResourceTags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.AllocationResourceTags) : undefined));
  ret.addPropertyResult("autoImport", "AutoImport", (properties.AutoImport != null ? cfn_parse.FromCloudFormation.getBoolean(properties.AutoImport) : undefined));
  ret.addPropertyResult("awsService", "AwsService", (properties.AwsService != null ? cfn_parse.FromCloudFormation.getString(properties.AwsService) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("ipamScopeId", "IpamScopeId", (properties.IpamScopeId != null ? cfn_parse.FromCloudFormation.getString(properties.IpamScopeId) : undefined));
  ret.addPropertyResult("locale", "Locale", (properties.Locale != null ? cfn_parse.FromCloudFormation.getString(properties.Locale) : undefined));
  ret.addPropertyResult("provisionedCidrs", "ProvisionedCidrs", (properties.ProvisionedCidrs != null ? cfn_parse.FromCloudFormation.getArray(CfnIPAMPoolProvisionedCidrPropertyFromCloudFormation)(properties.ProvisionedCidrs) : undefined));
  ret.addPropertyResult("publicIpSource", "PublicIpSource", (properties.PublicIpSource != null ? cfn_parse.FromCloudFormation.getString(properties.PublicIpSource) : undefined));
  ret.addPropertyResult("publiclyAdvertisable", "PubliclyAdvertisable", (properties.PubliclyAdvertisable != null ? cfn_parse.FromCloudFormation.getBoolean(properties.PubliclyAdvertisable) : undefined));
  ret.addPropertyResult("sourceIpamPoolId", "SourceIpamPoolId", (properties.SourceIpamPoolId != null ? cfn_parse.FromCloudFormation.getString(properties.SourceIpamPoolId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * A CIDR provisioned to an IPAM pool.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampoolcidr.html
 */
export class CfnIPAMPoolCidr extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::IPAMPoolCidr";

  /**
   * Build a CfnIPAMPoolCidr from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnIPAMPoolCidr {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnIPAMPoolCidrPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnIPAMPoolCidr(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The IPAM pool CIDR ID.
   *
   * @cloudformationAttribute IpamPoolCidrId
   */
  public readonly attrIpamPoolCidrId: string;

  /**
   * The state of the CIDR.
   *
   * @cloudformationAttribute State
   */
  public readonly attrState: string;

  /**
   * The CIDR provisioned to the IPAM pool.
   */
  public cidr?: string;

  /**
   * The ID of the IPAM pool.
   */
  public ipamPoolId: string;

  /**
   * The netmask length of the CIDR you'd like to provision to a pool.
   */
  public netmaskLength?: number;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnIPAMPoolCidrProps) {
    super(scope, id, {
      "type": CfnIPAMPoolCidr.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "ipamPoolId", this);

    this.attrIpamPoolCidrId = cdk.Token.asString(this.getAtt("IpamPoolCidrId", cdk.ResolutionTypeHint.STRING));
    this.attrState = cdk.Token.asString(this.getAtt("State", cdk.ResolutionTypeHint.STRING));
    this.cidr = props.cidr;
    this.ipamPoolId = props.ipamPoolId;
    this.netmaskLength = props.netmaskLength;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "cidr": this.cidr,
      "ipamPoolId": this.ipamPoolId,
      "netmaskLength": this.netmaskLength
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnIPAMPoolCidr.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnIPAMPoolCidrPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnIPAMPoolCidr\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampoolcidr.html
 */
export interface CfnIPAMPoolCidrProps {
  /**
   * The CIDR provisioned to the IPAM pool.
   *
   * A CIDR is a representation of an IP address and its associated network mask (or netmask) and refers to a range of IP addresses. An IPv4 CIDR example is \`10.24.34.0/23\` . An IPv6 CIDR example is \`2001:DB8::/32\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampoolcidr.html#cfn-ec2-ipampoolcidr-cidr
   */
  readonly cidr?: string;

  /**
   * The ID of the IPAM pool.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampoolcidr.html#cfn-ec2-ipampoolcidr-ipampoolid
   */
  readonly ipamPoolId: string;

  /**
   * The netmask length of the CIDR you'd like to provision to a pool.
   *
   * Can be used for provisioning Amazon-provided IPv6 CIDRs to top-level pools and for provisioning CIDRs to pools with source pools. Cannot be used to provision BYOIP CIDRs to top-level pools. "NetmaskLength" or "Cidr" is required.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampoolcidr.html#cfn-ec2-ipampoolcidr-netmasklength
   */
  readonly netmaskLength?: number;
}

/**
 * Determine whether the given properties match those of a \`CfnIPAMPoolCidrProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnIPAMPoolCidrProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnIPAMPoolCidrPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("cidr", cdk.validateString)(properties.cidr));
  errors.collect(cdk.propertyValidator("ipamPoolId", cdk.requiredValidator)(properties.ipamPoolId));
  errors.collect(cdk.propertyValidator("ipamPoolId", cdk.validateString)(properties.ipamPoolId));
  errors.collect(cdk.propertyValidator("netmaskLength", cdk.validateNumber)(properties.netmaskLength));
  return errors.wrap("supplied properties not correct for \\"CfnIPAMPoolCidrProps\\"");
}

// @ts-ignore TS6133
function convertCfnIPAMPoolCidrPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnIPAMPoolCidrPropsValidator(properties).assertSuccess();
  return {
    "Cidr": cdk.stringToCloudFormation(properties.cidr),
    "IpamPoolId": cdk.stringToCloudFormation(properties.ipamPoolId),
    "NetmaskLength": cdk.numberToCloudFormation(properties.netmaskLength)
  };
}

// @ts-ignore TS6133
function CfnIPAMPoolCidrPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnIPAMPoolCidrProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnIPAMPoolCidrProps>();
  ret.addPropertyResult("cidr", "Cidr", (properties.Cidr != null ? cfn_parse.FromCloudFormation.getString(properties.Cidr) : undefined));
  ret.addPropertyResult("ipamPoolId", "IpamPoolId", (properties.IpamPoolId != null ? cfn_parse.FromCloudFormation.getString(properties.IpamPoolId) : undefined));
  ret.addPropertyResult("netmaskLength", "NetmaskLength", (properties.NetmaskLength != null ? cfn_parse.FromCloudFormation.getNumber(properties.NetmaskLength) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * A resource discovery is an IPAM component that enables IPAM to manage and monitor resources that belong to the owning account.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamresourcediscovery.html
 */
export class CfnIPAMResourceDiscovery extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::IPAMResourceDiscovery";

  /**
   * Build a CfnIPAMResourceDiscovery from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnIPAMResourceDiscovery {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnIPAMResourceDiscoveryPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnIPAMResourceDiscovery(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The resource discovery ARN.
   *
   * @cloudformationAttribute IpamResourceDiscoveryArn
   */
  public readonly attrIpamResourceDiscoveryArn: string;

  /**
   * The resource discovery ID.
   *
   * @cloudformationAttribute IpamResourceDiscoveryId
   */
  public readonly attrIpamResourceDiscoveryId: string;

  /**
   * The resource discovery Region.
   *
   * @cloudformationAttribute IpamResourceDiscoveryRegion
   */
  public readonly attrIpamResourceDiscoveryRegion: string;

  /**
   * Defines if the resource discovery is the default. The default resource discovery is the resource discovery automatically created when you create an IPAM.
   *
   * @cloudformationAttribute IsDefault
   */
  public readonly attrIsDefault: cdk.IResolvable;

  /**
   * The owner ID.
   *
   * @cloudformationAttribute OwnerId
   */
  public readonly attrOwnerId: string;

  /**
   * The resource discovery's state.
   *
   * - \`create-in-progress\` - Resource discovery is being created.
   * - \`create-complete\` - Resource discovery creation is complete.
   * - \`create-failed\` - Resource discovery creation has failed.
   * - \`modify-in-progress\` - Resource discovery is being modified.
   * - \`modify-complete\` - Resource discovery modification is complete.
   * - \`modify-failed\` - Resource discovery modification has failed.
   * - \`delete-in-progress\` - Resource discovery is being deleted.
   * - \`delete-complete\` - Resource discovery deletion is complete.
   * - \`delete-failed\` - Resource discovery deletion has failed.
   * - \`isolate-in-progress\` - AWS account that created the resource discovery has been removed and the resource discovery is being isolated.
   * - \`isolate-complete\` - Resource discovery isolation is complete.
   * - \`restore-in-progress\` - AWS account that created the resource discovery and was isolated has been restored.
   *
   * @cloudformationAttribute State
   */
  public readonly attrState: string;

  /**
   * The resource discovery description.
   */
  public description?: string;

  /**
   * The operating Regions for the resource discovery.
   */
  public operatingRegions?: Array<CfnIPAMResourceDiscovery.IpamOperatingRegionProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * A tag is a label that you assign to an AWS resource.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnIPAMResourceDiscoveryProps = {}) {
    super(scope, id, {
      "type": CfnIPAMResourceDiscovery.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.attrIpamResourceDiscoveryArn = cdk.Token.asString(this.getAtt("IpamResourceDiscoveryArn", cdk.ResolutionTypeHint.STRING));
    this.attrIpamResourceDiscoveryId = cdk.Token.asString(this.getAtt("IpamResourceDiscoveryId", cdk.ResolutionTypeHint.STRING));
    this.attrIpamResourceDiscoveryRegion = cdk.Token.asString(this.getAtt("IpamResourceDiscoveryRegion", cdk.ResolutionTypeHint.STRING));
    this.attrIsDefault = this.getAtt("IsDefault");
    this.attrOwnerId = cdk.Token.asString(this.getAtt("OwnerId", cdk.ResolutionTypeHint.STRING));
    this.attrState = cdk.Token.asString(this.getAtt("State", cdk.ResolutionTypeHint.STRING));
    this.description = props.description;
    this.operatingRegions = props.operatingRegions;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::IPAMResourceDiscovery", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "description": this.description,
      "operatingRegions": this.operatingRegions,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnIPAMResourceDiscovery.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnIPAMResourceDiscoveryPropsToCloudFormation(props);
  }
}

export namespace CfnIPAMResourceDiscovery {
  /**
   * The operating Regions for an IPAM.
   *
   * Operating Regions are AWS Regions where the IPAM is allowed to manage IP address CIDRs. IPAM only discovers and monitors resources in the AWS Regions you select as operating Regions.
   *
   * For more information about operating Regions, see [Create an IPAM](https://docs.aws.amazon.com//vpc/latest/ipam/create-ipam.html) in the *Amazon VPC IPAM User Guide* .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipamresourcediscovery-ipamoperatingregion.html
   */
  export interface IpamOperatingRegionProperty {
    /**
     * The name of the operating Region.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipamresourcediscovery-ipamoperatingregion.html#cfn-ec2-ipamresourcediscovery-ipamoperatingregion-regionname
     */
    readonly regionName: string;
  }
}

/**
 * Properties for defining a \`CfnIPAMResourceDiscovery\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamresourcediscovery.html
 */
export interface CfnIPAMResourceDiscoveryProps {
  /**
   * The resource discovery description.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamresourcediscovery.html#cfn-ec2-ipamresourcediscovery-description
   */
  readonly description?: string;

  /**
   * The operating Regions for the resource discovery.
   *
   * Operating Regions are AWS Regions where the IPAM is allowed to manage IP address CIDRs. IPAM only discovers and monitors resources in the AWS Regions you select as operating Regions.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamresourcediscovery.html#cfn-ec2-ipamresourcediscovery-operatingregions
   */
  readonly operatingRegions?: Array<CfnIPAMResourceDiscovery.IpamOperatingRegionProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * A tag is a label that you assign to an AWS resource.
   *
   * Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your AWS costs.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamresourcediscovery.html#cfn-ec2-ipamresourcediscovery-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a \`IpamOperatingRegionProperty\`
 *
 * @param properties - the TypeScript properties of a \`IpamOperatingRegionProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnIPAMResourceDiscoveryIpamOperatingRegionPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("regionName", cdk.requiredValidator)(properties.regionName));
  errors.collect(cdk.propertyValidator("regionName", cdk.validateString)(properties.regionName));
  return errors.wrap("supplied properties not correct for \\"IpamOperatingRegionProperty\\"");
}

// @ts-ignore TS6133
function convertCfnIPAMResourceDiscoveryIpamOperatingRegionPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnIPAMResourceDiscoveryIpamOperatingRegionPropertyValidator(properties).assertSuccess();
  return {
    "RegionName": cdk.stringToCloudFormation(properties.regionName)
  };
}

// @ts-ignore TS6133
function CfnIPAMResourceDiscoveryIpamOperatingRegionPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnIPAMResourceDiscovery.IpamOperatingRegionProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnIPAMResourceDiscovery.IpamOperatingRegionProperty>();
  ret.addPropertyResult("regionName", "RegionName", (properties.RegionName != null ? cfn_parse.FromCloudFormation.getString(properties.RegionName) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnIPAMResourceDiscoveryProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnIPAMResourceDiscoveryProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnIPAMResourceDiscoveryPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("operatingRegions", cdk.listValidator(CfnIPAMResourceDiscoveryIpamOperatingRegionPropertyValidator))(properties.operatingRegions));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnIPAMResourceDiscoveryProps\\"");
}

// @ts-ignore TS6133
function convertCfnIPAMResourceDiscoveryPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnIPAMResourceDiscoveryPropsValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "OperatingRegions": cdk.listMapper(convertCfnIPAMResourceDiscoveryIpamOperatingRegionPropertyToCloudFormation)(properties.operatingRegions),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnIPAMResourceDiscoveryPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnIPAMResourceDiscoveryProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnIPAMResourceDiscoveryProps>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("operatingRegions", "OperatingRegions", (properties.OperatingRegions != null ? cfn_parse.FromCloudFormation.getArray(CfnIPAMResourceDiscoveryIpamOperatingRegionPropertyFromCloudFormation)(properties.OperatingRegions) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * An IPAM resource discovery association.
 *
 * An associated resource discovery is a resource discovery that has been associated with an IPAM. IPAM aggregates the resource CIDRs discovered by the associated resource discovery.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamresourcediscoveryassociation.html
 */
export class CfnIPAMResourceDiscoveryAssociation extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::IPAMResourceDiscoveryAssociation";

  /**
   * Build a CfnIPAMResourceDiscoveryAssociation from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnIPAMResourceDiscoveryAssociation {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnIPAMResourceDiscoveryAssociationPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnIPAMResourceDiscoveryAssociation(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The IPAM ARN.
   *
   * @cloudformationAttribute IpamArn
   */
  public readonly attrIpamArn: string;

  /**
   * The IPAM home Region.
   *
   * @cloudformationAttribute IpamRegion
   */
  public readonly attrIpamRegion: string;

  /**
   * The resource discovery association ARN.
   *
   * @cloudformationAttribute IpamResourceDiscoveryAssociationArn
   */
  public readonly attrIpamResourceDiscoveryAssociationArn: string;

  /**
   * The resource discovery association ID.
   *
   * @cloudformationAttribute IpamResourceDiscoveryAssociationId
   */
  public readonly attrIpamResourceDiscoveryAssociationId: string;

  /**
   * Defines if the resource discovery is the default. When you create an IPAM, a default resource discovery is created for your IPAM and it's associated with your IPAM.
   *
   * @cloudformationAttribute IsDefault
   */
  public readonly attrIsDefault: cdk.IResolvable;

  /**
   * The owner ID.
   *
   * @cloudformationAttribute OwnerId
   */
  public readonly attrOwnerId: string;

  /**
   * The resource discovery status.
   *
   * - \`active\` - Connection or permissions required to read the results of the resource discovery are intact.
   * - \`not-found\` - Connection or permissions required to read the results of the resource discovery are broken. This may happen if the owner of the resource discovery stopped sharing it or deleted the resource discovery. Verify the resource discovery still exists and the AWS RAM resource share is still intact.
   *
   * @cloudformationAttribute ResourceDiscoveryStatus
   */
  public readonly attrResourceDiscoveryStatus: string;

  /**
   * The lifecycle state of the association when you associate or disassociate a resource discovery.
   *
   * - \`associate-in-progress\` - Resource discovery is being associated.
   * - \`associate-complete\` - Resource discovery association is complete.
   * - \`associate-failed\` - Resource discovery association has failed.
   * - \`disassociate-in-progress\` - Resource discovery is being disassociated.
   * - \`disassociate-complete\` - Resource discovery disassociation is complete.
   * - \`disassociate-failed\` - Resource discovery disassociation has failed.
   * - \`isolate-in-progress\` - AWS account that created the resource discovery association has been removed and the resource discovery associatation is being isolated.
   * - \`isolate-complete\` - Resource discovery isolation is complete..
   * - \`restore-in-progress\` - Resource discovery is being restored.
   *
   * @cloudformationAttribute State
   */
  public readonly attrState: string;

  /**
   * The IPAM ID.
   */
  public ipamId: string;

  /**
   * The resource discovery ID.
   */
  public ipamResourceDiscoveryId: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * A tag is a label that you assign to an AWS resource.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnIPAMResourceDiscoveryAssociationProps) {
    super(scope, id, {
      "type": CfnIPAMResourceDiscoveryAssociation.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "ipamId", this);
    cdk.requireProperty(props, "ipamResourceDiscoveryId", this);

    this.attrIpamArn = cdk.Token.asString(this.getAtt("IpamArn", cdk.ResolutionTypeHint.STRING));
    this.attrIpamRegion = cdk.Token.asString(this.getAtt("IpamRegion", cdk.ResolutionTypeHint.STRING));
    this.attrIpamResourceDiscoveryAssociationArn = cdk.Token.asString(this.getAtt("IpamResourceDiscoveryAssociationArn", cdk.ResolutionTypeHint.STRING));
    this.attrIpamResourceDiscoveryAssociationId = cdk.Token.asString(this.getAtt("IpamResourceDiscoveryAssociationId", cdk.ResolutionTypeHint.STRING));
    this.attrIsDefault = this.getAtt("IsDefault");
    this.attrOwnerId = cdk.Token.asString(this.getAtt("OwnerId", cdk.ResolutionTypeHint.STRING));
    this.attrResourceDiscoveryStatus = cdk.Token.asString(this.getAtt("ResourceDiscoveryStatus", cdk.ResolutionTypeHint.STRING));
    this.attrState = cdk.Token.asString(this.getAtt("State", cdk.ResolutionTypeHint.STRING));
    this.ipamId = props.ipamId;
    this.ipamResourceDiscoveryId = props.ipamResourceDiscoveryId;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::IPAMResourceDiscoveryAssociation", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "ipamId": this.ipamId,
      "ipamResourceDiscoveryId": this.ipamResourceDiscoveryId,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnIPAMResourceDiscoveryAssociation.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnIPAMResourceDiscoveryAssociationPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnIPAMResourceDiscoveryAssociation\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamresourcediscoveryassociation.html
 */
export interface CfnIPAMResourceDiscoveryAssociationProps {
  /**
   * The IPAM ID.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamresourcediscoveryassociation.html#cfn-ec2-ipamresourcediscoveryassociation-ipamid
   */
  readonly ipamId: string;

  /**
   * The resource discovery ID.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamresourcediscoveryassociation.html#cfn-ec2-ipamresourcediscoveryassociation-ipamresourcediscoveryid
   */
  readonly ipamResourceDiscoveryId: string;

  /**
   * A tag is a label that you assign to an AWS resource.
   *
   * Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your AWS costs.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamresourcediscoveryassociation.html#cfn-ec2-ipamresourcediscoveryassociation-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a \`CfnIPAMResourceDiscoveryAssociationProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnIPAMResourceDiscoveryAssociationProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnIPAMResourceDiscoveryAssociationPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("ipamId", cdk.requiredValidator)(properties.ipamId));
  errors.collect(cdk.propertyValidator("ipamId", cdk.validateString)(properties.ipamId));
  errors.collect(cdk.propertyValidator("ipamResourceDiscoveryId", cdk.requiredValidator)(properties.ipamResourceDiscoveryId));
  errors.collect(cdk.propertyValidator("ipamResourceDiscoveryId", cdk.validateString)(properties.ipamResourceDiscoveryId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnIPAMResourceDiscoveryAssociationProps\\"");
}

// @ts-ignore TS6133
function convertCfnIPAMResourceDiscoveryAssociationPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnIPAMResourceDiscoveryAssociationPropsValidator(properties).assertSuccess();
  return {
    "IpamId": cdk.stringToCloudFormation(properties.ipamId),
    "IpamResourceDiscoveryId": cdk.stringToCloudFormation(properties.ipamResourceDiscoveryId),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnIPAMResourceDiscoveryAssociationPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnIPAMResourceDiscoveryAssociationProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnIPAMResourceDiscoveryAssociationProps>();
  ret.addPropertyResult("ipamId", "IpamId", (properties.IpamId != null ? cfn_parse.FromCloudFormation.getString(properties.IpamId) : undefined));
  ret.addPropertyResult("ipamResourceDiscoveryId", "IpamResourceDiscoveryId", (properties.IpamResourceDiscoveryId != null ? cfn_parse.FromCloudFormation.getString(properties.IpamResourceDiscoveryId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * In IPAM, a scope is the highest-level container within IPAM.
 *
 * An IPAM contains two default scopes. Each scope represents the IP space for a single network. The private scope is intended for all private IP address space. The public scope is intended for all public IP address space. Scopes enable you to reuse IP addresses across multiple unconnected networks without causing IP address overlap or conflict.
 *
 * For more information, see [How IPAM works](https://docs.aws.amazon.com//vpc/latest/ipam/how-it-works-ipam.html) in the *Amazon VPC IPAM User Guide* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamscope.html
 */
export class CfnIPAMScope extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::IPAMScope";

  /**
   * Build a CfnIPAMScope from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnIPAMScope {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnIPAMScopePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnIPAMScope(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ARN of the scope.
   *
   * @cloudformationAttribute Arn
   */
  public readonly attrArn: string;

  /**
   * The ARN of an IPAM.
   *
   * @cloudformationAttribute IpamArn
   */
  public readonly attrIpamArn: string;

  /**
   * The ID of an IPAM scope.
   *
   * @cloudformationAttribute IpamScopeId
   */
  public readonly attrIpamScopeId: string;

  /**
   * The type of the scope.
   *
   * @cloudformationAttribute IpamScopeType
   */
  public readonly attrIpamScopeType: string;

  /**
   * Defines if the scope is the default scope or not.
   *
   * @cloudformationAttribute IsDefault
   */
  public readonly attrIsDefault: cdk.IResolvable;

  /**
   * The number of pools in a scope.
   *
   * @cloudformationAttribute PoolCount
   */
  public readonly attrPoolCount: number;

  /**
   * The description of the scope.
   */
  public description?: string;

  /**
   * The ID of the IPAM for which you're creating this scope.
   */
  public ipamId: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The key/value combination of a tag assigned to the resource.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnIPAMScopeProps) {
    super(scope, id, {
      "type": CfnIPAMScope.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "ipamId", this);

    this.attrArn = cdk.Token.asString(this.getAtt("Arn", cdk.ResolutionTypeHint.STRING));
    this.attrIpamArn = cdk.Token.asString(this.getAtt("IpamArn", cdk.ResolutionTypeHint.STRING));
    this.attrIpamScopeId = cdk.Token.asString(this.getAtt("IpamScopeId", cdk.ResolutionTypeHint.STRING));
    this.attrIpamScopeType = cdk.Token.asString(this.getAtt("IpamScopeType", cdk.ResolutionTypeHint.STRING));
    this.attrIsDefault = this.getAtt("IsDefault");
    this.attrPoolCount = cdk.Token.asNumber(this.getAtt("PoolCount", cdk.ResolutionTypeHint.NUMBER));
    this.description = props.description;
    this.ipamId = props.ipamId;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::IPAMScope", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "description": this.description,
      "ipamId": this.ipamId,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnIPAMScope.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnIPAMScopePropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnIPAMScope\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamscope.html
 */
export interface CfnIPAMScopeProps {
  /**
   * The description of the scope.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamscope.html#cfn-ec2-ipamscope-description
   */
  readonly description?: string;

  /**
   * The ID of the IPAM for which you're creating this scope.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamscope.html#cfn-ec2-ipamscope-ipamid
   */
  readonly ipamId: string;

  /**
   * The key/value combination of a tag assigned to the resource.
   *
   * Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key \`Owner\` and the value \`TeamA\` , specify \`tag:Owner\` for the filter name and \`TeamA\` for the filter value.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamscope.html#cfn-ec2-ipamscope-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a \`CfnIPAMScopeProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnIPAMScopeProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnIPAMScopePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("ipamId", cdk.requiredValidator)(properties.ipamId));
  errors.collect(cdk.propertyValidator("ipamId", cdk.validateString)(properties.ipamId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnIPAMScopeProps\\"");
}

// @ts-ignore TS6133
function convertCfnIPAMScopePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnIPAMScopePropsValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "IpamId": cdk.stringToCloudFormation(properties.ipamId),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnIPAMScopePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnIPAMScopeProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnIPAMScopeProps>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("ipamId", "IpamId", (properties.IpamId != null ? cfn_parse.FromCloudFormation.getString(properties.IpamId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a key pair for use with an Amazon Elastic Compute Cloud instance as follows:.
 *
 * - To import an existing key pair, include the \`PublicKeyMaterial\` property.
 * - To create a new key pair, omit the \`PublicKeyMaterial\` property.
 *
 * When you import an existing key pair, you specify the public key material for the key. We assume that you have the private key material for the key. AWS CloudFormation does not create or return the private key material when you import a key pair.
 *
 * When you create a new key pair, the private key is saved to AWS Systems Manager Parameter Store, using a parameter with the following name: \`/ec2/keypair/{key_pair_id}\` . For more information about retrieving private key, and the required permissions, see [Create a key pair using AWS CloudFormation](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/create-key-pairs.html#create-key-pair-cloudformation) in the *Amazon EC2 User Guide* .
 *
 * When AWS CloudFormation deletes a key pair that was created or imported by a stack, it also deletes the parameter that was used to store the private key material in Parameter Store.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-keypair.html
 */
export class CfnKeyPair extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::KeyPair";

  /**
   * Build a CfnKeyPair from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnKeyPair {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnKeyPairPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnKeyPair(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * If you created the key pair using Amazon EC2:
   *
   * - For RSA key pairs, the key fingerprint is the SHA-1 digest of the DER encoded private key.
   * - For ED25519 key pairs, the key fingerprint is the base64-encoded SHA-256 digest, which is the default for OpenSSH, starting with [OpenSSH 6.8](https://docs.aws.amazon.com/http://www.openssh.com/txt/release-6.8) .
   *
   * If you imported the key pair to Amazon EC2:
   *
   * - For RSA key pairs, the key fingerprint is the MD5 public key fingerprint as specified in section 4 of RFC 4716.
   * - For ED25519 key pairs, the key fingerprint is the base64-encoded SHA-256 digest, which is the default for OpenSSH, starting with [OpenSSH 6.8](https://docs.aws.amazon.com/http://www.openssh.com/txt/release-6.8) .
   *
   * @cloudformationAttribute KeyFingerprint
   */
  public readonly attrKeyFingerprint: string;

  /**
   * The ID of the key pair.
   *
   * @cloudformationAttribute KeyPairId
   */
  public readonly attrKeyPairId: string;

  /**
   * The format of the key pair.
   */
  public keyFormat?: string;

  /**
   * A unique name for the key pair.
   */
  public keyName: string;

  /**
   * The type of key pair. Note that ED25519 keys are not supported for Windows instances.
   */
  public keyType?: string;

  /**
   * The public key material.
   */
  public publicKeyMaterial?: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags to apply to the key pair.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnKeyPairProps) {
    super(scope, id, {
      "type": CfnKeyPair.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "keyName", this);

    this.attrKeyFingerprint = cdk.Token.asString(this.getAtt("KeyFingerprint", cdk.ResolutionTypeHint.STRING));
    this.attrKeyPairId = cdk.Token.asString(this.getAtt("KeyPairId", cdk.ResolutionTypeHint.STRING));
    this.keyFormat = props.keyFormat;
    this.keyName = props.keyName;
    this.keyType = props.keyType;
    this.publicKeyMaterial = props.publicKeyMaterial;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::KeyPair", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "keyFormat": this.keyFormat,
      "keyName": this.keyName,
      "keyType": this.keyType,
      "publicKeyMaterial": this.publicKeyMaterial,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnKeyPair.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnKeyPairPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnKeyPair\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-keypair.html
 */
export interface CfnKeyPairProps {
  /**
   * The format of the key pair.
   *
   * Default: \`pem\`
   *
   * @default - "pem"
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-keypair.html#cfn-ec2-keypair-keyformat
   */
  readonly keyFormat?: string;

  /**
   * A unique name for the key pair.
   *
   * Constraints: Up to 255 ASCII characters
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-keypair.html#cfn-ec2-keypair-keyname
   */
  readonly keyName: string;

  /**
   * The type of key pair. Note that ED25519 keys are not supported for Windows instances.
   *
   * If the \`PublicKeyMaterial\` property is specified, the \`KeyType\` property is ignored, and the key type is inferred from the \`PublicKeyMaterial\` value.
   *
   * Default: \`rsa\`
   *
   * @default - "rsa"
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-keypair.html#cfn-ec2-keypair-keytype
   */
  readonly keyType?: string;

  /**
   * The public key material.
   *
   * The \`PublicKeyMaterial\` property is used to import a key pair. If this property is not specified, then a new key pair will be created.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-keypair.html#cfn-ec2-keypair-publickeymaterial
   */
  readonly publicKeyMaterial?: string;

  /**
   * The tags to apply to the key pair.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-keypair.html#cfn-ec2-keypair-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a \`CfnKeyPairProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnKeyPairProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnKeyPairPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("keyFormat", cdk.validateString)(properties.keyFormat));
  errors.collect(cdk.propertyValidator("keyName", cdk.requiredValidator)(properties.keyName));
  errors.collect(cdk.propertyValidator("keyName", cdk.validateString)(properties.keyName));
  errors.collect(cdk.propertyValidator("keyType", cdk.validateString)(properties.keyType));
  errors.collect(cdk.propertyValidator("publicKeyMaterial", cdk.validateString)(properties.publicKeyMaterial));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnKeyPairProps\\"");
}

// @ts-ignore TS6133
function convertCfnKeyPairPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnKeyPairPropsValidator(properties).assertSuccess();
  return {
    "KeyFormat": cdk.stringToCloudFormation(properties.keyFormat),
    "KeyName": cdk.stringToCloudFormation(properties.keyName),
    "KeyType": cdk.stringToCloudFormation(properties.keyType),
    "PublicKeyMaterial": cdk.stringToCloudFormation(properties.publicKeyMaterial),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnKeyPairPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnKeyPairProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnKeyPairProps>();
  ret.addPropertyResult("keyFormat", "KeyFormat", (properties.KeyFormat != null ? cfn_parse.FromCloudFormation.getString(properties.KeyFormat) : undefined));
  ret.addPropertyResult("keyName", "KeyName", (properties.KeyName != null ? cfn_parse.FromCloudFormation.getString(properties.KeyName) : undefined));
  ret.addPropertyResult("keyType", "KeyType", (properties.KeyType != null ? cfn_parse.FromCloudFormation.getString(properties.KeyType) : undefined));
  ret.addPropertyResult("publicKeyMaterial", "PublicKeyMaterial", (properties.PublicKeyMaterial != null ? cfn_parse.FromCloudFormation.getString(properties.PublicKeyMaterial) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies the properties for creating a launch template.
 *
 * The minimum required properties for specifying a launch template are as follows:
 *
 * - You must specify at least one property for the launch template data.
 * - You do not need to specify a name for the launch template. If you do not specify a name, AWS CloudFormation creates the name for you.
 *
 * A launch template can contain some or all of the configuration information to launch an instance. When you launch an instance using a launch template, instance properties that are not specified in the launch template use default values, except the \`ImageId\` property, which has no default value. If you do not specify an AMI ID for the launch template \`ImageId\` property, you must specify an AMI ID for the instance \`ImageId\` property.
 *
 * For more information, see [Launch an instance from a launch template](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-templates.html) in the *Amazon EC2 User Guide* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html
 */
export class CfnLaunchTemplate extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::LaunchTemplate";

  /**
   * Build a CfnLaunchTemplate from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnLaunchTemplate {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnLaunchTemplatePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnLaunchTemplate(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The default version of the launch template, such as 2.
   *
   * The default version of a launch template cannot be specified in AWS CloudFormation . The default version can be set in the Amazon EC2 console or by using the \`modify-launch-template\` AWS CLI command.
   *
   * @cloudformationAttribute DefaultVersionNumber
   */
  public readonly attrDefaultVersionNumber: string;

  /**
   * The latest version of the launch template, such as \`5\` .
   *
   * @cloudformationAttribute LatestVersionNumber
   */
  public readonly attrLatestVersionNumber: string;

  /**
   * The ID of the launch template.
   *
   * @cloudformationAttribute LaunchTemplateId
   */
  public readonly attrLaunchTemplateId: string;

  /**
   * The information for the launch template.
   */
  public launchTemplateData: cdk.IResolvable | CfnLaunchTemplate.LaunchTemplateDataProperty;

  /**
   * A name for the launch template.
   */
  public launchTemplateName?: string;

  /**
   * The tags to apply to the launch template on creation.
   */
  public tagSpecifications?: Array<cdk.IResolvable | CfnLaunchTemplate.LaunchTemplateTagSpecificationProperty> | cdk.IResolvable;

  /**
   * A description for the first version of the launch template.
   */
  public versionDescription?: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnLaunchTemplateProps) {
    super(scope, id, {
      "type": CfnLaunchTemplate.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "launchTemplateData", this);

    this.attrDefaultVersionNumber = cdk.Token.asString(this.getAtt("DefaultVersionNumber", cdk.ResolutionTypeHint.STRING));
    this.attrLatestVersionNumber = cdk.Token.asString(this.getAtt("LatestVersionNumber", cdk.ResolutionTypeHint.STRING));
    this.attrLaunchTemplateId = cdk.Token.asString(this.getAtt("LaunchTemplateId", cdk.ResolutionTypeHint.STRING));
    this.launchTemplateData = props.launchTemplateData;
    this.launchTemplateName = props.launchTemplateName;
    this.tagSpecifications = props.tagSpecifications;
    this.versionDescription = props.versionDescription;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "launchTemplateData": this.launchTemplateData,
      "launchTemplateName": this.launchTemplateName,
      "tagSpecifications": this.tagSpecifications,
      "versionDescription": this.versionDescription
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnLaunchTemplate.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnLaunchTemplatePropsToCloudFormation(props);
  }
}

export namespace CfnLaunchTemplate {
  /**
   * The information to include in the launch template.
   *
   * > You must specify at least one parameter for the launch template data.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html
   */
  export interface LaunchTemplateDataProperty {
    /**
     * The block device mapping.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-blockdevicemappings
     */
    readonly blockDeviceMappings?: Array<CfnLaunchTemplate.BlockDeviceMappingProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The Capacity Reservation targeting option.
     *
     * If you do not specify this parameter, the instance's Capacity Reservation preference defaults to \`open\` , which enables it to run in any open Capacity Reservation that has matching attributes (instance type, platform, Availability Zone).
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-capacityreservationspecification
     */
    readonly capacityReservationSpecification?: CfnLaunchTemplate.CapacityReservationSpecificationProperty | cdk.IResolvable;

    /**
     * The CPU options for the instance.
     *
     * For more information, see [Optimizing CPU Options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html) in the *Amazon Elastic Compute Cloud User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-cpuoptions
     */
    readonly cpuOptions?: CfnLaunchTemplate.CpuOptionsProperty | cdk.IResolvable;

    /**
     * The credit option for CPU usage of the instance.
     *
     * Valid only for T instances.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-creditspecification
     */
    readonly creditSpecification?: CfnLaunchTemplate.CreditSpecificationProperty | cdk.IResolvable;

    /**
     * Indicates whether to enable the instance for stop protection.
     *
     * For more information, see [Stop protection](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Stop_Start.html#Using_StopProtection) in the *Amazon Elastic Compute Cloud User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-disableapistop
     */
    readonly disableApiStop?: boolean | cdk.IResolvable;

    /**
     * If you set this parameter to \`true\` , you can't terminate the instance using the Amazon EC2 console, CLI, or API;
     *
     * otherwise, you can. To change this attribute after launch, use [ModifyInstanceAttribute](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceAttribute.html) . Alternatively, if you set \`InstanceInitiatedShutdownBehavior\` to \`terminate\` , you can terminate the instance by running the shutdown command from the instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-disableapitermination
     */
    readonly disableApiTermination?: boolean | cdk.IResolvable;

    /**
     * Indicates whether the instance is optimized for Amazon EBS I/O.
     *
     * This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal Amazon EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-ebsoptimized
     */
    readonly ebsOptimized?: boolean | cdk.IResolvable;

    /**
     * An elastic GPU to associate with the instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-elasticgpuspecifications
     */
    readonly elasticGpuSpecifications?: Array<CfnLaunchTemplate.ElasticGpuSpecificationProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The elastic inference accelerator for the instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-elasticinferenceaccelerators
     */
    readonly elasticInferenceAccelerators?: Array<cdk.IResolvable | CfnLaunchTemplate.LaunchTemplateElasticInferenceAcceleratorProperty> | cdk.IResolvable;

    /**
     * Indicates whether the instance is enabled for AWS Nitro Enclaves.
     *
     * For more information, see [What is AWS Nitro Enclaves?](https://docs.aws.amazon.com/enclaves/latest/user/nitro-enclave.html) in the *AWS Nitro Enclaves User Guide* .
     *
     * You can't enable AWS Nitro Enclaves and hibernation on the same instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-enclaveoptions
     */
    readonly enclaveOptions?: CfnLaunchTemplate.EnclaveOptionsProperty | cdk.IResolvable;

    /**
     * Indicates whether an instance is enabled for hibernation.
     *
     * This parameter is valid only if the instance meets the [hibernation prerequisites](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/hibernating-prerequisites.html) . For more information, see [Hibernate your instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html) in the *Amazon Elastic Compute Cloud User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-hibernationoptions
     */
    readonly hibernationOptions?: CfnLaunchTemplate.HibernationOptionsProperty | cdk.IResolvable;

    /**
     * The name or Amazon Resource Name (ARN) of an IAM instance profile.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-iaminstanceprofile
     */
    readonly iamInstanceProfile?: CfnLaunchTemplate.IamInstanceProfileProperty | cdk.IResolvable;

    /**
     * The ID of the AMI.
     *
     * Alternatively, you can specify a Systems Manager parameter, which will resolve to an AMI ID on launch.
     *
     * Valid formats:
     *
     * - \`ami-17characters00000\`
     * - \`resolve:ssm:parameter-name\`
     * - \`resolve:ssm:parameter-name:version-number\`
     * - \`resolve:ssm:parameter-name:label\`
     *
     * For more information, see [Use a Systems Manager parameter to find an AMI](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/finding-an-ami.html#using-systems-manager-parameter-to-find-AMI) in the *Amazon Elastic Compute Cloud User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-imageid
     */
    readonly imageId?: string;

    /**
     * Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).
     *
     * Default: \`stop\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-instanceinitiatedshutdownbehavior
     */
    readonly instanceInitiatedShutdownBehavior?: string;

    /**
     * The market (purchasing) option for the instances.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-instancemarketoptions
     */
    readonly instanceMarketOptions?: CfnLaunchTemplate.InstanceMarketOptionsProperty | cdk.IResolvable;

    /**
     * The attributes for the instance types.
     *
     * When you specify instance attributes, Amazon EC2 will identify instance types with these attributes.
     *
     * If you specify \`InstanceRequirements\` , you can't specify \`InstanceType\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-instancerequirements
     */
    readonly instanceRequirements?: CfnLaunchTemplate.InstanceRequirementsProperty | cdk.IResolvable;

    /**
     * The instance type. For more information, see [Instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the *Amazon Elastic Compute Cloud User Guide* .
     *
     * If you specify \`InstanceType\` , you can't specify \`InstanceRequirements\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-instancetype
     */
    readonly instanceType?: string;

    /**
     * The ID of the kernel.
     *
     * We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see [User Provided Kernels](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-kernelid
     */
    readonly kernelId?: string;

    /**
     * The name of the key pair. You can create a key pair using [CreateKeyPair](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateKeyPair.html) or [ImportKeyPair](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportKeyPair.html) .
     *
     * > If you do not specify a key pair, you can't connect to the instance unless you choose an AMI that is configured to allow users another way to log in.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-keyname
     */
    readonly keyName?: string;

    /**
     * The license configurations.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-licensespecifications
     */
    readonly licenseSpecifications?: Array<cdk.IResolvable | CfnLaunchTemplate.LicenseSpecificationProperty> | cdk.IResolvable;

    /**
     * The maintenance options of your instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-maintenanceoptions
     */
    readonly maintenanceOptions?: cdk.IResolvable | CfnLaunchTemplate.MaintenanceOptionsProperty;

    /**
     * The metadata options for the instance.
     *
     * For more information, see [Instance metadata and user data](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html) in the *Amazon Elastic Compute Cloud User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-metadataoptions
     */
    readonly metadataOptions?: cdk.IResolvable | CfnLaunchTemplate.MetadataOptionsProperty;

    /**
     * The monitoring for the instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-monitoring
     */
    readonly monitoring?: cdk.IResolvable | CfnLaunchTemplate.MonitoringProperty;

    /**
     * One or more network interfaces.
     *
     * If you specify a network interface, you must specify any security groups and subnets as part of the network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-networkinterfaces
     */
    readonly networkInterfaces?: Array<cdk.IResolvable | CfnLaunchTemplate.NetworkInterfaceProperty> | cdk.IResolvable;

    /**
     * The placement for the instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-placement
     */
    readonly placement?: cdk.IResolvable | CfnLaunchTemplate.PlacementProperty;

    /**
     * The hostname type for EC2 instances launched into this subnet and how DNS A and AAAA record queries should be handled.
     *
     * For more information, see [Amazon EC2 instance hostname types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html) in the *Amazon Elastic Compute Cloud User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-privatednsnameoptions
     */
    readonly privateDnsNameOptions?: cdk.IResolvable | CfnLaunchTemplate.PrivateDnsNameOptionsProperty;

    /**
     * The ID of the RAM disk.
     *
     * > We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see [User provided kernels](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html) in the *Amazon Elastic Compute Cloud User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-ramdiskid
     */
    readonly ramDiskId?: string;

    /**
     * The IDs of the security groups.
     *
     * You can specify the IDs of existing security groups and references to resources created by the stack template.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-securitygroupids
     */
    readonly securityGroupIds?: Array<string>;

    /**
     * One or more security group names.
     *
     * For a nondefault VPC, you must use security group IDs instead. You cannot specify both a security group ID and security name in the same request.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-securitygroups
     */
    readonly securityGroups?: Array<string>;

    /**
     * The tags to apply to the resources that are created during instance launch.
     *
     * You can specify tags for the following resources only:
     *
     * - Instances
     * - Volumes
     * - Elastic graphics
     * - Spot Instance requests
     * - Network interfaces
     *
     * To tag a resource after it has been created, see [CreateTags](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateTags.html) .
     *
     * > To tag the launch template itself, you must use the [TagSpecification](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateLaunchTemplate.html) parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-tagspecifications
     */
    readonly tagSpecifications?: Array<cdk.IResolvable | CfnLaunchTemplate.TagSpecificationProperty> | cdk.IResolvable;

    /**
     * The user data to make available to the instance.
     *
     * You must provide base64-encoded text. User data is limited to 16 KB. For more information, see [Run commands on your Linux instance at launch](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html) (Linux) or [Work with instance user data](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/instancedata-add-user-data.html) (Windows) in the *Amazon Elastic Compute Cloud User Guide* .
     *
     * If you are creating the launch template for use with AWS Batch , the user data must be provided in the [MIME multi-part archive format](https://docs.aws.amazon.com/https://cloudinit.readthedocs.io/en/latest/topics/format.html#mime-multi-part-archive) . For more information, see [Amazon EC2 user data in launch templates](https://docs.aws.amazon.com/batch/latest/userguide/launch-templates.html) in the *AWS Batch User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-userdata
     */
    readonly userData?: string;
  }

  /**
   * Specifies the tags to apply to a resource when the resource is created for the launch template.
   *
   * \`TagSpecification\` is a property type of [\`TagSpecifications\`](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-tagspecifications) . [\`TagSpecifications\`](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-tagspecifications) is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html) .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-tagspecification.html
   */
  export interface TagSpecificationProperty {
    /**
     * The type of resource to tag.
     *
     * The \`Valid Values\` are all the resource types that can be tagged. However, when creating a launch template, you can specify tags for the following resource types only: \`instance\` | \`volume\` | \`elastic-gpu\` | \`network-interface\` | \`spot-instances-request\`
     *
     * To tag a resource after it has been created, see [CreateTags](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateTags.html) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-tagspecification.html#cfn-ec2-launchtemplate-tagspecification-resourcetype
     */
    readonly resourceType?: string;

    /**
     * The tags to apply to the resource.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-tagspecification.html#cfn-ec2-launchtemplate-tagspecification-tags
     */
    readonly tags?: Array<cdk.CfnTag>;
  }

  /**
   * Information about a block device mapping for an Amazon EC2 launch template.
   *
   * \`BlockDeviceMapping\` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html) .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-blockdevicemapping.html
   */
  export interface BlockDeviceMappingProperty {
    /**
     * The device name (for example, /dev/sdh or xvdh).
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-blockdevicemapping.html#cfn-ec2-launchtemplate-blockdevicemapping-devicename
     */
    readonly deviceName?: string;

    /**
     * Parameters used to automatically set up EBS volumes when the instance is launched.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-blockdevicemapping.html#cfn-ec2-launchtemplate-blockdevicemapping-ebs
     */
    readonly ebs?: CfnLaunchTemplate.EbsProperty | cdk.IResolvable;

    /**
     * To omit the device from the block device mapping, specify an empty string.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-blockdevicemapping.html#cfn-ec2-launchtemplate-blockdevicemapping-nodevice
     */
    readonly noDevice?: string;

    /**
     * The virtual device name (ephemeralN).
     *
     * Instance store volumes are numbered starting from 0. An instance type with 2 available instance store volumes can specify mappings for ephemeral0 and ephemeral1. The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-blockdevicemapping.html#cfn-ec2-launchtemplate-blockdevicemapping-virtualname
     */
    readonly virtualName?: string;
  }

  /**
   * Parameters for a block device for an EBS volume in an Amazon EC2 launch template.
   *
   * \`Ebs\` is a property of [AWS::EC2::LaunchTemplate BlockDeviceMapping](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-blockdevicemapping.html) .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-ebs.html
   */
  export interface EbsProperty {
    /**
     * Indicates whether the EBS volume is deleted on instance termination.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-ebs.html#cfn-ec2-launchtemplate-ebs-deleteontermination
     */
    readonly deleteOnTermination?: boolean | cdk.IResolvable;

    /**
     * Indicates whether the EBS volume is encrypted.
     *
     * Encrypted volumes can only be attached to instances that support Amazon EBS encryption. If you are creating a volume from a snapshot, you can't specify an encryption value.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-ebs.html#cfn-ec2-launchtemplate-ebs-encrypted
     */
    readonly encrypted?: boolean | cdk.IResolvable;

    /**
     * The number of I/O operations per second (IOPS).
     *
     * For \`gp3\` , \`io1\` , and \`io2\` volumes, this represents the number of IOPS that are provisioned for the volume. For \`gp2\` volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting.
     *
     * The following are the supported values for each volume type:
     *
     * - \`gp3\` : 3,000-16,000 IOPS
     * - \`io1\` : 100-64,000 IOPS
     * - \`io2\` : 100-64,000 IOPS
     *
     * For \`io1\` and \`io2\` volumes, we guarantee 64,000 IOPS only for [Instances built on the Nitro System](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances) . Other instance families guarantee performance up to 32,000 IOPS.
     *
     * This parameter is supported for \`io1\` , \`io2\` , and \`gp3\` volumes only. This parameter is not supported for \`gp2\` , \`st1\` , \`sc1\` , or \`standard\` volumes.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-ebs.html#cfn-ec2-launchtemplate-ebs-iops
     */
    readonly iops?: number;

    /**
     * The ARN of the symmetric AWS Key Management Service ( AWS KMS ) CMK used for encryption.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-ebs.html#cfn-ec2-launchtemplate-ebs-kmskeyid
     */
    readonly kmsKeyId?: string;

    /**
     * The ID of the snapshot.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-ebs.html#cfn-ec2-launchtemplate-ebs-snapshotid
     */
    readonly snapshotId?: string;

    /**
     * The throughput to provision for a \`gp3\` volume, with a maximum of 1,000 MiB/s.
     *
     * Valid Range: Minimum value of 125. Maximum value of 1000.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-ebs.html#cfn-ec2-launchtemplate-ebs-throughput
     */
    readonly throughput?: number;

    /**
     * The size of the volume, in GiBs.
     *
     * You must specify either a snapshot ID or a volume size. The following are the supported volumes sizes for each volume type:
     *
     * - \`gp2\` and \`gp3\` : 1-16,384
     * - \`io1\` and \`io2\` : 4-16,384
     * - \`st1\` and \`sc1\` : 125-16,384
     * - \`standard\` : 1-1,024
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-ebs.html#cfn-ec2-launchtemplate-ebs-volumesize
     */
    readonly volumeSize?: number;

    /**
     * The volume type.
     *
     * For more information, see [Amazon EBS volume types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html) in the *Amazon Elastic Compute Cloud User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-ebs.html#cfn-ec2-launchtemplate-ebs-volumetype
     */
    readonly volumeType?: string;
  }

  /**
   * The maintenance options of your instance.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-maintenanceoptions.html
   */
  export interface MaintenanceOptionsProperty {
    /**
     * Disables the automatic recovery behavior of your instance or sets it to default.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-maintenanceoptions.html#cfn-ec2-launchtemplate-maintenanceoptions-autorecovery
     */
    readonly autoRecovery?: string;
  }

  /**
   * Specifies an IAM instance profile, which is a container for an IAM role for your instance.
   *
   * You can use an IAM role to distribute your AWS credentials to your instances.
   *
   * If you are creating the launch template for use with an Amazon EC2 Auto Scaling group, you can specify either the name or the ARN of the instance profile, but not both.
   *
   * \`IamInstanceProfile\` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html) .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-iaminstanceprofile.html
   */
  export interface IamInstanceProfileProperty {
    /**
     * The Amazon Resource Name (ARN) of the instance profile.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-iaminstanceprofile.html#cfn-ec2-launchtemplate-iaminstanceprofile-arn
     */
    readonly arn?: string;

    /**
     * The name of the instance profile.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-iaminstanceprofile.html#cfn-ec2-launchtemplate-iaminstanceprofile-name
     */
    readonly name?: string;
  }

  /**
   * Specifies a specification for an Elastic GPU for an Amazon EC2 launch template.
   *
   * \`ElasticGpuSpecification\` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html) .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-elasticgpuspecification.html
   */
  export interface ElasticGpuSpecificationProperty {
    /**
     * The type of Elastic Graphics accelerator.
     *
     * For more information about the values to specify for \`Type\` , see [Elastic Graphics Basics](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/elastic-graphics.html#elastic-graphics-basics) , specifically the Elastic Graphics accelerator column, in the *Amazon Elastic Compute Cloud User Guide for Windows Instances* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-elasticgpuspecification.html#cfn-ec2-launchtemplate-elasticgpuspecification-type
     */
    readonly type?: string;
  }

  /**
   * Specifies an elastic inference accelerator.
   *
   * \`LaunchTemplateElasticInferenceAccelerator\` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html) .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplateelasticinferenceaccelerator.html
   */
  export interface LaunchTemplateElasticInferenceAcceleratorProperty {
    /**
     * The number of elastic inference accelerators to attach to the instance.
     *
     * Default: 1
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplateelasticinferenceaccelerator.html#cfn-ec2-launchtemplate-launchtemplateelasticinferenceaccelerator-count
     */
    readonly count?: number;

    /**
     * The type of elastic inference accelerator.
     *
     * The possible values are eia1.medium, eia1.large, and eia1.xlarge.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplateelasticinferenceaccelerator.html#cfn-ec2-launchtemplate-launchtemplateelasticinferenceaccelerator-type
     */
    readonly type?: string;
  }

  /**
   * Specifies the placement of an instance.
   *
   * \`Placement\` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html) .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-placement.html
   */
  export interface PlacementProperty {
    /**
     * The affinity setting for an instance on a Dedicated Host.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-placement.html#cfn-ec2-launchtemplate-placement-affinity
     */
    readonly affinity?: string;

    /**
     * The Availability Zone for the instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-placement.html#cfn-ec2-launchtemplate-placement-availabilityzone
     */
    readonly availabilityZone?: string;

    /**
     * The Group Id of a placement group.
     *
     * You must specify the Placement Group *Group Id* to launch an instance in a shared placement group.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-placement.html#cfn-ec2-launchtemplate-placement-groupid
     */
    readonly groupId?: string;

    /**
     * The name of the placement group for the instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-placement.html#cfn-ec2-launchtemplate-placement-groupname
     */
    readonly groupName?: string;

    /**
     * The ID of the Dedicated Host for the instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-placement.html#cfn-ec2-launchtemplate-placement-hostid
     */
    readonly hostId?: string;

    /**
     * The ARN of the host resource group in which to launch the instances.
     *
     * If you specify a host resource group ARN, omit the *Tenancy* parameter or set it to \`host\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-placement.html#cfn-ec2-launchtemplate-placement-hostresourcegrouparn
     */
    readonly hostResourceGroupArn?: string;

    /**
     * The number of the partition the instance should launch in.
     *
     * Valid only if the placement group strategy is set to \`partition\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-placement.html#cfn-ec2-launchtemplate-placement-partitionnumber
     */
    readonly partitionNumber?: number;

    /**
     * Reserved for future use.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-placement.html#cfn-ec2-launchtemplate-placement-spreaddomain
     */
    readonly spreadDomain?: string;

    /**
     * The tenancy of the instance.
     *
     * An instance with a tenancy of dedicated runs on single-tenant hardware.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-placement.html#cfn-ec2-launchtemplate-placement-tenancy
     */
    readonly tenancy?: string;
  }

  /**
   * Specifies the parameters for a network interface.
   *
   * \`NetworkInterface\` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html) .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html
   */
  export interface NetworkInterfaceProperty {
    /**
     * Indicates whether to associate a Carrier IP address with eth0 for a new network interface.
     *
     * Use this option when you launch an instance in a Wavelength Zone and want to associate a Carrier IP address with the network interface. For more information about Carrier IP addresses, see [Carrier IP addresses](https://docs.aws.amazon.com/wavelength/latest/developerguide/how-wavelengths-work.html#provider-owned-ip) in the *AWS Wavelength Developer Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-associatecarrieripaddress
     */
    readonly associateCarrierIpAddress?: boolean | cdk.IResolvable;

    /**
     * Associates a public IPv4 address with eth0 for a new network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-associatepublicipaddress
     */
    readonly associatePublicIpAddress?: boolean | cdk.IResolvable;

    /**
     * Indicates whether the network interface is deleted when the instance is terminated.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-deleteontermination
     */
    readonly deleteOnTermination?: boolean | cdk.IResolvable;

    /**
     * A description for the network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-description
     */
    readonly description?: string;

    /**
     * The device index for the network interface attachment.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-deviceindex
     */
    readonly deviceIndex?: number;

    /**
     * The IDs of one or more security groups.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-groups
     */
    readonly groups?: Array<string>;

    /**
     * The type of network interface.
     *
     * To create an Elastic Fabric Adapter (EFA), specify \`efa\` . For more information, see [Elastic Fabric Adapter](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/efa.html) in the *Amazon Elastic Compute Cloud User Guide* .
     *
     * If you are not creating an EFA, specify \`interface\` or omit this parameter.
     *
     * Valid values: \`interface\` | \`efa\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-interfacetype
     */
    readonly interfaceType?: string;

    /**
     * The number of IPv4 prefixes to be automatically assigned to the network interface.
     *
     * You cannot use this option if you use the \`Ipv4Prefix\` option.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-ipv4prefixcount
     */
    readonly ipv4PrefixCount?: number;

    /**
     * One or more IPv4 prefixes to be assigned to the network interface.
     *
     * You cannot use this option if you use the \`Ipv4PrefixCount\` option.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-ipv4prefixes
     */
    readonly ipv4Prefixes?: Array<CfnLaunchTemplate.Ipv4PrefixSpecificationProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The number of IPv6 addresses to assign to a network interface.
     *
     * Amazon EC2 automatically selects the IPv6 addresses from the subnet range. You can't use this option if specifying specific IPv6 addresses.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-ipv6addresscount
     */
    readonly ipv6AddressCount?: number;

    /**
     * One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet.
     *
     * You can't use this option if you're specifying a number of IPv6 addresses.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-ipv6addresses
     */
    readonly ipv6Addresses?: Array<CfnLaunchTemplate.Ipv6AddProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The number of IPv6 prefixes to be automatically assigned to the network interface.
     *
     * You cannot use this option if you use the \`Ipv6Prefix\` option.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-ipv6prefixcount
     */
    readonly ipv6PrefixCount?: number;

    /**
     * One or more IPv6 prefixes to be assigned to the network interface.
     *
     * You cannot use this option if you use the \`Ipv6PrefixCount\` option.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-ipv6prefixes
     */
    readonly ipv6Prefixes?: Array<CfnLaunchTemplate.Ipv6PrefixSpecificationProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The index of the network card.
     *
     * Some instance types support multiple network cards. The primary network interface must be assigned to network card index 0. The default is network card index 0.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-networkcardindex
     */
    readonly networkCardIndex?: number;

    /**
     * The ID of the network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-networkinterfaceid
     */
    readonly networkInterfaceId?: string;

    /**
     * The primary private IPv4 address of the network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-privateipaddress
     */
    readonly privateIpAddress?: string;

    /**
     * One or more private IPv4 addresses.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-privateipaddresses
     */
    readonly privateIpAddresses?: Array<cdk.IResolvable | CfnLaunchTemplate.PrivateIpAddProperty> | cdk.IResolvable;

    /**
     * The number of secondary private IPv4 addresses to assign to a network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-secondaryprivateipaddresscount
     */
    readonly secondaryPrivateIpAddressCount?: number;

    /**
     * The ID of the subnet for the network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-subnetid
     */
    readonly subnetId?: string;
  }

  /**
   * Specifies a secondary private IPv4 address for a network interface.
   *
   * \`PrivateIpAdd\` is a property of [AWS::EC2::LaunchTemplate NetworkInterface](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html) .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-privateipadd.html
   */
  export interface PrivateIpAddProperty {
    /**
     * Indicates whether the private IPv4 address is the primary private IPv4 address.
     *
     * Only one IPv4 address can be designated as primary.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-privateipadd.html#cfn-ec2-launchtemplate-privateipadd-primary
     */
    readonly primary?: boolean | cdk.IResolvable;

    /**
     * The private IPv4 address.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-privateipadd.html#cfn-ec2-launchtemplate-privateipadd-privateipaddress
     */
    readonly privateIpAddress?: string;
  }

  /**
   * Specifies an IPv4 prefix for a network interface.
   *
   * \`Ipv4PrefixSpecification\` is a property of [AWS::EC2::LaunchTemplate NetworkInterface](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html) .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-ipv4prefixspecification.html
   */
  export interface Ipv4PrefixSpecificationProperty {
    /**
     * The IPv4 prefix.
     *
     * For information, see [Assigning prefixes to Amazon EC2 network interfaces](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-prefix-eni.html) in the *Amazon Elastic Compute Cloud User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-ipv4prefixspecification.html#cfn-ec2-launchtemplate-ipv4prefixspecification-ipv4prefix
     */
    readonly ipv4Prefix?: string;
  }

  /**
   * Specifies an IPv6 prefix for a network interface.
   *
   * \`Ipv6PrefixSpecification\` is a property of [AWS::EC2::LaunchTemplate NetworkInterface](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html) .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-ipv6prefixspecification.html
   */
  export interface Ipv6PrefixSpecificationProperty {
    /**
     * The IPv6 prefix.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-ipv6prefixspecification.html#cfn-ec2-launchtemplate-ipv6prefixspecification-ipv6prefix
     */
    readonly ipv6Prefix?: string;
  }

  /**
   * Specifies an IPv6 address in an Amazon EC2 launch template.
   *
   * \`Ipv6Add\` is a property of [AWS::EC2::LaunchTemplate NetworkInterface](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html) .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-ipv6add.html
   */
  export interface Ipv6AddProperty {
    /**
     * One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet.
     *
     * You can't use this option if you're specifying a number of IPv6 addresses.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-ipv6add.html#cfn-ec2-launchtemplate-ipv6add-ipv6address
     */
    readonly ipv6Address?: string;
  }

  /**
   * Indicates whether the instance is enabled for AWS Nitro Enclaves.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-enclaveoptions.html
   */
  export interface EnclaveOptionsProperty {
    /**
     * If this parameter is set to \`true\` , the instance is enabled for AWS Nitro Enclaves;
     *
     * otherwise, it is not enabled for AWS Nitro Enclaves.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-enclaveoptions.html#cfn-ec2-launchtemplate-enclaveoptions-enabled
     */
    readonly enabled?: boolean | cdk.IResolvable;
  }

  /**
   * Specifies whether detailed monitoring is enabled for an instance.
   *
   * For more information about detailed monitoring, see [Enable or turn off detailed monitoring for your instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-cloudwatch-new.html) in the *Amazon EC2 User Guide* .
   *
   * \`Monitoring\` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html) .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-monitoring.html
   */
  export interface MonitoringProperty {
    /**
     * Specify \`true\` to enable detailed monitoring.
     *
     * Otherwise, basic monitoring is enabled.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-monitoring.html#cfn-ec2-launchtemplate-monitoring-enabled
     */
    readonly enabled?: boolean | cdk.IResolvable;
  }

  /**
   * Specifies whether your instance is configured for hibernation.
   *
   * This parameter is valid only if the instance meets the [hibernation prerequisites](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html#hibernating-prerequisites) . For more information, see [Hibernate Your Instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html) in the *Amazon EC2 User Guide* .
   *
   * \`HibernationOptions\` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html) .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-hibernationoptions.html
   */
  export interface HibernationOptionsProperty {
    /**
     * If you set this parameter to \`true\` , the instance is enabled for hibernation.
     *
     * Default: \`false\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-hibernationoptions.html#cfn-ec2-launchtemplate-hibernationoptions-configured
     */
    readonly configured?: boolean | cdk.IResolvable;
  }

  /**
   * The metadata options for the instance.
   *
   * For more information, see [Instance metadata and user data](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html) in the *Amazon EC2 User Guide* .
   *
   * \`MetadataOptions\` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html) .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-metadataoptions.html
   */
  export interface MetadataOptionsProperty {
    /**
     * Enables or disables the HTTP metadata endpoint on your instances.
     *
     * If the parameter is not specified, the default state is \`enabled\` .
     *
     * > If you specify a value of \`disabled\` , you will not be able to access your instance metadata.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-metadataoptions.html#cfn-ec2-launchtemplate-metadataoptions-httpendpoint
     */
    readonly httpEndpoint?: string;

    /**
     * Enables or disables the IPv6 endpoint for the instance metadata service.
     *
     * Default: \`disabled\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-metadataoptions.html#cfn-ec2-launchtemplate-metadataoptions-httpprotocolipv6
     */
    readonly httpProtocolIpv6?: string;

    /**
     * The desired HTTP PUT response hop limit for instance metadata requests.
     *
     * The larger the number, the further instance metadata requests can travel.
     *
     * Default: \`1\`
     *
     * Possible values: Integers from 1 to 64
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-metadataoptions.html#cfn-ec2-launchtemplate-metadataoptions-httpputresponsehoplimit
     */
    readonly httpPutResponseHopLimit?: number;

    /**
     * IMDSv2 uses token-backed sessions.
     *
     * Set the use of HTTP tokens to \`optional\` (in other words, set the use of IMDSv2 to \`optional\` ) or \`required\` (in other words, set the use of IMDSv2 to \`required\` ).
     *
     * - \`optional\` - When IMDSv2 is optional, you can choose to retrieve instance metadata with or without a session token in your request. If you retrieve the IAM role credentials without a token, the IMDSv1 role credentials are returned. If you retrieve the IAM role credentials using a valid session token, the IMDSv2 role credentials are returned.
     * - \`required\` - When IMDSv2 is required, you must send a session token with any instance metadata retrieval requests. In this state, retrieving the IAM role credentials always returns IMDSv2 credentials; IMDSv1 credentials are not available.
     *
     * Default: \`optional\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-metadataoptions.html#cfn-ec2-launchtemplate-metadataoptions-httptokens
     */
    readonly httpTokens?: string;

    /**
     * Set to \`enabled\` to allow access to instance tags from the instance metadata.
     *
     * Set to \`disabled\` to turn off access to instance tags from the instance metadata. For more information, see [Work with instance tags using the instance metadata](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html#work-with-tags-in-IMDS) .
     *
     * Default: \`disabled\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-metadataoptions.html#cfn-ec2-launchtemplate-metadataoptions-instancemetadatatags
     */
    readonly instanceMetadataTags?: string;
  }

  /**
   * Specifies a license configuration for an instance.
   *
   * \`LicenseSpecification\` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html) .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-licensespecification.html
   */
  export interface LicenseSpecificationProperty {
    /**
     * The Amazon Resource Name (ARN) of the license configuration.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-licensespecification.html#cfn-ec2-launchtemplate-licensespecification-licenseconfigurationarn
     */
    readonly licenseConfigurationArn?: string;
  }

  /**
   * Specifies the CPU options for an instance.
   *
   * For more information, see [Optimize CPU options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html) in the *Amazon Elastic Compute Cloud User Guide* .
   *
   * \`CpuOptions\` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html) .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-cpuoptions.html
   */
  export interface CpuOptionsProperty {
    /**
     * Indicates whether to enable the instance for AMD SEV-SNP.
     *
     * AMD SEV-SNP is supported with M6a, R6a, and C6a instance types only. For more information, see [AMD SEV-SNP](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/sev-snp.html) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-cpuoptions.html#cfn-ec2-launchtemplate-cpuoptions-amdsevsnp
     */
    readonly amdSevSnp?: string;

    /**
     * The number of CPU cores for the instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-cpuoptions.html#cfn-ec2-launchtemplate-cpuoptions-corecount
     */
    readonly coreCount?: number;

    /**
     * The number of threads per CPU core.
     *
     * To disable multithreading for the instance, specify a value of \`1\` . Otherwise, specify the default value of \`2\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-cpuoptions.html#cfn-ec2-launchtemplate-cpuoptions-threadspercore
     */
    readonly threadsPerCore?: number;
  }

  /**
   * The hostname type for EC2 instances launched into this subnet and how DNS A and AAAA record queries should be handled.
   *
   * For more information, see [Amazon EC2 instance hostname types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html) in the *Amazon Elastic Compute Cloud User Guide* .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-privatednsnameoptions.html
   */
  export interface PrivateDnsNameOptionsProperty {
    /**
     * Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-privatednsnameoptions.html#cfn-ec2-launchtemplate-privatednsnameoptions-enableresourcenamednsaaaarecord
     */
    readonly enableResourceNameDnsAaaaRecord?: boolean | cdk.IResolvable;

    /**
     * Indicates whether to respond to DNS queries for instance hostnames with DNS A records.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-privatednsnameoptions.html#cfn-ec2-launchtemplate-privatednsnameoptions-enableresourcenamednsarecord
     */
    readonly enableResourceNameDnsARecord?: boolean | cdk.IResolvable;

    /**
     * The type of hostname for EC2 instances.
     *
     * For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 only subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID. For more information, see [Amazon EC2 instance hostname types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html) in the *Amazon Elastic Compute Cloud User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-privatednsnameoptions.html#cfn-ec2-launchtemplate-privatednsnameoptions-hostnametype
     */
    readonly hostnameType?: string;
  }

  /**
   * Specifies the market (purchasing) option for an instance.
   *
   * \`InstanceMarketOptions\` is a property of the [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html) .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancemarketoptions.html
   */
  export interface InstanceMarketOptionsProperty {
    /**
     * The market type.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancemarketoptions.html#cfn-ec2-launchtemplate-instancemarketoptions-markettype
     */
    readonly marketType?: string;

    /**
     * The options for Spot Instances.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancemarketoptions.html#cfn-ec2-launchtemplate-instancemarketoptions-spotoptions
     */
    readonly spotOptions?: cdk.IResolvable | CfnLaunchTemplate.SpotOptionsProperty;
  }

  /**
   * Specifies options for Spot Instances.
   *
   * \`SpotOptions\` is a property of [AWS::EC2::LaunchTemplate InstanceMarketOptions](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-instancemarketoptions.html) .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-spotoptions.html
   */
  export interface SpotOptionsProperty {
    /**
     * Deprecated.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-spotoptions.html#cfn-ec2-launchtemplate-spotoptions-blockdurationminutes
     */
    readonly blockDurationMinutes?: number;

    /**
     * The behavior when a Spot Instance is interrupted.
     *
     * The default is \`terminate\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-spotoptions.html#cfn-ec2-launchtemplate-spotoptions-instanceinterruptionbehavior
     */
    readonly instanceInterruptionBehavior?: string;

    /**
     * The maximum hourly price you're willing to pay for the Spot Instances.
     *
     * We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price.
     *
     * > If you specify a maximum price, your Spot Instances will be interrupted more frequently than if you do not specify this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-spotoptions.html#cfn-ec2-launchtemplate-spotoptions-maxprice
     */
    readonly maxPrice?: string;

    /**
     * The Spot Instance request type.
     *
     * If you are using Spot Instances with an Auto Scaling group, use \`one-time\` requests, as the Amazon EC2 Auto Scaling service handles requesting new Spot Instances whenever the group is below its desired capacity.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-spotoptions.html#cfn-ec2-launchtemplate-spotoptions-spotinstancetype
     */
    readonly spotInstanceType?: string;

    /**
     * The end date of the request, in UTC format ( *YYYY-MM-DD* T *HH:MM:SS* Z). Supported only for persistent requests.
     *
     * - For a persistent request, the request remains active until the \`ValidUntil\` date and time is reached. Otherwise, the request remains active until you cancel it.
     * - For a one-time request, \`ValidUntil\` is not supported. The request remains active until all instances launch or you cancel the request.
     *
     * Default: 7 days from the current date
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-spotoptions.html#cfn-ec2-launchtemplate-spotoptions-validuntil
     */
    readonly validUntil?: string;
  }

  /**
   * The attributes for the instance types.
   *
   * When you specify instance attributes, Amazon EC2 will identify instance types with these attributes.
   *
   * When you specify multiple attributes, you get instance types that satisfy all of the specified attributes. If you specify multiple values for an attribute, you get instance types that satisfy any of the specified values.
   *
   * To limit the list of instance types from which Amazon EC2 can identify matching instance types, you can use one of the following parameters, but not both in the same request:
   *
   * - \`AllowedInstanceTypes\` - The instance types to include in the list. All other instance types are ignored, even if they match your specified attributes.
   * - \`ExcludedInstanceTypes\` - The instance types to exclude from the list, even if they match your specified attributes.
   *
   * > You must specify \`VCpuCount\` and \`MemoryMiB\` . All other attributes are optional. Any unspecified optional attribute is set to its default.
   *
   * For more information, see [Attribute-based instance type selection for EC2 Fleet](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html) , [Attribute-based instance type selection for Spot Fleet](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-attribute-based-instance-type-selection.html) , and [Spot placement score](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-placement-score.html) in the *Amazon EC2 User Guide* .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html
   */
  export interface InstanceRequirementsProperty {
    /**
     * The minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips) on an instance.
     *
     * To exclude accelerator-enabled instance types, set \`Max\` to \`0\` .
     *
     * Default: No minimum or maximum limits
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-acceleratorcount
     */
    readonly acceleratorCount?: CfnLaunchTemplate.AcceleratorCountProperty | cdk.IResolvable;

    /**
     * Indicates whether instance types must have accelerators by specific manufacturers.
     *
     * - For instance types with NVIDIA devices, specify \`nvidia\` .
     * - For instance types with AMD devices, specify \`amd\` .
     * - For instance types with AWS devices, specify \`amazon-web-services\` .
     * - For instance types with Xilinx devices, specify \`xilinx\` .
     *
     * Default: Any manufacturer
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-acceleratormanufacturers
     */
    readonly acceleratorManufacturers?: Array<string>;

    /**
     * The accelerators that must be on the instance type.
     *
     * - For instance types with NVIDIA A100 GPUs, specify \`a100\` .
     * - For instance types with NVIDIA V100 GPUs, specify \`v100\` .
     * - For instance types with NVIDIA K80 GPUs, specify \`k80\` .
     * - For instance types with NVIDIA T4 GPUs, specify \`t4\` .
     * - For instance types with NVIDIA M60 GPUs, specify \`m60\` .
     * - For instance types with AMD Radeon Pro V520 GPUs, specify \`radeon-pro-v520\` .
     * - For instance types with Xilinx VU9P FPGAs, specify \`vu9p\` .
     * - For instance types with AWS Inferentia chips, specify \`inferentia\` .
     * - For instance types with NVIDIA GRID K520 GPUs, specify \`k520\` .
     *
     * Default: Any accelerator
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-acceleratornames
     */
    readonly acceleratorNames?: Array<string>;

    /**
     * The minimum and maximum amount of total accelerator memory, in MiB.
     *
     * Default: No minimum or maximum limits
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-acceleratortotalmemorymib
     */
    readonly acceleratorTotalMemoryMiB?: CfnLaunchTemplate.AcceleratorTotalMemoryMiBProperty | cdk.IResolvable;

    /**
     * The accelerator types that must be on the instance type.
     *
     * - For instance types with GPU accelerators, specify \`gpu\` .
     * - For instance types with FPGA accelerators, specify \`fpga\` .
     * - For instance types with inference accelerators, specify \`inference\` .
     *
     * Default: Any accelerator type
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-acceleratortypes
     */
    readonly acceleratorTypes?: Array<string>;

    /**
     * The instance types to apply your specified attributes against.
     *
     * All other instance types are ignored, even if they match your specified attributes.
     *
     * You can use strings with one or more wild cards, represented by an asterisk ( \`*\` ), to allow an instance type, size, or generation. The following are examples: \`m5.8xlarge\` , \`c5*.*\` , \`m5a.*\` , \`r*\` , \`*3*\` .
     *
     * For example, if you specify \`c5*\` ,Amazon EC2 will allow the entire C5 instance family, which includes all C5a and C5n instance types. If you specify \`m5a.*\` , Amazon EC2 will allow all the M5a instance types, but not the M5n instance types.
     *
     * > If you specify \`AllowedInstanceTypes\` , you can't specify \`ExcludedInstanceTypes\` .
     *
     * Default: All instance types
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-allowedinstancetypes
     */
    readonly allowedInstanceTypes?: Array<string>;

    /**
     * Indicates whether bare metal instance types must be included, excluded, or required.
     *
     * - To include bare metal instance types, specify \`included\` .
     * - To require only bare metal instance types, specify \`required\` .
     * - To exclude bare metal instance types, specify \`excluded\` .
     *
     * Default: \`excluded\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-baremetal
     */
    readonly bareMetal?: string;

    /**
     * The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps.
     *
     * For more information, see [Amazon EBSoptimized instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html) in the *Amazon EC2 User Guide* .
     *
     * Default: No minimum or maximum limits
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-baselineebsbandwidthmbps
     */
    readonly baselineEbsBandwidthMbps?: CfnLaunchTemplate.BaselineEbsBandwidthMbpsProperty | cdk.IResolvable;

    /**
     * Indicates whether burstable performance T instance types are included, excluded, or required.
     *
     * For more information, see [Burstable performance instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html) .
     *
     * - To include burstable performance instance types, specify \`included\` .
     * - To require only burstable performance instance types, specify \`required\` .
     * - To exclude burstable performance instance types, specify \`excluded\` .
     *
     * Default: \`excluded\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-burstableperformance
     */
    readonly burstablePerformance?: string;

    /**
     * The CPU manufacturers to include.
     *
     * - For instance types with Intel CPUs, specify \`intel\` .
     * - For instance types with AMD CPUs, specify \`amd\` .
     * - For instance types with AWS CPUs, specify \`amazon-web-services\` .
     *
     * > Don't confuse the CPU manufacturer with the CPU architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template.
     *
     * Default: Any manufacturer
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-cpumanufacturers
     */
    readonly cpuManufacturers?: Array<string>;

    /**
     * The instance types to exclude.
     *
     * You can use strings with one or more wild cards, represented by an asterisk ( \`*\` ), to exclude an instance type, size, or generation. The following are examples: \`m5.8xlarge\` , \`c5*.*\` , \`m5a.*\` , \`r*\` , \`*3*\` .
     *
     * For example, if you specify \`c5*\` ,Amazon EC2 will exclude the entire C5 instance family, which includes all C5a and C5n instance types. If you specify \`m5a.*\` , Amazon EC2 will exclude all the M5a instance types, but not the M5n instance types.
     *
     * > If you specify \`ExcludedInstanceTypes\` , you can't specify \`AllowedInstanceTypes\` .
     *
     * Default: No excluded instance types
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-excludedinstancetypes
     */
    readonly excludedInstanceTypes?: Array<string>;

    /**
     * Indicates whether current or previous generation instance types are included.
     *
     * The current generation instance types are recommended for use. Current generation instance types are typically the latest two to three generations in each instance family. For more information, see [Instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the *Amazon EC2 User Guide* .
     *
     * For current generation instance types, specify \`current\` .
     *
     * For previous generation instance types, specify \`previous\` .
     *
     * Default: Current and previous generation instance types
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-instancegenerations
     */
    readonly instanceGenerations?: Array<string>;

    /**
     * Indicates whether instance types with instance store volumes are included, excluded, or required.
     *
     * For more information, [Amazon EC2 instance store](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html) in the *Amazon EC2 User Guide* .
     *
     * - To include instance types with instance store volumes, specify \`included\` .
     * - To require only instance types with instance store volumes, specify \`required\` .
     * - To exclude instance types with instance store volumes, specify \`excluded\` .
     *
     * Default: \`included\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-localstorage
     */
    readonly localStorage?: string;

    /**
     * The type of local storage that is required.
     *
     * - For instance types with hard disk drive (HDD) storage, specify \`hdd\` .
     * - For instance types with solid state drive (SSD) storage, specify \`ssd\` .
     *
     * Default: \`hdd\` and \`ssd\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-localstoragetypes
     */
    readonly localStorageTypes?: Array<string>;

    /**
     * The minimum and maximum amount of memory per vCPU, in GiB.
     *
     * Default: No minimum or maximum limits
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-memorygibpervcpu
     */
    readonly memoryGiBPerVCpu?: cdk.IResolvable | CfnLaunchTemplate.MemoryGiBPerVCpuProperty;

    /**
     * The minimum and maximum amount of memory, in MiB.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-memorymib
     */
    readonly memoryMiB?: cdk.IResolvable | CfnLaunchTemplate.MemoryMiBProperty;

    /**
     * The minimum and maximum amount of network bandwidth, in gigabits per second (Gbps).
     *
     * Default: No minimum or maximum limits
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-networkbandwidthgbps
     */
    readonly networkBandwidthGbps?: cdk.IResolvable | CfnLaunchTemplate.NetworkBandwidthGbpsProperty;

    /**
     * The minimum and maximum number of network interfaces.
     *
     * Default: No minimum or maximum limits
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-networkinterfacecount
     */
    readonly networkInterfaceCount?: cdk.IResolvable | CfnLaunchTemplate.NetworkInterfaceCountProperty;

    /**
     * The price protection threshold for On-Demand Instances.
     *
     * This is the maximum youll pay for an On-Demand Instance, expressed as a percentage above the least expensive current generation M, C, or R instance type with your specified attributes. When Amazon EC2 selects instance types with your attributes, it excludes instance types priced above your threshold.
     *
     * The parameter accepts an integer, which Amazon EC2 interprets as a percentage.
     *
     * To turn off price protection, specify a high value, such as \`999999\` .
     *
     * This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) and [GetInstanceTypesFromInstanceRequirements](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html) .
     *
     * > If you set \`TargetCapacityUnitType\` to \`vcpu\` or \`memory-mib\` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price.
     *
     * Default: \`20\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-ondemandmaxpricepercentageoverlowestprice
     */
    readonly onDemandMaxPricePercentageOverLowestPrice?: number;

    /**
     * Indicates whether instance types must support hibernation for On-Demand Instances.
     *
     * This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) .
     *
     * Default: \`false\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-requirehibernatesupport
     */
    readonly requireHibernateSupport?: boolean | cdk.IResolvable;

    /**
     * The price protection threshold for Spot Instances.
     *
     * This is the maximum youll pay for a Spot Instance, expressed as a percentage above the least expensive current generation M, C, or R instance type with your specified attributes. When Amazon EC2 selects instance types with your attributes, it excludes instance types priced above your threshold.
     *
     * The parameter accepts an integer, which Amazon EC2 interprets as a percentage.
     *
     * To turn off price protection, specify a high value, such as \`999999\` .
     *
     * This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) and [GetInstanceTypesFromInstanceRequirements](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html) .
     *
     * > If you set \`TargetCapacityUnitType\` to \`vcpu\` or \`memory-mib\` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price.
     *
     * Default: \`100\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-spotmaxpricepercentageoverlowestprice
     */
    readonly spotMaxPricePercentageOverLowestPrice?: number;

    /**
     * The minimum and maximum amount of total local storage, in GB.
     *
     * Default: No minimum or maximum limits
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-totallocalstoragegb
     */
    readonly totalLocalStorageGb?: cdk.IResolvable | CfnLaunchTemplate.TotalLocalStorageGBProperty;

    /**
     * The minimum and maximum number of vCPUs.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-vcpucount
     */
    readonly vCpuCount?: cdk.IResolvable | CfnLaunchTemplate.VCpuCountProperty;
  }

  /**
   * The minimum and maximum number of network interfaces.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterfacecount.html
   */
  export interface NetworkInterfaceCountProperty {
    /**
     * The maximum number of network interfaces.
     *
     * To specify no maximum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterfacecount.html#cfn-ec2-launchtemplate-networkinterfacecount-max
     */
    readonly max?: number;

    /**
     * The minimum number of network interfaces.
     *
     * To specify no minimum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterfacecount.html#cfn-ec2-launchtemplate-networkinterfacecount-min
     */
    readonly min?: number;
  }

  /**
   * The minimum and maximum amount of memory per vCPU, in GiB.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-memorygibpervcpu.html
   */
  export interface MemoryGiBPerVCpuProperty {
    /**
     * The maximum amount of memory per vCPU, in GiB.
     *
     * To specify no maximum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-memorygibpervcpu.html#cfn-ec2-launchtemplate-memorygibpervcpu-max
     */
    readonly max?: number;

    /**
     * The minimum amount of memory per vCPU, in GiB.
     *
     * To specify no minimum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-memorygibpervcpu.html#cfn-ec2-launchtemplate-memorygibpervcpu-min
     */
    readonly min?: number;
  }

  /**
   * The minimum and maximum number of vCPUs.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-vcpucount.html
   */
  export interface VCpuCountProperty {
    /**
     * The maximum number of vCPUs.
     *
     * To specify no maximum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-vcpucount.html#cfn-ec2-launchtemplate-vcpucount-max
     */
    readonly max?: number;

    /**
     * The minimum number of vCPUs.
     *
     * To specify no minimum limit, specify \`0\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-vcpucount.html#cfn-ec2-launchtemplate-vcpucount-min
     */
    readonly min?: number;
  }

  /**
   * The minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips) on an instance.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-acceleratorcount.html
   */
  export interface AcceleratorCountProperty {
    /**
     * The maximum number of accelerators.
     *
     * To specify no maximum limit, omit this parameter. To exclude accelerator-enabled instance types, set \`Max\` to \`0\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-acceleratorcount.html#cfn-ec2-launchtemplate-acceleratorcount-max
     */
    readonly max?: number;

    /**
     * The minimum number of accelerators.
     *
     * To specify no minimum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-acceleratorcount.html#cfn-ec2-launchtemplate-acceleratorcount-min
     */
    readonly min?: number;
  }

  /**
   * The minimum and maximum amount of network bandwidth, in gigabits per second (Gbps).
   *
   * > Setting the minimum bandwidth does not guarantee that your instance will achieve the minimum bandwidth. Amazon EC2 will identify instance types that support the specified minimum bandwidth, but the actual bandwidth of your instance might go below the specified minimum at times. For more information, see [Available instance bandwidth](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-network-bandwidth.html#available-instance-bandwidth) in the *Amazon EC2 User Guide* .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkbandwidthgbps.html
   */
  export interface NetworkBandwidthGbpsProperty {
    /**
     * The maximum amount of network bandwidth, in Gbps.
     *
     * To specify no maximum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkbandwidthgbps.html#cfn-ec2-launchtemplate-networkbandwidthgbps-max
     */
    readonly max?: number;

    /**
     * The minimum amount of network bandwidth, in Gbps.
     *
     * If this parameter is not specified, there is no minimum limit.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkbandwidthgbps.html#cfn-ec2-launchtemplate-networkbandwidthgbps-min
     */
    readonly min?: number;
  }

  /**
   * The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps.
   *
   * For more information, see [Amazon EBSoptimized instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html) in the *Amazon EC2 User Guide* .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-baselineebsbandwidthmbps.html
   */
  export interface BaselineEbsBandwidthMbpsProperty {
    /**
     * The maximum baseline bandwidth, in Mbps.
     *
     * To specify no maximum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-baselineebsbandwidthmbps.html#cfn-ec2-launchtemplate-baselineebsbandwidthmbps-max
     */
    readonly max?: number;

    /**
     * The minimum baseline bandwidth, in Mbps.
     *
     * To specify no minimum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-baselineebsbandwidthmbps.html#cfn-ec2-launchtemplate-baselineebsbandwidthmbps-min
     */
    readonly min?: number;
  }

  /**
   * The minimum and maximum amount of total accelerator memory, in MiB.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-acceleratortotalmemorymib.html
   */
  export interface AcceleratorTotalMemoryMiBProperty {
    /**
     * The maximum amount of accelerator memory, in MiB.
     *
     * To specify no maximum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-acceleratortotalmemorymib.html#cfn-ec2-launchtemplate-acceleratortotalmemorymib-max
     */
    readonly max?: number;

    /**
     * The minimum amount of accelerator memory, in MiB.
     *
     * To specify no minimum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-acceleratortotalmemorymib.html#cfn-ec2-launchtemplate-acceleratortotalmemorymib-min
     */
    readonly min?: number;
  }

  /**
   * The minimum and maximum amount of memory, in MiB.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-memorymib.html
   */
  export interface MemoryMiBProperty {
    /**
     * The maximum amount of memory, in MiB.
     *
     * To specify no maximum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-memorymib.html#cfn-ec2-launchtemplate-memorymib-max
     */
    readonly max?: number;

    /**
     * The minimum amount of memory, in MiB.
     *
     * To specify no minimum limit, specify \`0\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-memorymib.html#cfn-ec2-launchtemplate-memorymib-min
     */
    readonly min?: number;
  }

  /**
   * The minimum and maximum amount of total local storage, in GB.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-totallocalstoragegb.html
   */
  export interface TotalLocalStorageGBProperty {
    /**
     * The maximum amount of total local storage, in GB.
     *
     * To specify no maximum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-totallocalstoragegb.html#cfn-ec2-launchtemplate-totallocalstoragegb-max
     */
    readonly max?: number;

    /**
     * The minimum amount of total local storage, in GB.
     *
     * To specify no minimum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-totallocalstoragegb.html#cfn-ec2-launchtemplate-totallocalstoragegb-min
     */
    readonly min?: number;
  }

  /**
   * Specifies an instance's Capacity Reservation targeting option. You can specify only one option at a time.
   *
   * \`CapacityReservationSpecification\` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html) .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-capacityreservationspecification.html
   */
  export interface CapacityReservationSpecificationProperty {
    /**
     * Indicates the instance's Capacity Reservation preferences. Possible preferences include:.
     *
     * - \`open\` - The instance can run in any \`open\` Capacity Reservation that has matching attributes (instance type, platform, Availability Zone).
     * - \`none\` - The instance avoids running in a Capacity Reservation even if one is available. The instance runs in On-Demand capacity.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-capacityreservationspecification.html#cfn-ec2-launchtemplate-capacityreservationspecification-capacityreservationpreference
     */
    readonly capacityReservationPreference?: string;

    /**
     * Information about the target Capacity Reservation or Capacity Reservation group.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-capacityreservationspecification.html#cfn-ec2-launchtemplate-capacityreservationspecification-capacityreservationtarget
     */
    readonly capacityReservationTarget?: CfnLaunchTemplate.CapacityReservationTargetProperty | cdk.IResolvable;
  }

  /**
   * Specifies a target Capacity Reservation.
   *
   * \`CapacityReservationTarget\` is a property of the [Amazon EC2 LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html) property type.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-capacityreservationtarget.html
   */
  export interface CapacityReservationTargetProperty {
    /**
     * The ID of the Capacity Reservation in which to run the instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-capacityreservationtarget.html#cfn-ec2-launchtemplate-capacityreservationtarget-capacityreservationid
     */
    readonly capacityReservationId?: string;

    /**
     * The ARN of the Capacity Reservation resource group in which to run the instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-capacityreservationtarget.html#cfn-ec2-launchtemplate-capacityreservationtarget-capacityreservationresourcegrouparn
     */
    readonly capacityReservationResourceGroupArn?: string;
  }

  /**
   * Specifies the credit option for CPU usage of a T2, T3, or T3a instance.
   *
   * \`CreditSpecification\` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html) .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-creditspecification.html
   */
  export interface CreditSpecificationProperty {
    /**
     * The credit option for CPU usage of a T instance.
     *
     * Valid values: \`standard\` | \`unlimited\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-creditspecification.html#cfn-ec2-launchtemplate-creditspecification-cpucredits
     */
    readonly cpuCredits?: string;
  }

  /**
   * Specifies the tags to apply to the launch template during creation.
   *
   * \`LaunchTemplateTagSpecification\` is a property of [AWS::EC2::LaunchTemplate](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html) .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatetagspecification.html
   */
  export interface LaunchTemplateTagSpecificationProperty {
    /**
     * The type of resource.
     *
     * To tag the launch template, \`ResourceType\` must be \`launch-template\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatetagspecification.html#cfn-ec2-launchtemplate-launchtemplatetagspecification-resourcetype
     */
    readonly resourceType?: string;

    /**
     * The tags for the resource.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatetagspecification.html#cfn-ec2-launchtemplate-launchtemplatetagspecification-tags
     */
    readonly tags?: Array<cdk.CfnTag>;
  }
}

/**
 * Properties for defining a \`CfnLaunchTemplate\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html
 */
export interface CfnLaunchTemplateProps {
  /**
   * The information for the launch template.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#cfn-ec2-launchtemplate-launchtemplatedata
   */
  readonly launchTemplateData: cdk.IResolvable | CfnLaunchTemplate.LaunchTemplateDataProperty;

  /**
   * A name for the launch template.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#cfn-ec2-launchtemplate-launchtemplatename
   */
  readonly launchTemplateName?: string;

  /**
   * The tags to apply to the launch template on creation.
   *
   * To tag the launch template, the resource type must be \`launch-template\` .
   *
   * > To specify the tags for the resources that are created when an instance is launched, you must use the \`TagSpecifications\` parameter in the [launch template data](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RequestLaunchTemplateData.html) structure.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#cfn-ec2-launchtemplate-tagspecifications
   */
  readonly tagSpecifications?: Array<cdk.IResolvable | CfnLaunchTemplate.LaunchTemplateTagSpecificationProperty> | cdk.IResolvable;

  /**
   * A description for the first version of the launch template.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#cfn-ec2-launchtemplate-versiondescription
   */
  readonly versionDescription?: string;
}

/**
 * Determine whether the given properties match those of a \`TagSpecificationProperty\`
 *
 * @param properties - the TypeScript properties of a \`TagSpecificationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateTagSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("resourceType", cdk.validateString)(properties.resourceType));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"TagSpecificationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateTagSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateTagSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "ResourceType": cdk.stringToCloudFormation(properties.resourceType),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateTagSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnLaunchTemplate.TagSpecificationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.TagSpecificationProperty>();
  ret.addPropertyResult("resourceType", "ResourceType", (properties.ResourceType != null ? cfn_parse.FromCloudFormation.getString(properties.ResourceType) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`EbsProperty\`
 *
 * @param properties - the TypeScript properties of a \`EbsProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateEbsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("deleteOnTermination", cdk.validateBoolean)(properties.deleteOnTermination));
  errors.collect(cdk.propertyValidator("encrypted", cdk.validateBoolean)(properties.encrypted));
  errors.collect(cdk.propertyValidator("iops", cdk.validateNumber)(properties.iops));
  errors.collect(cdk.propertyValidator("kmsKeyId", cdk.validateString)(properties.kmsKeyId));
  errors.collect(cdk.propertyValidator("snapshotId", cdk.validateString)(properties.snapshotId));
  errors.collect(cdk.propertyValidator("throughput", cdk.validateNumber)(properties.throughput));
  errors.collect(cdk.propertyValidator("volumeSize", cdk.validateNumber)(properties.volumeSize));
  errors.collect(cdk.propertyValidator("volumeType", cdk.validateString)(properties.volumeType));
  return errors.wrap("supplied properties not correct for \\"EbsProperty\\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateEbsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateEbsPropertyValidator(properties).assertSuccess();
  return {
    "DeleteOnTermination": cdk.booleanToCloudFormation(properties.deleteOnTermination),
    "Encrypted": cdk.booleanToCloudFormation(properties.encrypted),
    "Iops": cdk.numberToCloudFormation(properties.iops),
    "KmsKeyId": cdk.stringToCloudFormation(properties.kmsKeyId),
    "SnapshotId": cdk.stringToCloudFormation(properties.snapshotId),
    "Throughput": cdk.numberToCloudFormation(properties.throughput),
    "VolumeSize": cdk.numberToCloudFormation(properties.volumeSize),
    "VolumeType": cdk.stringToCloudFormation(properties.volumeType)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateEbsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnLaunchTemplate.EbsProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.EbsProperty>();
  ret.addPropertyResult("deleteOnTermination", "DeleteOnTermination", (properties.DeleteOnTermination != null ? cfn_parse.FromCloudFormation.getBoolean(properties.DeleteOnTermination) : undefined));
  ret.addPropertyResult("encrypted", "Encrypted", (properties.Encrypted != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Encrypted) : undefined));
  ret.addPropertyResult("iops", "Iops", (properties.Iops != null ? cfn_parse.FromCloudFormation.getNumber(properties.Iops) : undefined));
  ret.addPropertyResult("kmsKeyId", "KmsKeyId", (properties.KmsKeyId != null ? cfn_parse.FromCloudFormation.getString(properties.KmsKeyId) : undefined));
  ret.addPropertyResult("snapshotId", "SnapshotId", (properties.SnapshotId != null ? cfn_parse.FromCloudFormation.getString(properties.SnapshotId) : undefined));
  ret.addPropertyResult("throughput", "Throughput", (properties.Throughput != null ? cfn_parse.FromCloudFormation.getNumber(properties.Throughput) : undefined));
  ret.addPropertyResult("volumeSize", "VolumeSize", (properties.VolumeSize != null ? cfn_parse.FromCloudFormation.getNumber(properties.VolumeSize) : undefined));
  ret.addPropertyResult("volumeType", "VolumeType", (properties.VolumeType != null ? cfn_parse.FromCloudFormation.getString(properties.VolumeType) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`BlockDeviceMappingProperty\`
 *
 * @param properties - the TypeScript properties of a \`BlockDeviceMappingProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateBlockDeviceMappingPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("deviceName", cdk.validateString)(properties.deviceName));
  errors.collect(cdk.propertyValidator("ebs", CfnLaunchTemplateEbsPropertyValidator)(properties.ebs));
  errors.collect(cdk.propertyValidator("noDevice", cdk.validateString)(properties.noDevice));
  errors.collect(cdk.propertyValidator("virtualName", cdk.validateString)(properties.virtualName));
  return errors.wrap("supplied properties not correct for \\"BlockDeviceMappingProperty\\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateBlockDeviceMappingPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateBlockDeviceMappingPropertyValidator(properties).assertSuccess();
  return {
    "DeviceName": cdk.stringToCloudFormation(properties.deviceName),
    "Ebs": convertCfnLaunchTemplateEbsPropertyToCloudFormation(properties.ebs),
    "NoDevice": cdk.stringToCloudFormation(properties.noDevice),
    "VirtualName": cdk.stringToCloudFormation(properties.virtualName)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateBlockDeviceMappingPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnLaunchTemplate.BlockDeviceMappingProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.BlockDeviceMappingProperty>();
  ret.addPropertyResult("deviceName", "DeviceName", (properties.DeviceName != null ? cfn_parse.FromCloudFormation.getString(properties.DeviceName) : undefined));
  ret.addPropertyResult("ebs", "Ebs", (properties.Ebs != null ? CfnLaunchTemplateEbsPropertyFromCloudFormation(properties.Ebs) : undefined));
  ret.addPropertyResult("noDevice", "NoDevice", (properties.NoDevice != null ? cfn_parse.FromCloudFormation.getString(properties.NoDevice) : undefined));
  ret.addPropertyResult("virtualName", "VirtualName", (properties.VirtualName != null ? cfn_parse.FromCloudFormation.getString(properties.VirtualName) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`MaintenanceOptionsProperty\`
 *
 * @param properties - the TypeScript properties of a \`MaintenanceOptionsProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateMaintenanceOptionsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("autoRecovery", cdk.validateString)(properties.autoRecovery));
  return errors.wrap("supplied properties not correct for \\"MaintenanceOptionsProperty\\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateMaintenanceOptionsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateMaintenanceOptionsPropertyValidator(properties).assertSuccess();
  return {
    "AutoRecovery": cdk.stringToCloudFormation(properties.autoRecovery)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateMaintenanceOptionsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnLaunchTemplate.MaintenanceOptionsProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.MaintenanceOptionsProperty>();
  ret.addPropertyResult("autoRecovery", "AutoRecovery", (properties.AutoRecovery != null ? cfn_parse.FromCloudFormation.getString(properties.AutoRecovery) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`IamInstanceProfileProperty\`
 *
 * @param properties - the TypeScript properties of a \`IamInstanceProfileProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateIamInstanceProfilePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("arn", cdk.validateString)(properties.arn));
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  return errors.wrap("supplied properties not correct for \\"IamInstanceProfileProperty\\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateIamInstanceProfilePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateIamInstanceProfilePropertyValidator(properties).assertSuccess();
  return {
    "Arn": cdk.stringToCloudFormation(properties.arn),
    "Name": cdk.stringToCloudFormation(properties.name)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateIamInstanceProfilePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnLaunchTemplate.IamInstanceProfileProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.IamInstanceProfileProperty>();
  ret.addPropertyResult("arn", "Arn", (properties.Arn != null ? cfn_parse.FromCloudFormation.getString(properties.Arn) : undefined));
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ElasticGpuSpecificationProperty\`
 *
 * @param properties - the TypeScript properties of a \`ElasticGpuSpecificationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateElasticGpuSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  return errors.wrap("supplied properties not correct for \\"ElasticGpuSpecificationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateElasticGpuSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateElasticGpuSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "Type": cdk.stringToCloudFormation(properties.type)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateElasticGpuSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnLaunchTemplate.ElasticGpuSpecificationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.ElasticGpuSpecificationProperty>();
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`LaunchTemplateElasticInferenceAcceleratorProperty\`
 *
 * @param properties - the TypeScript properties of a \`LaunchTemplateElasticInferenceAcceleratorProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateLaunchTemplateElasticInferenceAcceleratorPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("count", cdk.validateNumber)(properties.count));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  return errors.wrap("supplied properties not correct for \\"LaunchTemplateElasticInferenceAcceleratorProperty\\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateLaunchTemplateElasticInferenceAcceleratorPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateLaunchTemplateElasticInferenceAcceleratorPropertyValidator(properties).assertSuccess();
  return {
    "Count": cdk.numberToCloudFormation(properties.count),
    "Type": cdk.stringToCloudFormation(properties.type)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateLaunchTemplateElasticInferenceAcceleratorPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnLaunchTemplate.LaunchTemplateElasticInferenceAcceleratorProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.LaunchTemplateElasticInferenceAcceleratorProperty>();
  ret.addPropertyResult("count", "Count", (properties.Count != null ? cfn_parse.FromCloudFormation.getNumber(properties.Count) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`PlacementProperty\`
 *
 * @param properties - the TypeScript properties of a \`PlacementProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplatePlacementPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("affinity", cdk.validateString)(properties.affinity));
  errors.collect(cdk.propertyValidator("availabilityZone", cdk.validateString)(properties.availabilityZone));
  errors.collect(cdk.propertyValidator("groupId", cdk.validateString)(properties.groupId));
  errors.collect(cdk.propertyValidator("groupName", cdk.validateString)(properties.groupName));
  errors.collect(cdk.propertyValidator("hostId", cdk.validateString)(properties.hostId));
  errors.collect(cdk.propertyValidator("hostResourceGroupArn", cdk.validateString)(properties.hostResourceGroupArn));
  errors.collect(cdk.propertyValidator("partitionNumber", cdk.validateNumber)(properties.partitionNumber));
  errors.collect(cdk.propertyValidator("spreadDomain", cdk.validateString)(properties.spreadDomain));
  errors.collect(cdk.propertyValidator("tenancy", cdk.validateString)(properties.tenancy));
  return errors.wrap("supplied properties not correct for \\"PlacementProperty\\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplatePlacementPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplatePlacementPropertyValidator(properties).assertSuccess();
  return {
    "Affinity": cdk.stringToCloudFormation(properties.affinity),
    "AvailabilityZone": cdk.stringToCloudFormation(properties.availabilityZone),
    "GroupId": cdk.stringToCloudFormation(properties.groupId),
    "GroupName": cdk.stringToCloudFormation(properties.groupName),
    "HostId": cdk.stringToCloudFormation(properties.hostId),
    "HostResourceGroupArn": cdk.stringToCloudFormation(properties.hostResourceGroupArn),
    "PartitionNumber": cdk.numberToCloudFormation(properties.partitionNumber),
    "SpreadDomain": cdk.stringToCloudFormation(properties.spreadDomain),
    "Tenancy": cdk.stringToCloudFormation(properties.tenancy)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplatePlacementPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnLaunchTemplate.PlacementProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.PlacementProperty>();
  ret.addPropertyResult("affinity", "Affinity", (properties.Affinity != null ? cfn_parse.FromCloudFormation.getString(properties.Affinity) : undefined));
  ret.addPropertyResult("availabilityZone", "AvailabilityZone", (properties.AvailabilityZone != null ? cfn_parse.FromCloudFormation.getString(properties.AvailabilityZone) : undefined));
  ret.addPropertyResult("groupId", "GroupId", (properties.GroupId != null ? cfn_parse.FromCloudFormation.getString(properties.GroupId) : undefined));
  ret.addPropertyResult("groupName", "GroupName", (properties.GroupName != null ? cfn_parse.FromCloudFormation.getString(properties.GroupName) : undefined));
  ret.addPropertyResult("hostId", "HostId", (properties.HostId != null ? cfn_parse.FromCloudFormation.getString(properties.HostId) : undefined));
  ret.addPropertyResult("hostResourceGroupArn", "HostResourceGroupArn", (properties.HostResourceGroupArn != null ? cfn_parse.FromCloudFormation.getString(properties.HostResourceGroupArn) : undefined));
  ret.addPropertyResult("partitionNumber", "PartitionNumber", (properties.PartitionNumber != null ? cfn_parse.FromCloudFormation.getNumber(properties.PartitionNumber) : undefined));
  ret.addPropertyResult("spreadDomain", "SpreadDomain", (properties.SpreadDomain != null ? cfn_parse.FromCloudFormation.getString(properties.SpreadDomain) : undefined));
  ret.addPropertyResult("tenancy", "Tenancy", (properties.Tenancy != null ? cfn_parse.FromCloudFormation.getString(properties.Tenancy) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`PrivateIpAddProperty\`
 *
 * @param properties - the TypeScript properties of a \`PrivateIpAddProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplatePrivateIpAddPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("primary", cdk.validateBoolean)(properties.primary));
  errors.collect(cdk.propertyValidator("privateIpAddress", cdk.validateString)(properties.privateIpAddress));
  return errors.wrap("supplied properties not correct for \\"PrivateIpAddProperty\\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplatePrivateIpAddPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplatePrivateIpAddPropertyValidator(properties).assertSuccess();
  return {
    "Primary": cdk.booleanToCloudFormation(properties.primary),
    "PrivateIpAddress": cdk.stringToCloudFormation(properties.privateIpAddress)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplatePrivateIpAddPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnLaunchTemplate.PrivateIpAddProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.PrivateIpAddProperty>();
  ret.addPropertyResult("primary", "Primary", (properties.Primary != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Primary) : undefined));
  ret.addPropertyResult("privateIpAddress", "PrivateIpAddress", (properties.PrivateIpAddress != null ? cfn_parse.FromCloudFormation.getString(properties.PrivateIpAddress) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`Ipv4PrefixSpecificationProperty\`
 *
 * @param properties - the TypeScript properties of a \`Ipv4PrefixSpecificationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateIpv4PrefixSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("ipv4Prefix", cdk.validateString)(properties.ipv4Prefix));
  return errors.wrap("supplied properties not correct for \\"Ipv4PrefixSpecificationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateIpv4PrefixSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateIpv4PrefixSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "Ipv4Prefix": cdk.stringToCloudFormation(properties.ipv4Prefix)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateIpv4PrefixSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnLaunchTemplate.Ipv4PrefixSpecificationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.Ipv4PrefixSpecificationProperty>();
  ret.addPropertyResult("ipv4Prefix", "Ipv4Prefix", (properties.Ipv4Prefix != null ? cfn_parse.FromCloudFormation.getString(properties.Ipv4Prefix) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`Ipv6PrefixSpecificationProperty\`
 *
 * @param properties - the TypeScript properties of a \`Ipv6PrefixSpecificationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateIpv6PrefixSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("ipv6Prefix", cdk.validateString)(properties.ipv6Prefix));
  return errors.wrap("supplied properties not correct for \\"Ipv6PrefixSpecificationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateIpv6PrefixSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateIpv6PrefixSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "Ipv6Prefix": cdk.stringToCloudFormation(properties.ipv6Prefix)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateIpv6PrefixSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnLaunchTemplate.Ipv6PrefixSpecificationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.Ipv6PrefixSpecificationProperty>();
  ret.addPropertyResult("ipv6Prefix", "Ipv6Prefix", (properties.Ipv6Prefix != null ? cfn_parse.FromCloudFormation.getString(properties.Ipv6Prefix) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`Ipv6AddProperty\`
 *
 * @param properties - the TypeScript properties of a \`Ipv6AddProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateIpv6AddPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("ipv6Address", cdk.validateString)(properties.ipv6Address));
  return errors.wrap("supplied properties not correct for \\"Ipv6AddProperty\\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateIpv6AddPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateIpv6AddPropertyValidator(properties).assertSuccess();
  return {
    "Ipv6Address": cdk.stringToCloudFormation(properties.ipv6Address)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateIpv6AddPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnLaunchTemplate.Ipv6AddProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.Ipv6AddProperty>();
  ret.addPropertyResult("ipv6Address", "Ipv6Address", (properties.Ipv6Address != null ? cfn_parse.FromCloudFormation.getString(properties.Ipv6Address) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`NetworkInterfaceProperty\`
 *
 * @param properties - the TypeScript properties of a \`NetworkInterfaceProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateNetworkInterfacePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("associateCarrierIpAddress", cdk.validateBoolean)(properties.associateCarrierIpAddress));
  errors.collect(cdk.propertyValidator("associatePublicIpAddress", cdk.validateBoolean)(properties.associatePublicIpAddress));
  errors.collect(cdk.propertyValidator("deleteOnTermination", cdk.validateBoolean)(properties.deleteOnTermination));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("deviceIndex", cdk.validateNumber)(properties.deviceIndex));
  errors.collect(cdk.propertyValidator("groups", cdk.listValidator(cdk.validateString))(properties.groups));
  errors.collect(cdk.propertyValidator("interfaceType", cdk.validateString)(properties.interfaceType));
  errors.collect(cdk.propertyValidator("ipv4PrefixCount", cdk.validateNumber)(properties.ipv4PrefixCount));
  errors.collect(cdk.propertyValidator("ipv4Prefixes", cdk.listValidator(CfnLaunchTemplateIpv4PrefixSpecificationPropertyValidator))(properties.ipv4Prefixes));
  errors.collect(cdk.propertyValidator("ipv6AddressCount", cdk.validateNumber)(properties.ipv6AddressCount));
  errors.collect(cdk.propertyValidator("ipv6Addresses", cdk.listValidator(CfnLaunchTemplateIpv6AddPropertyValidator))(properties.ipv6Addresses));
  errors.collect(cdk.propertyValidator("ipv6PrefixCount", cdk.validateNumber)(properties.ipv6PrefixCount));
  errors.collect(cdk.propertyValidator("ipv6Prefixes", cdk.listValidator(CfnLaunchTemplateIpv6PrefixSpecificationPropertyValidator))(properties.ipv6Prefixes));
  errors.collect(cdk.propertyValidator("networkCardIndex", cdk.validateNumber)(properties.networkCardIndex));
  errors.collect(cdk.propertyValidator("networkInterfaceId", cdk.validateString)(properties.networkInterfaceId));
  errors.collect(cdk.propertyValidator("privateIpAddress", cdk.validateString)(properties.privateIpAddress));
  errors.collect(cdk.propertyValidator("privateIpAddresses", cdk.listValidator(CfnLaunchTemplatePrivateIpAddPropertyValidator))(properties.privateIpAddresses));
  errors.collect(cdk.propertyValidator("secondaryPrivateIpAddressCount", cdk.validateNumber)(properties.secondaryPrivateIpAddressCount));
  errors.collect(cdk.propertyValidator("subnetId", cdk.validateString)(properties.subnetId));
  return errors.wrap("supplied properties not correct for \\"NetworkInterfaceProperty\\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateNetworkInterfacePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateNetworkInterfacePropertyValidator(properties).assertSuccess();
  return {
    "AssociateCarrierIpAddress": cdk.booleanToCloudFormation(properties.associateCarrierIpAddress),
    "AssociatePublicIpAddress": cdk.booleanToCloudFormation(properties.associatePublicIpAddress),
    "DeleteOnTermination": cdk.booleanToCloudFormation(properties.deleteOnTermination),
    "Description": cdk.stringToCloudFormation(properties.description),
    "DeviceIndex": cdk.numberToCloudFormation(properties.deviceIndex),
    "Groups": cdk.listMapper(cdk.stringToCloudFormation)(properties.groups),
    "InterfaceType": cdk.stringToCloudFormation(properties.interfaceType),
    "Ipv4PrefixCount": cdk.numberToCloudFormation(properties.ipv4PrefixCount),
    "Ipv4Prefixes": cdk.listMapper(convertCfnLaunchTemplateIpv4PrefixSpecificationPropertyToCloudFormation)(properties.ipv4Prefixes),
    "Ipv6AddressCount": cdk.numberToCloudFormation(properties.ipv6AddressCount),
    "Ipv6Addresses": cdk.listMapper(convertCfnLaunchTemplateIpv6AddPropertyToCloudFormation)(properties.ipv6Addresses),
    "Ipv6PrefixCount": cdk.numberToCloudFormation(properties.ipv6PrefixCount),
    "Ipv6Prefixes": cdk.listMapper(convertCfnLaunchTemplateIpv6PrefixSpecificationPropertyToCloudFormation)(properties.ipv6Prefixes),
    "NetworkCardIndex": cdk.numberToCloudFormation(properties.networkCardIndex),
    "NetworkInterfaceId": cdk.stringToCloudFormation(properties.networkInterfaceId),
    "PrivateIpAddress": cdk.stringToCloudFormation(properties.privateIpAddress),
    "PrivateIpAddresses": cdk.listMapper(convertCfnLaunchTemplatePrivateIpAddPropertyToCloudFormation)(properties.privateIpAddresses),
    "SecondaryPrivateIpAddressCount": cdk.numberToCloudFormation(properties.secondaryPrivateIpAddressCount),
    "SubnetId": cdk.stringToCloudFormation(properties.subnetId)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateNetworkInterfacePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnLaunchTemplate.NetworkInterfaceProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.NetworkInterfaceProperty>();
  ret.addPropertyResult("associateCarrierIpAddress", "AssociateCarrierIpAddress", (properties.AssociateCarrierIpAddress != null ? cfn_parse.FromCloudFormation.getBoolean(properties.AssociateCarrierIpAddress) : undefined));
  ret.addPropertyResult("associatePublicIpAddress", "AssociatePublicIpAddress", (properties.AssociatePublicIpAddress != null ? cfn_parse.FromCloudFormation.getBoolean(properties.AssociatePublicIpAddress) : undefined));
  ret.addPropertyResult("deleteOnTermination", "DeleteOnTermination", (properties.DeleteOnTermination != null ? cfn_parse.FromCloudFormation.getBoolean(properties.DeleteOnTermination) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("deviceIndex", "DeviceIndex", (properties.DeviceIndex != null ? cfn_parse.FromCloudFormation.getNumber(properties.DeviceIndex) : undefined));
  ret.addPropertyResult("groups", "Groups", (properties.Groups != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.Groups) : undefined));
  ret.addPropertyResult("interfaceType", "InterfaceType", (properties.InterfaceType != null ? cfn_parse.FromCloudFormation.getString(properties.InterfaceType) : undefined));
  ret.addPropertyResult("ipv4PrefixCount", "Ipv4PrefixCount", (properties.Ipv4PrefixCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.Ipv4PrefixCount) : undefined));
  ret.addPropertyResult("ipv4Prefixes", "Ipv4Prefixes", (properties.Ipv4Prefixes != null ? cfn_parse.FromCloudFormation.getArray(CfnLaunchTemplateIpv4PrefixSpecificationPropertyFromCloudFormation)(properties.Ipv4Prefixes) : undefined));
  ret.addPropertyResult("ipv6AddressCount", "Ipv6AddressCount", (properties.Ipv6AddressCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.Ipv6AddressCount) : undefined));
  ret.addPropertyResult("ipv6Addresses", "Ipv6Addresses", (properties.Ipv6Addresses != null ? cfn_parse.FromCloudFormation.getArray(CfnLaunchTemplateIpv6AddPropertyFromCloudFormation)(properties.Ipv6Addresses) : undefined));
  ret.addPropertyResult("ipv6PrefixCount", "Ipv6PrefixCount", (properties.Ipv6PrefixCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.Ipv6PrefixCount) : undefined));
  ret.addPropertyResult("ipv6Prefixes", "Ipv6Prefixes", (properties.Ipv6Prefixes != null ? cfn_parse.FromCloudFormation.getArray(CfnLaunchTemplateIpv6PrefixSpecificationPropertyFromCloudFormation)(properties.Ipv6Prefixes) : undefined));
  ret.addPropertyResult("networkCardIndex", "NetworkCardIndex", (properties.NetworkCardIndex != null ? cfn_parse.FromCloudFormation.getNumber(properties.NetworkCardIndex) : undefined));
  ret.addPropertyResult("networkInterfaceId", "NetworkInterfaceId", (properties.NetworkInterfaceId != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkInterfaceId) : undefined));
  ret.addPropertyResult("privateIpAddress", "PrivateIpAddress", (properties.PrivateIpAddress != null ? cfn_parse.FromCloudFormation.getString(properties.PrivateIpAddress) : undefined));
  ret.addPropertyResult("privateIpAddresses", "PrivateIpAddresses", (properties.PrivateIpAddresses != null ? cfn_parse.FromCloudFormation.getArray(CfnLaunchTemplatePrivateIpAddPropertyFromCloudFormation)(properties.PrivateIpAddresses) : undefined));
  ret.addPropertyResult("secondaryPrivateIpAddressCount", "SecondaryPrivateIpAddressCount", (properties.SecondaryPrivateIpAddressCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.SecondaryPrivateIpAddressCount) : undefined));
  ret.addPropertyResult("subnetId", "SubnetId", (properties.SubnetId != null ? cfn_parse.FromCloudFormation.getString(properties.SubnetId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`EnclaveOptionsProperty\`
 *
 * @param properties - the TypeScript properties of a \`EnclaveOptionsProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateEnclaveOptionsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("enabled", cdk.validateBoolean)(properties.enabled));
  return errors.wrap("supplied properties not correct for \\"EnclaveOptionsProperty\\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateEnclaveOptionsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateEnclaveOptionsPropertyValidator(properties).assertSuccess();
  return {
    "Enabled": cdk.booleanToCloudFormation(properties.enabled)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateEnclaveOptionsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnLaunchTemplate.EnclaveOptionsProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.EnclaveOptionsProperty>();
  ret.addPropertyResult("enabled", "Enabled", (properties.Enabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Enabled) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`MonitoringProperty\`
 *
 * @param properties - the TypeScript properties of a \`MonitoringProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateMonitoringPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("enabled", cdk.validateBoolean)(properties.enabled));
  return errors.wrap("supplied properties not correct for \\"MonitoringProperty\\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateMonitoringPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateMonitoringPropertyValidator(properties).assertSuccess();
  return {
    "Enabled": cdk.booleanToCloudFormation(properties.enabled)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateMonitoringPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnLaunchTemplate.MonitoringProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.MonitoringProperty>();
  ret.addPropertyResult("enabled", "Enabled", (properties.Enabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Enabled) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`HibernationOptionsProperty\`
 *
 * @param properties - the TypeScript properties of a \`HibernationOptionsProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateHibernationOptionsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("configured", cdk.validateBoolean)(properties.configured));
  return errors.wrap("supplied properties not correct for \\"HibernationOptionsProperty\\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateHibernationOptionsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateHibernationOptionsPropertyValidator(properties).assertSuccess();
  return {
    "Configured": cdk.booleanToCloudFormation(properties.configured)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateHibernationOptionsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnLaunchTemplate.HibernationOptionsProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.HibernationOptionsProperty>();
  ret.addPropertyResult("configured", "Configured", (properties.Configured != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Configured) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`MetadataOptionsProperty\`
 *
 * @param properties - the TypeScript properties of a \`MetadataOptionsProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateMetadataOptionsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("httpEndpoint", cdk.validateString)(properties.httpEndpoint));
  errors.collect(cdk.propertyValidator("httpProtocolIpv6", cdk.validateString)(properties.httpProtocolIpv6));
  errors.collect(cdk.propertyValidator("httpPutResponseHopLimit", cdk.validateNumber)(properties.httpPutResponseHopLimit));
  errors.collect(cdk.propertyValidator("httpTokens", cdk.validateString)(properties.httpTokens));
  errors.collect(cdk.propertyValidator("instanceMetadataTags", cdk.validateString)(properties.instanceMetadataTags));
  return errors.wrap("supplied properties not correct for \\"MetadataOptionsProperty\\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateMetadataOptionsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateMetadataOptionsPropertyValidator(properties).assertSuccess();
  return {
    "HttpEndpoint": cdk.stringToCloudFormation(properties.httpEndpoint),
    "HttpProtocolIpv6": cdk.stringToCloudFormation(properties.httpProtocolIpv6),
    "HttpPutResponseHopLimit": cdk.numberToCloudFormation(properties.httpPutResponseHopLimit),
    "HttpTokens": cdk.stringToCloudFormation(properties.httpTokens),
    "InstanceMetadataTags": cdk.stringToCloudFormation(properties.instanceMetadataTags)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateMetadataOptionsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnLaunchTemplate.MetadataOptionsProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.MetadataOptionsProperty>();
  ret.addPropertyResult("httpEndpoint", "HttpEndpoint", (properties.HttpEndpoint != null ? cfn_parse.FromCloudFormation.getString(properties.HttpEndpoint) : undefined));
  ret.addPropertyResult("httpProtocolIpv6", "HttpProtocolIpv6", (properties.HttpProtocolIpv6 != null ? cfn_parse.FromCloudFormation.getString(properties.HttpProtocolIpv6) : undefined));
  ret.addPropertyResult("httpPutResponseHopLimit", "HttpPutResponseHopLimit", (properties.HttpPutResponseHopLimit != null ? cfn_parse.FromCloudFormation.getNumber(properties.HttpPutResponseHopLimit) : undefined));
  ret.addPropertyResult("httpTokens", "HttpTokens", (properties.HttpTokens != null ? cfn_parse.FromCloudFormation.getString(properties.HttpTokens) : undefined));
  ret.addPropertyResult("instanceMetadataTags", "InstanceMetadataTags", (properties.InstanceMetadataTags != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceMetadataTags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`LicenseSpecificationProperty\`
 *
 * @param properties - the TypeScript properties of a \`LicenseSpecificationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateLicenseSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("licenseConfigurationArn", cdk.validateString)(properties.licenseConfigurationArn));
  return errors.wrap("supplied properties not correct for \\"LicenseSpecificationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateLicenseSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateLicenseSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "LicenseConfigurationArn": cdk.stringToCloudFormation(properties.licenseConfigurationArn)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateLicenseSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnLaunchTemplate.LicenseSpecificationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.LicenseSpecificationProperty>();
  ret.addPropertyResult("licenseConfigurationArn", "LicenseConfigurationArn", (properties.LicenseConfigurationArn != null ? cfn_parse.FromCloudFormation.getString(properties.LicenseConfigurationArn) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CpuOptionsProperty\`
 *
 * @param properties - the TypeScript properties of a \`CpuOptionsProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateCpuOptionsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("amdSevSnp", cdk.validateString)(properties.amdSevSnp));
  errors.collect(cdk.propertyValidator("coreCount", cdk.validateNumber)(properties.coreCount));
  errors.collect(cdk.propertyValidator("threadsPerCore", cdk.validateNumber)(properties.threadsPerCore));
  return errors.wrap("supplied properties not correct for \\"CpuOptionsProperty\\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateCpuOptionsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateCpuOptionsPropertyValidator(properties).assertSuccess();
  return {
    "AmdSevSnp": cdk.stringToCloudFormation(properties.amdSevSnp),
    "CoreCount": cdk.numberToCloudFormation(properties.coreCount),
    "ThreadsPerCore": cdk.numberToCloudFormation(properties.threadsPerCore)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateCpuOptionsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnLaunchTemplate.CpuOptionsProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.CpuOptionsProperty>();
  ret.addPropertyResult("amdSevSnp", "AmdSevSnp", (properties.AmdSevSnp != null ? cfn_parse.FromCloudFormation.getString(properties.AmdSevSnp) : undefined));
  ret.addPropertyResult("coreCount", "CoreCount", (properties.CoreCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.CoreCount) : undefined));
  ret.addPropertyResult("threadsPerCore", "ThreadsPerCore", (properties.ThreadsPerCore != null ? cfn_parse.FromCloudFormation.getNumber(properties.ThreadsPerCore) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`PrivateDnsNameOptionsProperty\`
 *
 * @param properties - the TypeScript properties of a \`PrivateDnsNameOptionsProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplatePrivateDnsNameOptionsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("enableResourceNameDnsAaaaRecord", cdk.validateBoolean)(properties.enableResourceNameDnsAaaaRecord));
  errors.collect(cdk.propertyValidator("enableResourceNameDnsARecord", cdk.validateBoolean)(properties.enableResourceNameDnsARecord));
  errors.collect(cdk.propertyValidator("hostnameType", cdk.validateString)(properties.hostnameType));
  return errors.wrap("supplied properties not correct for \\"PrivateDnsNameOptionsProperty\\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplatePrivateDnsNameOptionsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplatePrivateDnsNameOptionsPropertyValidator(properties).assertSuccess();
  return {
    "EnableResourceNameDnsAAAARecord": cdk.booleanToCloudFormation(properties.enableResourceNameDnsAaaaRecord),
    "EnableResourceNameDnsARecord": cdk.booleanToCloudFormation(properties.enableResourceNameDnsARecord),
    "HostnameType": cdk.stringToCloudFormation(properties.hostnameType)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplatePrivateDnsNameOptionsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnLaunchTemplate.PrivateDnsNameOptionsProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.PrivateDnsNameOptionsProperty>();
  ret.addPropertyResult("enableResourceNameDnsAaaaRecord", "EnableResourceNameDnsAAAARecord", (properties.EnableResourceNameDnsAAAARecord != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EnableResourceNameDnsAAAARecord) : undefined));
  ret.addPropertyResult("enableResourceNameDnsARecord", "EnableResourceNameDnsARecord", (properties.EnableResourceNameDnsARecord != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EnableResourceNameDnsARecord) : undefined));
  ret.addPropertyResult("hostnameType", "HostnameType", (properties.HostnameType != null ? cfn_parse.FromCloudFormation.getString(properties.HostnameType) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`SpotOptionsProperty\`
 *
 * @param properties - the TypeScript properties of a \`SpotOptionsProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateSpotOptionsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("blockDurationMinutes", cdk.validateNumber)(properties.blockDurationMinutes));
  errors.collect(cdk.propertyValidator("instanceInterruptionBehavior", cdk.validateString)(properties.instanceInterruptionBehavior));
  errors.collect(cdk.propertyValidator("maxPrice", cdk.validateString)(properties.maxPrice));
  errors.collect(cdk.propertyValidator("spotInstanceType", cdk.validateString)(properties.spotInstanceType));
  errors.collect(cdk.propertyValidator("validUntil", cdk.validateString)(properties.validUntil));
  return errors.wrap("supplied properties not correct for \\"SpotOptionsProperty\\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateSpotOptionsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateSpotOptionsPropertyValidator(properties).assertSuccess();
  return {
    "BlockDurationMinutes": cdk.numberToCloudFormation(properties.blockDurationMinutes),
    "InstanceInterruptionBehavior": cdk.stringToCloudFormation(properties.instanceInterruptionBehavior),
    "MaxPrice": cdk.stringToCloudFormation(properties.maxPrice),
    "SpotInstanceType": cdk.stringToCloudFormation(properties.spotInstanceType),
    "ValidUntil": cdk.stringToCloudFormation(properties.validUntil)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateSpotOptionsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnLaunchTemplate.SpotOptionsProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.SpotOptionsProperty>();
  ret.addPropertyResult("blockDurationMinutes", "BlockDurationMinutes", (properties.BlockDurationMinutes != null ? cfn_parse.FromCloudFormation.getNumber(properties.BlockDurationMinutes) : undefined));
  ret.addPropertyResult("instanceInterruptionBehavior", "InstanceInterruptionBehavior", (properties.InstanceInterruptionBehavior != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceInterruptionBehavior) : undefined));
  ret.addPropertyResult("maxPrice", "MaxPrice", (properties.MaxPrice != null ? cfn_parse.FromCloudFormation.getString(properties.MaxPrice) : undefined));
  ret.addPropertyResult("spotInstanceType", "SpotInstanceType", (properties.SpotInstanceType != null ? cfn_parse.FromCloudFormation.getString(properties.SpotInstanceType) : undefined));
  ret.addPropertyResult("validUntil", "ValidUntil", (properties.ValidUntil != null ? cfn_parse.FromCloudFormation.getString(properties.ValidUntil) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`InstanceMarketOptionsProperty\`
 *
 * @param properties - the TypeScript properties of a \`InstanceMarketOptionsProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateInstanceMarketOptionsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("marketType", cdk.validateString)(properties.marketType));
  errors.collect(cdk.propertyValidator("spotOptions", CfnLaunchTemplateSpotOptionsPropertyValidator)(properties.spotOptions));
  return errors.wrap("supplied properties not correct for \\"InstanceMarketOptionsProperty\\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateInstanceMarketOptionsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateInstanceMarketOptionsPropertyValidator(properties).assertSuccess();
  return {
    "MarketType": cdk.stringToCloudFormation(properties.marketType),
    "SpotOptions": convertCfnLaunchTemplateSpotOptionsPropertyToCloudFormation(properties.spotOptions)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateInstanceMarketOptionsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnLaunchTemplate.InstanceMarketOptionsProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.InstanceMarketOptionsProperty>();
  ret.addPropertyResult("marketType", "MarketType", (properties.MarketType != null ? cfn_parse.FromCloudFormation.getString(properties.MarketType) : undefined));
  ret.addPropertyResult("spotOptions", "SpotOptions", (properties.SpotOptions != null ? CfnLaunchTemplateSpotOptionsPropertyFromCloudFormation(properties.SpotOptions) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`NetworkInterfaceCountProperty\`
 *
 * @param properties - the TypeScript properties of a \`NetworkInterfaceCountProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateNetworkInterfaceCountPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("max", cdk.validateNumber)(properties.max));
  errors.collect(cdk.propertyValidator("min", cdk.validateNumber)(properties.min));
  return errors.wrap("supplied properties not correct for \\"NetworkInterfaceCountProperty\\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateNetworkInterfaceCountPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateNetworkInterfaceCountPropertyValidator(properties).assertSuccess();
  return {
    "Max": cdk.numberToCloudFormation(properties.max),
    "Min": cdk.numberToCloudFormation(properties.min)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateNetworkInterfaceCountPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnLaunchTemplate.NetworkInterfaceCountProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.NetworkInterfaceCountProperty>();
  ret.addPropertyResult("max", "Max", (properties.Max != null ? cfn_parse.FromCloudFormation.getNumber(properties.Max) : undefined));
  ret.addPropertyResult("min", "Min", (properties.Min != null ? cfn_parse.FromCloudFormation.getNumber(properties.Min) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`MemoryGiBPerVCpuProperty\`
 *
 * @param properties - the TypeScript properties of a \`MemoryGiBPerVCpuProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateMemoryGiBPerVCpuPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("max", cdk.validateNumber)(properties.max));
  errors.collect(cdk.propertyValidator("min", cdk.validateNumber)(properties.min));
  return errors.wrap("supplied properties not correct for \\"MemoryGiBPerVCpuProperty\\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateMemoryGiBPerVCpuPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateMemoryGiBPerVCpuPropertyValidator(properties).assertSuccess();
  return {
    "Max": cdk.numberToCloudFormation(properties.max),
    "Min": cdk.numberToCloudFormation(properties.min)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateMemoryGiBPerVCpuPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnLaunchTemplate.MemoryGiBPerVCpuProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.MemoryGiBPerVCpuProperty>();
  ret.addPropertyResult("max", "Max", (properties.Max != null ? cfn_parse.FromCloudFormation.getNumber(properties.Max) : undefined));
  ret.addPropertyResult("min", "Min", (properties.Min != null ? cfn_parse.FromCloudFormation.getNumber(properties.Min) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`VCpuCountProperty\`
 *
 * @param properties - the TypeScript properties of a \`VCpuCountProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateVCpuCountPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("max", cdk.validateNumber)(properties.max));
  errors.collect(cdk.propertyValidator("min", cdk.validateNumber)(properties.min));
  return errors.wrap("supplied properties not correct for \\"VCpuCountProperty\\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateVCpuCountPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateVCpuCountPropertyValidator(properties).assertSuccess();
  return {
    "Max": cdk.numberToCloudFormation(properties.max),
    "Min": cdk.numberToCloudFormation(properties.min)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateVCpuCountPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnLaunchTemplate.VCpuCountProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.VCpuCountProperty>();
  ret.addPropertyResult("max", "Max", (properties.Max != null ? cfn_parse.FromCloudFormation.getNumber(properties.Max) : undefined));
  ret.addPropertyResult("min", "Min", (properties.Min != null ? cfn_parse.FromCloudFormation.getNumber(properties.Min) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`AcceleratorCountProperty\`
 *
 * @param properties - the TypeScript properties of a \`AcceleratorCountProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateAcceleratorCountPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("max", cdk.validateNumber)(properties.max));
  errors.collect(cdk.propertyValidator("min", cdk.validateNumber)(properties.min));
  return errors.wrap("supplied properties not correct for \\"AcceleratorCountProperty\\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateAcceleratorCountPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateAcceleratorCountPropertyValidator(properties).assertSuccess();
  return {
    "Max": cdk.numberToCloudFormation(properties.max),
    "Min": cdk.numberToCloudFormation(properties.min)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateAcceleratorCountPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnLaunchTemplate.AcceleratorCountProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.AcceleratorCountProperty>();
  ret.addPropertyResult("max", "Max", (properties.Max != null ? cfn_parse.FromCloudFormation.getNumber(properties.Max) : undefined));
  ret.addPropertyResult("min", "Min", (properties.Min != null ? cfn_parse.FromCloudFormation.getNumber(properties.Min) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`NetworkBandwidthGbpsProperty\`
 *
 * @param properties - the TypeScript properties of a \`NetworkBandwidthGbpsProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateNetworkBandwidthGbpsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("max", cdk.validateNumber)(properties.max));
  errors.collect(cdk.propertyValidator("min", cdk.validateNumber)(properties.min));
  return errors.wrap("supplied properties not correct for \\"NetworkBandwidthGbpsProperty\\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateNetworkBandwidthGbpsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateNetworkBandwidthGbpsPropertyValidator(properties).assertSuccess();
  return {
    "Max": cdk.numberToCloudFormation(properties.max),
    "Min": cdk.numberToCloudFormation(properties.min)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateNetworkBandwidthGbpsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnLaunchTemplate.NetworkBandwidthGbpsProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.NetworkBandwidthGbpsProperty>();
  ret.addPropertyResult("max", "Max", (properties.Max != null ? cfn_parse.FromCloudFormation.getNumber(properties.Max) : undefined));
  ret.addPropertyResult("min", "Min", (properties.Min != null ? cfn_parse.FromCloudFormation.getNumber(properties.Min) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`BaselineEbsBandwidthMbpsProperty\`
 *
 * @param properties - the TypeScript properties of a \`BaselineEbsBandwidthMbpsProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateBaselineEbsBandwidthMbpsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("max", cdk.validateNumber)(properties.max));
  errors.collect(cdk.propertyValidator("min", cdk.validateNumber)(properties.min));
  return errors.wrap("supplied properties not correct for \\"BaselineEbsBandwidthMbpsProperty\\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateBaselineEbsBandwidthMbpsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateBaselineEbsBandwidthMbpsPropertyValidator(properties).assertSuccess();
  return {
    "Max": cdk.numberToCloudFormation(properties.max),
    "Min": cdk.numberToCloudFormation(properties.min)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateBaselineEbsBandwidthMbpsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnLaunchTemplate.BaselineEbsBandwidthMbpsProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.BaselineEbsBandwidthMbpsProperty>();
  ret.addPropertyResult("max", "Max", (properties.Max != null ? cfn_parse.FromCloudFormation.getNumber(properties.Max) : undefined));
  ret.addPropertyResult("min", "Min", (properties.Min != null ? cfn_parse.FromCloudFormation.getNumber(properties.Min) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`AcceleratorTotalMemoryMiBProperty\`
 *
 * @param properties - the TypeScript properties of a \`AcceleratorTotalMemoryMiBProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateAcceleratorTotalMemoryMiBPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("max", cdk.validateNumber)(properties.max));
  errors.collect(cdk.propertyValidator("min", cdk.validateNumber)(properties.min));
  return errors.wrap("supplied properties not correct for \\"AcceleratorTotalMemoryMiBProperty\\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateAcceleratorTotalMemoryMiBPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateAcceleratorTotalMemoryMiBPropertyValidator(properties).assertSuccess();
  return {
    "Max": cdk.numberToCloudFormation(properties.max),
    "Min": cdk.numberToCloudFormation(properties.min)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateAcceleratorTotalMemoryMiBPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnLaunchTemplate.AcceleratorTotalMemoryMiBProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.AcceleratorTotalMemoryMiBProperty>();
  ret.addPropertyResult("max", "Max", (properties.Max != null ? cfn_parse.FromCloudFormation.getNumber(properties.Max) : undefined));
  ret.addPropertyResult("min", "Min", (properties.Min != null ? cfn_parse.FromCloudFormation.getNumber(properties.Min) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`MemoryMiBProperty\`
 *
 * @param properties - the TypeScript properties of a \`MemoryMiBProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateMemoryMiBPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("max", cdk.validateNumber)(properties.max));
  errors.collect(cdk.propertyValidator("min", cdk.validateNumber)(properties.min));
  return errors.wrap("supplied properties not correct for \\"MemoryMiBProperty\\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateMemoryMiBPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateMemoryMiBPropertyValidator(properties).assertSuccess();
  return {
    "Max": cdk.numberToCloudFormation(properties.max),
    "Min": cdk.numberToCloudFormation(properties.min)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateMemoryMiBPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnLaunchTemplate.MemoryMiBProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.MemoryMiBProperty>();
  ret.addPropertyResult("max", "Max", (properties.Max != null ? cfn_parse.FromCloudFormation.getNumber(properties.Max) : undefined));
  ret.addPropertyResult("min", "Min", (properties.Min != null ? cfn_parse.FromCloudFormation.getNumber(properties.Min) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`TotalLocalStorageGBProperty\`
 *
 * @param properties - the TypeScript properties of a \`TotalLocalStorageGBProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateTotalLocalStorageGBPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("max", cdk.validateNumber)(properties.max));
  errors.collect(cdk.propertyValidator("min", cdk.validateNumber)(properties.min));
  return errors.wrap("supplied properties not correct for \\"TotalLocalStorageGBProperty\\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateTotalLocalStorageGBPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateTotalLocalStorageGBPropertyValidator(properties).assertSuccess();
  return {
    "Max": cdk.numberToCloudFormation(properties.max),
    "Min": cdk.numberToCloudFormation(properties.min)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateTotalLocalStorageGBPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnLaunchTemplate.TotalLocalStorageGBProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.TotalLocalStorageGBProperty>();
  ret.addPropertyResult("max", "Max", (properties.Max != null ? cfn_parse.FromCloudFormation.getNumber(properties.Max) : undefined));
  ret.addPropertyResult("min", "Min", (properties.Min != null ? cfn_parse.FromCloudFormation.getNumber(properties.Min) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`InstanceRequirementsProperty\`
 *
 * @param properties - the TypeScript properties of a \`InstanceRequirementsProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateInstanceRequirementsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("acceleratorCount", CfnLaunchTemplateAcceleratorCountPropertyValidator)(properties.acceleratorCount));
  errors.collect(cdk.propertyValidator("acceleratorManufacturers", cdk.listValidator(cdk.validateString))(properties.acceleratorManufacturers));
  errors.collect(cdk.propertyValidator("acceleratorNames", cdk.listValidator(cdk.validateString))(properties.acceleratorNames));
  errors.collect(cdk.propertyValidator("acceleratorTotalMemoryMiB", CfnLaunchTemplateAcceleratorTotalMemoryMiBPropertyValidator)(properties.acceleratorTotalMemoryMiB));
  errors.collect(cdk.propertyValidator("acceleratorTypes", cdk.listValidator(cdk.validateString))(properties.acceleratorTypes));
  errors.collect(cdk.propertyValidator("allowedInstanceTypes", cdk.listValidator(cdk.validateString))(properties.allowedInstanceTypes));
  errors.collect(cdk.propertyValidator("bareMetal", cdk.validateString)(properties.bareMetal));
  errors.collect(cdk.propertyValidator("baselineEbsBandwidthMbps", CfnLaunchTemplateBaselineEbsBandwidthMbpsPropertyValidator)(properties.baselineEbsBandwidthMbps));
  errors.collect(cdk.propertyValidator("burstablePerformance", cdk.validateString)(properties.burstablePerformance));
  errors.collect(cdk.propertyValidator("cpuManufacturers", cdk.listValidator(cdk.validateString))(properties.cpuManufacturers));
  errors.collect(cdk.propertyValidator("excludedInstanceTypes", cdk.listValidator(cdk.validateString))(properties.excludedInstanceTypes));
  errors.collect(cdk.propertyValidator("instanceGenerations", cdk.listValidator(cdk.validateString))(properties.instanceGenerations));
  errors.collect(cdk.propertyValidator("localStorage", cdk.validateString)(properties.localStorage));
  errors.collect(cdk.propertyValidator("localStorageTypes", cdk.listValidator(cdk.validateString))(properties.localStorageTypes));
  errors.collect(cdk.propertyValidator("memoryGiBPerVCpu", CfnLaunchTemplateMemoryGiBPerVCpuPropertyValidator)(properties.memoryGiBPerVCpu));
  errors.collect(cdk.propertyValidator("memoryMiB", CfnLaunchTemplateMemoryMiBPropertyValidator)(properties.memoryMiB));
  errors.collect(cdk.propertyValidator("networkBandwidthGbps", CfnLaunchTemplateNetworkBandwidthGbpsPropertyValidator)(properties.networkBandwidthGbps));
  errors.collect(cdk.propertyValidator("networkInterfaceCount", CfnLaunchTemplateNetworkInterfaceCountPropertyValidator)(properties.networkInterfaceCount));
  errors.collect(cdk.propertyValidator("onDemandMaxPricePercentageOverLowestPrice", cdk.validateNumber)(properties.onDemandMaxPricePercentageOverLowestPrice));
  errors.collect(cdk.propertyValidator("requireHibernateSupport", cdk.validateBoolean)(properties.requireHibernateSupport));
  errors.collect(cdk.propertyValidator("spotMaxPricePercentageOverLowestPrice", cdk.validateNumber)(properties.spotMaxPricePercentageOverLowestPrice));
  errors.collect(cdk.propertyValidator("totalLocalStorageGb", CfnLaunchTemplateTotalLocalStorageGBPropertyValidator)(properties.totalLocalStorageGb));
  errors.collect(cdk.propertyValidator("vCpuCount", CfnLaunchTemplateVCpuCountPropertyValidator)(properties.vCpuCount));
  return errors.wrap("supplied properties not correct for \\"InstanceRequirementsProperty\\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateInstanceRequirementsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateInstanceRequirementsPropertyValidator(properties).assertSuccess();
  return {
    "AcceleratorCount": convertCfnLaunchTemplateAcceleratorCountPropertyToCloudFormation(properties.acceleratorCount),
    "AcceleratorManufacturers": cdk.listMapper(cdk.stringToCloudFormation)(properties.acceleratorManufacturers),
    "AcceleratorNames": cdk.listMapper(cdk.stringToCloudFormation)(properties.acceleratorNames),
    "AcceleratorTotalMemoryMiB": convertCfnLaunchTemplateAcceleratorTotalMemoryMiBPropertyToCloudFormation(properties.acceleratorTotalMemoryMiB),
    "AcceleratorTypes": cdk.listMapper(cdk.stringToCloudFormation)(properties.acceleratorTypes),
    "AllowedInstanceTypes": cdk.listMapper(cdk.stringToCloudFormation)(properties.allowedInstanceTypes),
    "BareMetal": cdk.stringToCloudFormation(properties.bareMetal),
    "BaselineEbsBandwidthMbps": convertCfnLaunchTemplateBaselineEbsBandwidthMbpsPropertyToCloudFormation(properties.baselineEbsBandwidthMbps),
    "BurstablePerformance": cdk.stringToCloudFormation(properties.burstablePerformance),
    "CpuManufacturers": cdk.listMapper(cdk.stringToCloudFormation)(properties.cpuManufacturers),
    "ExcludedInstanceTypes": cdk.listMapper(cdk.stringToCloudFormation)(properties.excludedInstanceTypes),
    "InstanceGenerations": cdk.listMapper(cdk.stringToCloudFormation)(properties.instanceGenerations),
    "LocalStorage": cdk.stringToCloudFormation(properties.localStorage),
    "LocalStorageTypes": cdk.listMapper(cdk.stringToCloudFormation)(properties.localStorageTypes),
    "MemoryGiBPerVCpu": convertCfnLaunchTemplateMemoryGiBPerVCpuPropertyToCloudFormation(properties.memoryGiBPerVCpu),
    "MemoryMiB": convertCfnLaunchTemplateMemoryMiBPropertyToCloudFormation(properties.memoryMiB),
    "NetworkBandwidthGbps": convertCfnLaunchTemplateNetworkBandwidthGbpsPropertyToCloudFormation(properties.networkBandwidthGbps),
    "NetworkInterfaceCount": convertCfnLaunchTemplateNetworkInterfaceCountPropertyToCloudFormation(properties.networkInterfaceCount),
    "OnDemandMaxPricePercentageOverLowestPrice": cdk.numberToCloudFormation(properties.onDemandMaxPricePercentageOverLowestPrice),
    "RequireHibernateSupport": cdk.booleanToCloudFormation(properties.requireHibernateSupport),
    "SpotMaxPricePercentageOverLowestPrice": cdk.numberToCloudFormation(properties.spotMaxPricePercentageOverLowestPrice),
    "TotalLocalStorageGB": convertCfnLaunchTemplateTotalLocalStorageGBPropertyToCloudFormation(properties.totalLocalStorageGb),
    "VCpuCount": convertCfnLaunchTemplateVCpuCountPropertyToCloudFormation(properties.vCpuCount)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateInstanceRequirementsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnLaunchTemplate.InstanceRequirementsProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.InstanceRequirementsProperty>();
  ret.addPropertyResult("acceleratorCount", "AcceleratorCount", (properties.AcceleratorCount != null ? CfnLaunchTemplateAcceleratorCountPropertyFromCloudFormation(properties.AcceleratorCount) : undefined));
  ret.addPropertyResult("acceleratorManufacturers", "AcceleratorManufacturers", (properties.AcceleratorManufacturers != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.AcceleratorManufacturers) : undefined));
  ret.addPropertyResult("acceleratorNames", "AcceleratorNames", (properties.AcceleratorNames != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.AcceleratorNames) : undefined));
  ret.addPropertyResult("acceleratorTotalMemoryMiB", "AcceleratorTotalMemoryMiB", (properties.AcceleratorTotalMemoryMiB != null ? CfnLaunchTemplateAcceleratorTotalMemoryMiBPropertyFromCloudFormation(properties.AcceleratorTotalMemoryMiB) : undefined));
  ret.addPropertyResult("acceleratorTypes", "AcceleratorTypes", (properties.AcceleratorTypes != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.AcceleratorTypes) : undefined));
  ret.addPropertyResult("allowedInstanceTypes", "AllowedInstanceTypes", (properties.AllowedInstanceTypes != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.AllowedInstanceTypes) : undefined));
  ret.addPropertyResult("bareMetal", "BareMetal", (properties.BareMetal != null ? cfn_parse.FromCloudFormation.getString(properties.BareMetal) : undefined));
  ret.addPropertyResult("baselineEbsBandwidthMbps", "BaselineEbsBandwidthMbps", (properties.BaselineEbsBandwidthMbps != null ? CfnLaunchTemplateBaselineEbsBandwidthMbpsPropertyFromCloudFormation(properties.BaselineEbsBandwidthMbps) : undefined));
  ret.addPropertyResult("burstablePerformance", "BurstablePerformance", (properties.BurstablePerformance != null ? cfn_parse.FromCloudFormation.getString(properties.BurstablePerformance) : undefined));
  ret.addPropertyResult("cpuManufacturers", "CpuManufacturers", (properties.CpuManufacturers != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.CpuManufacturers) : undefined));
  ret.addPropertyResult("excludedInstanceTypes", "ExcludedInstanceTypes", (properties.ExcludedInstanceTypes != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.ExcludedInstanceTypes) : undefined));
  ret.addPropertyResult("instanceGenerations", "InstanceGenerations", (properties.InstanceGenerations != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.InstanceGenerations) : undefined));
  ret.addPropertyResult("localStorage", "LocalStorage", (properties.LocalStorage != null ? cfn_parse.FromCloudFormation.getString(properties.LocalStorage) : undefined));
  ret.addPropertyResult("localStorageTypes", "LocalStorageTypes", (properties.LocalStorageTypes != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.LocalStorageTypes) : undefined));
  ret.addPropertyResult("memoryGiBPerVCpu", "MemoryGiBPerVCpu", (properties.MemoryGiBPerVCpu != null ? CfnLaunchTemplateMemoryGiBPerVCpuPropertyFromCloudFormation(properties.MemoryGiBPerVCpu) : undefined));
  ret.addPropertyResult("memoryMiB", "MemoryMiB", (properties.MemoryMiB != null ? CfnLaunchTemplateMemoryMiBPropertyFromCloudFormation(properties.MemoryMiB) : undefined));
  ret.addPropertyResult("networkBandwidthGbps", "NetworkBandwidthGbps", (properties.NetworkBandwidthGbps != null ? CfnLaunchTemplateNetworkBandwidthGbpsPropertyFromCloudFormation(properties.NetworkBandwidthGbps) : undefined));
  ret.addPropertyResult("networkInterfaceCount", "NetworkInterfaceCount", (properties.NetworkInterfaceCount != null ? CfnLaunchTemplateNetworkInterfaceCountPropertyFromCloudFormation(properties.NetworkInterfaceCount) : undefined));
  ret.addPropertyResult("onDemandMaxPricePercentageOverLowestPrice", "OnDemandMaxPricePercentageOverLowestPrice", (properties.OnDemandMaxPricePercentageOverLowestPrice != null ? cfn_parse.FromCloudFormation.getNumber(properties.OnDemandMaxPricePercentageOverLowestPrice) : undefined));
  ret.addPropertyResult("requireHibernateSupport", "RequireHibernateSupport", (properties.RequireHibernateSupport != null ? cfn_parse.FromCloudFormation.getBoolean(properties.RequireHibernateSupport) : undefined));
  ret.addPropertyResult("spotMaxPricePercentageOverLowestPrice", "SpotMaxPricePercentageOverLowestPrice", (properties.SpotMaxPricePercentageOverLowestPrice != null ? cfn_parse.FromCloudFormation.getNumber(properties.SpotMaxPricePercentageOverLowestPrice) : undefined));
  ret.addPropertyResult("totalLocalStorageGb", "TotalLocalStorageGB", (properties.TotalLocalStorageGB != null ? CfnLaunchTemplateTotalLocalStorageGBPropertyFromCloudFormation(properties.TotalLocalStorageGB) : undefined));
  ret.addPropertyResult("vCpuCount", "VCpuCount", (properties.VCpuCount != null ? CfnLaunchTemplateVCpuCountPropertyFromCloudFormation(properties.VCpuCount) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CapacityReservationTargetProperty\`
 *
 * @param properties - the TypeScript properties of a \`CapacityReservationTargetProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateCapacityReservationTargetPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("capacityReservationId", cdk.validateString)(properties.capacityReservationId));
  errors.collect(cdk.propertyValidator("capacityReservationResourceGroupArn", cdk.validateString)(properties.capacityReservationResourceGroupArn));
  return errors.wrap("supplied properties not correct for \\"CapacityReservationTargetProperty\\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateCapacityReservationTargetPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateCapacityReservationTargetPropertyValidator(properties).assertSuccess();
  return {
    "CapacityReservationId": cdk.stringToCloudFormation(properties.capacityReservationId),
    "CapacityReservationResourceGroupArn": cdk.stringToCloudFormation(properties.capacityReservationResourceGroupArn)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateCapacityReservationTargetPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnLaunchTemplate.CapacityReservationTargetProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.CapacityReservationTargetProperty>();
  ret.addPropertyResult("capacityReservationId", "CapacityReservationId", (properties.CapacityReservationId != null ? cfn_parse.FromCloudFormation.getString(properties.CapacityReservationId) : undefined));
  ret.addPropertyResult("capacityReservationResourceGroupArn", "CapacityReservationResourceGroupArn", (properties.CapacityReservationResourceGroupArn != null ? cfn_parse.FromCloudFormation.getString(properties.CapacityReservationResourceGroupArn) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CapacityReservationSpecificationProperty\`
 *
 * @param properties - the TypeScript properties of a \`CapacityReservationSpecificationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateCapacityReservationSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("capacityReservationPreference", cdk.validateString)(properties.capacityReservationPreference));
  errors.collect(cdk.propertyValidator("capacityReservationTarget", CfnLaunchTemplateCapacityReservationTargetPropertyValidator)(properties.capacityReservationTarget));
  return errors.wrap("supplied properties not correct for \\"CapacityReservationSpecificationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateCapacityReservationSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateCapacityReservationSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "CapacityReservationPreference": cdk.stringToCloudFormation(properties.capacityReservationPreference),
    "CapacityReservationTarget": convertCfnLaunchTemplateCapacityReservationTargetPropertyToCloudFormation(properties.capacityReservationTarget)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateCapacityReservationSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnLaunchTemplate.CapacityReservationSpecificationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.CapacityReservationSpecificationProperty>();
  ret.addPropertyResult("capacityReservationPreference", "CapacityReservationPreference", (properties.CapacityReservationPreference != null ? cfn_parse.FromCloudFormation.getString(properties.CapacityReservationPreference) : undefined));
  ret.addPropertyResult("capacityReservationTarget", "CapacityReservationTarget", (properties.CapacityReservationTarget != null ? CfnLaunchTemplateCapacityReservationTargetPropertyFromCloudFormation(properties.CapacityReservationTarget) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CreditSpecificationProperty\`
 *
 * @param properties - the TypeScript properties of a \`CreditSpecificationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateCreditSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("cpuCredits", cdk.validateString)(properties.cpuCredits));
  return errors.wrap("supplied properties not correct for \\"CreditSpecificationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateCreditSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateCreditSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "CpuCredits": cdk.stringToCloudFormation(properties.cpuCredits)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateCreditSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnLaunchTemplate.CreditSpecificationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.CreditSpecificationProperty>();
  ret.addPropertyResult("cpuCredits", "CpuCredits", (properties.CpuCredits != null ? cfn_parse.FromCloudFormation.getString(properties.CpuCredits) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`LaunchTemplateDataProperty\`
 *
 * @param properties - the TypeScript properties of a \`LaunchTemplateDataProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateLaunchTemplateDataPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("blockDeviceMappings", cdk.listValidator(CfnLaunchTemplateBlockDeviceMappingPropertyValidator))(properties.blockDeviceMappings));
  errors.collect(cdk.propertyValidator("capacityReservationSpecification", CfnLaunchTemplateCapacityReservationSpecificationPropertyValidator)(properties.capacityReservationSpecification));
  errors.collect(cdk.propertyValidator("cpuOptions", CfnLaunchTemplateCpuOptionsPropertyValidator)(properties.cpuOptions));
  errors.collect(cdk.propertyValidator("creditSpecification", CfnLaunchTemplateCreditSpecificationPropertyValidator)(properties.creditSpecification));
  errors.collect(cdk.propertyValidator("disableApiStop", cdk.validateBoolean)(properties.disableApiStop));
  errors.collect(cdk.propertyValidator("disableApiTermination", cdk.validateBoolean)(properties.disableApiTermination));
  errors.collect(cdk.propertyValidator("ebsOptimized", cdk.validateBoolean)(properties.ebsOptimized));
  errors.collect(cdk.propertyValidator("elasticGpuSpecifications", cdk.listValidator(CfnLaunchTemplateElasticGpuSpecificationPropertyValidator))(properties.elasticGpuSpecifications));
  errors.collect(cdk.propertyValidator("elasticInferenceAccelerators", cdk.listValidator(CfnLaunchTemplateLaunchTemplateElasticInferenceAcceleratorPropertyValidator))(properties.elasticInferenceAccelerators));
  errors.collect(cdk.propertyValidator("enclaveOptions", CfnLaunchTemplateEnclaveOptionsPropertyValidator)(properties.enclaveOptions));
  errors.collect(cdk.propertyValidator("hibernationOptions", CfnLaunchTemplateHibernationOptionsPropertyValidator)(properties.hibernationOptions));
  errors.collect(cdk.propertyValidator("iamInstanceProfile", CfnLaunchTemplateIamInstanceProfilePropertyValidator)(properties.iamInstanceProfile));
  errors.collect(cdk.propertyValidator("imageId", cdk.validateString)(properties.imageId));
  errors.collect(cdk.propertyValidator("instanceInitiatedShutdownBehavior", cdk.validateString)(properties.instanceInitiatedShutdownBehavior));
  errors.collect(cdk.propertyValidator("instanceMarketOptions", CfnLaunchTemplateInstanceMarketOptionsPropertyValidator)(properties.instanceMarketOptions));
  errors.collect(cdk.propertyValidator("instanceRequirements", CfnLaunchTemplateInstanceRequirementsPropertyValidator)(properties.instanceRequirements));
  errors.collect(cdk.propertyValidator("instanceType", cdk.validateString)(properties.instanceType));
  errors.collect(cdk.propertyValidator("kernelId", cdk.validateString)(properties.kernelId));
  errors.collect(cdk.propertyValidator("keyName", cdk.validateString)(properties.keyName));
  errors.collect(cdk.propertyValidator("licenseSpecifications", cdk.listValidator(CfnLaunchTemplateLicenseSpecificationPropertyValidator))(properties.licenseSpecifications));
  errors.collect(cdk.propertyValidator("maintenanceOptions", CfnLaunchTemplateMaintenanceOptionsPropertyValidator)(properties.maintenanceOptions));
  errors.collect(cdk.propertyValidator("metadataOptions", CfnLaunchTemplateMetadataOptionsPropertyValidator)(properties.metadataOptions));
  errors.collect(cdk.propertyValidator("monitoring", CfnLaunchTemplateMonitoringPropertyValidator)(properties.monitoring));
  errors.collect(cdk.propertyValidator("networkInterfaces", cdk.listValidator(CfnLaunchTemplateNetworkInterfacePropertyValidator))(properties.networkInterfaces));
  errors.collect(cdk.propertyValidator("placement", CfnLaunchTemplatePlacementPropertyValidator)(properties.placement));
  errors.collect(cdk.propertyValidator("privateDnsNameOptions", CfnLaunchTemplatePrivateDnsNameOptionsPropertyValidator)(properties.privateDnsNameOptions));
  errors.collect(cdk.propertyValidator("ramDiskId", cdk.validateString)(properties.ramDiskId));
  errors.collect(cdk.propertyValidator("securityGroupIds", cdk.listValidator(cdk.validateString))(properties.securityGroupIds));
  errors.collect(cdk.propertyValidator("securityGroups", cdk.listValidator(cdk.validateString))(properties.securityGroups));
  errors.collect(cdk.propertyValidator("tagSpecifications", cdk.listValidator(CfnLaunchTemplateTagSpecificationPropertyValidator))(properties.tagSpecifications));
  errors.collect(cdk.propertyValidator("userData", cdk.validateString)(properties.userData));
  return errors.wrap("supplied properties not correct for \\"LaunchTemplateDataProperty\\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateLaunchTemplateDataPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateLaunchTemplateDataPropertyValidator(properties).assertSuccess();
  return {
    "BlockDeviceMappings": cdk.listMapper(convertCfnLaunchTemplateBlockDeviceMappingPropertyToCloudFormation)(properties.blockDeviceMappings),
    "CapacityReservationSpecification": convertCfnLaunchTemplateCapacityReservationSpecificationPropertyToCloudFormation(properties.capacityReservationSpecification),
    "CpuOptions": convertCfnLaunchTemplateCpuOptionsPropertyToCloudFormation(properties.cpuOptions),
    "CreditSpecification": convertCfnLaunchTemplateCreditSpecificationPropertyToCloudFormation(properties.creditSpecification),
    "DisableApiStop": cdk.booleanToCloudFormation(properties.disableApiStop),
    "DisableApiTermination": cdk.booleanToCloudFormation(properties.disableApiTermination),
    "EbsOptimized": cdk.booleanToCloudFormation(properties.ebsOptimized),
    "ElasticGpuSpecifications": cdk.listMapper(convertCfnLaunchTemplateElasticGpuSpecificationPropertyToCloudFormation)(properties.elasticGpuSpecifications),
    "ElasticInferenceAccelerators": cdk.listMapper(convertCfnLaunchTemplateLaunchTemplateElasticInferenceAcceleratorPropertyToCloudFormation)(properties.elasticInferenceAccelerators),
    "EnclaveOptions": convertCfnLaunchTemplateEnclaveOptionsPropertyToCloudFormation(properties.enclaveOptions),
    "HibernationOptions": convertCfnLaunchTemplateHibernationOptionsPropertyToCloudFormation(properties.hibernationOptions),
    "IamInstanceProfile": convertCfnLaunchTemplateIamInstanceProfilePropertyToCloudFormation(properties.iamInstanceProfile),
    "ImageId": cdk.stringToCloudFormation(properties.imageId),
    "InstanceInitiatedShutdownBehavior": cdk.stringToCloudFormation(properties.instanceInitiatedShutdownBehavior),
    "InstanceMarketOptions": convertCfnLaunchTemplateInstanceMarketOptionsPropertyToCloudFormation(properties.instanceMarketOptions),
    "InstanceRequirements": convertCfnLaunchTemplateInstanceRequirementsPropertyToCloudFormation(properties.instanceRequirements),
    "InstanceType": cdk.stringToCloudFormation(properties.instanceType),
    "KernelId": cdk.stringToCloudFormation(properties.kernelId),
    "KeyName": cdk.stringToCloudFormation(properties.keyName),
    "LicenseSpecifications": cdk.listMapper(convertCfnLaunchTemplateLicenseSpecificationPropertyToCloudFormation)(properties.licenseSpecifications),
    "MaintenanceOptions": convertCfnLaunchTemplateMaintenanceOptionsPropertyToCloudFormation(properties.maintenanceOptions),
    "MetadataOptions": convertCfnLaunchTemplateMetadataOptionsPropertyToCloudFormation(properties.metadataOptions),
    "Monitoring": convertCfnLaunchTemplateMonitoringPropertyToCloudFormation(properties.monitoring),
    "NetworkInterfaces": cdk.listMapper(convertCfnLaunchTemplateNetworkInterfacePropertyToCloudFormation)(properties.networkInterfaces),
    "Placement": convertCfnLaunchTemplatePlacementPropertyToCloudFormation(properties.placement),
    "PrivateDnsNameOptions": convertCfnLaunchTemplatePrivateDnsNameOptionsPropertyToCloudFormation(properties.privateDnsNameOptions),
    "RamDiskId": cdk.stringToCloudFormation(properties.ramDiskId),
    "SecurityGroupIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.securityGroupIds),
    "SecurityGroups": cdk.listMapper(cdk.stringToCloudFormation)(properties.securityGroups),
    "TagSpecifications": cdk.listMapper(convertCfnLaunchTemplateTagSpecificationPropertyToCloudFormation)(properties.tagSpecifications),
    "UserData": cdk.stringToCloudFormation(properties.userData)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateLaunchTemplateDataPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnLaunchTemplate.LaunchTemplateDataProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.LaunchTemplateDataProperty>();
  ret.addPropertyResult("blockDeviceMappings", "BlockDeviceMappings", (properties.BlockDeviceMappings != null ? cfn_parse.FromCloudFormation.getArray(CfnLaunchTemplateBlockDeviceMappingPropertyFromCloudFormation)(properties.BlockDeviceMappings) : undefined));
  ret.addPropertyResult("capacityReservationSpecification", "CapacityReservationSpecification", (properties.CapacityReservationSpecification != null ? CfnLaunchTemplateCapacityReservationSpecificationPropertyFromCloudFormation(properties.CapacityReservationSpecification) : undefined));
  ret.addPropertyResult("cpuOptions", "CpuOptions", (properties.CpuOptions != null ? CfnLaunchTemplateCpuOptionsPropertyFromCloudFormation(properties.CpuOptions) : undefined));
  ret.addPropertyResult("creditSpecification", "CreditSpecification", (properties.CreditSpecification != null ? CfnLaunchTemplateCreditSpecificationPropertyFromCloudFormation(properties.CreditSpecification) : undefined));
  ret.addPropertyResult("disableApiStop", "DisableApiStop", (properties.DisableApiStop != null ? cfn_parse.FromCloudFormation.getBoolean(properties.DisableApiStop) : undefined));
  ret.addPropertyResult("disableApiTermination", "DisableApiTermination", (properties.DisableApiTermination != null ? cfn_parse.FromCloudFormation.getBoolean(properties.DisableApiTermination) : undefined));
  ret.addPropertyResult("ebsOptimized", "EbsOptimized", (properties.EbsOptimized != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EbsOptimized) : undefined));
  ret.addPropertyResult("elasticGpuSpecifications", "ElasticGpuSpecifications", (properties.ElasticGpuSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnLaunchTemplateElasticGpuSpecificationPropertyFromCloudFormation)(properties.ElasticGpuSpecifications) : undefined));
  ret.addPropertyResult("elasticInferenceAccelerators", "ElasticInferenceAccelerators", (properties.ElasticInferenceAccelerators != null ? cfn_parse.FromCloudFormation.getArray(CfnLaunchTemplateLaunchTemplateElasticInferenceAcceleratorPropertyFromCloudFormation)(properties.ElasticInferenceAccelerators) : undefined));
  ret.addPropertyResult("enclaveOptions", "EnclaveOptions", (properties.EnclaveOptions != null ? CfnLaunchTemplateEnclaveOptionsPropertyFromCloudFormation(properties.EnclaveOptions) : undefined));
  ret.addPropertyResult("hibernationOptions", "HibernationOptions", (properties.HibernationOptions != null ? CfnLaunchTemplateHibernationOptionsPropertyFromCloudFormation(properties.HibernationOptions) : undefined));
  ret.addPropertyResult("iamInstanceProfile", "IamInstanceProfile", (properties.IamInstanceProfile != null ? CfnLaunchTemplateIamInstanceProfilePropertyFromCloudFormation(properties.IamInstanceProfile) : undefined));
  ret.addPropertyResult("imageId", "ImageId", (properties.ImageId != null ? cfn_parse.FromCloudFormation.getString(properties.ImageId) : undefined));
  ret.addPropertyResult("instanceInitiatedShutdownBehavior", "InstanceInitiatedShutdownBehavior", (properties.InstanceInitiatedShutdownBehavior != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceInitiatedShutdownBehavior) : undefined));
  ret.addPropertyResult("instanceMarketOptions", "InstanceMarketOptions", (properties.InstanceMarketOptions != null ? CfnLaunchTemplateInstanceMarketOptionsPropertyFromCloudFormation(properties.InstanceMarketOptions) : undefined));
  ret.addPropertyResult("instanceRequirements", "InstanceRequirements", (properties.InstanceRequirements != null ? CfnLaunchTemplateInstanceRequirementsPropertyFromCloudFormation(properties.InstanceRequirements) : undefined));
  ret.addPropertyResult("instanceType", "InstanceType", (properties.InstanceType != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceType) : undefined));
  ret.addPropertyResult("kernelId", "KernelId", (properties.KernelId != null ? cfn_parse.FromCloudFormation.getString(properties.KernelId) : undefined));
  ret.addPropertyResult("keyName", "KeyName", (properties.KeyName != null ? cfn_parse.FromCloudFormation.getString(properties.KeyName) : undefined));
  ret.addPropertyResult("licenseSpecifications", "LicenseSpecifications", (properties.LicenseSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnLaunchTemplateLicenseSpecificationPropertyFromCloudFormation)(properties.LicenseSpecifications) : undefined));
  ret.addPropertyResult("maintenanceOptions", "MaintenanceOptions", (properties.MaintenanceOptions != null ? CfnLaunchTemplateMaintenanceOptionsPropertyFromCloudFormation(properties.MaintenanceOptions) : undefined));
  ret.addPropertyResult("metadataOptions", "MetadataOptions", (properties.MetadataOptions != null ? CfnLaunchTemplateMetadataOptionsPropertyFromCloudFormation(properties.MetadataOptions) : undefined));
  ret.addPropertyResult("monitoring", "Monitoring", (properties.Monitoring != null ? CfnLaunchTemplateMonitoringPropertyFromCloudFormation(properties.Monitoring) : undefined));
  ret.addPropertyResult("networkInterfaces", "NetworkInterfaces", (properties.NetworkInterfaces != null ? cfn_parse.FromCloudFormation.getArray(CfnLaunchTemplateNetworkInterfacePropertyFromCloudFormation)(properties.NetworkInterfaces) : undefined));
  ret.addPropertyResult("placement", "Placement", (properties.Placement != null ? CfnLaunchTemplatePlacementPropertyFromCloudFormation(properties.Placement) : undefined));
  ret.addPropertyResult("privateDnsNameOptions", "PrivateDnsNameOptions", (properties.PrivateDnsNameOptions != null ? CfnLaunchTemplatePrivateDnsNameOptionsPropertyFromCloudFormation(properties.PrivateDnsNameOptions) : undefined));
  ret.addPropertyResult("ramDiskId", "RamDiskId", (properties.RamDiskId != null ? cfn_parse.FromCloudFormation.getString(properties.RamDiskId) : undefined));
  ret.addPropertyResult("securityGroupIds", "SecurityGroupIds", (properties.SecurityGroupIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecurityGroupIds) : undefined));
  ret.addPropertyResult("securityGroups", "SecurityGroups", (properties.SecurityGroups != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecurityGroups) : undefined));
  ret.addPropertyResult("tagSpecifications", "TagSpecifications", (properties.TagSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnLaunchTemplateTagSpecificationPropertyFromCloudFormation)(properties.TagSpecifications) : undefined));
  ret.addPropertyResult("userData", "UserData", (properties.UserData != null ? cfn_parse.FromCloudFormation.getString(properties.UserData) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`LaunchTemplateTagSpecificationProperty\`
 *
 * @param properties - the TypeScript properties of a \`LaunchTemplateTagSpecificationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateLaunchTemplateTagSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("resourceType", cdk.validateString)(properties.resourceType));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"LaunchTemplateTagSpecificationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateLaunchTemplateTagSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateLaunchTemplateTagSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "ResourceType": cdk.stringToCloudFormation(properties.resourceType),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateLaunchTemplateTagSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnLaunchTemplate.LaunchTemplateTagSpecificationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.LaunchTemplateTagSpecificationProperty>();
  ret.addPropertyResult("resourceType", "ResourceType", (properties.ResourceType != null ? cfn_parse.FromCloudFormation.getString(properties.ResourceType) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnLaunchTemplateProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnLaunchTemplateProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplatePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("launchTemplateData", cdk.requiredValidator)(properties.launchTemplateData));
  errors.collect(cdk.propertyValidator("launchTemplateData", CfnLaunchTemplateLaunchTemplateDataPropertyValidator)(properties.launchTemplateData));
  errors.collect(cdk.propertyValidator("launchTemplateName", cdk.validateString)(properties.launchTemplateName));
  errors.collect(cdk.propertyValidator("tagSpecifications", cdk.listValidator(CfnLaunchTemplateLaunchTemplateTagSpecificationPropertyValidator))(properties.tagSpecifications));
  errors.collect(cdk.propertyValidator("versionDescription", cdk.validateString)(properties.versionDescription));
  return errors.wrap("supplied properties not correct for \\"CfnLaunchTemplateProps\\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplatePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplatePropsValidator(properties).assertSuccess();
  return {
    "LaunchTemplateData": convertCfnLaunchTemplateLaunchTemplateDataPropertyToCloudFormation(properties.launchTemplateData),
    "LaunchTemplateName": cdk.stringToCloudFormation(properties.launchTemplateName),
    "TagSpecifications": cdk.listMapper(convertCfnLaunchTemplateLaunchTemplateTagSpecificationPropertyToCloudFormation)(properties.tagSpecifications),
    "VersionDescription": cdk.stringToCloudFormation(properties.versionDescription)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplatePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnLaunchTemplateProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplateProps>();
  ret.addPropertyResult("launchTemplateData", "LaunchTemplateData", (properties.LaunchTemplateData != null ? CfnLaunchTemplateLaunchTemplateDataPropertyFromCloudFormation(properties.LaunchTemplateData) : undefined));
  ret.addPropertyResult("launchTemplateName", "LaunchTemplateName", (properties.LaunchTemplateName != null ? cfn_parse.FromCloudFormation.getString(properties.LaunchTemplateName) : undefined));
  ret.addPropertyResult("tagSpecifications", "TagSpecifications", (properties.TagSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnLaunchTemplateLaunchTemplateTagSpecificationPropertyFromCloudFormation)(properties.TagSpecifications) : undefined));
  ret.addPropertyResult("versionDescription", "VersionDescription", (properties.VersionDescription != null ? cfn_parse.FromCloudFormation.getString(properties.VersionDescription) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Creates a static route for the specified local gateway route table. You must specify one of the following targets:.
 *
 * - \`LocalGatewayVirtualInterfaceGroupId\`
 * - \`NetworkInterfaceId\`
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroute.html
 */
export class CfnLocalGatewayRoute extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::LocalGatewayRoute";

  /**
   * Build a CfnLocalGatewayRoute from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnLocalGatewayRoute {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnLocalGatewayRoutePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnLocalGatewayRoute(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The state of the local gateway route table.
   *
   * @cloudformationAttribute State
   */
  public readonly attrState: string;

  /**
   * The type of local gateway route.
   *
   * @cloudformationAttribute Type
   */
  public readonly attrType: string;

  /**
   * The CIDR block used for destination matches.
   */
  public destinationCidrBlock: string;

  /**
   * The ID of the local gateway route table.
   */
  public localGatewayRouteTableId: string;

  /**
   * The ID of the virtual interface group.
   */
  public localGatewayVirtualInterfaceGroupId?: string;

  /**
   * The ID of the network interface.
   */
  public networkInterfaceId?: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnLocalGatewayRouteProps) {
    super(scope, id, {
      "type": CfnLocalGatewayRoute.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "destinationCidrBlock", this);
    cdk.requireProperty(props, "localGatewayRouteTableId", this);

    this.attrState = cdk.Token.asString(this.getAtt("State", cdk.ResolutionTypeHint.STRING));
    this.attrType = cdk.Token.asString(this.getAtt("Type", cdk.ResolutionTypeHint.STRING));
    this.destinationCidrBlock = props.destinationCidrBlock;
    this.localGatewayRouteTableId = props.localGatewayRouteTableId;
    this.localGatewayVirtualInterfaceGroupId = props.localGatewayVirtualInterfaceGroupId;
    this.networkInterfaceId = props.networkInterfaceId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "destinationCidrBlock": this.destinationCidrBlock,
      "localGatewayRouteTableId": this.localGatewayRouteTableId,
      "localGatewayVirtualInterfaceGroupId": this.localGatewayVirtualInterfaceGroupId,
      "networkInterfaceId": this.networkInterfaceId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnLocalGatewayRoute.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnLocalGatewayRoutePropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnLocalGatewayRoute\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroute.html
 */
export interface CfnLocalGatewayRouteProps {
  /**
   * The CIDR block used for destination matches.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroute.html#cfn-ec2-localgatewayroute-destinationcidrblock
   */
  readonly destinationCidrBlock: string;

  /**
   * The ID of the local gateway route table.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroute.html#cfn-ec2-localgatewayroute-localgatewayroutetableid
   */
  readonly localGatewayRouteTableId: string;

  /**
   * The ID of the virtual interface group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroute.html#cfn-ec2-localgatewayroute-localgatewayvirtualinterfacegroupid
   */
  readonly localGatewayVirtualInterfaceGroupId?: string;

  /**
   * The ID of the network interface.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroute.html#cfn-ec2-localgatewayroute-networkinterfaceid
   */
  readonly networkInterfaceId?: string;
}

/**
 * Determine whether the given properties match those of a \`CfnLocalGatewayRouteProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnLocalGatewayRouteProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLocalGatewayRoutePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("destinationCidrBlock", cdk.requiredValidator)(properties.destinationCidrBlock));
  errors.collect(cdk.propertyValidator("destinationCidrBlock", cdk.validateString)(properties.destinationCidrBlock));
  errors.collect(cdk.propertyValidator("localGatewayRouteTableId", cdk.requiredValidator)(properties.localGatewayRouteTableId));
  errors.collect(cdk.propertyValidator("localGatewayRouteTableId", cdk.validateString)(properties.localGatewayRouteTableId));
  errors.collect(cdk.propertyValidator("localGatewayVirtualInterfaceGroupId", cdk.validateString)(properties.localGatewayVirtualInterfaceGroupId));
  errors.collect(cdk.propertyValidator("networkInterfaceId", cdk.validateString)(properties.networkInterfaceId));
  return errors.wrap("supplied properties not correct for \\"CfnLocalGatewayRouteProps\\"");
}

// @ts-ignore TS6133
function convertCfnLocalGatewayRoutePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLocalGatewayRoutePropsValidator(properties).assertSuccess();
  return {
    "DestinationCidrBlock": cdk.stringToCloudFormation(properties.destinationCidrBlock),
    "LocalGatewayRouteTableId": cdk.stringToCloudFormation(properties.localGatewayRouteTableId),
    "LocalGatewayVirtualInterfaceGroupId": cdk.stringToCloudFormation(properties.localGatewayVirtualInterfaceGroupId),
    "NetworkInterfaceId": cdk.stringToCloudFormation(properties.networkInterfaceId)
  };
}

// @ts-ignore TS6133
function CfnLocalGatewayRoutePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnLocalGatewayRouteProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLocalGatewayRouteProps>();
  ret.addPropertyResult("destinationCidrBlock", "DestinationCidrBlock", (properties.DestinationCidrBlock != null ? cfn_parse.FromCloudFormation.getString(properties.DestinationCidrBlock) : undefined));
  ret.addPropertyResult("localGatewayRouteTableId", "LocalGatewayRouteTableId", (properties.LocalGatewayRouteTableId != null ? cfn_parse.FromCloudFormation.getString(properties.LocalGatewayRouteTableId) : undefined));
  ret.addPropertyResult("localGatewayVirtualInterfaceGroupId", "LocalGatewayVirtualInterfaceGroupId", (properties.LocalGatewayVirtualInterfaceGroupId != null ? cfn_parse.FromCloudFormation.getString(properties.LocalGatewayVirtualInterfaceGroupId) : undefined));
  ret.addPropertyResult("networkInterfaceId", "NetworkInterfaceId", (properties.NetworkInterfaceId != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkInterfaceId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Describes a local gateway route table.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetable.html
 */
export class CfnLocalGatewayRouteTable extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::LocalGatewayRouteTable";

  /**
   * Build a CfnLocalGatewayRouteTable from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnLocalGatewayRouteTable {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnLocalGatewayRouteTablePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnLocalGatewayRouteTable(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The Amazon Resource Name (ARN) of the local gateway route table.
   *
   * @cloudformationAttribute LocalGatewayRouteTableArn
   */
  public readonly attrLocalGatewayRouteTableArn: string;

  /**
   * The ID of the local gateway route table.
   *
   * @cloudformationAttribute LocalGatewayRouteTableId
   */
  public readonly attrLocalGatewayRouteTableId: string;

  /**
   * The Amazon Resource Name (ARN) of the Outpost.
   *
   * @cloudformationAttribute OutpostArn
   */
  public readonly attrOutpostArn: string;

  /**
   * The ID of the AWS account that owns the local gateway route table.
   *
   * @cloudformationAttribute OwnerId
   */
  public readonly attrOwnerId: string;

  /**
   * The state of the local gateway route table.
   *
   * @cloudformationAttribute State
   */
  public readonly attrState: string;

  /**
   * The ID of the local gateway.
   */
  public localGatewayId: string;

  /**
   * The mode of the local gateway route table.
   */
  public mode?: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags assigned to the local gateway route table.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnLocalGatewayRouteTableProps) {
    super(scope, id, {
      "type": CfnLocalGatewayRouteTable.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "localGatewayId", this);

    this.attrLocalGatewayRouteTableArn = cdk.Token.asString(this.getAtt("LocalGatewayRouteTableArn", cdk.ResolutionTypeHint.STRING));
    this.attrLocalGatewayRouteTableId = cdk.Token.asString(this.getAtt("LocalGatewayRouteTableId", cdk.ResolutionTypeHint.STRING));
    this.attrOutpostArn = cdk.Token.asString(this.getAtt("OutpostArn", cdk.ResolutionTypeHint.STRING));
    this.attrOwnerId = cdk.Token.asString(this.getAtt("OwnerId", cdk.ResolutionTypeHint.STRING));
    this.attrState = cdk.Token.asString(this.getAtt("State", cdk.ResolutionTypeHint.STRING));
    this.localGatewayId = props.localGatewayId;
    this.mode = props.mode;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::LocalGatewayRouteTable", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "localGatewayId": this.localGatewayId,
      "mode": this.mode,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnLocalGatewayRouteTable.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnLocalGatewayRouteTablePropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnLocalGatewayRouteTable\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetable.html
 */
export interface CfnLocalGatewayRouteTableProps {
  /**
   * The ID of the local gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetable.html#cfn-ec2-localgatewayroutetable-localgatewayid
   */
  readonly localGatewayId: string;

  /**
   * The mode of the local gateway route table.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetable.html#cfn-ec2-localgatewayroutetable-mode
   */
  readonly mode?: string;

  /**
   * The tags assigned to the local gateway route table.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetable.html#cfn-ec2-localgatewayroutetable-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a \`CfnLocalGatewayRouteTableProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnLocalGatewayRouteTableProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLocalGatewayRouteTablePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("localGatewayId", cdk.requiredValidator)(properties.localGatewayId));
  errors.collect(cdk.propertyValidator("localGatewayId", cdk.validateString)(properties.localGatewayId));
  errors.collect(cdk.propertyValidator("mode", cdk.validateString)(properties.mode));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnLocalGatewayRouteTableProps\\"");
}

// @ts-ignore TS6133
function convertCfnLocalGatewayRouteTablePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLocalGatewayRouteTablePropsValidator(properties).assertSuccess();
  return {
    "LocalGatewayId": cdk.stringToCloudFormation(properties.localGatewayId),
    "Mode": cdk.stringToCloudFormation(properties.mode),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnLocalGatewayRouteTablePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnLocalGatewayRouteTableProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLocalGatewayRouteTableProps>();
  ret.addPropertyResult("localGatewayId", "LocalGatewayId", (properties.LocalGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.LocalGatewayId) : undefined));
  ret.addPropertyResult("mode", "Mode", (properties.Mode != null ? cfn_parse.FromCloudFormation.getString(properties.Mode) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Describes an association between a local gateway route table and a virtual interface group.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetablevirtualinterfacegroupassociation.html
 */
export class CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociation extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::LocalGatewayRouteTableVirtualInterfaceGroupAssociation";

  /**
   * Build a CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociation from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociation {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociation(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the local gateway.
   *
   * @cloudformationAttribute LocalGatewayId
   */
  public readonly attrLocalGatewayId: string;

  /**
   * The Amazon Resource Name (ARN) of the local gateway route table for the virtual interface group.
   *
   * @cloudformationAttribute LocalGatewayRouteTableArn
   */
  public readonly attrLocalGatewayRouteTableArn: string;

  /**
   * The ID of the association.
   *
   * @cloudformationAttribute LocalGatewayRouteTableVirtualInterfaceGroupAssociationId
   */
  public readonly attrLocalGatewayRouteTableVirtualInterfaceGroupAssociationId: string;

  /**
   * The ID of the AWS account that owns the local gateway virtual interface group association.
   *
   * @cloudformationAttribute OwnerId
   */
  public readonly attrOwnerId: string;

  /**
   * The state of the association.
   *
   * @cloudformationAttribute State
   */
  public readonly attrState: string;

  /**
   * The ID of the local gateway route table.
   */
  public localGatewayRouteTableId: string;

  /**
   * The ID of the virtual interface group.
   */
  public localGatewayVirtualInterfaceGroupId: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags assigned to the association.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationProps) {
    super(scope, id, {
      "type": CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociation.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "localGatewayRouteTableId", this);
    cdk.requireProperty(props, "localGatewayVirtualInterfaceGroupId", this);

    this.attrLocalGatewayId = cdk.Token.asString(this.getAtt("LocalGatewayId", cdk.ResolutionTypeHint.STRING));
    this.attrLocalGatewayRouteTableArn = cdk.Token.asString(this.getAtt("LocalGatewayRouteTableArn", cdk.ResolutionTypeHint.STRING));
    this.attrLocalGatewayRouteTableVirtualInterfaceGroupAssociationId = cdk.Token.asString(this.getAtt("LocalGatewayRouteTableVirtualInterfaceGroupAssociationId", cdk.ResolutionTypeHint.STRING));
    this.attrOwnerId = cdk.Token.asString(this.getAtt("OwnerId", cdk.ResolutionTypeHint.STRING));
    this.attrState = cdk.Token.asString(this.getAtt("State", cdk.ResolutionTypeHint.STRING));
    this.localGatewayRouteTableId = props.localGatewayRouteTableId;
    this.localGatewayVirtualInterfaceGroupId = props.localGatewayVirtualInterfaceGroupId;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::LocalGatewayRouteTableVirtualInterfaceGroupAssociation", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "localGatewayRouteTableId": this.localGatewayRouteTableId,
      "localGatewayVirtualInterfaceGroupId": this.localGatewayVirtualInterfaceGroupId,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociation.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociation\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetablevirtualinterfacegroupassociation.html
 */
export interface CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationProps {
  /**
   * The ID of the local gateway route table.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetablevirtualinterfacegroupassociation.html#cfn-ec2-localgatewayroutetablevirtualinterfacegroupassociation-localgatewayroutetableid
   */
  readonly localGatewayRouteTableId: string;

  /**
   * The ID of the virtual interface group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetablevirtualinterfacegroupassociation.html#cfn-ec2-localgatewayroutetablevirtualinterfacegroupassociation-localgatewayvirtualinterfacegroupid
   */
  readonly localGatewayVirtualInterfaceGroupId: string;

  /**
   * The tags assigned to the association.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetablevirtualinterfacegroupassociation.html#cfn-ec2-localgatewayroutetablevirtualinterfacegroupassociation-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a \`CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("localGatewayRouteTableId", cdk.requiredValidator)(properties.localGatewayRouteTableId));
  errors.collect(cdk.propertyValidator("localGatewayRouteTableId", cdk.validateString)(properties.localGatewayRouteTableId));
  errors.collect(cdk.propertyValidator("localGatewayVirtualInterfaceGroupId", cdk.requiredValidator)(properties.localGatewayVirtualInterfaceGroupId));
  errors.collect(cdk.propertyValidator("localGatewayVirtualInterfaceGroupId", cdk.validateString)(properties.localGatewayVirtualInterfaceGroupId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationProps\\"");
}

// @ts-ignore TS6133
function convertCfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationPropsValidator(properties).assertSuccess();
  return {
    "LocalGatewayRouteTableId": cdk.stringToCloudFormation(properties.localGatewayRouteTableId),
    "LocalGatewayVirtualInterfaceGroupId": cdk.stringToCloudFormation(properties.localGatewayVirtualInterfaceGroupId),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationProps>();
  ret.addPropertyResult("localGatewayRouteTableId", "LocalGatewayRouteTableId", (properties.LocalGatewayRouteTableId != null ? cfn_parse.FromCloudFormation.getString(properties.LocalGatewayRouteTableId) : undefined));
  ret.addPropertyResult("localGatewayVirtualInterfaceGroupId", "LocalGatewayVirtualInterfaceGroupId", (properties.LocalGatewayVirtualInterfaceGroupId != null ? cfn_parse.FromCloudFormation.getString(properties.LocalGatewayVirtualInterfaceGroupId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Associates the specified VPC with the specified local gateway route table.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetablevpcassociation.html
 */
export class CfnLocalGatewayRouteTableVPCAssociation extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::LocalGatewayRouteTableVPCAssociation";

  /**
   * Build a CfnLocalGatewayRouteTableVPCAssociation from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnLocalGatewayRouteTableVPCAssociation {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnLocalGatewayRouteTableVPCAssociationPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnLocalGatewayRouteTableVPCAssociation(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the local gateway.
   *
   * @cloudformationAttribute LocalGatewayId
   */
  public readonly attrLocalGatewayId: string;

  /**
   * The ID of the association.
   *
   * @cloudformationAttribute LocalGatewayRouteTableVpcAssociationId
   */
  public readonly attrLocalGatewayRouteTableVpcAssociationId: string;

  /**
   * The state of the association.
   *
   * @cloudformationAttribute State
   */
  public readonly attrState: string;

  /**
   * The ID of the local gateway route table.
   */
  public localGatewayRouteTableId: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags assigned to the association.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The ID of the VPC.
   */
  public vpcId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnLocalGatewayRouteTableVPCAssociationProps) {
    super(scope, id, {
      "type": CfnLocalGatewayRouteTableVPCAssociation.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "localGatewayRouteTableId", this);
    cdk.requireProperty(props, "vpcId", this);

    this.attrLocalGatewayId = cdk.Token.asString(this.getAtt("LocalGatewayId", cdk.ResolutionTypeHint.STRING));
    this.attrLocalGatewayRouteTableVpcAssociationId = cdk.Token.asString(this.getAtt("LocalGatewayRouteTableVpcAssociationId", cdk.ResolutionTypeHint.STRING));
    this.attrState = cdk.Token.asString(this.getAtt("State", cdk.ResolutionTypeHint.STRING));
    this.localGatewayRouteTableId = props.localGatewayRouteTableId;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::LocalGatewayRouteTableVPCAssociation", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.vpcId = props.vpcId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "localGatewayRouteTableId": this.localGatewayRouteTableId,
      "tags": this.tags.renderTags(),
      "vpcId": this.vpcId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnLocalGatewayRouteTableVPCAssociation.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnLocalGatewayRouteTableVPCAssociationPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnLocalGatewayRouteTableVPCAssociation\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetablevpcassociation.html
 */
export interface CfnLocalGatewayRouteTableVPCAssociationProps {
  /**
   * The ID of the local gateway route table.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetablevpcassociation.html#cfn-ec2-localgatewayroutetablevpcassociation-localgatewayroutetableid
   */
  readonly localGatewayRouteTableId: string;

  /**
   * The tags assigned to the association.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetablevpcassociation.html#cfn-ec2-localgatewayroutetablevpcassociation-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The ID of the VPC.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetablevpcassociation.html#cfn-ec2-localgatewayroutetablevpcassociation-vpcid
   */
  readonly vpcId: string;
}

/**
 * Determine whether the given properties match those of a \`CfnLocalGatewayRouteTableVPCAssociationProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnLocalGatewayRouteTableVPCAssociationProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLocalGatewayRouteTableVPCAssociationPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("localGatewayRouteTableId", cdk.requiredValidator)(properties.localGatewayRouteTableId));
  errors.collect(cdk.propertyValidator("localGatewayRouteTableId", cdk.validateString)(properties.localGatewayRouteTableId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("vpcId", cdk.requiredValidator)(properties.vpcId));
  errors.collect(cdk.propertyValidator("vpcId", cdk.validateString)(properties.vpcId));
  return errors.wrap("supplied properties not correct for \\"CfnLocalGatewayRouteTableVPCAssociationProps\\"");
}

// @ts-ignore TS6133
function convertCfnLocalGatewayRouteTableVPCAssociationPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLocalGatewayRouteTableVPCAssociationPropsValidator(properties).assertSuccess();
  return {
    "LocalGatewayRouteTableId": cdk.stringToCloudFormation(properties.localGatewayRouteTableId),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "VpcId": cdk.stringToCloudFormation(properties.vpcId)
  };
}

// @ts-ignore TS6133
function CfnLocalGatewayRouteTableVPCAssociationPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnLocalGatewayRouteTableVPCAssociationProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLocalGatewayRouteTableVPCAssociationProps>();
  ret.addPropertyResult("localGatewayRouteTableId", "LocalGatewayRouteTableId", (properties.LocalGatewayRouteTableId != null ? cfn_parse.FromCloudFormation.getString(properties.LocalGatewayRouteTableId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("vpcId", "VpcId", (properties.VpcId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a network address translation (NAT) gateway in the specified subnet.
 *
 * You can create either a public NAT gateway or a private NAT gateway. The default is a public NAT gateway. If you create a public NAT gateway, you must specify an elastic IP address.
 *
 * With a NAT gateway, instances in a private subnet can connect to the internet, other AWS services, or an on-premises network using the IP address of the NAT gateway.
 *
 * If you add a default route ( \`AWS::EC2::Route\` resource) that points to a NAT gateway, specify the NAT gateway ID for the route's \`NatGatewayId\` property.
 *
 * For more information, see [NAT Gateways](https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html) in the *Amazon VPC User Guide* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html
 */
export class CfnNatGateway extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::NatGateway";

  /**
   * Build a CfnNatGateway from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnNatGateway {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnNatGatewayPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnNatGateway(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the NAT gateway.
   *
   * @cloudformationAttribute NatGatewayId
   */
  public readonly attrNatGatewayId: string;

  /**
   * [Public NAT gateway only] The allocation ID of the Elastic IP address that's associated with the NAT gateway.
   */
  public allocationId?: string;

  /**
   * Indicates whether the NAT gateway supports public or private connectivity.
   */
  public connectivityType?: string;

  /**
   * The maximum amount of time to wait (in seconds) before forcibly releasing the IP addresses if connections are still in progress.
   */
  public maxDrainDurationSeconds?: number;

  /**
   * The private IPv4 address to assign to the NAT gateway.
   */
  public privateIpAddress?: string;

  /**
   * Secondary EIP allocation IDs.
   */
  public secondaryAllocationIds?: Array<string>;

  /**
   * [Private NAT gateway only] The number of secondary private IPv4 addresses you want to assign to the NAT gateway.
   */
  public secondaryPrivateIpAddressCount?: number;

  /**
   * Secondary private IPv4 addresses.
   */
  public secondaryPrivateIpAddresses?: Array<string>;

  /**
   * The ID of the subnet in which the NAT gateway is located.
   */
  public subnetId: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags for the NAT gateway.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnNatGatewayProps) {
    super(scope, id, {
      "type": CfnNatGateway.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "subnetId", this);

    this.attrNatGatewayId = cdk.Token.asString(this.getAtt("NatGatewayId", cdk.ResolutionTypeHint.STRING));
    this.allocationId = props.allocationId;
    this.connectivityType = props.connectivityType;
    this.maxDrainDurationSeconds = props.maxDrainDurationSeconds;
    this.privateIpAddress = props.privateIpAddress;
    this.secondaryAllocationIds = props.secondaryAllocationIds;
    this.secondaryPrivateIpAddressCount = props.secondaryPrivateIpAddressCount;
    this.secondaryPrivateIpAddresses = props.secondaryPrivateIpAddresses;
    this.subnetId = props.subnetId;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::NatGateway", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "allocationId": this.allocationId,
      "connectivityType": this.connectivityType,
      "maxDrainDurationSeconds": this.maxDrainDurationSeconds,
      "privateIpAddress": this.privateIpAddress,
      "secondaryAllocationIds": this.secondaryAllocationIds,
      "secondaryPrivateIpAddressCount": this.secondaryPrivateIpAddressCount,
      "secondaryPrivateIpAddresses": this.secondaryPrivateIpAddresses,
      "subnetId": this.subnetId,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnNatGateway.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnNatGatewayPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnNatGateway\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html
 */
export interface CfnNatGatewayProps {
  /**
   * [Public NAT gateway only] The allocation ID of the Elastic IP address that's associated with the NAT gateway.
   *
   * This property is required for a public NAT gateway and cannot be specified with a private NAT gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html#cfn-ec2-natgateway-allocationid
   */
  readonly allocationId?: string;

  /**
   * Indicates whether the NAT gateway supports public or private connectivity.
   *
   * The default is public connectivity.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html#cfn-ec2-natgateway-connectivitytype
   */
  readonly connectivityType?: string;

  /**
   * The maximum amount of time to wait (in seconds) before forcibly releasing the IP addresses if connections are still in progress.
   *
   * Default value is 350 seconds.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html#cfn-ec2-natgateway-maxdraindurationseconds
   */
  readonly maxDrainDurationSeconds?: number;

  /**
   * The private IPv4 address to assign to the NAT gateway.
   *
   * If you don't provide an address, a private IPv4 address will be automatically assigned.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html#cfn-ec2-natgateway-privateipaddress
   */
  readonly privateIpAddress?: string;

  /**
   * Secondary EIP allocation IDs.
   *
   * For more information, see [Create a NAT gateway](https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html#nat-gateway-creating) in the *Amazon VPC User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html#cfn-ec2-natgateway-secondaryallocationids
   */
  readonly secondaryAllocationIds?: Array<string>;

  /**
   * [Private NAT gateway only] The number of secondary private IPv4 addresses you want to assign to the NAT gateway.
   *
   * For more information about secondary addresses, see [Create a NAT gateway](https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html#nat-gateway-creating) in the *Amazon Virtual Private Cloud User Guide* .
   *
   * > \`SecondaryPrivateIpAddressCount\` and \`SecondaryPrivateIpAddresses\` cannot be set at the same time.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html#cfn-ec2-natgateway-secondaryprivateipaddresscount
   */
  readonly secondaryPrivateIpAddressCount?: number;

  /**
   * Secondary private IPv4 addresses.
   *
   * For more information about secondary addresses, see [Create a NAT gateway](https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html#nat-gateway-creating) in the *Amazon Virtual Private Cloud User Guide* .
   *
   * > \`SecondaryPrivateIpAddressCount\` and \`SecondaryPrivateIpAddresses\` cannot be set at the same time.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html#cfn-ec2-natgateway-secondaryprivateipaddresses
   */
  readonly secondaryPrivateIpAddresses?: Array<string>;

  /**
   * The ID of the subnet in which the NAT gateway is located.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html#cfn-ec2-natgateway-subnetid
   */
  readonly subnetId: string;

  /**
   * The tags for the NAT gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html#cfn-ec2-natgateway-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a \`CfnNatGatewayProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnNatGatewayProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNatGatewayPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("allocationId", cdk.validateString)(properties.allocationId));
  errors.collect(cdk.propertyValidator("connectivityType", cdk.validateString)(properties.connectivityType));
  errors.collect(cdk.propertyValidator("maxDrainDurationSeconds", cdk.validateNumber)(properties.maxDrainDurationSeconds));
  errors.collect(cdk.propertyValidator("privateIpAddress", cdk.validateString)(properties.privateIpAddress));
  errors.collect(cdk.propertyValidator("secondaryAllocationIds", cdk.listValidator(cdk.validateString))(properties.secondaryAllocationIds));
  errors.collect(cdk.propertyValidator("secondaryPrivateIpAddressCount", cdk.validateNumber)(properties.secondaryPrivateIpAddressCount));
  errors.collect(cdk.propertyValidator("secondaryPrivateIpAddresses", cdk.listValidator(cdk.validateString))(properties.secondaryPrivateIpAddresses));
  errors.collect(cdk.propertyValidator("subnetId", cdk.requiredValidator)(properties.subnetId));
  errors.collect(cdk.propertyValidator("subnetId", cdk.validateString)(properties.subnetId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnNatGatewayProps\\"");
}

// @ts-ignore TS6133
function convertCfnNatGatewayPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNatGatewayPropsValidator(properties).assertSuccess();
  return {
    "AllocationId": cdk.stringToCloudFormation(properties.allocationId),
    "ConnectivityType": cdk.stringToCloudFormation(properties.connectivityType),
    "MaxDrainDurationSeconds": cdk.numberToCloudFormation(properties.maxDrainDurationSeconds),
    "PrivateIpAddress": cdk.stringToCloudFormation(properties.privateIpAddress),
    "SecondaryAllocationIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.secondaryAllocationIds),
    "SecondaryPrivateIpAddressCount": cdk.numberToCloudFormation(properties.secondaryPrivateIpAddressCount),
    "SecondaryPrivateIpAddresses": cdk.listMapper(cdk.stringToCloudFormation)(properties.secondaryPrivateIpAddresses),
    "SubnetId": cdk.stringToCloudFormation(properties.subnetId),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnNatGatewayPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNatGatewayProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNatGatewayProps>();
  ret.addPropertyResult("allocationId", "AllocationId", (properties.AllocationId != null ? cfn_parse.FromCloudFormation.getString(properties.AllocationId) : undefined));
  ret.addPropertyResult("connectivityType", "ConnectivityType", (properties.ConnectivityType != null ? cfn_parse.FromCloudFormation.getString(properties.ConnectivityType) : undefined));
  ret.addPropertyResult("maxDrainDurationSeconds", "MaxDrainDurationSeconds", (properties.MaxDrainDurationSeconds != null ? cfn_parse.FromCloudFormation.getNumber(properties.MaxDrainDurationSeconds) : undefined));
  ret.addPropertyResult("privateIpAddress", "PrivateIpAddress", (properties.PrivateIpAddress != null ? cfn_parse.FromCloudFormation.getString(properties.PrivateIpAddress) : undefined));
  ret.addPropertyResult("secondaryAllocationIds", "SecondaryAllocationIds", (properties.SecondaryAllocationIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecondaryAllocationIds) : undefined));
  ret.addPropertyResult("secondaryPrivateIpAddressCount", "SecondaryPrivateIpAddressCount", (properties.SecondaryPrivateIpAddressCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.SecondaryPrivateIpAddressCount) : undefined));
  ret.addPropertyResult("secondaryPrivateIpAddresses", "SecondaryPrivateIpAddresses", (properties.SecondaryPrivateIpAddresses != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecondaryPrivateIpAddresses) : undefined));
  ret.addPropertyResult("subnetId", "SubnetId", (properties.SubnetId != null ? cfn_parse.FromCloudFormation.getString(properties.SubnetId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a network ACL for your VPC.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkacl.html
 */
export class CfnNetworkAcl extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::NetworkAcl";

  /**
   * Build a CfnNetworkAcl from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnNetworkAcl {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnNetworkAclPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnNetworkAcl(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the network ACL.
   *
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags for the network ACL.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The ID of the VPC for the network ACL.
   */
  public vpcId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnNetworkAclProps) {
    super(scope, id, {
      "type": CfnNetworkAcl.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "vpcId", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::NetworkAcl", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.vpcId = props.vpcId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "tags": this.tags.renderTags(),
      "vpcId": this.vpcId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnNetworkAcl.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnNetworkAclPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnNetworkAcl\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkacl.html
 */
export interface CfnNetworkAclProps {
  /**
   * The tags for the network ACL.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkacl.html#cfn-ec2-networkacl-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The ID of the VPC for the network ACL.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkacl.html#cfn-ec2-networkacl-vpcid
   */
  readonly vpcId: string;
}

/**
 * Determine whether the given properties match those of a \`CfnNetworkAclProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnNetworkAclProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkAclPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("vpcId", cdk.requiredValidator)(properties.vpcId));
  errors.collect(cdk.propertyValidator("vpcId", cdk.validateString)(properties.vpcId));
  return errors.wrap("supplied properties not correct for \\"CfnNetworkAclProps\\"");
}

// @ts-ignore TS6133
function convertCfnNetworkAclPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkAclPropsValidator(properties).assertSuccess();
  return {
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "VpcId": cdk.stringToCloudFormation(properties.vpcId)
  };
}

// @ts-ignore TS6133
function CfnNetworkAclPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNetworkAclProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkAclProps>();
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("vpcId", "VpcId", (properties.VpcId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies an entry, known as a rule, in a network ACL with a rule number you specify.
 *
 * Each network ACL has a set of numbered ingress rules and a separate set of numbered egress rules.
 *
 * For information about the protocol value, see [Protocol Numbers](https://docs.aws.amazon.com/https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml) on the Internet Assigned Numbers Authority (IANA) website.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html
 */
export class CfnNetworkAclEntry extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::NetworkAclEntry";

  /**
   * Build a CfnNetworkAclEntry from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnNetworkAclEntry {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnNetworkAclEntryPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnNetworkAclEntry(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The IPv4 CIDR range to allow or deny, in CIDR notation (for example, 172.16.0.0/24). Requirement is conditional: You must specify the \`CidrBlock\` or \`Ipv6CidrBlock\` property.
   */
  public cidrBlock?: string;

  /**
   * Whether this rule applies to egress traffic from the subnet ( \`true\` ) or ingress traffic to the subnet ( \`false\` ).
   */
  public egress?: boolean | cdk.IResolvable;

  /**
   * The Internet Control Message Protocol (ICMP) code and type.
   */
  public icmp?: CfnNetworkAclEntry.IcmpProperty | cdk.IResolvable;

  /**
   * The IPv6 network range to allow or deny, in CIDR notation.
   */
  public ipv6CidrBlock?: string;

  /**
   * The ID of the ACL for the entry.
   */
  public networkAclId: string;

  /**
   * The range of port numbers for the UDP/TCP protocol.
   */
  public portRange?: cdk.IResolvable | CfnNetworkAclEntry.PortRangeProperty;

  /**
   * The IP protocol that the rule applies to.
   */
  public protocol: number;

  /**
   * Whether to allow or deny traffic that matches the rule;
   */
  public ruleAction: string;

  /**
   * Rule number to assign to the entry, such as 100.
   */
  public ruleNumber: number;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnNetworkAclEntryProps) {
    super(scope, id, {
      "type": CfnNetworkAclEntry.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "networkAclId", this);
    cdk.requireProperty(props, "protocol", this);
    cdk.requireProperty(props, "ruleAction", this);
    cdk.requireProperty(props, "ruleNumber", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.cidrBlock = props.cidrBlock;
    this.egress = props.egress;
    this.icmp = props.icmp;
    this.ipv6CidrBlock = props.ipv6CidrBlock;
    this.networkAclId = props.networkAclId;
    this.portRange = props.portRange;
    this.protocol = props.protocol;
    this.ruleAction = props.ruleAction;
    this.ruleNumber = props.ruleNumber;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "cidrBlock": this.cidrBlock,
      "egress": this.egress,
      "icmp": this.icmp,
      "ipv6CidrBlock": this.ipv6CidrBlock,
      "networkAclId": this.networkAclId,
      "portRange": this.portRange,
      "protocol": this.protocol,
      "ruleAction": this.ruleAction,
      "ruleNumber": this.ruleNumber
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnNetworkAclEntry.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnNetworkAclEntryPropsToCloudFormation(props);
  }
}

export namespace CfnNetworkAclEntry {
  /**
   * Describes a range of ports.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkaclentry-portrange.html
   */
  export interface PortRangeProperty {
    /**
     * The first port in the range.
     *
     * Required if you specify 6 (TCP) or 17 (UDP) for the protocol parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkaclentry-portrange.html#cfn-ec2-networkaclentry-portrange-from
     */
    readonly from?: number;

    /**
     * The last port in the range.
     *
     * Required if you specify 6 (TCP) or 17 (UDP) for the protocol parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkaclentry-portrange.html#cfn-ec2-networkaclentry-portrange-to
     */
    readonly to?: number;
  }

  /**
   * Describes the ICMP type and code.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkaclentry-icmp.html
   */
  export interface IcmpProperty {
    /**
     * The Internet Control Message Protocol (ICMP) code.
     *
     * You can use -1 to specify all ICMP codes for the given ICMP type. Requirement is conditional: Required if you specify 1 (ICMP) for the protocol parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkaclentry-icmp.html#cfn-ec2-networkaclentry-icmp-code
     */
    readonly code?: number;

    /**
     * The Internet Control Message Protocol (ICMP) type.
     *
     * You can use -1 to specify all ICMP types. Conditional requirement: Required if you specify 1 (ICMP) for the \`CreateNetworkAclEntry\` protocol parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkaclentry-icmp.html#cfn-ec2-networkaclentry-icmp-type
     */
    readonly type?: number;
  }
}

/**
 * Properties for defining a \`CfnNetworkAclEntry\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html
 */
export interface CfnNetworkAclEntryProps {
  /**
   * The IPv4 CIDR range to allow or deny, in CIDR notation (for example, 172.16.0.0/24). Requirement is conditional: You must specify the \`CidrBlock\` or \`Ipv6CidrBlock\` property.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-cidrblock
   */
  readonly cidrBlock?: string;

  /**
   * Whether this rule applies to egress traffic from the subnet ( \`true\` ) or ingress traffic to the subnet ( \`false\` ).
   *
   * By default, AWS CloudFormation specifies \`false\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-egress
   */
  readonly egress?: boolean | cdk.IResolvable;

  /**
   * The Internet Control Message Protocol (ICMP) code and type.
   *
   * Requirement is conditional: Required if specifying 1 (ICMP) for the protocol parameter.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-icmp
   */
  readonly icmp?: CfnNetworkAclEntry.IcmpProperty | cdk.IResolvable;

  /**
   * The IPv6 network range to allow or deny, in CIDR notation.
   *
   * Requirement is conditional: You must specify the \`CidrBlock\` or \`Ipv6CidrBlock\` property.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-ipv6cidrblock
   */
  readonly ipv6CidrBlock?: string;

  /**
   * The ID of the ACL for the entry.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-networkaclid
   */
  readonly networkAclId: string;

  /**
   * The range of port numbers for the UDP/TCP protocol.
   *
   * Conditional required if specifying 6 (TCP) or 17 (UDP) for the protocol parameter.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-portrange
   */
  readonly portRange?: cdk.IResolvable | CfnNetworkAclEntry.PortRangeProperty;

  /**
   * The IP protocol that the rule applies to.
   *
   * You must specify -1 or a protocol number. You can specify -1 for all protocols.
   *
   * > If you specify -1, all ports are opened and the \`PortRange\` property is ignored.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-protocol
   */
  readonly protocol: number;

  /**
   * Whether to allow or deny traffic that matches the rule;
   *
   * valid values are "allow" or "deny".
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-ruleaction
   */
  readonly ruleAction: string;

  /**
   * Rule number to assign to the entry, such as 100.
   *
   * ACL entries are processed in ascending order by rule number. Entries can't use the same rule number unless one is an egress rule and the other is an ingress rule.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-rulenumber
   */
  readonly ruleNumber: number;
}

/**
 * Determine whether the given properties match those of a \`PortRangeProperty\`
 *
 * @param properties - the TypeScript properties of a \`PortRangeProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkAclEntryPortRangePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("from", cdk.validateNumber)(properties.from));
  errors.collect(cdk.propertyValidator("to", cdk.validateNumber)(properties.to));
  return errors.wrap("supplied properties not correct for \\"PortRangeProperty\\"");
}

// @ts-ignore TS6133
function convertCfnNetworkAclEntryPortRangePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkAclEntryPortRangePropertyValidator(properties).assertSuccess();
  return {
    "From": cdk.numberToCloudFormation(properties.from),
    "To": cdk.numberToCloudFormation(properties.to)
  };
}

// @ts-ignore TS6133
function CfnNetworkAclEntryPortRangePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnNetworkAclEntry.PortRangeProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkAclEntry.PortRangeProperty>();
  ret.addPropertyResult("from", "From", (properties.From != null ? cfn_parse.FromCloudFormation.getNumber(properties.From) : undefined));
  ret.addPropertyResult("to", "To", (properties.To != null ? cfn_parse.FromCloudFormation.getNumber(properties.To) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`IcmpProperty\`
 *
 * @param properties - the TypeScript properties of a \`IcmpProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkAclEntryIcmpPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("code", cdk.validateNumber)(properties.code));
  errors.collect(cdk.propertyValidator("type", cdk.validateNumber)(properties.type));
  return errors.wrap("supplied properties not correct for \\"IcmpProperty\\"");
}

// @ts-ignore TS6133
function convertCfnNetworkAclEntryIcmpPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkAclEntryIcmpPropertyValidator(properties).assertSuccess();
  return {
    "Code": cdk.numberToCloudFormation(properties.code),
    "Type": cdk.numberToCloudFormation(properties.type)
  };
}

// @ts-ignore TS6133
function CfnNetworkAclEntryIcmpPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNetworkAclEntry.IcmpProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkAclEntry.IcmpProperty>();
  ret.addPropertyResult("code", "Code", (properties.Code != null ? cfn_parse.FromCloudFormation.getNumber(properties.Code) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getNumber(properties.Type) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnNetworkAclEntryProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnNetworkAclEntryProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkAclEntryPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("cidrBlock", cdk.validateString)(properties.cidrBlock));
  errors.collect(cdk.propertyValidator("egress", cdk.validateBoolean)(properties.egress));
  errors.collect(cdk.propertyValidator("icmp", CfnNetworkAclEntryIcmpPropertyValidator)(properties.icmp));
  errors.collect(cdk.propertyValidator("ipv6CidrBlock", cdk.validateString)(properties.ipv6CidrBlock));
  errors.collect(cdk.propertyValidator("networkAclId", cdk.requiredValidator)(properties.networkAclId));
  errors.collect(cdk.propertyValidator("networkAclId", cdk.validateString)(properties.networkAclId));
  errors.collect(cdk.propertyValidator("portRange", CfnNetworkAclEntryPortRangePropertyValidator)(properties.portRange));
  errors.collect(cdk.propertyValidator("protocol", cdk.requiredValidator)(properties.protocol));
  errors.collect(cdk.propertyValidator("protocol", cdk.validateNumber)(properties.protocol));
  errors.collect(cdk.propertyValidator("ruleAction", cdk.requiredValidator)(properties.ruleAction));
  errors.collect(cdk.propertyValidator("ruleAction", cdk.validateString)(properties.ruleAction));
  errors.collect(cdk.propertyValidator("ruleNumber", cdk.requiredValidator)(properties.ruleNumber));
  errors.collect(cdk.propertyValidator("ruleNumber", cdk.validateNumber)(properties.ruleNumber));
  return errors.wrap("supplied properties not correct for \\"CfnNetworkAclEntryProps\\"");
}

// @ts-ignore TS6133
function convertCfnNetworkAclEntryPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkAclEntryPropsValidator(properties).assertSuccess();
  return {
    "CidrBlock": cdk.stringToCloudFormation(properties.cidrBlock),
    "Egress": cdk.booleanToCloudFormation(properties.egress),
    "Icmp": convertCfnNetworkAclEntryIcmpPropertyToCloudFormation(properties.icmp),
    "Ipv6CidrBlock": cdk.stringToCloudFormation(properties.ipv6CidrBlock),
    "NetworkAclId": cdk.stringToCloudFormation(properties.networkAclId),
    "PortRange": convertCfnNetworkAclEntryPortRangePropertyToCloudFormation(properties.portRange),
    "Protocol": cdk.numberToCloudFormation(properties.protocol),
    "RuleAction": cdk.stringToCloudFormation(properties.ruleAction),
    "RuleNumber": cdk.numberToCloudFormation(properties.ruleNumber)
  };
}

// @ts-ignore TS6133
function CfnNetworkAclEntryPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNetworkAclEntryProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkAclEntryProps>();
  ret.addPropertyResult("cidrBlock", "CidrBlock", (properties.CidrBlock != null ? cfn_parse.FromCloudFormation.getString(properties.CidrBlock) : undefined));
  ret.addPropertyResult("egress", "Egress", (properties.Egress != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Egress) : undefined));
  ret.addPropertyResult("icmp", "Icmp", (properties.Icmp != null ? CfnNetworkAclEntryIcmpPropertyFromCloudFormation(properties.Icmp) : undefined));
  ret.addPropertyResult("ipv6CidrBlock", "Ipv6CidrBlock", (properties.Ipv6CidrBlock != null ? cfn_parse.FromCloudFormation.getString(properties.Ipv6CidrBlock) : undefined));
  ret.addPropertyResult("networkAclId", "NetworkAclId", (properties.NetworkAclId != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkAclId) : undefined));
  ret.addPropertyResult("portRange", "PortRange", (properties.PortRange != null ? CfnNetworkAclEntryPortRangePropertyFromCloudFormation(properties.PortRange) : undefined));
  ret.addPropertyResult("protocol", "Protocol", (properties.Protocol != null ? cfn_parse.FromCloudFormation.getNumber(properties.Protocol) : undefined));
  ret.addPropertyResult("ruleAction", "RuleAction", (properties.RuleAction != null ? cfn_parse.FromCloudFormation.getString(properties.RuleAction) : undefined));
  ret.addPropertyResult("ruleNumber", "RuleNumber", (properties.RuleNumber != null ? cfn_parse.FromCloudFormation.getNumber(properties.RuleNumber) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Describes a Network Access Scope.
 *
 * A Network Access Scope defines outbound (egress) and inbound (ingress) traffic patterns, including sources, destinations, paths, and traffic types.
 *
 * Network Access Analyzer identifies unintended network access to your resources on AWS . When you start an analysis on a Network Access Scope, Network Access Analyzer produces findings. For more information, see the [Network Access Analyzer User Guide](https://docs.aws.amazon.com/vpc/latest/network-access-analyzer/) .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsaccessscope.html
 */
export class CfnNetworkInsightsAccessScope extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::NetworkInsightsAccessScope";

  /**
   * Build a CfnNetworkInsightsAccessScope from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnNetworkInsightsAccessScope {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnNetworkInsightsAccessScopePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnNetworkInsightsAccessScope(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The creation date.
   *
   * @cloudformationAttribute CreatedDate
   */
  public readonly attrCreatedDate: string;

  /**
   * The ARN of the Network Access Scope.
   *
   * @cloudformationAttribute NetworkInsightsAccessScopeArn
   */
  public readonly attrNetworkInsightsAccessScopeArn: string;

  /**
   * The ID of the Network Access Scope.
   *
   * @cloudformationAttribute NetworkInsightsAccessScopeId
   */
  public readonly attrNetworkInsightsAccessScopeId: string;

  /**
   * The last updated date.
   *
   * @cloudformationAttribute UpdatedDate
   */
  public readonly attrUpdatedDate: string;

  /**
   * The paths to exclude.
   */
  public excludePaths?: Array<CfnNetworkInsightsAccessScope.AccessScopePathRequestProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * The paths to match.
   */
  public matchPaths?: Array<CfnNetworkInsightsAccessScope.AccessScopePathRequestProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnNetworkInsightsAccessScopeProps = {}) {
    super(scope, id, {
      "type": CfnNetworkInsightsAccessScope.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.attrCreatedDate = cdk.Token.asString(this.getAtt("CreatedDate", cdk.ResolutionTypeHint.STRING));
    this.attrNetworkInsightsAccessScopeArn = cdk.Token.asString(this.getAtt("NetworkInsightsAccessScopeArn", cdk.ResolutionTypeHint.STRING));
    this.attrNetworkInsightsAccessScopeId = cdk.Token.asString(this.getAtt("NetworkInsightsAccessScopeId", cdk.ResolutionTypeHint.STRING));
    this.attrUpdatedDate = cdk.Token.asString(this.getAtt("UpdatedDate", cdk.ResolutionTypeHint.STRING));
    this.excludePaths = props.excludePaths;
    this.matchPaths = props.matchPaths;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::NetworkInsightsAccessScope", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "excludePaths": this.excludePaths,
      "matchPaths": this.matchPaths,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnNetworkInsightsAccessScope.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnNetworkInsightsAccessScopePropsToCloudFormation(props);
  }
}

export namespace CfnNetworkInsightsAccessScope {
  /**
   * Describes a path.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-accessscopepathrequest.html
   */
  export interface AccessScopePathRequestProperty {
    /**
     * The destination.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-accessscopepathrequest.html#cfn-ec2-networkinsightsaccessscope-accessscopepathrequest-destination
     */
    readonly destination?: cdk.IResolvable | CfnNetworkInsightsAccessScope.PathStatementRequestProperty;

    /**
     * The source.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-accessscopepathrequest.html#cfn-ec2-networkinsightsaccessscope-accessscopepathrequest-source
     */
    readonly source?: cdk.IResolvable | CfnNetworkInsightsAccessScope.PathStatementRequestProperty;

    /**
     * The through resources.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-accessscopepathrequest.html#cfn-ec2-networkinsightsaccessscope-accessscopepathrequest-throughresources
     */
    readonly throughResources?: Array<cdk.IResolvable | CfnNetworkInsightsAccessScope.ThroughResourcesStatementRequestProperty> | cdk.IResolvable;
  }

  /**
   * Describes a path statement.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-pathstatementrequest.html
   */
  export interface PathStatementRequestProperty {
    /**
     * The packet header statement.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-pathstatementrequest.html#cfn-ec2-networkinsightsaccessscope-pathstatementrequest-packetheaderstatement
     */
    readonly packetHeaderStatement?: cdk.IResolvable | CfnNetworkInsightsAccessScope.PacketHeaderStatementRequestProperty;

    /**
     * The resource statement.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-pathstatementrequest.html#cfn-ec2-networkinsightsaccessscope-pathstatementrequest-resourcestatement
     */
    readonly resourceStatement?: cdk.IResolvable | CfnNetworkInsightsAccessScope.ResourceStatementRequestProperty;
  }

  /**
   * Describes a packet header statement.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-packetheaderstatementrequest.html
   */
  export interface PacketHeaderStatementRequestProperty {
    /**
     * The destination addresses.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-packetheaderstatementrequest.html#cfn-ec2-networkinsightsaccessscope-packetheaderstatementrequest-destinationaddresses
     */
    readonly destinationAddresses?: Array<string>;

    /**
     * The destination ports.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-packetheaderstatementrequest.html#cfn-ec2-networkinsightsaccessscope-packetheaderstatementrequest-destinationports
     */
    readonly destinationPorts?: Array<string>;

    /**
     * The destination prefix lists.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-packetheaderstatementrequest.html#cfn-ec2-networkinsightsaccessscope-packetheaderstatementrequest-destinationprefixlists
     */
    readonly destinationPrefixLists?: Array<string>;

    /**
     * The protocols.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-packetheaderstatementrequest.html#cfn-ec2-networkinsightsaccessscope-packetheaderstatementrequest-protocols
     */
    readonly protocols?: Array<string>;

    /**
     * The source addresses.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-packetheaderstatementrequest.html#cfn-ec2-networkinsightsaccessscope-packetheaderstatementrequest-sourceaddresses
     */
    readonly sourceAddresses?: Array<string>;

    /**
     * The source ports.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-packetheaderstatementrequest.html#cfn-ec2-networkinsightsaccessscope-packetheaderstatementrequest-sourceports
     */
    readonly sourcePorts?: Array<string>;

    /**
     * The source prefix lists.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-packetheaderstatementrequest.html#cfn-ec2-networkinsightsaccessscope-packetheaderstatementrequest-sourceprefixlists
     */
    readonly sourcePrefixLists?: Array<string>;
  }

  /**
   * Describes a resource statement.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-resourcestatementrequest.html
   */
  export interface ResourceStatementRequestProperty {
    /**
     * The resources.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-resourcestatementrequest.html#cfn-ec2-networkinsightsaccessscope-resourcestatementrequest-resources
     */
    readonly resources?: Array<string>;

    /**
     * The resource types.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-resourcestatementrequest.html#cfn-ec2-networkinsightsaccessscope-resourcestatementrequest-resourcetypes
     */
    readonly resourceTypes?: Array<string>;
  }

  /**
   * Describes a through resource statement.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-throughresourcesstatementrequest.html
   */
  export interface ThroughResourcesStatementRequestProperty {
    /**
     * The resource statement.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-throughresourcesstatementrequest.html#cfn-ec2-networkinsightsaccessscope-throughresourcesstatementrequest-resourcestatement
     */
    readonly resourceStatement?: cdk.IResolvable | CfnNetworkInsightsAccessScope.ResourceStatementRequestProperty;
  }
}

/**
 * Properties for defining a \`CfnNetworkInsightsAccessScope\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsaccessscope.html
 */
export interface CfnNetworkInsightsAccessScopeProps {
  /**
   * The paths to exclude.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsaccessscope.html#cfn-ec2-networkinsightsaccessscope-excludepaths
   */
  readonly excludePaths?: Array<CfnNetworkInsightsAccessScope.AccessScopePathRequestProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * The paths to match.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsaccessscope.html#cfn-ec2-networkinsightsaccessscope-matchpaths
   */
  readonly matchPaths?: Array<CfnNetworkInsightsAccessScope.AccessScopePathRequestProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * The tags.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsaccessscope.html#cfn-ec2-networkinsightsaccessscope-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a \`PacketHeaderStatementRequestProperty\`
 *
 * @param properties - the TypeScript properties of a \`PacketHeaderStatementRequestProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInsightsAccessScopePacketHeaderStatementRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("destinationAddresses", cdk.listValidator(cdk.validateString))(properties.destinationAddresses));
  errors.collect(cdk.propertyValidator("destinationPorts", cdk.listValidator(cdk.validateString))(properties.destinationPorts));
  errors.collect(cdk.propertyValidator("destinationPrefixLists", cdk.listValidator(cdk.validateString))(properties.destinationPrefixLists));
  errors.collect(cdk.propertyValidator("protocols", cdk.listValidator(cdk.validateString))(properties.protocols));
  errors.collect(cdk.propertyValidator("sourceAddresses", cdk.listValidator(cdk.validateString))(properties.sourceAddresses));
  errors.collect(cdk.propertyValidator("sourcePorts", cdk.listValidator(cdk.validateString))(properties.sourcePorts));
  errors.collect(cdk.propertyValidator("sourcePrefixLists", cdk.listValidator(cdk.validateString))(properties.sourcePrefixLists));
  return errors.wrap("supplied properties not correct for \\"PacketHeaderStatementRequestProperty\\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInsightsAccessScopePacketHeaderStatementRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInsightsAccessScopePacketHeaderStatementRequestPropertyValidator(properties).assertSuccess();
  return {
    "DestinationAddresses": cdk.listMapper(cdk.stringToCloudFormation)(properties.destinationAddresses),
    "DestinationPorts": cdk.listMapper(cdk.stringToCloudFormation)(properties.destinationPorts),
    "DestinationPrefixLists": cdk.listMapper(cdk.stringToCloudFormation)(properties.destinationPrefixLists),
    "Protocols": cdk.listMapper(cdk.stringToCloudFormation)(properties.protocols),
    "SourceAddresses": cdk.listMapper(cdk.stringToCloudFormation)(properties.sourceAddresses),
    "SourcePorts": cdk.listMapper(cdk.stringToCloudFormation)(properties.sourcePorts),
    "SourcePrefixLists": cdk.listMapper(cdk.stringToCloudFormation)(properties.sourcePrefixLists)
  };
}

// @ts-ignore TS6133
function CfnNetworkInsightsAccessScopePacketHeaderStatementRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnNetworkInsightsAccessScope.PacketHeaderStatementRequestProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInsightsAccessScope.PacketHeaderStatementRequestProperty>();
  ret.addPropertyResult("destinationAddresses", "DestinationAddresses", (properties.DestinationAddresses != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.DestinationAddresses) : undefined));
  ret.addPropertyResult("destinationPorts", "DestinationPorts", (properties.DestinationPorts != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.DestinationPorts) : undefined));
  ret.addPropertyResult("destinationPrefixLists", "DestinationPrefixLists", (properties.DestinationPrefixLists != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.DestinationPrefixLists) : undefined));
  ret.addPropertyResult("protocols", "Protocols", (properties.Protocols != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.Protocols) : undefined));
  ret.addPropertyResult("sourceAddresses", "SourceAddresses", (properties.SourceAddresses != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SourceAddresses) : undefined));
  ret.addPropertyResult("sourcePorts", "SourcePorts", (properties.SourcePorts != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SourcePorts) : undefined));
  ret.addPropertyResult("sourcePrefixLists", "SourcePrefixLists", (properties.SourcePrefixLists != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SourcePrefixLists) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ResourceStatementRequestProperty\`
 *
 * @param properties - the TypeScript properties of a \`ResourceStatementRequestProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInsightsAccessScopeResourceStatementRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("resourceTypes", cdk.listValidator(cdk.validateString))(properties.resourceTypes));
  errors.collect(cdk.propertyValidator("resources", cdk.listValidator(cdk.validateString))(properties.resources));
  return errors.wrap("supplied properties not correct for \\"ResourceStatementRequestProperty\\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInsightsAccessScopeResourceStatementRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInsightsAccessScopeResourceStatementRequestPropertyValidator(properties).assertSuccess();
  return {
    "ResourceTypes": cdk.listMapper(cdk.stringToCloudFormation)(properties.resourceTypes),
    "Resources": cdk.listMapper(cdk.stringToCloudFormation)(properties.resources)
  };
}

// @ts-ignore TS6133
function CfnNetworkInsightsAccessScopeResourceStatementRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnNetworkInsightsAccessScope.ResourceStatementRequestProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInsightsAccessScope.ResourceStatementRequestProperty>();
  ret.addPropertyResult("resources", "Resources", (properties.Resources != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.Resources) : undefined));
  ret.addPropertyResult("resourceTypes", "ResourceTypes", (properties.ResourceTypes != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.ResourceTypes) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`PathStatementRequestProperty\`
 *
 * @param properties - the TypeScript properties of a \`PathStatementRequestProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInsightsAccessScopePathStatementRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("packetHeaderStatement", CfnNetworkInsightsAccessScopePacketHeaderStatementRequestPropertyValidator)(properties.packetHeaderStatement));
  errors.collect(cdk.propertyValidator("resourceStatement", CfnNetworkInsightsAccessScopeResourceStatementRequestPropertyValidator)(properties.resourceStatement));
  return errors.wrap("supplied properties not correct for \\"PathStatementRequestProperty\\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInsightsAccessScopePathStatementRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInsightsAccessScopePathStatementRequestPropertyValidator(properties).assertSuccess();
  return {
    "PacketHeaderStatement": convertCfnNetworkInsightsAccessScopePacketHeaderStatementRequestPropertyToCloudFormation(properties.packetHeaderStatement),
    "ResourceStatement": convertCfnNetworkInsightsAccessScopeResourceStatementRequestPropertyToCloudFormation(properties.resourceStatement)
  };
}

// @ts-ignore TS6133
function CfnNetworkInsightsAccessScopePathStatementRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnNetworkInsightsAccessScope.PathStatementRequestProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInsightsAccessScope.PathStatementRequestProperty>();
  ret.addPropertyResult("packetHeaderStatement", "PacketHeaderStatement", (properties.PacketHeaderStatement != null ? CfnNetworkInsightsAccessScopePacketHeaderStatementRequestPropertyFromCloudFormation(properties.PacketHeaderStatement) : undefined));
  ret.addPropertyResult("resourceStatement", "ResourceStatement", (properties.ResourceStatement != null ? CfnNetworkInsightsAccessScopeResourceStatementRequestPropertyFromCloudFormation(properties.ResourceStatement) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ThroughResourcesStatementRequestProperty\`
 *
 * @param properties - the TypeScript properties of a \`ThroughResourcesStatementRequestProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInsightsAccessScopeThroughResourcesStatementRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("resourceStatement", CfnNetworkInsightsAccessScopeResourceStatementRequestPropertyValidator)(properties.resourceStatement));
  return errors.wrap("supplied properties not correct for \\"ThroughResourcesStatementRequestProperty\\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInsightsAccessScopeThroughResourcesStatementRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInsightsAccessScopeThroughResourcesStatementRequestPropertyValidator(properties).assertSuccess();
  return {
    "ResourceStatement": convertCfnNetworkInsightsAccessScopeResourceStatementRequestPropertyToCloudFormation(properties.resourceStatement)
  };
}

// @ts-ignore TS6133
function CfnNetworkInsightsAccessScopeThroughResourcesStatementRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnNetworkInsightsAccessScope.ThroughResourcesStatementRequestProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInsightsAccessScope.ThroughResourcesStatementRequestProperty>();
  ret.addPropertyResult("resourceStatement", "ResourceStatement", (properties.ResourceStatement != null ? CfnNetworkInsightsAccessScopeResourceStatementRequestPropertyFromCloudFormation(properties.ResourceStatement) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`AccessScopePathRequestProperty\`
 *
 * @param properties - the TypeScript properties of a \`AccessScopePathRequestProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInsightsAccessScopeAccessScopePathRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("destination", CfnNetworkInsightsAccessScopePathStatementRequestPropertyValidator)(properties.destination));
  errors.collect(cdk.propertyValidator("source", CfnNetworkInsightsAccessScopePathStatementRequestPropertyValidator)(properties.source));
  errors.collect(cdk.propertyValidator("throughResources", cdk.listValidator(CfnNetworkInsightsAccessScopeThroughResourcesStatementRequestPropertyValidator))(properties.throughResources));
  return errors.wrap("supplied properties not correct for \\"AccessScopePathRequestProperty\\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInsightsAccessScopeAccessScopePathRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInsightsAccessScopeAccessScopePathRequestPropertyValidator(properties).assertSuccess();
  return {
    "Destination": convertCfnNetworkInsightsAccessScopePathStatementRequestPropertyToCloudFormation(properties.destination),
    "Source": convertCfnNetworkInsightsAccessScopePathStatementRequestPropertyToCloudFormation(properties.source),
    "ThroughResources": cdk.listMapper(convertCfnNetworkInsightsAccessScopeThroughResourcesStatementRequestPropertyToCloudFormation)(properties.throughResources)
  };
}

// @ts-ignore TS6133
function CfnNetworkInsightsAccessScopeAccessScopePathRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNetworkInsightsAccessScope.AccessScopePathRequestProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInsightsAccessScope.AccessScopePathRequestProperty>();
  ret.addPropertyResult("destination", "Destination", (properties.Destination != null ? CfnNetworkInsightsAccessScopePathStatementRequestPropertyFromCloudFormation(properties.Destination) : undefined));
  ret.addPropertyResult("source", "Source", (properties.Source != null ? CfnNetworkInsightsAccessScopePathStatementRequestPropertyFromCloudFormation(properties.Source) : undefined));
  ret.addPropertyResult("throughResources", "ThroughResources", (properties.ThroughResources != null ? cfn_parse.FromCloudFormation.getArray(CfnNetworkInsightsAccessScopeThroughResourcesStatementRequestPropertyFromCloudFormation)(properties.ThroughResources) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnNetworkInsightsAccessScopeProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnNetworkInsightsAccessScopeProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInsightsAccessScopePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("excludePaths", cdk.listValidator(CfnNetworkInsightsAccessScopeAccessScopePathRequestPropertyValidator))(properties.excludePaths));
  errors.collect(cdk.propertyValidator("matchPaths", cdk.listValidator(CfnNetworkInsightsAccessScopeAccessScopePathRequestPropertyValidator))(properties.matchPaths));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnNetworkInsightsAccessScopeProps\\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInsightsAccessScopePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInsightsAccessScopePropsValidator(properties).assertSuccess();
  return {
    "ExcludePaths": cdk.listMapper(convertCfnNetworkInsightsAccessScopeAccessScopePathRequestPropertyToCloudFormation)(properties.excludePaths),
    "MatchPaths": cdk.listMapper(convertCfnNetworkInsightsAccessScopeAccessScopePathRequestPropertyToCloudFormation)(properties.matchPaths),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnNetworkInsightsAccessScopePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNetworkInsightsAccessScopeProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInsightsAccessScopeProps>();
  ret.addPropertyResult("excludePaths", "ExcludePaths", (properties.ExcludePaths != null ? cfn_parse.FromCloudFormation.getArray(CfnNetworkInsightsAccessScopeAccessScopePathRequestPropertyFromCloudFormation)(properties.ExcludePaths) : undefined));
  ret.addPropertyResult("matchPaths", "MatchPaths", (properties.MatchPaths != null ? cfn_parse.FromCloudFormation.getArray(CfnNetworkInsightsAccessScopeAccessScopePathRequestPropertyFromCloudFormation)(properties.MatchPaths) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Describes a Network Access Scope analysis.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsaccessscopeanalysis.html
 */
export class CfnNetworkInsightsAccessScopeAnalysis extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::NetworkInsightsAccessScopeAnalysis";

  /**
   * Build a CfnNetworkInsightsAccessScopeAnalysis from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnNetworkInsightsAccessScopeAnalysis {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnNetworkInsightsAccessScopeAnalysisPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnNetworkInsightsAccessScopeAnalysis(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The number of network interfaces analyzed.
   *
   * @cloudformationAttribute AnalyzedEniCount
   */
  public readonly attrAnalyzedEniCount: number;

  /**
   * The end date of the analysis.
   *
   * @cloudformationAttribute EndDate
   */
  public readonly attrEndDate: string;

  /**
   * Indicates whether there are findings (true | false | unknown).
   *
   * @cloudformationAttribute FindingsFound
   */
  public readonly attrFindingsFound: string;

  /**
   * The ARN of the Network Access Scope analysis.
   *
   * @cloudformationAttribute NetworkInsightsAccessScopeAnalysisArn
   */
  public readonly attrNetworkInsightsAccessScopeAnalysisArn: string;

  /**
   * The ID of the Network Access Scope analysis.
   *
   * @cloudformationAttribute NetworkInsightsAccessScopeAnalysisId
   */
  public readonly attrNetworkInsightsAccessScopeAnalysisId: string;

  /**
   * The start date of the analysis.
   *
   * @cloudformationAttribute StartDate
   */
  public readonly attrStartDate: string;

  /**
   * The status of the analysis (running | succeeded | failed).
   *
   * @cloudformationAttribute Status
   */
  public readonly attrStatus: string;

  /**
   * The status message.
   *
   * @cloudformationAttribute StatusMessage
   */
  public readonly attrStatusMessage: string;

  /**
   * The ID of the Network Access Scope.
   */
  public networkInsightsAccessScopeId: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnNetworkInsightsAccessScopeAnalysisProps) {
    super(scope, id, {
      "type": CfnNetworkInsightsAccessScopeAnalysis.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "networkInsightsAccessScopeId", this);

    this.attrAnalyzedEniCount = cdk.Token.asNumber(this.getAtt("AnalyzedEniCount", cdk.ResolutionTypeHint.NUMBER));
    this.attrEndDate = cdk.Token.asString(this.getAtt("EndDate", cdk.ResolutionTypeHint.STRING));
    this.attrFindingsFound = cdk.Token.asString(this.getAtt("FindingsFound", cdk.ResolutionTypeHint.STRING));
    this.attrNetworkInsightsAccessScopeAnalysisArn = cdk.Token.asString(this.getAtt("NetworkInsightsAccessScopeAnalysisArn", cdk.ResolutionTypeHint.STRING));
    this.attrNetworkInsightsAccessScopeAnalysisId = cdk.Token.asString(this.getAtt("NetworkInsightsAccessScopeAnalysisId", cdk.ResolutionTypeHint.STRING));
    this.attrStartDate = cdk.Token.asString(this.getAtt("StartDate", cdk.ResolutionTypeHint.STRING));
    this.attrStatus = cdk.Token.asString(this.getAtt("Status", cdk.ResolutionTypeHint.STRING));
    this.attrStatusMessage = cdk.Token.asString(this.getAtt("StatusMessage", cdk.ResolutionTypeHint.STRING));
    this.networkInsightsAccessScopeId = props.networkInsightsAccessScopeId;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::NetworkInsightsAccessScopeAnalysis", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "networkInsightsAccessScopeId": this.networkInsightsAccessScopeId,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnNetworkInsightsAccessScopeAnalysis.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnNetworkInsightsAccessScopeAnalysisPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnNetworkInsightsAccessScopeAnalysis\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsaccessscopeanalysis.html
 */
export interface CfnNetworkInsightsAccessScopeAnalysisProps {
  /**
   * The ID of the Network Access Scope.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsaccessscopeanalysis.html#cfn-ec2-networkinsightsaccessscopeanalysis-networkinsightsaccessscopeid
   */
  readonly networkInsightsAccessScopeId: string;

  /**
   * The tags.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsaccessscopeanalysis.html#cfn-ec2-networkinsightsaccessscopeanalysis-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a \`CfnNetworkInsightsAccessScopeAnalysisProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnNetworkInsightsAccessScopeAnalysisProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInsightsAccessScopeAnalysisPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("networkInsightsAccessScopeId", cdk.requiredValidator)(properties.networkInsightsAccessScopeId));
  errors.collect(cdk.propertyValidator("networkInsightsAccessScopeId", cdk.validateString)(properties.networkInsightsAccessScopeId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnNetworkInsightsAccessScopeAnalysisProps\\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInsightsAccessScopeAnalysisPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInsightsAccessScopeAnalysisPropsValidator(properties).assertSuccess();
  return {
    "NetworkInsightsAccessScopeId": cdk.stringToCloudFormation(properties.networkInsightsAccessScopeId),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnNetworkInsightsAccessScopeAnalysisPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNetworkInsightsAccessScopeAnalysisProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInsightsAccessScopeAnalysisProps>();
  ret.addPropertyResult("networkInsightsAccessScopeId", "NetworkInsightsAccessScopeId", (properties.NetworkInsightsAccessScopeId != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkInsightsAccessScopeId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a network insights analysis.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsanalysis.html
 */
export class CfnNetworkInsightsAnalysis extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::NetworkInsightsAnalysis";

  /**
   * Build a CfnNetworkInsightsAnalysis from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnNetworkInsightsAnalysis {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnNetworkInsightsAnalysisPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnNetworkInsightsAnalysis(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * Potential intermediate components.
   *
   * @cloudformationAttribute AlternatePathHints
   */
  public readonly attrAlternatePathHints: cdk.IResolvable;

  /**
   * The explanations. For more information, see [Reachability Analyzer explanation codes](https://docs.aws.amazon.com/vpc/latest/reachability/explanation-codes.html) .
   *
   * @cloudformationAttribute Explanations
   */
  public readonly attrExplanations: cdk.IResolvable;

  /**
   * The components in the path from source to destination.
   *
   * @cloudformationAttribute ForwardPathComponents
   */
  public readonly attrForwardPathComponents: cdk.IResolvable;

  /**
   * The Amazon Resource Name (ARN) of the network insights analysis.
   *
   * @cloudformationAttribute NetworkInsightsAnalysisArn
   */
  public readonly attrNetworkInsightsAnalysisArn: string;

  /**
   * The ID of the network insights analysis.
   *
   * @cloudformationAttribute NetworkInsightsAnalysisId
   */
  public readonly attrNetworkInsightsAnalysisId: string;

  /**
   * Indicates whether the destination is reachable from the source.
   *
   * @cloudformationAttribute NetworkPathFound
   */
  public readonly attrNetworkPathFound: cdk.IResolvable;

  /**
   * The components in the path from destination to source.
   *
   * @cloudformationAttribute ReturnPathComponents
   */
  public readonly attrReturnPathComponents: cdk.IResolvable;

  /**
   * The time the analysis started.
   *
   * @cloudformationAttribute StartDate
   */
  public readonly attrStartDate: string;

  /**
   * The status of the network insights analysis.
   *
   * @cloudformationAttribute Status
   */
  public readonly attrStatus: string;

  /**
   * The status message, if the status is \`failed\` .
   *
   * @cloudformationAttribute StatusMessage
   */
  public readonly attrStatusMessage: string;

  /**
   * The IDs of potential intermediate accounts.
   *
   * @cloudformationAttribute SuggestedAccounts
   */
  public readonly attrSuggestedAccounts: Array<string>;

  /**
   * The member accounts that contain resources that the path can traverse.
   */
  public additionalAccounts?: Array<string>;

  /**
   * The Amazon Resource Names (ARN) of the resources that the path must traverse.
   */
  public filterInArns?: Array<string>;

  /**
   * The ID of the path.
   */
  public networkInsightsPathId: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags to apply.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnNetworkInsightsAnalysisProps) {
    super(scope, id, {
      "type": CfnNetworkInsightsAnalysis.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "networkInsightsPathId", this);

    this.attrAlternatePathHints = this.getAtt("AlternatePathHints");
    this.attrExplanations = this.getAtt("Explanations");
    this.attrForwardPathComponents = this.getAtt("ForwardPathComponents");
    this.attrNetworkInsightsAnalysisArn = cdk.Token.asString(this.getAtt("NetworkInsightsAnalysisArn", cdk.ResolutionTypeHint.STRING));
    this.attrNetworkInsightsAnalysisId = cdk.Token.asString(this.getAtt("NetworkInsightsAnalysisId", cdk.ResolutionTypeHint.STRING));
    this.attrNetworkPathFound = this.getAtt("NetworkPathFound");
    this.attrReturnPathComponents = this.getAtt("ReturnPathComponents");
    this.attrStartDate = cdk.Token.asString(this.getAtt("StartDate", cdk.ResolutionTypeHint.STRING));
    this.attrStatus = cdk.Token.asString(this.getAtt("Status", cdk.ResolutionTypeHint.STRING));
    this.attrStatusMessage = cdk.Token.asString(this.getAtt("StatusMessage", cdk.ResolutionTypeHint.STRING));
    this.attrSuggestedAccounts = cdk.Token.asList(this.getAtt("SuggestedAccounts", cdk.ResolutionTypeHint.STRING_LIST));
    this.additionalAccounts = props.additionalAccounts;
    this.filterInArns = props.filterInArns;
    this.networkInsightsPathId = props.networkInsightsPathId;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::NetworkInsightsAnalysis", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "additionalAccounts": this.additionalAccounts,
      "filterInArns": this.filterInArns,
      "networkInsightsPathId": this.networkInsightsPathId,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnNetworkInsightsAnalysis.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnNetworkInsightsAnalysisPropsToCloudFormation(props);
  }
}

export namespace CfnNetworkInsightsAnalysis {
  /**
   * Describes a path component.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html
   */
  export interface PathComponentProperty {
    /**
     * The network ACL rule.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-aclrule
     */
    readonly aclRule?: CfnNetworkInsightsAnalysis.AnalysisAclRuleProperty | cdk.IResolvable;

    /**
     * The additional details.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-additionaldetails
     */
    readonly additionalDetails?: Array<CfnNetworkInsightsAnalysis.AdditionalDetailProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The component.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-component
     */
    readonly component?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;

    /**
     * The destination VPC.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-destinationvpc
     */
    readonly destinationVpc?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;

    /**
     * The load balancer listener.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-elasticloadbalancerlistener
     */
    readonly elasticLoadBalancerListener?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;

    /**
     * The explanation codes.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-explanations
     */
    readonly explanations?: Array<CfnNetworkInsightsAnalysis.ExplanationProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The inbound header.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-inboundheader
     */
    readonly inboundHeader?: CfnNetworkInsightsAnalysis.AnalysisPacketHeaderProperty | cdk.IResolvable;

    /**
     * The outbound header.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-outboundheader
     */
    readonly outboundHeader?: CfnNetworkInsightsAnalysis.AnalysisPacketHeaderProperty | cdk.IResolvable;

    /**
     * The route table route.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-routetableroute
     */
    readonly routeTableRoute?: CfnNetworkInsightsAnalysis.AnalysisRouteTableRouteProperty | cdk.IResolvable;

    /**
     * The security group rule.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-securitygrouprule
     */
    readonly securityGroupRule?: CfnNetworkInsightsAnalysis.AnalysisSecurityGroupRuleProperty | cdk.IResolvable;

    /**
     * The sequence number.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-sequencenumber
     */
    readonly sequenceNumber?: number;

    /**
     * The name of the VPC endpoint service.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-servicename
     */
    readonly serviceName?: string;

    /**
     * The source VPC.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-sourcevpc
     */
    readonly sourceVpc?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;

    /**
     * The subnet.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-subnet
     */
    readonly subnet?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;

    /**
     * The transit gateway.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-transitgateway
     */
    readonly transitGateway?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;

    /**
     * The route in a transit gateway route table.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-transitgatewayroutetableroute
     */
    readonly transitGatewayRouteTableRoute?: cdk.IResolvable | CfnNetworkInsightsAnalysis.TransitGatewayRouteTableRouteProperty;

    /**
     * The component VPC.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-vpc
     */
    readonly vpc?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;
  }

  /**
   * Describes an additional detail for a path analysis.
   *
   * For more information, see [Reachability Analyzer additional detail codes](https://docs.aws.amazon.com/vpc/latest/reachability/additional-detail-codes.html) .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-additionaldetail.html
   */
  export interface AdditionalDetailProperty {
    /**
     * The additional detail code.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-additionaldetail.html#cfn-ec2-networkinsightsanalysis-additionaldetail-additionaldetailtype
     */
    readonly additionalDetailType?: string;

    /**
     * The path component.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-additionaldetail.html#cfn-ec2-networkinsightsanalysis-additionaldetail-component
     */
    readonly component?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;

    /**
     * The load balancers.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-additionaldetail.html#cfn-ec2-networkinsightsanalysis-additionaldetail-loadbalancers
     */
    readonly loadBalancers?: Array<CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The name of the VPC endpoint service.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-additionaldetail.html#cfn-ec2-networkinsightsanalysis-additionaldetail-servicename
     */
    readonly serviceName?: string;
  }

  /**
   * Describes a path component.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysiscomponent.html
   */
  export interface AnalysisComponentProperty {
    /**
     * The Amazon Resource Name (ARN) of the component.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysiscomponent.html#cfn-ec2-networkinsightsanalysis-analysiscomponent-arn
     */
    readonly arn?: string;

    /**
     * The ID of the component.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysiscomponent.html#cfn-ec2-networkinsightsanalysis-analysiscomponent-id
     */
    readonly id?: string;
  }

  /**
   * Describes a header.
   *
   * Reflects any changes made by a component as traffic passes through. The fields of an inbound header are null except for the first component of a path.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysispacketheader.html
   */
  export interface AnalysisPacketHeaderProperty {
    /**
     * The destination addresses.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysispacketheader.html#cfn-ec2-networkinsightsanalysis-analysispacketheader-destinationaddresses
     */
    readonly destinationAddresses?: Array<string>;

    /**
     * The destination port ranges.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysispacketheader.html#cfn-ec2-networkinsightsanalysis-analysispacketheader-destinationportranges
     */
    readonly destinationPortRanges?: Array<cdk.IResolvable | CfnNetworkInsightsAnalysis.PortRangeProperty> | cdk.IResolvable;

    /**
     * The protocol.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysispacketheader.html#cfn-ec2-networkinsightsanalysis-analysispacketheader-protocol
     */
    readonly protocol?: string;

    /**
     * The source addresses.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysispacketheader.html#cfn-ec2-networkinsightsanalysis-analysispacketheader-sourceaddresses
     */
    readonly sourceAddresses?: Array<string>;

    /**
     * The source port ranges.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysispacketheader.html#cfn-ec2-networkinsightsanalysis-analysispacketheader-sourceportranges
     */
    readonly sourcePortRanges?: Array<cdk.IResolvable | CfnNetworkInsightsAnalysis.PortRangeProperty> | cdk.IResolvable;
  }

  /**
   * Describes a range of ports.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-portrange.html
   */
  export interface PortRangeProperty {
    /**
     * The first port in the range.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-portrange.html#cfn-ec2-networkinsightsanalysis-portrange-from
     */
    readonly from?: number;

    /**
     * The last port in the range.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-portrange.html#cfn-ec2-networkinsightsanalysis-portrange-to
     */
    readonly to?: number;
  }

  /**
   * Describes a security group rule.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysissecuritygrouprule.html
   */
  export interface AnalysisSecurityGroupRuleProperty {
    /**
     * The IPv4 address range, in CIDR notation.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysissecuritygrouprule.html#cfn-ec2-networkinsightsanalysis-analysissecuritygrouprule-cidr
     */
    readonly cidr?: string;

    /**
     * The direction. The following are the possible values:.
     *
     * - egress
     * - ingress
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysissecuritygrouprule.html#cfn-ec2-networkinsightsanalysis-analysissecuritygrouprule-direction
     */
    readonly direction?: string;

    /**
     * The port range.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysissecuritygrouprule.html#cfn-ec2-networkinsightsanalysis-analysissecuritygrouprule-portrange
     */
    readonly portRange?: cdk.IResolvable | CfnNetworkInsightsAnalysis.PortRangeProperty;

    /**
     * The prefix list ID.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysissecuritygrouprule.html#cfn-ec2-networkinsightsanalysis-analysissecuritygrouprule-prefixlistid
     */
    readonly prefixListId?: string;

    /**
     * The protocol name.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysissecuritygrouprule.html#cfn-ec2-networkinsightsanalysis-analysissecuritygrouprule-protocol
     */
    readonly protocol?: string;

    /**
     * The security group ID.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysissecuritygrouprule.html#cfn-ec2-networkinsightsanalysis-analysissecuritygrouprule-securitygroupid
     */
    readonly securityGroupId?: string;
  }

  /**
   * Describes an explanation code for an unreachable path.
   *
   * For more information, see [Reachability Analyzer explanation codes](https://docs.aws.amazon.com/vpc/latest/reachability/explanation-codes.html) .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html
   */
  export interface ExplanationProperty {
    /**
     * The network ACL.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-acl
     */
    readonly acl?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;

    /**
     * The network ACL rule.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-aclrule
     */
    readonly aclRule?: CfnNetworkInsightsAnalysis.AnalysisAclRuleProperty | cdk.IResolvable;

    /**
     * The IPv4 address, in CIDR notation.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-address
     */
    readonly address?: string;

    /**
     * The IPv4 addresses, in CIDR notation.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-addresses
     */
    readonly addresses?: Array<string>;

    /**
     * The resource to which the component is attached.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-attachedto
     */
    readonly attachedTo?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;

    /**
     * The Availability Zones.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-availabilityzones
     */
    readonly availabilityZones?: Array<string>;

    /**
     * The CIDR ranges.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-cidrs
     */
    readonly cidrs?: Array<string>;

    /**
     * The listener for a Classic Load Balancer.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-classicloadbalancerlistener
     */
    readonly classicLoadBalancerListener?: CfnNetworkInsightsAnalysis.AnalysisLoadBalancerListenerProperty | cdk.IResolvable;

    /**
     * The component.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-component
     */
    readonly component?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;

    /**
     * The AWS account for the component.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-componentaccount
     */
    readonly componentAccount?: string;

    /**
     * The Region for the component.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-componentregion
     */
    readonly componentRegion?: string;

    /**
     * The customer gateway.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-customergateway
     */
    readonly customerGateway?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;

    /**
     * The destination.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-destination
     */
    readonly destination?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;

    /**
     * The destination VPC.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-destinationvpc
     */
    readonly destinationVpc?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;

    /**
     * The direction. The following are the possible values:.
     *
     * - egress
     * - ingress
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-direction
     */
    readonly direction?: string;

    /**
     * The load balancer listener.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-elasticloadbalancerlistener
     */
    readonly elasticLoadBalancerListener?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;

    /**
     * The explanation code.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-explanationcode
     */
    readonly explanationCode?: string;

    /**
     * The route table.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-ingressroutetable
     */
    readonly ingressRouteTable?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;

    /**
     * The internet gateway.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-internetgateway
     */
    readonly internetGateway?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;

    /**
     * The Amazon Resource Name (ARN) of the load balancer.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-loadbalancerarn
     */
    readonly loadBalancerArn?: string;

    /**
     * The listener port of the load balancer.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-loadbalancerlistenerport
     */
    readonly loadBalancerListenerPort?: number;

    /**
     * The target.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-loadbalancertarget
     */
    readonly loadBalancerTarget?: CfnNetworkInsightsAnalysis.AnalysisLoadBalancerTargetProperty | cdk.IResolvable;

    /**
     * The target group.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-loadbalancertargetgroup
     */
    readonly loadBalancerTargetGroup?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;

    /**
     * The target groups.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-loadbalancertargetgroups
     */
    readonly loadBalancerTargetGroups?: Array<CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The target port.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-loadbalancertargetport
     */
    readonly loadBalancerTargetPort?: number;

    /**
     * The missing component.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-missingcomponent
     */
    readonly missingComponent?: string;

    /**
     * The NAT gateway.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-natgateway
     */
    readonly natGateway?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;

    /**
     * The network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-networkinterface
     */
    readonly networkInterface?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;

    /**
     * The packet field.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-packetfield
     */
    readonly packetField?: string;

    /**
     * The port.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-port
     */
    readonly port?: number;

    /**
     * The port ranges.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-portranges
     */
    readonly portRanges?: Array<cdk.IResolvable | CfnNetworkInsightsAnalysis.PortRangeProperty> | cdk.IResolvable;

    /**
     * The prefix list.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-prefixlist
     */
    readonly prefixList?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;

    /**
     * The protocols.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-protocols
     */
    readonly protocols?: Array<string>;

    /**
     * The route table.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-routetable
     */
    readonly routeTable?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;

    /**
     * The route table route.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-routetableroute
     */
    readonly routeTableRoute?: CfnNetworkInsightsAnalysis.AnalysisRouteTableRouteProperty | cdk.IResolvable;

    /**
     * The security group.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-securitygroup
     */
    readonly securityGroup?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;

    /**
     * The security group rule.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-securitygrouprule
     */
    readonly securityGroupRule?: CfnNetworkInsightsAnalysis.AnalysisSecurityGroupRuleProperty | cdk.IResolvable;

    /**
     * The security groups.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-securitygroups
     */
    readonly securityGroups?: Array<CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The source VPC.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-sourcevpc
     */
    readonly sourceVpc?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;

    /**
     * The state.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-state
     */
    readonly state?: string;

    /**
     * The subnet.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-subnet
     */
    readonly subnet?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;

    /**
     * The route table for the subnet.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-subnetroutetable
     */
    readonly subnetRouteTable?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;

    /**
     * The transit gateway.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-transitgateway
     */
    readonly transitGateway?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;

    /**
     * The transit gateway attachment.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-transitgatewayattachment
     */
    readonly transitGatewayAttachment?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;

    /**
     * The transit gateway route table.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-transitgatewayroutetable
     */
    readonly transitGatewayRouteTable?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;

    /**
     * The transit gateway route table route.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-transitgatewayroutetableroute
     */
    readonly transitGatewayRouteTableRoute?: cdk.IResolvable | CfnNetworkInsightsAnalysis.TransitGatewayRouteTableRouteProperty;

    /**
     * The component VPC.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-vpc
     */
    readonly vpc?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;

    /**
     * The VPC endpoint.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-vpcendpoint
     */
    readonly vpcEndpoint?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;

    /**
     * The VPC peering connection.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-vpcpeeringconnection
     */
    readonly vpcPeeringConnection?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;

    /**
     * The VPN connection.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-vpnconnection
     */
    readonly vpnConnection?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;

    /**
     * The VPN gateway.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-vpngateway
     */
    readonly vpnGateway?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;
  }

  /**
   * Describes a load balancer listener.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisloadbalancerlistener.html
   */
  export interface AnalysisLoadBalancerListenerProperty {
    /**
     * [Classic Load Balancers] The back-end port for the listener.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisloadbalancerlistener.html#cfn-ec2-networkinsightsanalysis-analysisloadbalancerlistener-instanceport
     */
    readonly instancePort?: number;

    /**
     * The port on which the load balancer is listening.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisloadbalancerlistener.html#cfn-ec2-networkinsightsanalysis-analysisloadbalancerlistener-loadbalancerport
     */
    readonly loadBalancerPort?: number;
  }

  /**
   * Describes a route in a transit gateway route table.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-transitgatewayroutetableroute.html
   */
  export interface TransitGatewayRouteTableRouteProperty {
    /**
     * The ID of the route attachment.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-transitgatewayroutetableroute.html#cfn-ec2-networkinsightsanalysis-transitgatewayroutetableroute-attachmentid
     */
    readonly attachmentId?: string;

    /**
     * The CIDR block used for destination matches.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-transitgatewayroutetableroute.html#cfn-ec2-networkinsightsanalysis-transitgatewayroutetableroute-destinationcidr
     */
    readonly destinationCidr?: string;

    /**
     * The ID of the prefix list.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-transitgatewayroutetableroute.html#cfn-ec2-networkinsightsanalysis-transitgatewayroutetableroute-prefixlistid
     */
    readonly prefixListId?: string;

    /**
     * The ID of the resource for the route attachment.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-transitgatewayroutetableroute.html#cfn-ec2-networkinsightsanalysis-transitgatewayroutetableroute-resourceid
     */
    readonly resourceId?: string;

    /**
     * The resource type for the route attachment.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-transitgatewayroutetableroute.html#cfn-ec2-networkinsightsanalysis-transitgatewayroutetableroute-resourcetype
     */
    readonly resourceType?: string;

    /**
     * The route origin. The following are the possible values:.
     *
     * - static
     * - propagated
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-transitgatewayroutetableroute.html#cfn-ec2-networkinsightsanalysis-transitgatewayroutetableroute-routeorigin
     */
    readonly routeOrigin?: string;

    /**
     * The state of the route.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-transitgatewayroutetableroute.html#cfn-ec2-networkinsightsanalysis-transitgatewayroutetableroute-state
     */
    readonly state?: string;
  }

  /**
   * Describes a load balancer target.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisloadbalancertarget.html
   */
  export interface AnalysisLoadBalancerTargetProperty {
    /**
     * The IP address.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisloadbalancertarget.html#cfn-ec2-networkinsightsanalysis-analysisloadbalancertarget-address
     */
    readonly address?: string;

    /**
     * The Availability Zone.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisloadbalancertarget.html#cfn-ec2-networkinsightsanalysis-analysisloadbalancertarget-availabilityzone
     */
    readonly availabilityZone?: string;

    /**
     * Information about the instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisloadbalancertarget.html#cfn-ec2-networkinsightsanalysis-analysisloadbalancertarget-instance
     */
    readonly instance?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;

    /**
     * The port on which the target is listening.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisloadbalancertarget.html#cfn-ec2-networkinsightsanalysis-analysisloadbalancertarget-port
     */
    readonly port?: number;
  }

  /**
   * Describes a route table route.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisroutetableroute.html
   */
  export interface AnalysisRouteTableRouteProperty {
    /**
     * The destination IPv4 address, in CIDR notation.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisroutetableroute.html#cfn-ec2-networkinsightsanalysis-analysisroutetableroute-destinationcidr
     */
    readonly destinationCidr?: string;

    /**
     * The prefix of the AWS service .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisroutetableroute.html#cfn-ec2-networkinsightsanalysis-analysisroutetableroute-destinationprefixlistid
     */
    readonly destinationPrefixListId?: string;

    /**
     * The ID of an egress-only internet gateway.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisroutetableroute.html#cfn-ec2-networkinsightsanalysis-analysisroutetableroute-egressonlyinternetgatewayid
     */
    readonly egressOnlyInternetGatewayId?: string;

    /**
     * The ID of the gateway, such as an internet gateway or virtual private gateway.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisroutetableroute.html#cfn-ec2-networkinsightsanalysis-analysisroutetableroute-gatewayid
     */
    readonly gatewayId?: string;

    /**
     * The ID of the instance, such as a NAT instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisroutetableroute.html#cfn-ec2-networkinsightsanalysis-analysisroutetableroute-instanceid
     */
    readonly instanceId?: string;

    /**
     * The ID of a NAT gateway.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisroutetableroute.html#cfn-ec2-networkinsightsanalysis-analysisroutetableroute-natgatewayid
     */
    readonly natGatewayId?: string;

    /**
     * The ID of a network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisroutetableroute.html#cfn-ec2-networkinsightsanalysis-analysisroutetableroute-networkinterfaceid
     */
    readonly networkInterfaceId?: string;

    /**
     * Describes how the route was created. The following are the possible values:.
     *
     * - CreateRouteTable - The route was automatically created when the route table was created.
     * - CreateRoute - The route was manually added to the route table.
     * - EnableVgwRoutePropagation - The route was propagated by route propagation.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisroutetableroute.html#cfn-ec2-networkinsightsanalysis-analysisroutetableroute-origin
     */
    readonly origin?: string;

    /**
     * The state. The following are the possible values:.
     *
     * - active
     * - blackhole
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisroutetableroute.html#cfn-ec2-networkinsightsanalysis-analysisroutetableroute-state
     */
    readonly state?: string;

    /**
     * The ID of a transit gateway.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisroutetableroute.html#cfn-ec2-networkinsightsanalysis-analysisroutetableroute-transitgatewayid
     */
    readonly transitGatewayId?: string;

    /**
     * The ID of a VPC peering connection.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisroutetableroute.html#cfn-ec2-networkinsightsanalysis-analysisroutetableroute-vpcpeeringconnectionid
     */
    readonly vpcPeeringConnectionId?: string;
  }

  /**
   * Describes a network access control (ACL) rule.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisaclrule.html
   */
  export interface AnalysisAclRuleProperty {
    /**
     * The IPv4 address range, in CIDR notation.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisaclrule.html#cfn-ec2-networkinsightsanalysis-analysisaclrule-cidr
     */
    readonly cidr?: string;

    /**
     * Indicates whether the rule is an outbound rule.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisaclrule.html#cfn-ec2-networkinsightsanalysis-analysisaclrule-egress
     */
    readonly egress?: boolean | cdk.IResolvable;

    /**
     * The range of ports.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisaclrule.html#cfn-ec2-networkinsightsanalysis-analysisaclrule-portrange
     */
    readonly portRange?: cdk.IResolvable | CfnNetworkInsightsAnalysis.PortRangeProperty;

    /**
     * The protocol.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisaclrule.html#cfn-ec2-networkinsightsanalysis-analysisaclrule-protocol
     */
    readonly protocol?: string;

    /**
     * Indicates whether to allow or deny traffic that matches the rule.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisaclrule.html#cfn-ec2-networkinsightsanalysis-analysisaclrule-ruleaction
     */
    readonly ruleAction?: string;

    /**
     * The rule number.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisaclrule.html#cfn-ec2-networkinsightsanalysis-analysisaclrule-rulenumber
     */
    readonly ruleNumber?: number;
  }

  /**
   * Describes an potential intermediate component of a feasible path.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-alternatepathhint.html
   */
  export interface AlternatePathHintProperty {
    /**
     * The Amazon Resource Name (ARN) of the component.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-alternatepathhint.html#cfn-ec2-networkinsightsanalysis-alternatepathhint-componentarn
     */
    readonly componentArn?: string;

    /**
     * The ID of the component.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-alternatepathhint.html#cfn-ec2-networkinsightsanalysis-alternatepathhint-componentid
     */
    readonly componentId?: string;
  }
}

/**
 * Properties for defining a \`CfnNetworkInsightsAnalysis\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsanalysis.html
 */
export interface CfnNetworkInsightsAnalysisProps {
  /**
   * The member accounts that contain resources that the path can traverse.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsanalysis.html#cfn-ec2-networkinsightsanalysis-additionalaccounts
   */
  readonly additionalAccounts?: Array<string>;

  /**
   * The Amazon Resource Names (ARN) of the resources that the path must traverse.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsanalysis.html#cfn-ec2-networkinsightsanalysis-filterinarns
   */
  readonly filterInArns?: Array<string>;

  /**
   * The ID of the path.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsanalysis.html#cfn-ec2-networkinsightsanalysis-networkinsightspathid
   */
  readonly networkInsightsPathId: string;

  /**
   * The tags to apply.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsanalysis.html#cfn-ec2-networkinsightsanalysis-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a \`AnalysisComponentProperty\`
 *
 * @param properties - the TypeScript properties of a \`AnalysisComponentProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("arn", cdk.validateString)(properties.arn));
  errors.collect(cdk.propertyValidator("id", cdk.validateString)(properties.id));
  return errors.wrap("supplied properties not correct for \\"AnalysisComponentProperty\\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator(properties).assertSuccess();
  return {
    "Arn": cdk.stringToCloudFormation(properties.arn),
    "Id": cdk.stringToCloudFormation(properties.id)
  };
}

// @ts-ignore TS6133
function CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInsightsAnalysis.AnalysisComponentProperty>();
  ret.addPropertyResult("arn", "Arn", (properties.Arn != null ? cfn_parse.FromCloudFormation.getString(properties.Arn) : undefined));
  ret.addPropertyResult("id", "Id", (properties.Id != null ? cfn_parse.FromCloudFormation.getString(properties.Id) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`AdditionalDetailProperty\`
 *
 * @param properties - the TypeScript properties of a \`AdditionalDetailProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInsightsAnalysisAdditionalDetailPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("additionalDetailType", cdk.validateString)(properties.additionalDetailType));
  errors.collect(cdk.propertyValidator("component", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.component));
  errors.collect(cdk.propertyValidator("loadBalancers", cdk.listValidator(CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator))(properties.loadBalancers));
  errors.collect(cdk.propertyValidator("serviceName", cdk.validateString)(properties.serviceName));
  return errors.wrap("supplied properties not correct for \\"AdditionalDetailProperty\\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInsightsAnalysisAdditionalDetailPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInsightsAnalysisAdditionalDetailPropertyValidator(properties).assertSuccess();
  return {
    "AdditionalDetailType": cdk.stringToCloudFormation(properties.additionalDetailType),
    "Component": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.component),
    "LoadBalancers": cdk.listMapper(convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation)(properties.loadBalancers),
    "ServiceName": cdk.stringToCloudFormation(properties.serviceName)
  };
}

// @ts-ignore TS6133
function CfnNetworkInsightsAnalysisAdditionalDetailPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNetworkInsightsAnalysis.AdditionalDetailProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInsightsAnalysis.AdditionalDetailProperty>();
  ret.addPropertyResult("additionalDetailType", "AdditionalDetailType", (properties.AdditionalDetailType != null ? cfn_parse.FromCloudFormation.getString(properties.AdditionalDetailType) : undefined));
  ret.addPropertyResult("component", "Component", (properties.Component != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.Component) : undefined));
  ret.addPropertyResult("loadBalancers", "LoadBalancers", (properties.LoadBalancers != null ? cfn_parse.FromCloudFormation.getArray(CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation)(properties.LoadBalancers) : undefined));
  ret.addPropertyResult("serviceName", "ServiceName", (properties.ServiceName != null ? cfn_parse.FromCloudFormation.getString(properties.ServiceName) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`PortRangeProperty\`
 *
 * @param properties - the TypeScript properties of a \`PortRangeProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInsightsAnalysisPortRangePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("from", cdk.validateNumber)(properties.from));
  errors.collect(cdk.propertyValidator("to", cdk.validateNumber)(properties.to));
  return errors.wrap("supplied properties not correct for \\"PortRangeProperty\\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInsightsAnalysisPortRangePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInsightsAnalysisPortRangePropertyValidator(properties).assertSuccess();
  return {
    "From": cdk.numberToCloudFormation(properties.from),
    "To": cdk.numberToCloudFormation(properties.to)
  };
}

// @ts-ignore TS6133
function CfnNetworkInsightsAnalysisPortRangePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnNetworkInsightsAnalysis.PortRangeProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInsightsAnalysis.PortRangeProperty>();
  ret.addPropertyResult("from", "From", (properties.From != null ? cfn_parse.FromCloudFormation.getNumber(properties.From) : undefined));
  ret.addPropertyResult("to", "To", (properties.To != null ? cfn_parse.FromCloudFormation.getNumber(properties.To) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`AnalysisPacketHeaderProperty\`
 *
 * @param properties - the TypeScript properties of a \`AnalysisPacketHeaderProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInsightsAnalysisAnalysisPacketHeaderPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("destinationAddresses", cdk.listValidator(cdk.validateString))(properties.destinationAddresses));
  errors.collect(cdk.propertyValidator("destinationPortRanges", cdk.listValidator(CfnNetworkInsightsAnalysisPortRangePropertyValidator))(properties.destinationPortRanges));
  errors.collect(cdk.propertyValidator("protocol", cdk.validateString)(properties.protocol));
  errors.collect(cdk.propertyValidator("sourceAddresses", cdk.listValidator(cdk.validateString))(properties.sourceAddresses));
  errors.collect(cdk.propertyValidator("sourcePortRanges", cdk.listValidator(CfnNetworkInsightsAnalysisPortRangePropertyValidator))(properties.sourcePortRanges));
  return errors.wrap("supplied properties not correct for \\"AnalysisPacketHeaderProperty\\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInsightsAnalysisAnalysisPacketHeaderPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInsightsAnalysisAnalysisPacketHeaderPropertyValidator(properties).assertSuccess();
  return {
    "DestinationAddresses": cdk.listMapper(cdk.stringToCloudFormation)(properties.destinationAddresses),
    "DestinationPortRanges": cdk.listMapper(convertCfnNetworkInsightsAnalysisPortRangePropertyToCloudFormation)(properties.destinationPortRanges),
    "Protocol": cdk.stringToCloudFormation(properties.protocol),
    "SourceAddresses": cdk.listMapper(cdk.stringToCloudFormation)(properties.sourceAddresses),
    "SourcePortRanges": cdk.listMapper(convertCfnNetworkInsightsAnalysisPortRangePropertyToCloudFormation)(properties.sourcePortRanges)
  };
}

// @ts-ignore TS6133
function CfnNetworkInsightsAnalysisAnalysisPacketHeaderPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNetworkInsightsAnalysis.AnalysisPacketHeaderProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInsightsAnalysis.AnalysisPacketHeaderProperty>();
  ret.addPropertyResult("destinationAddresses", "DestinationAddresses", (properties.DestinationAddresses != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.DestinationAddresses) : undefined));
  ret.addPropertyResult("destinationPortRanges", "DestinationPortRanges", (properties.DestinationPortRanges != null ? cfn_parse.FromCloudFormation.getArray(CfnNetworkInsightsAnalysisPortRangePropertyFromCloudFormation)(properties.DestinationPortRanges) : undefined));
  ret.addPropertyResult("protocol", "Protocol", (properties.Protocol != null ? cfn_parse.FromCloudFormation.getString(properties.Protocol) : undefined));
  ret.addPropertyResult("sourceAddresses", "SourceAddresses", (properties.SourceAddresses != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SourceAddresses) : undefined));
  ret.addPropertyResult("sourcePortRanges", "SourcePortRanges", (properties.SourcePortRanges != null ? cfn_parse.FromCloudFormation.getArray(CfnNetworkInsightsAnalysisPortRangePropertyFromCloudFormation)(properties.SourcePortRanges) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`AnalysisSecurityGroupRuleProperty\`
 *
 * @param properties - the TypeScript properties of a \`AnalysisSecurityGroupRuleProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInsightsAnalysisAnalysisSecurityGroupRulePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("cidr", cdk.validateString)(properties.cidr));
  errors.collect(cdk.propertyValidator("direction", cdk.validateString)(properties.direction));
  errors.collect(cdk.propertyValidator("portRange", CfnNetworkInsightsAnalysisPortRangePropertyValidator)(properties.portRange));
  errors.collect(cdk.propertyValidator("prefixListId", cdk.validateString)(properties.prefixListId));
  errors.collect(cdk.propertyValidator("protocol", cdk.validateString)(properties.protocol));
  errors.collect(cdk.propertyValidator("securityGroupId", cdk.validateString)(properties.securityGroupId));
  return errors.wrap("supplied properties not correct for \\"AnalysisSecurityGroupRuleProperty\\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInsightsAnalysisAnalysisSecurityGroupRulePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInsightsAnalysisAnalysisSecurityGroupRulePropertyValidator(properties).assertSuccess();
  return {
    "Cidr": cdk.stringToCloudFormation(properties.cidr),
    "Direction": cdk.stringToCloudFormation(properties.direction),
    "PortRange": convertCfnNetworkInsightsAnalysisPortRangePropertyToCloudFormation(properties.portRange),
    "PrefixListId": cdk.stringToCloudFormation(properties.prefixListId),
    "Protocol": cdk.stringToCloudFormation(properties.protocol),
    "SecurityGroupId": cdk.stringToCloudFormation(properties.securityGroupId)
  };
}

// @ts-ignore TS6133
function CfnNetworkInsightsAnalysisAnalysisSecurityGroupRulePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNetworkInsightsAnalysis.AnalysisSecurityGroupRuleProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInsightsAnalysis.AnalysisSecurityGroupRuleProperty>();
  ret.addPropertyResult("cidr", "Cidr", (properties.Cidr != null ? cfn_parse.FromCloudFormation.getString(properties.Cidr) : undefined));
  ret.addPropertyResult("direction", "Direction", (properties.Direction != null ? cfn_parse.FromCloudFormation.getString(properties.Direction) : undefined));
  ret.addPropertyResult("portRange", "PortRange", (properties.PortRange != null ? CfnNetworkInsightsAnalysisPortRangePropertyFromCloudFormation(properties.PortRange) : undefined));
  ret.addPropertyResult("prefixListId", "PrefixListId", (properties.PrefixListId != null ? cfn_parse.FromCloudFormation.getString(properties.PrefixListId) : undefined));
  ret.addPropertyResult("protocol", "Protocol", (properties.Protocol != null ? cfn_parse.FromCloudFormation.getString(properties.Protocol) : undefined));
  ret.addPropertyResult("securityGroupId", "SecurityGroupId", (properties.SecurityGroupId != null ? cfn_parse.FromCloudFormation.getString(properties.SecurityGroupId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`AnalysisLoadBalancerListenerProperty\`
 *
 * @param properties - the TypeScript properties of a \`AnalysisLoadBalancerListenerProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInsightsAnalysisAnalysisLoadBalancerListenerPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("instancePort", cdk.validateNumber)(properties.instancePort));
  errors.collect(cdk.propertyValidator("loadBalancerPort", cdk.validateNumber)(properties.loadBalancerPort));
  return errors.wrap("supplied properties not correct for \\"AnalysisLoadBalancerListenerProperty\\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInsightsAnalysisAnalysisLoadBalancerListenerPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInsightsAnalysisAnalysisLoadBalancerListenerPropertyValidator(properties).assertSuccess();
  return {
    "InstancePort": cdk.numberToCloudFormation(properties.instancePort),
    "LoadBalancerPort": cdk.numberToCloudFormation(properties.loadBalancerPort)
  };
}

// @ts-ignore TS6133
function CfnNetworkInsightsAnalysisAnalysisLoadBalancerListenerPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNetworkInsightsAnalysis.AnalysisLoadBalancerListenerProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInsightsAnalysis.AnalysisLoadBalancerListenerProperty>();
  ret.addPropertyResult("instancePort", "InstancePort", (properties.InstancePort != null ? cfn_parse.FromCloudFormation.getNumber(properties.InstancePort) : undefined));
  ret.addPropertyResult("loadBalancerPort", "LoadBalancerPort", (properties.LoadBalancerPort != null ? cfn_parse.FromCloudFormation.getNumber(properties.LoadBalancerPort) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`TransitGatewayRouteTableRouteProperty\`
 *
 * @param properties - the TypeScript properties of a \`TransitGatewayRouteTableRouteProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInsightsAnalysisTransitGatewayRouteTableRoutePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("attachmentId", cdk.validateString)(properties.attachmentId));
  errors.collect(cdk.propertyValidator("destinationCidr", cdk.validateString)(properties.destinationCidr));
  errors.collect(cdk.propertyValidator("prefixListId", cdk.validateString)(properties.prefixListId));
  errors.collect(cdk.propertyValidator("resourceId", cdk.validateString)(properties.resourceId));
  errors.collect(cdk.propertyValidator("resourceType", cdk.validateString)(properties.resourceType));
  errors.collect(cdk.propertyValidator("routeOrigin", cdk.validateString)(properties.routeOrigin));
  errors.collect(cdk.propertyValidator("state", cdk.validateString)(properties.state));
  return errors.wrap("supplied properties not correct for \\"TransitGatewayRouteTableRouteProperty\\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInsightsAnalysisTransitGatewayRouteTableRoutePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInsightsAnalysisTransitGatewayRouteTableRoutePropertyValidator(properties).assertSuccess();
  return {
    "AttachmentId": cdk.stringToCloudFormation(properties.attachmentId),
    "DestinationCidr": cdk.stringToCloudFormation(properties.destinationCidr),
    "PrefixListId": cdk.stringToCloudFormation(properties.prefixListId),
    "ResourceId": cdk.stringToCloudFormation(properties.resourceId),
    "ResourceType": cdk.stringToCloudFormation(properties.resourceType),
    "RouteOrigin": cdk.stringToCloudFormation(properties.routeOrigin),
    "State": cdk.stringToCloudFormation(properties.state)
  };
}

// @ts-ignore TS6133
function CfnNetworkInsightsAnalysisTransitGatewayRouteTableRoutePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnNetworkInsightsAnalysis.TransitGatewayRouteTableRouteProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInsightsAnalysis.TransitGatewayRouteTableRouteProperty>();
  ret.addPropertyResult("attachmentId", "AttachmentId", (properties.AttachmentId != null ? cfn_parse.FromCloudFormation.getString(properties.AttachmentId) : undefined));
  ret.addPropertyResult("destinationCidr", "DestinationCidr", (properties.DestinationCidr != null ? cfn_parse.FromCloudFormation.getString(properties.DestinationCidr) : undefined));
  ret.addPropertyResult("prefixListId", "PrefixListId", (properties.PrefixListId != null ? cfn_parse.FromCloudFormation.getString(properties.PrefixListId) : undefined));
  ret.addPropertyResult("resourceId", "ResourceId", (properties.ResourceId != null ? cfn_parse.FromCloudFormation.getString(properties.ResourceId) : undefined));
  ret.addPropertyResult("resourceType", "ResourceType", (properties.ResourceType != null ? cfn_parse.FromCloudFormation.getString(properties.ResourceType) : undefined));
  ret.addPropertyResult("routeOrigin", "RouteOrigin", (properties.RouteOrigin != null ? cfn_parse.FromCloudFormation.getString(properties.RouteOrigin) : undefined));
  ret.addPropertyResult("state", "State", (properties.State != null ? cfn_parse.FromCloudFormation.getString(properties.State) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`AnalysisLoadBalancerTargetProperty\`
 *
 * @param properties - the TypeScript properties of a \`AnalysisLoadBalancerTargetProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInsightsAnalysisAnalysisLoadBalancerTargetPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("address", cdk.validateString)(properties.address));
  errors.collect(cdk.propertyValidator("availabilityZone", cdk.validateString)(properties.availabilityZone));
  errors.collect(cdk.propertyValidator("instance", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.instance));
  errors.collect(cdk.propertyValidator("port", cdk.validateNumber)(properties.port));
  return errors.wrap("supplied properties not correct for \\"AnalysisLoadBalancerTargetProperty\\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInsightsAnalysisAnalysisLoadBalancerTargetPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInsightsAnalysisAnalysisLoadBalancerTargetPropertyValidator(properties).assertSuccess();
  return {
    "Address": cdk.stringToCloudFormation(properties.address),
    "AvailabilityZone": cdk.stringToCloudFormation(properties.availabilityZone),
    "Instance": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.instance),
    "Port": cdk.numberToCloudFormation(properties.port)
  };
}

// @ts-ignore TS6133
function CfnNetworkInsightsAnalysisAnalysisLoadBalancerTargetPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNetworkInsightsAnalysis.AnalysisLoadBalancerTargetProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInsightsAnalysis.AnalysisLoadBalancerTargetProperty>();
  ret.addPropertyResult("address", "Address", (properties.Address != null ? cfn_parse.FromCloudFormation.getString(properties.Address) : undefined));
  ret.addPropertyResult("availabilityZone", "AvailabilityZone", (properties.AvailabilityZone != null ? cfn_parse.FromCloudFormation.getString(properties.AvailabilityZone) : undefined));
  ret.addPropertyResult("instance", "Instance", (properties.Instance != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.Instance) : undefined));
  ret.addPropertyResult("port", "Port", (properties.Port != null ? cfn_parse.FromCloudFormation.getNumber(properties.Port) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`AnalysisRouteTableRouteProperty\`
 *
 * @param properties - the TypeScript properties of a \`AnalysisRouteTableRouteProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInsightsAnalysisAnalysisRouteTableRoutePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("natGatewayId", cdk.validateString)(properties.natGatewayId));
  errors.collect(cdk.propertyValidator("networkInterfaceId", cdk.validateString)(properties.networkInterfaceId));
  errors.collect(cdk.propertyValidator("origin", cdk.validateString)(properties.origin));
  errors.collect(cdk.propertyValidator("state", cdk.validateString)(properties.state));
  errors.collect(cdk.propertyValidator("transitGatewayId", cdk.validateString)(properties.transitGatewayId));
  errors.collect(cdk.propertyValidator("vpcPeeringConnectionId", cdk.validateString)(properties.vpcPeeringConnectionId));
  errors.collect(cdk.propertyValidator("destinationCidr", cdk.validateString)(properties.destinationCidr));
  errors.collect(cdk.propertyValidator("destinationPrefixListId", cdk.validateString)(properties.destinationPrefixListId));
  errors.collect(cdk.propertyValidator("egressOnlyInternetGatewayId", cdk.validateString)(properties.egressOnlyInternetGatewayId));
  errors.collect(cdk.propertyValidator("gatewayId", cdk.validateString)(properties.gatewayId));
  errors.collect(cdk.propertyValidator("instanceId", cdk.validateString)(properties.instanceId));
  return errors.wrap("supplied properties not correct for \\"AnalysisRouteTableRouteProperty\\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInsightsAnalysisAnalysisRouteTableRoutePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInsightsAnalysisAnalysisRouteTableRoutePropertyValidator(properties).assertSuccess();
  return {
    "NatGatewayId": cdk.stringToCloudFormation(properties.natGatewayId),
    "NetworkInterfaceId": cdk.stringToCloudFormation(properties.networkInterfaceId),
    "Origin": cdk.stringToCloudFormation(properties.origin),
    "State": cdk.stringToCloudFormation(properties.state),
    "TransitGatewayId": cdk.stringToCloudFormation(properties.transitGatewayId),
    "VpcPeeringConnectionId": cdk.stringToCloudFormation(properties.vpcPeeringConnectionId),
    "destinationCidr": cdk.stringToCloudFormation(properties.destinationCidr),
    "destinationPrefixListId": cdk.stringToCloudFormation(properties.destinationPrefixListId),
    "egressOnlyInternetGatewayId": cdk.stringToCloudFormation(properties.egressOnlyInternetGatewayId),
    "gatewayId": cdk.stringToCloudFormation(properties.gatewayId),
    "instanceId": cdk.stringToCloudFormation(properties.instanceId)
  };
}

// @ts-ignore TS6133
function CfnNetworkInsightsAnalysisAnalysisRouteTableRoutePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNetworkInsightsAnalysis.AnalysisRouteTableRouteProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInsightsAnalysis.AnalysisRouteTableRouteProperty>();
  ret.addPropertyResult("destinationCidr", "destinationCidr", (properties.destinationCidr != null ? cfn_parse.FromCloudFormation.getString(properties.destinationCidr) : undefined));
  ret.addPropertyResult("destinationPrefixListId", "destinationPrefixListId", (properties.destinationPrefixListId != null ? cfn_parse.FromCloudFormation.getString(properties.destinationPrefixListId) : undefined));
  ret.addPropertyResult("egressOnlyInternetGatewayId", "egressOnlyInternetGatewayId", (properties.egressOnlyInternetGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.egressOnlyInternetGatewayId) : undefined));
  ret.addPropertyResult("gatewayId", "gatewayId", (properties.gatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.gatewayId) : undefined));
  ret.addPropertyResult("instanceId", "instanceId", (properties.instanceId != null ? cfn_parse.FromCloudFormation.getString(properties.instanceId) : undefined));
  ret.addPropertyResult("natGatewayId", "NatGatewayId", (properties.NatGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.NatGatewayId) : undefined));
  ret.addPropertyResult("networkInterfaceId", "NetworkInterfaceId", (properties.NetworkInterfaceId != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkInterfaceId) : undefined));
  ret.addPropertyResult("origin", "Origin", (properties.Origin != null ? cfn_parse.FromCloudFormation.getString(properties.Origin) : undefined));
  ret.addPropertyResult("state", "State", (properties.State != null ? cfn_parse.FromCloudFormation.getString(properties.State) : undefined));
  ret.addPropertyResult("transitGatewayId", "TransitGatewayId", (properties.TransitGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.TransitGatewayId) : undefined));
  ret.addPropertyResult("vpcPeeringConnectionId", "VpcPeeringConnectionId", (properties.VpcPeeringConnectionId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcPeeringConnectionId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`AnalysisAclRuleProperty\`
 *
 * @param properties - the TypeScript properties of a \`AnalysisAclRuleProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInsightsAnalysisAnalysisAclRulePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("cidr", cdk.validateString)(properties.cidr));
  errors.collect(cdk.propertyValidator("egress", cdk.validateBoolean)(properties.egress));
  errors.collect(cdk.propertyValidator("portRange", CfnNetworkInsightsAnalysisPortRangePropertyValidator)(properties.portRange));
  errors.collect(cdk.propertyValidator("protocol", cdk.validateString)(properties.protocol));
  errors.collect(cdk.propertyValidator("ruleAction", cdk.validateString)(properties.ruleAction));
  errors.collect(cdk.propertyValidator("ruleNumber", cdk.validateNumber)(properties.ruleNumber));
  return errors.wrap("supplied properties not correct for \\"AnalysisAclRuleProperty\\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInsightsAnalysisAnalysisAclRulePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInsightsAnalysisAnalysisAclRulePropertyValidator(properties).assertSuccess();
  return {
    "Cidr": cdk.stringToCloudFormation(properties.cidr),
    "Egress": cdk.booleanToCloudFormation(properties.egress),
    "PortRange": convertCfnNetworkInsightsAnalysisPortRangePropertyToCloudFormation(properties.portRange),
    "Protocol": cdk.stringToCloudFormation(properties.protocol),
    "RuleAction": cdk.stringToCloudFormation(properties.ruleAction),
    "RuleNumber": cdk.numberToCloudFormation(properties.ruleNumber)
  };
}

// @ts-ignore TS6133
function CfnNetworkInsightsAnalysisAnalysisAclRulePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNetworkInsightsAnalysis.AnalysisAclRuleProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInsightsAnalysis.AnalysisAclRuleProperty>();
  ret.addPropertyResult("cidr", "Cidr", (properties.Cidr != null ? cfn_parse.FromCloudFormation.getString(properties.Cidr) : undefined));
  ret.addPropertyResult("egress", "Egress", (properties.Egress != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Egress) : undefined));
  ret.addPropertyResult("portRange", "PortRange", (properties.PortRange != null ? CfnNetworkInsightsAnalysisPortRangePropertyFromCloudFormation(properties.PortRange) : undefined));
  ret.addPropertyResult("protocol", "Protocol", (properties.Protocol != null ? cfn_parse.FromCloudFormation.getString(properties.Protocol) : undefined));
  ret.addPropertyResult("ruleAction", "RuleAction", (properties.RuleAction != null ? cfn_parse.FromCloudFormation.getString(properties.RuleAction) : undefined));
  ret.addPropertyResult("ruleNumber", "RuleNumber", (properties.RuleNumber != null ? cfn_parse.FromCloudFormation.getNumber(properties.RuleNumber) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ExplanationProperty\`
 *
 * @param properties - the TypeScript properties of a \`ExplanationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInsightsAnalysisExplanationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("acl", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.acl));
  errors.collect(cdk.propertyValidator("aclRule", CfnNetworkInsightsAnalysisAnalysisAclRulePropertyValidator)(properties.aclRule));
  errors.collect(cdk.propertyValidator("address", cdk.validateString)(properties.address));
  errors.collect(cdk.propertyValidator("addresses", cdk.listValidator(cdk.validateString))(properties.addresses));
  errors.collect(cdk.propertyValidator("attachedTo", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.attachedTo));
  errors.collect(cdk.propertyValidator("availabilityZones", cdk.listValidator(cdk.validateString))(properties.availabilityZones));
  errors.collect(cdk.propertyValidator("cidrs", cdk.listValidator(cdk.validateString))(properties.cidrs));
  errors.collect(cdk.propertyValidator("classicLoadBalancerListener", CfnNetworkInsightsAnalysisAnalysisLoadBalancerListenerPropertyValidator)(properties.classicLoadBalancerListener));
  errors.collect(cdk.propertyValidator("component", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.component));
  errors.collect(cdk.propertyValidator("componentAccount", cdk.validateString)(properties.componentAccount));
  errors.collect(cdk.propertyValidator("componentRegion", cdk.validateString)(properties.componentRegion));
  errors.collect(cdk.propertyValidator("customerGateway", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.customerGateway));
  errors.collect(cdk.propertyValidator("destination", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.destination));
  errors.collect(cdk.propertyValidator("destinationVpc", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.destinationVpc));
  errors.collect(cdk.propertyValidator("direction", cdk.validateString)(properties.direction));
  errors.collect(cdk.propertyValidator("elasticLoadBalancerListener", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.elasticLoadBalancerListener));
  errors.collect(cdk.propertyValidator("explanationCode", cdk.validateString)(properties.explanationCode));
  errors.collect(cdk.propertyValidator("ingressRouteTable", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.ingressRouteTable));
  errors.collect(cdk.propertyValidator("internetGateway", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.internetGateway));
  errors.collect(cdk.propertyValidator("loadBalancerArn", cdk.validateString)(properties.loadBalancerArn));
  errors.collect(cdk.propertyValidator("loadBalancerListenerPort", cdk.validateNumber)(properties.loadBalancerListenerPort));
  errors.collect(cdk.propertyValidator("loadBalancerTarget", CfnNetworkInsightsAnalysisAnalysisLoadBalancerTargetPropertyValidator)(properties.loadBalancerTarget));
  errors.collect(cdk.propertyValidator("loadBalancerTargetGroup", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.loadBalancerTargetGroup));
  errors.collect(cdk.propertyValidator("loadBalancerTargetGroups", cdk.listValidator(CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator))(properties.loadBalancerTargetGroups));
  errors.collect(cdk.propertyValidator("loadBalancerTargetPort", cdk.validateNumber)(properties.loadBalancerTargetPort));
  errors.collect(cdk.propertyValidator("missingComponent", cdk.validateString)(properties.missingComponent));
  errors.collect(cdk.propertyValidator("natGateway", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.natGateway));
  errors.collect(cdk.propertyValidator("networkInterface", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.networkInterface));
  errors.collect(cdk.propertyValidator("packetField", cdk.validateString)(properties.packetField));
  errors.collect(cdk.propertyValidator("port", cdk.validateNumber)(properties.port));
  errors.collect(cdk.propertyValidator("portRanges", cdk.listValidator(CfnNetworkInsightsAnalysisPortRangePropertyValidator))(properties.portRanges));
  errors.collect(cdk.propertyValidator("prefixList", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.prefixList));
  errors.collect(cdk.propertyValidator("protocols", cdk.listValidator(cdk.validateString))(properties.protocols));
  errors.collect(cdk.propertyValidator("routeTable", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.routeTable));
  errors.collect(cdk.propertyValidator("routeTableRoute", CfnNetworkInsightsAnalysisAnalysisRouteTableRoutePropertyValidator)(properties.routeTableRoute));
  errors.collect(cdk.propertyValidator("securityGroup", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.securityGroup));
  errors.collect(cdk.propertyValidator("securityGroupRule", CfnNetworkInsightsAnalysisAnalysisSecurityGroupRulePropertyValidator)(properties.securityGroupRule));
  errors.collect(cdk.propertyValidator("securityGroups", cdk.listValidator(CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator))(properties.securityGroups));
  errors.collect(cdk.propertyValidator("sourceVpc", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.sourceVpc));
  errors.collect(cdk.propertyValidator("state", cdk.validateString)(properties.state));
  errors.collect(cdk.propertyValidator("subnet", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.subnet));
  errors.collect(cdk.propertyValidator("subnetRouteTable", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.subnetRouteTable));
  errors.collect(cdk.propertyValidator("transitGateway", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.transitGateway));
  errors.collect(cdk.propertyValidator("transitGatewayAttachment", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.transitGatewayAttachment));
  errors.collect(cdk.propertyValidator("transitGatewayRouteTable", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.transitGatewayRouteTable));
  errors.collect(cdk.propertyValidator("transitGatewayRouteTableRoute", CfnNetworkInsightsAnalysisTransitGatewayRouteTableRoutePropertyValidator)(properties.transitGatewayRouteTableRoute));
  errors.collect(cdk.propertyValidator("vpc", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.vpc));
  errors.collect(cdk.propertyValidator("vpcPeeringConnection", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.vpcPeeringConnection));
  errors.collect(cdk.propertyValidator("vpnConnection", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.vpnConnection));
  errors.collect(cdk.propertyValidator("vpnGateway", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.vpnGateway));
  errors.collect(cdk.propertyValidator("vpcEndpoint", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.vpcEndpoint));
  return errors.wrap("supplied properties not correct for \\"ExplanationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInsightsAnalysisExplanationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInsightsAnalysisExplanationPropertyValidator(properties).assertSuccess();
  return {
    "Acl": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.acl),
    "AclRule": convertCfnNetworkInsightsAnalysisAnalysisAclRulePropertyToCloudFormation(properties.aclRule),
    "Address": cdk.stringToCloudFormation(properties.address),
    "Addresses": cdk.listMapper(cdk.stringToCloudFormation)(properties.addresses),
    "AttachedTo": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.attachedTo),
    "AvailabilityZones": cdk.listMapper(cdk.stringToCloudFormation)(properties.availabilityZones),
    "Cidrs": cdk.listMapper(cdk.stringToCloudFormation)(properties.cidrs),
    "ClassicLoadBalancerListener": convertCfnNetworkInsightsAnalysisAnalysisLoadBalancerListenerPropertyToCloudFormation(properties.classicLoadBalancerListener),
    "Component": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.component),
    "ComponentAccount": cdk.stringToCloudFormation(properties.componentAccount),
    "ComponentRegion": cdk.stringToCloudFormation(properties.componentRegion),
    "CustomerGateway": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.customerGateway),
    "Destination": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.destination),
    "DestinationVpc": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.destinationVpc),
    "Direction": cdk.stringToCloudFormation(properties.direction),
    "ElasticLoadBalancerListener": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.elasticLoadBalancerListener),
    "ExplanationCode": cdk.stringToCloudFormation(properties.explanationCode),
    "IngressRouteTable": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.ingressRouteTable),
    "InternetGateway": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.internetGateway),
    "LoadBalancerArn": cdk.stringToCloudFormation(properties.loadBalancerArn),
    "LoadBalancerListenerPort": cdk.numberToCloudFormation(properties.loadBalancerListenerPort),
    "LoadBalancerTarget": convertCfnNetworkInsightsAnalysisAnalysisLoadBalancerTargetPropertyToCloudFormation(properties.loadBalancerTarget),
    "LoadBalancerTargetGroup": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.loadBalancerTargetGroup),
    "LoadBalancerTargetGroups": cdk.listMapper(convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation)(properties.loadBalancerTargetGroups),
    "LoadBalancerTargetPort": cdk.numberToCloudFormation(properties.loadBalancerTargetPort),
    "MissingComponent": cdk.stringToCloudFormation(properties.missingComponent),
    "NatGateway": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.natGateway),
    "NetworkInterface": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.networkInterface),
    "PacketField": cdk.stringToCloudFormation(properties.packetField),
    "Port": cdk.numberToCloudFormation(properties.port),
    "PortRanges": cdk.listMapper(convertCfnNetworkInsightsAnalysisPortRangePropertyToCloudFormation)(properties.portRanges),
    "PrefixList": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.prefixList),
    "Protocols": cdk.listMapper(cdk.stringToCloudFormation)(properties.protocols),
    "RouteTable": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.routeTable),
    "RouteTableRoute": convertCfnNetworkInsightsAnalysisAnalysisRouteTableRoutePropertyToCloudFormation(properties.routeTableRoute),
    "SecurityGroup": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.securityGroup),
    "SecurityGroupRule": convertCfnNetworkInsightsAnalysisAnalysisSecurityGroupRulePropertyToCloudFormation(properties.securityGroupRule),
    "SecurityGroups": cdk.listMapper(convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation)(properties.securityGroups),
    "SourceVpc": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.sourceVpc),
    "State": cdk.stringToCloudFormation(properties.state),
    "Subnet": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.subnet),
    "SubnetRouteTable": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.subnetRouteTable),
    "TransitGateway": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.transitGateway),
    "TransitGatewayAttachment": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.transitGatewayAttachment),
    "TransitGatewayRouteTable": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.transitGatewayRouteTable),
    "TransitGatewayRouteTableRoute": convertCfnNetworkInsightsAnalysisTransitGatewayRouteTableRoutePropertyToCloudFormation(properties.transitGatewayRouteTableRoute),
    "Vpc": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.vpc),
    "VpcPeeringConnection": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.vpcPeeringConnection),
    "VpnConnection": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.vpnConnection),
    "VpnGateway": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.vpnGateway),
    "vpcEndpoint": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.vpcEndpoint)
  };
}

// @ts-ignore TS6133
function CfnNetworkInsightsAnalysisExplanationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNetworkInsightsAnalysis.ExplanationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInsightsAnalysis.ExplanationProperty>();
  ret.addPropertyResult("acl", "Acl", (properties.Acl != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.Acl) : undefined));
  ret.addPropertyResult("aclRule", "AclRule", (properties.AclRule != null ? CfnNetworkInsightsAnalysisAnalysisAclRulePropertyFromCloudFormation(properties.AclRule) : undefined));
  ret.addPropertyResult("address", "Address", (properties.Address != null ? cfn_parse.FromCloudFormation.getString(properties.Address) : undefined));
  ret.addPropertyResult("addresses", "Addresses", (properties.Addresses != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.Addresses) : undefined));
  ret.addPropertyResult("attachedTo", "AttachedTo", (properties.AttachedTo != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.AttachedTo) : undefined));
  ret.addPropertyResult("availabilityZones", "AvailabilityZones", (properties.AvailabilityZones != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.AvailabilityZones) : undefined));
  ret.addPropertyResult("cidrs", "Cidrs", (properties.Cidrs != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.Cidrs) : undefined));
  ret.addPropertyResult("classicLoadBalancerListener", "ClassicLoadBalancerListener", (properties.ClassicLoadBalancerListener != null ? CfnNetworkInsightsAnalysisAnalysisLoadBalancerListenerPropertyFromCloudFormation(properties.ClassicLoadBalancerListener) : undefined));
  ret.addPropertyResult("component", "Component", (properties.Component != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.Component) : undefined));
  ret.addPropertyResult("componentAccount", "ComponentAccount", (properties.ComponentAccount != null ? cfn_parse.FromCloudFormation.getString(properties.ComponentAccount) : undefined));
  ret.addPropertyResult("componentRegion", "ComponentRegion", (properties.ComponentRegion != null ? cfn_parse.FromCloudFormation.getString(properties.ComponentRegion) : undefined));
  ret.addPropertyResult("customerGateway", "CustomerGateway", (properties.CustomerGateway != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.CustomerGateway) : undefined));
  ret.addPropertyResult("destination", "Destination", (properties.Destination != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.Destination) : undefined));
  ret.addPropertyResult("destinationVpc", "DestinationVpc", (properties.DestinationVpc != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.DestinationVpc) : undefined));
  ret.addPropertyResult("direction", "Direction", (properties.Direction != null ? cfn_parse.FromCloudFormation.getString(properties.Direction) : undefined));
  ret.addPropertyResult("elasticLoadBalancerListener", "ElasticLoadBalancerListener", (properties.ElasticLoadBalancerListener != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.ElasticLoadBalancerListener) : undefined));
  ret.addPropertyResult("explanationCode", "ExplanationCode", (properties.ExplanationCode != null ? cfn_parse.FromCloudFormation.getString(properties.ExplanationCode) : undefined));
  ret.addPropertyResult("ingressRouteTable", "IngressRouteTable", (properties.IngressRouteTable != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.IngressRouteTable) : undefined));
  ret.addPropertyResult("internetGateway", "InternetGateway", (properties.InternetGateway != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.InternetGateway) : undefined));
  ret.addPropertyResult("loadBalancerArn", "LoadBalancerArn", (properties.LoadBalancerArn != null ? cfn_parse.FromCloudFormation.getString(properties.LoadBalancerArn) : undefined));
  ret.addPropertyResult("loadBalancerListenerPort", "LoadBalancerListenerPort", (properties.LoadBalancerListenerPort != null ? cfn_parse.FromCloudFormation.getNumber(properties.LoadBalancerListenerPort) : undefined));
  ret.addPropertyResult("loadBalancerTarget", "LoadBalancerTarget", (properties.LoadBalancerTarget != null ? CfnNetworkInsightsAnalysisAnalysisLoadBalancerTargetPropertyFromCloudFormation(properties.LoadBalancerTarget) : undefined));
  ret.addPropertyResult("loadBalancerTargetGroup", "LoadBalancerTargetGroup", (properties.LoadBalancerTargetGroup != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.LoadBalancerTargetGroup) : undefined));
  ret.addPropertyResult("loadBalancerTargetGroups", "LoadBalancerTargetGroups", (properties.LoadBalancerTargetGroups != null ? cfn_parse.FromCloudFormation.getArray(CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation)(properties.LoadBalancerTargetGroups) : undefined));
  ret.addPropertyResult("loadBalancerTargetPort", "LoadBalancerTargetPort", (properties.LoadBalancerTargetPort != null ? cfn_parse.FromCloudFormation.getNumber(properties.LoadBalancerTargetPort) : undefined));
  ret.addPropertyResult("missingComponent", "MissingComponent", (properties.MissingComponent != null ? cfn_parse.FromCloudFormation.getString(properties.MissingComponent) : undefined));
  ret.addPropertyResult("natGateway", "NatGateway", (properties.NatGateway != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.NatGateway) : undefined));
  ret.addPropertyResult("networkInterface", "NetworkInterface", (properties.NetworkInterface != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.NetworkInterface) : undefined));
  ret.addPropertyResult("packetField", "PacketField", (properties.PacketField != null ? cfn_parse.FromCloudFormation.getString(properties.PacketField) : undefined));
  ret.addPropertyResult("port", "Port", (properties.Port != null ? cfn_parse.FromCloudFormation.getNumber(properties.Port) : undefined));
  ret.addPropertyResult("portRanges", "PortRanges", (properties.PortRanges != null ? cfn_parse.FromCloudFormation.getArray(CfnNetworkInsightsAnalysisPortRangePropertyFromCloudFormation)(properties.PortRanges) : undefined));
  ret.addPropertyResult("prefixList", "PrefixList", (properties.PrefixList != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.PrefixList) : undefined));
  ret.addPropertyResult("protocols", "Protocols", (properties.Protocols != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.Protocols) : undefined));
  ret.addPropertyResult("routeTable", "RouteTable", (properties.RouteTable != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.RouteTable) : undefined));
  ret.addPropertyResult("routeTableRoute", "RouteTableRoute", (properties.RouteTableRoute != null ? CfnNetworkInsightsAnalysisAnalysisRouteTableRoutePropertyFromCloudFormation(properties.RouteTableRoute) : undefined));
  ret.addPropertyResult("securityGroup", "SecurityGroup", (properties.SecurityGroup != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.SecurityGroup) : undefined));
  ret.addPropertyResult("securityGroupRule", "SecurityGroupRule", (properties.SecurityGroupRule != null ? CfnNetworkInsightsAnalysisAnalysisSecurityGroupRulePropertyFromCloudFormation(properties.SecurityGroupRule) : undefined));
  ret.addPropertyResult("securityGroups", "SecurityGroups", (properties.SecurityGroups != null ? cfn_parse.FromCloudFormation.getArray(CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation)(properties.SecurityGroups) : undefined));
  ret.addPropertyResult("sourceVpc", "SourceVpc", (properties.SourceVpc != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.SourceVpc) : undefined));
  ret.addPropertyResult("state", "State", (properties.State != null ? cfn_parse.FromCloudFormation.getString(properties.State) : undefined));
  ret.addPropertyResult("subnet", "Subnet", (properties.Subnet != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.Subnet) : undefined));
  ret.addPropertyResult("subnetRouteTable", "SubnetRouteTable", (properties.SubnetRouteTable != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.SubnetRouteTable) : undefined));
  ret.addPropertyResult("transitGateway", "TransitGateway", (properties.TransitGateway != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.TransitGateway) : undefined));
  ret.addPropertyResult("transitGatewayAttachment", "TransitGatewayAttachment", (properties.TransitGatewayAttachment != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.TransitGatewayAttachment) : undefined));
  ret.addPropertyResult("transitGatewayRouteTable", "TransitGatewayRouteTable", (properties.TransitGatewayRouteTable != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.TransitGatewayRouteTable) : undefined));
  ret.addPropertyResult("transitGatewayRouteTableRoute", "TransitGatewayRouteTableRoute", (properties.TransitGatewayRouteTableRoute != null ? CfnNetworkInsightsAnalysisTransitGatewayRouteTableRoutePropertyFromCloudFormation(properties.TransitGatewayRouteTableRoute) : undefined));
  ret.addPropertyResult("vpc", "Vpc", (properties.Vpc != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.Vpc) : undefined));
  ret.addPropertyResult("vpcEndpoint", "vpcEndpoint", (properties.vpcEndpoint != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.vpcEndpoint) : undefined));
  ret.addPropertyResult("vpcPeeringConnection", "VpcPeeringConnection", (properties.VpcPeeringConnection != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.VpcPeeringConnection) : undefined));
  ret.addPropertyResult("vpnConnection", "VpnConnection", (properties.VpnConnection != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.VpnConnection) : undefined));
  ret.addPropertyResult("vpnGateway", "VpnGateway", (properties.VpnGateway != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.VpnGateway) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`PathComponentProperty\`
 *
 * @param properties - the TypeScript properties of a \`PathComponentProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInsightsAnalysisPathComponentPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("aclRule", CfnNetworkInsightsAnalysisAnalysisAclRulePropertyValidator)(properties.aclRule));
  errors.collect(cdk.propertyValidator("additionalDetails", cdk.listValidator(CfnNetworkInsightsAnalysisAdditionalDetailPropertyValidator))(properties.additionalDetails));
  errors.collect(cdk.propertyValidator("component", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.component));
  errors.collect(cdk.propertyValidator("destinationVpc", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.destinationVpc));
  errors.collect(cdk.propertyValidator("elasticLoadBalancerListener", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.elasticLoadBalancerListener));
  errors.collect(cdk.propertyValidator("explanations", cdk.listValidator(CfnNetworkInsightsAnalysisExplanationPropertyValidator))(properties.explanations));
  errors.collect(cdk.propertyValidator("inboundHeader", CfnNetworkInsightsAnalysisAnalysisPacketHeaderPropertyValidator)(properties.inboundHeader));
  errors.collect(cdk.propertyValidator("outboundHeader", CfnNetworkInsightsAnalysisAnalysisPacketHeaderPropertyValidator)(properties.outboundHeader));
  errors.collect(cdk.propertyValidator("routeTableRoute", CfnNetworkInsightsAnalysisAnalysisRouteTableRoutePropertyValidator)(properties.routeTableRoute));
  errors.collect(cdk.propertyValidator("securityGroupRule", CfnNetworkInsightsAnalysisAnalysisSecurityGroupRulePropertyValidator)(properties.securityGroupRule));
  errors.collect(cdk.propertyValidator("sequenceNumber", cdk.validateNumber)(properties.sequenceNumber));
  errors.collect(cdk.propertyValidator("serviceName", cdk.validateString)(properties.serviceName));
  errors.collect(cdk.propertyValidator("sourceVpc", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.sourceVpc));
  errors.collect(cdk.propertyValidator("subnet", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.subnet));
  errors.collect(cdk.propertyValidator("transitGateway", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.transitGateway));
  errors.collect(cdk.propertyValidator("transitGatewayRouteTableRoute", CfnNetworkInsightsAnalysisTransitGatewayRouteTableRoutePropertyValidator)(properties.transitGatewayRouteTableRoute));
  errors.collect(cdk.propertyValidator("vpc", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.vpc));
  return errors.wrap("supplied properties not correct for \\"PathComponentProperty\\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInsightsAnalysisPathComponentPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInsightsAnalysisPathComponentPropertyValidator(properties).assertSuccess();
  return {
    "AclRule": convertCfnNetworkInsightsAnalysisAnalysisAclRulePropertyToCloudFormation(properties.aclRule),
    "AdditionalDetails": cdk.listMapper(convertCfnNetworkInsightsAnalysisAdditionalDetailPropertyToCloudFormation)(properties.additionalDetails),
    "Component": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.component),
    "DestinationVpc": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.destinationVpc),
    "ElasticLoadBalancerListener": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.elasticLoadBalancerListener),
    "Explanations": cdk.listMapper(convertCfnNetworkInsightsAnalysisExplanationPropertyToCloudFormation)(properties.explanations),
    "InboundHeader": convertCfnNetworkInsightsAnalysisAnalysisPacketHeaderPropertyToCloudFormation(properties.inboundHeader),
    "OutboundHeader": convertCfnNetworkInsightsAnalysisAnalysisPacketHeaderPropertyToCloudFormation(properties.outboundHeader),
    "RouteTableRoute": convertCfnNetworkInsightsAnalysisAnalysisRouteTableRoutePropertyToCloudFormation(properties.routeTableRoute),
    "SecurityGroupRule": convertCfnNetworkInsightsAnalysisAnalysisSecurityGroupRulePropertyToCloudFormation(properties.securityGroupRule),
    "SequenceNumber": cdk.numberToCloudFormation(properties.sequenceNumber),
    "ServiceName": cdk.stringToCloudFormation(properties.serviceName),
    "SourceVpc": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.sourceVpc),
    "Subnet": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.subnet),
    "TransitGateway": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.transitGateway),
    "TransitGatewayRouteTableRoute": convertCfnNetworkInsightsAnalysisTransitGatewayRouteTableRoutePropertyToCloudFormation(properties.transitGatewayRouteTableRoute),
    "Vpc": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.vpc)
  };
}

// @ts-ignore TS6133
function CfnNetworkInsightsAnalysisPathComponentPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnNetworkInsightsAnalysis.PathComponentProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInsightsAnalysis.PathComponentProperty>();
  ret.addPropertyResult("aclRule", "AclRule", (properties.AclRule != null ? CfnNetworkInsightsAnalysisAnalysisAclRulePropertyFromCloudFormation(properties.AclRule) : undefined));
  ret.addPropertyResult("additionalDetails", "AdditionalDetails", (properties.AdditionalDetails != null ? cfn_parse.FromCloudFormation.getArray(CfnNetworkInsightsAnalysisAdditionalDetailPropertyFromCloudFormation)(properties.AdditionalDetails) : undefined));
  ret.addPropertyResult("component", "Component", (properties.Component != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.Component) : undefined));
  ret.addPropertyResult("destinationVpc", "DestinationVpc", (properties.DestinationVpc != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.DestinationVpc) : undefined));
  ret.addPropertyResult("elasticLoadBalancerListener", "ElasticLoadBalancerListener", (properties.ElasticLoadBalancerListener != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.ElasticLoadBalancerListener) : undefined));
  ret.addPropertyResult("explanations", "Explanations", (properties.Explanations != null ? cfn_parse.FromCloudFormation.getArray(CfnNetworkInsightsAnalysisExplanationPropertyFromCloudFormation)(properties.Explanations) : undefined));
  ret.addPropertyResult("inboundHeader", "InboundHeader", (properties.InboundHeader != null ? CfnNetworkInsightsAnalysisAnalysisPacketHeaderPropertyFromCloudFormation(properties.InboundHeader) : undefined));
  ret.addPropertyResult("outboundHeader", "OutboundHeader", (properties.OutboundHeader != null ? CfnNetworkInsightsAnalysisAnalysisPacketHeaderPropertyFromCloudFormation(properties.OutboundHeader) : undefined));
  ret.addPropertyResult("routeTableRoute", "RouteTableRoute", (properties.RouteTableRoute != null ? CfnNetworkInsightsAnalysisAnalysisRouteTableRoutePropertyFromCloudFormation(properties.RouteTableRoute) : undefined));
  ret.addPropertyResult("securityGroupRule", "SecurityGroupRule", (properties.SecurityGroupRule != null ? CfnNetworkInsightsAnalysisAnalysisSecurityGroupRulePropertyFromCloudFormation(properties.SecurityGroupRule) : undefined));
  ret.addPropertyResult("sequenceNumber", "SequenceNumber", (properties.SequenceNumber != null ? cfn_parse.FromCloudFormation.getNumber(properties.SequenceNumber) : undefined));
  ret.addPropertyResult("serviceName", "ServiceName", (properties.ServiceName != null ? cfn_parse.FromCloudFormation.getString(properties.ServiceName) : undefined));
  ret.addPropertyResult("sourceVpc", "SourceVpc", (properties.SourceVpc != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.SourceVpc) : undefined));
  ret.addPropertyResult("subnet", "Subnet", (properties.Subnet != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.Subnet) : undefined));
  ret.addPropertyResult("transitGateway", "TransitGateway", (properties.TransitGateway != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.TransitGateway) : undefined));
  ret.addPropertyResult("transitGatewayRouteTableRoute", "TransitGatewayRouteTableRoute", (properties.TransitGatewayRouteTableRoute != null ? CfnNetworkInsightsAnalysisTransitGatewayRouteTableRoutePropertyFromCloudFormation(properties.TransitGatewayRouteTableRoute) : undefined));
  ret.addPropertyResult("vpc", "Vpc", (properties.Vpc != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.Vpc) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`AlternatePathHintProperty\`
 *
 * @param properties - the TypeScript properties of a \`AlternatePathHintProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInsightsAnalysisAlternatePathHintPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("componentArn", cdk.validateString)(properties.componentArn));
  errors.collect(cdk.propertyValidator("componentId", cdk.validateString)(properties.componentId));
  return errors.wrap("supplied properties not correct for \\"AlternatePathHintProperty\\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInsightsAnalysisAlternatePathHintPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInsightsAnalysisAlternatePathHintPropertyValidator(properties).assertSuccess();
  return {
    "ComponentArn": cdk.stringToCloudFormation(properties.componentArn),
    "ComponentId": cdk.stringToCloudFormation(properties.componentId)
  };
}

// @ts-ignore TS6133
function CfnNetworkInsightsAnalysisAlternatePathHintPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNetworkInsightsAnalysis.AlternatePathHintProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInsightsAnalysis.AlternatePathHintProperty>();
  ret.addPropertyResult("componentArn", "ComponentArn", (properties.ComponentArn != null ? cfn_parse.FromCloudFormation.getString(properties.ComponentArn) : undefined));
  ret.addPropertyResult("componentId", "ComponentId", (properties.ComponentId != null ? cfn_parse.FromCloudFormation.getString(properties.ComponentId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnNetworkInsightsAnalysisProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnNetworkInsightsAnalysisProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInsightsAnalysisPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("additionalAccounts", cdk.listValidator(cdk.validateString))(properties.additionalAccounts));
  errors.collect(cdk.propertyValidator("filterInArns", cdk.listValidator(cdk.validateString))(properties.filterInArns));
  errors.collect(cdk.propertyValidator("networkInsightsPathId", cdk.requiredValidator)(properties.networkInsightsPathId));
  errors.collect(cdk.propertyValidator("networkInsightsPathId", cdk.validateString)(properties.networkInsightsPathId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnNetworkInsightsAnalysisProps\\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInsightsAnalysisPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInsightsAnalysisPropsValidator(properties).assertSuccess();
  return {
    "AdditionalAccounts": cdk.listMapper(cdk.stringToCloudFormation)(properties.additionalAccounts),
    "FilterInArns": cdk.listMapper(cdk.stringToCloudFormation)(properties.filterInArns),
    "NetworkInsightsPathId": cdk.stringToCloudFormation(properties.networkInsightsPathId),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnNetworkInsightsAnalysisPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNetworkInsightsAnalysisProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInsightsAnalysisProps>();
  ret.addPropertyResult("additionalAccounts", "AdditionalAccounts", (properties.AdditionalAccounts != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.AdditionalAccounts) : undefined));
  ret.addPropertyResult("filterInArns", "FilterInArns", (properties.FilterInArns != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.FilterInArns) : undefined));
  ret.addPropertyResult("networkInsightsPathId", "NetworkInsightsPathId", (properties.NetworkInsightsPathId != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkInsightsPathId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a path to analyze for reachability.
 *
 * VPC Reachability Analyzer enables you to analyze and debug network reachability between two resources in your virtual private cloud (VPC). For more information, see the [Reachability Analyzer User Guide](https://docs.aws.amazon.com/vpc/latest/reachability/what-is-reachability-analyzer.html) .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html
 */
export class CfnNetworkInsightsPath extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::NetworkInsightsPath";

  /**
   * Build a CfnNetworkInsightsPath from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnNetworkInsightsPath {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnNetworkInsightsPathPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnNetworkInsightsPath(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The time stamp when the path was created.
   *
   * @cloudformationAttribute CreatedDate
   */
  public readonly attrCreatedDate: string;

  /**
   * The Amazon Resource Name (ARN) of the destination.
   *
   * @cloudformationAttribute DestinationArn
   */
  public readonly attrDestinationArn: string;

  /**
   * The Amazon Resource Name (ARN) of the path.
   *
   * @cloudformationAttribute NetworkInsightsPathArn
   */
  public readonly attrNetworkInsightsPathArn: string;

  /**
   * The ID of the path.
   *
   * @cloudformationAttribute NetworkInsightsPathId
   */
  public readonly attrNetworkInsightsPathId: string;

  /**
   * The Amazon Resource Name (ARN) of the source.
   *
   * @cloudformationAttribute SourceArn
   */
  public readonly attrSourceArn: string;

  /**
   * The ID or ARN of the destination.
   */
  public destination?: string;

  /**
   * The IP address of the destination.
   */
  public destinationIp?: string;

  /**
   * The destination port.
   */
  public destinationPort?: number;

  /**
   * Scopes the analysis to network paths that match specific filters at the destination.
   */
  public filterAtDestination?: cdk.IResolvable | CfnNetworkInsightsPath.PathFilterProperty;

  /**
   * Scopes the analysis to network paths that match specific filters at the source.
   */
  public filterAtSource?: cdk.IResolvable | CfnNetworkInsightsPath.PathFilterProperty;

  /**
   * The protocol.
   */
  public protocol: string;

  /**
   * The ID or ARN of the source.
   */
  public source: string;

  /**
   * The IP address of the source.
   */
  public sourceIp?: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags to add to the path.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnNetworkInsightsPathProps) {
    super(scope, id, {
      "type": CfnNetworkInsightsPath.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "protocol", this);
    cdk.requireProperty(props, "source", this);

    this.attrCreatedDate = cdk.Token.asString(this.getAtt("CreatedDate", cdk.ResolutionTypeHint.STRING));
    this.attrDestinationArn = cdk.Token.asString(this.getAtt("DestinationArn", cdk.ResolutionTypeHint.STRING));
    this.attrNetworkInsightsPathArn = cdk.Token.asString(this.getAtt("NetworkInsightsPathArn", cdk.ResolutionTypeHint.STRING));
    this.attrNetworkInsightsPathId = cdk.Token.asString(this.getAtt("NetworkInsightsPathId", cdk.ResolutionTypeHint.STRING));
    this.attrSourceArn = cdk.Token.asString(this.getAtt("SourceArn", cdk.ResolutionTypeHint.STRING));
    this.destination = props.destination;
    this.destinationIp = props.destinationIp;
    this.destinationPort = props.destinationPort;
    this.filterAtDestination = props.filterAtDestination;
    this.filterAtSource = props.filterAtSource;
    this.protocol = props.protocol;
    this.source = props.source;
    this.sourceIp = props.sourceIp;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::NetworkInsightsPath", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "destination": this.destination,
      "destinationIp": this.destinationIp,
      "destinationPort": this.destinationPort,
      "filterAtDestination": this.filterAtDestination,
      "filterAtSource": this.filterAtSource,
      "protocol": this.protocol,
      "source": this.source,
      "sourceIp": this.sourceIp,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnNetworkInsightsPath.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnNetworkInsightsPathPropsToCloudFormation(props);
  }
}

export namespace CfnNetworkInsightsPath {
  /**
   * Describes a set of filters for a path analysis.
   *
   * Use path filters to scope the analysis when there can be multiple resulting paths.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightspath-pathfilter.html
   */
  export interface PathFilterProperty {
    /**
     * The destination IPv4 address.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightspath-pathfilter.html#cfn-ec2-networkinsightspath-pathfilter-destinationaddress
     */
    readonly destinationAddress?: string;

    /**
     * The destination port range.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightspath-pathfilter.html#cfn-ec2-networkinsightspath-pathfilter-destinationportrange
     */
    readonly destinationPortRange?: CfnNetworkInsightsPath.FilterPortRangeProperty | cdk.IResolvable;

    /**
     * The source IPv4 address.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightspath-pathfilter.html#cfn-ec2-networkinsightspath-pathfilter-sourceaddress
     */
    readonly sourceAddress?: string;

    /**
     * The source port range.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightspath-pathfilter.html#cfn-ec2-networkinsightspath-pathfilter-sourceportrange
     */
    readonly sourcePortRange?: CfnNetworkInsightsPath.FilterPortRangeProperty | cdk.IResolvable;
  }

  /**
   * Describes a port range.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightspath-filterportrange.html
   */
  export interface FilterPortRangeProperty {
    /**
     * The first port in the range.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightspath-filterportrange.html#cfn-ec2-networkinsightspath-filterportrange-fromport
     */
    readonly fromPort?: number;

    /**
     * The last port in the range.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightspath-filterportrange.html#cfn-ec2-networkinsightspath-filterportrange-toport
     */
    readonly toPort?: number;
  }
}

/**
 * Properties for defining a \`CfnNetworkInsightsPath\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html
 */
export interface CfnNetworkInsightsPathProps {
  /**
   * The ID or ARN of the destination.
   *
   * If the resource is in another account, you must specify an ARN.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-destination
   */
  readonly destination?: string;

  /**
   * The IP address of the destination.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-destinationip
   */
  readonly destinationIp?: string;

  /**
   * The destination port.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-destinationport
   */
  readonly destinationPort?: number;

  /**
   * Scopes the analysis to network paths that match specific filters at the destination.
   *
   * If you specify this parameter, you can't specify the parameter for the destination IP address.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-filteratdestination
   */
  readonly filterAtDestination?: cdk.IResolvable | CfnNetworkInsightsPath.PathFilterProperty;

  /**
   * Scopes the analysis to network paths that match specific filters at the source.
   *
   * If you specify this parameter, you can't specify the parameters for the source IP address or the destination port.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-filteratsource
   */
  readonly filterAtSource?: cdk.IResolvable | CfnNetworkInsightsPath.PathFilterProperty;

  /**
   * The protocol.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-protocol
   */
  readonly protocol: string;

  /**
   * The ID or ARN of the source.
   *
   * If the resource is in another account, you must specify an ARN.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-source
   */
  readonly source: string;

  /**
   * The IP address of the source.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-sourceip
   */
  readonly sourceIp?: string;

  /**
   * The tags to add to the path.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a \`FilterPortRangeProperty\`
 *
 * @param properties - the TypeScript properties of a \`FilterPortRangeProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInsightsPathFilterPortRangePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("fromPort", cdk.validateNumber)(properties.fromPort));
  errors.collect(cdk.propertyValidator("toPort", cdk.validateNumber)(properties.toPort));
  return errors.wrap("supplied properties not correct for \\"FilterPortRangeProperty\\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInsightsPathFilterPortRangePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInsightsPathFilterPortRangePropertyValidator(properties).assertSuccess();
  return {
    "FromPort": cdk.numberToCloudFormation(properties.fromPort),
    "ToPort": cdk.numberToCloudFormation(properties.toPort)
  };
}

// @ts-ignore TS6133
function CfnNetworkInsightsPathFilterPortRangePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNetworkInsightsPath.FilterPortRangeProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInsightsPath.FilterPortRangeProperty>();
  ret.addPropertyResult("fromPort", "FromPort", (properties.FromPort != null ? cfn_parse.FromCloudFormation.getNumber(properties.FromPort) : undefined));
  ret.addPropertyResult("toPort", "ToPort", (properties.ToPort != null ? cfn_parse.FromCloudFormation.getNumber(properties.ToPort) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`PathFilterProperty\`
 *
 * @param properties - the TypeScript properties of a \`PathFilterProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInsightsPathPathFilterPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("destinationAddress", cdk.validateString)(properties.destinationAddress));
  errors.collect(cdk.propertyValidator("destinationPortRange", CfnNetworkInsightsPathFilterPortRangePropertyValidator)(properties.destinationPortRange));
  errors.collect(cdk.propertyValidator("sourceAddress", cdk.validateString)(properties.sourceAddress));
  errors.collect(cdk.propertyValidator("sourcePortRange", CfnNetworkInsightsPathFilterPortRangePropertyValidator)(properties.sourcePortRange));
  return errors.wrap("supplied properties not correct for \\"PathFilterProperty\\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInsightsPathPathFilterPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInsightsPathPathFilterPropertyValidator(properties).assertSuccess();
  return {
    "DestinationAddress": cdk.stringToCloudFormation(properties.destinationAddress),
    "DestinationPortRange": convertCfnNetworkInsightsPathFilterPortRangePropertyToCloudFormation(properties.destinationPortRange),
    "SourceAddress": cdk.stringToCloudFormation(properties.sourceAddress),
    "SourcePortRange": convertCfnNetworkInsightsPathFilterPortRangePropertyToCloudFormation(properties.sourcePortRange)
  };
}

// @ts-ignore TS6133
function CfnNetworkInsightsPathPathFilterPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnNetworkInsightsPath.PathFilterProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInsightsPath.PathFilterProperty>();
  ret.addPropertyResult("destinationAddress", "DestinationAddress", (properties.DestinationAddress != null ? cfn_parse.FromCloudFormation.getString(properties.DestinationAddress) : undefined));
  ret.addPropertyResult("destinationPortRange", "DestinationPortRange", (properties.DestinationPortRange != null ? CfnNetworkInsightsPathFilterPortRangePropertyFromCloudFormation(properties.DestinationPortRange) : undefined));
  ret.addPropertyResult("sourceAddress", "SourceAddress", (properties.SourceAddress != null ? cfn_parse.FromCloudFormation.getString(properties.SourceAddress) : undefined));
  ret.addPropertyResult("sourcePortRange", "SourcePortRange", (properties.SourcePortRange != null ? CfnNetworkInsightsPathFilterPortRangePropertyFromCloudFormation(properties.SourcePortRange) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnNetworkInsightsPathProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnNetworkInsightsPathProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInsightsPathPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("destination", cdk.validateString)(properties.destination));
  errors.collect(cdk.propertyValidator("destinationIp", cdk.validateString)(properties.destinationIp));
  errors.collect(cdk.propertyValidator("destinationPort", cdk.validateNumber)(properties.destinationPort));
  errors.collect(cdk.propertyValidator("filterAtDestination", CfnNetworkInsightsPathPathFilterPropertyValidator)(properties.filterAtDestination));
  errors.collect(cdk.propertyValidator("filterAtSource", CfnNetworkInsightsPathPathFilterPropertyValidator)(properties.filterAtSource));
  errors.collect(cdk.propertyValidator("protocol", cdk.requiredValidator)(properties.protocol));
  errors.collect(cdk.propertyValidator("protocol", cdk.validateString)(properties.protocol));
  errors.collect(cdk.propertyValidator("source", cdk.requiredValidator)(properties.source));
  errors.collect(cdk.propertyValidator("source", cdk.validateString)(properties.source));
  errors.collect(cdk.propertyValidator("sourceIp", cdk.validateString)(properties.sourceIp));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnNetworkInsightsPathProps\\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInsightsPathPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInsightsPathPropsValidator(properties).assertSuccess();
  return {
    "Destination": cdk.stringToCloudFormation(properties.destination),
    "DestinationIp": cdk.stringToCloudFormation(properties.destinationIp),
    "DestinationPort": cdk.numberToCloudFormation(properties.destinationPort),
    "FilterAtDestination": convertCfnNetworkInsightsPathPathFilterPropertyToCloudFormation(properties.filterAtDestination),
    "FilterAtSource": convertCfnNetworkInsightsPathPathFilterPropertyToCloudFormation(properties.filterAtSource),
    "Protocol": cdk.stringToCloudFormation(properties.protocol),
    "Source": cdk.stringToCloudFormation(properties.source),
    "SourceIp": cdk.stringToCloudFormation(properties.sourceIp),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnNetworkInsightsPathPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNetworkInsightsPathProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInsightsPathProps>();
  ret.addPropertyResult("destination", "Destination", (properties.Destination != null ? cfn_parse.FromCloudFormation.getString(properties.Destination) : undefined));
  ret.addPropertyResult("destinationIp", "DestinationIp", (properties.DestinationIp != null ? cfn_parse.FromCloudFormation.getString(properties.DestinationIp) : undefined));
  ret.addPropertyResult("destinationPort", "DestinationPort", (properties.DestinationPort != null ? cfn_parse.FromCloudFormation.getNumber(properties.DestinationPort) : undefined));
  ret.addPropertyResult("filterAtDestination", "FilterAtDestination", (properties.FilterAtDestination != null ? CfnNetworkInsightsPathPathFilterPropertyFromCloudFormation(properties.FilterAtDestination) : undefined));
  ret.addPropertyResult("filterAtSource", "FilterAtSource", (properties.FilterAtSource != null ? CfnNetworkInsightsPathPathFilterPropertyFromCloudFormation(properties.FilterAtSource) : undefined));
  ret.addPropertyResult("protocol", "Protocol", (properties.Protocol != null ? cfn_parse.FromCloudFormation.getString(properties.Protocol) : undefined));
  ret.addPropertyResult("source", "Source", (properties.Source != null ? cfn_parse.FromCloudFormation.getString(properties.Source) : undefined));
  ret.addPropertyResult("sourceIp", "SourceIp", (properties.SourceIp != null ? cfn_parse.FromCloudFormation.getString(properties.SourceIp) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Describes a network interface in an Amazon EC2 instance for AWS CloudFormation .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html
 */
export class CfnNetworkInterface extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::NetworkInterface";

  /**
   * Build a CfnNetworkInterface from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnNetworkInterface {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnNetworkInterfacePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnNetworkInterface(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the network interface.
   *
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The primary private IP address of the network interface. For example, \`10.0.0.192\` .
   *
   * @cloudformationAttribute PrimaryPrivateIpAddress
   */
  public readonly attrPrimaryPrivateIpAddress: string;

  /**
   * The secondary private IP addresses of the network interface. For example, \`["10.0.0.161", "10.0.0.162", "10.0.0.163"]\` .
   *
   * @cloudformationAttribute SecondaryPrivateIpAddresses
   */
  public readonly attrSecondaryPrivateIpAddresses: Array<string>;

  /**
   * A description for the network interface.
   */
  public description?: string;

  /**
   * If you have instances or ENIs that rely on the IPv6 address not changing, to avoid disrupting traffic to instances or ENIs, you can enable a primary IPv6 address.
   */
  public enablePrimaryIpv6?: boolean | cdk.IResolvable;

  /**
   * The security group IDs associated with this network interface.
   */
  public groupSet?: Array<string>;

  /**
   * The type of network interface.
   */
  public interfaceType?: string;

  /**
   * The number of IPv6 addresses to assign to a network interface.
   */
  public ipv6AddressCount?: number;

  /**
   * One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet to associate with the network interface.
   */
  public ipv6Addresses?: Array<CfnNetworkInterface.InstanceIpv6AddressProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * Assigns a single private IP address to the network interface, which is used as the primary private IP address.
   */
  public privateIpAddress?: string;

  /**
   * Assigns private IP addresses to the network interface.
   */
  public privateIpAddresses?: Array<cdk.IResolvable | CfnNetworkInterface.PrivateIpAddressSpecificationProperty> | cdk.IResolvable;

  /**
   * The number of secondary private IPv4 addresses to assign to a network interface.
   */
  public secondaryPrivateIpAddressCount?: number;

  /**
   * Enable or disable source/destination checks, which ensure that the instance is either the source or the destination of any traffic that it receives.
   */
  public sourceDestCheck?: boolean | cdk.IResolvable;

  /**
   * The ID of the subnet to associate with the network interface.
   */
  public subnetId: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * An arbitrary set of tags (key-value pairs) for this network interface.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnNetworkInterfaceProps) {
    super(scope, id, {
      "type": CfnNetworkInterface.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "subnetId", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.attrPrimaryPrivateIpAddress = cdk.Token.asString(this.getAtt("PrimaryPrivateIpAddress", cdk.ResolutionTypeHint.STRING));
    this.attrSecondaryPrivateIpAddresses = cdk.Token.asList(this.getAtt("SecondaryPrivateIpAddresses", cdk.ResolutionTypeHint.STRING_LIST));
    this.description = props.description;
    this.enablePrimaryIpv6 = props.enablePrimaryIpv6;
    this.groupSet = props.groupSet;
    this.interfaceType = props.interfaceType;
    this.ipv6AddressCount = props.ipv6AddressCount;
    this.ipv6Addresses = props.ipv6Addresses;
    this.privateIpAddress = props.privateIpAddress;
    this.privateIpAddresses = props.privateIpAddresses;
    this.secondaryPrivateIpAddressCount = props.secondaryPrivateIpAddressCount;
    this.sourceDestCheck = props.sourceDestCheck;
    this.subnetId = props.subnetId;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::NetworkInterface", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "description": this.description,
      "enablePrimaryIpv6": this.enablePrimaryIpv6,
      "groupSet": this.groupSet,
      "interfaceType": this.interfaceType,
      "ipv6AddressCount": this.ipv6AddressCount,
      "ipv6Addresses": this.ipv6Addresses,
      "privateIpAddress": this.privateIpAddress,
      "privateIpAddresses": this.privateIpAddresses,
      "secondaryPrivateIpAddressCount": this.secondaryPrivateIpAddressCount,
      "sourceDestCheck": this.sourceDestCheck,
      "subnetId": this.subnetId,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnNetworkInterface.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnNetworkInterfacePropsToCloudFormation(props);
  }
}

export namespace CfnNetworkInterface {
  /**
   * Describes a secondary private IPv4 address for a network interface.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-privateipaddressspecification.html
   */
  export interface PrivateIpAddressSpecificationProperty {
    /**
     * Sets the private IP address as the primary private address.
     *
     * You can set only one primary private IP address. If you don't specify a primary private IP address, Amazon EC2 automatically assigns a primary private IP address.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-privateipaddressspecification.html#cfn-ec2-networkinterface-privateipaddressspecification-primary
     */
    readonly primary: boolean | cdk.IResolvable;

    /**
     * The private IP address of the network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-privateipaddressspecification.html#cfn-ec2-networkinterface-privateipaddressspecification-privateipaddress
     */
    readonly privateIpAddress: string;
  }

  /**
   * Describes the IPv6 addresses to associate with the network interface.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-instanceipv6address.html
   */
  export interface InstanceIpv6AddressProperty {
    /**
     * An IPv6 address to associate with the network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-instanceipv6address.html#cfn-ec2-networkinterface-instanceipv6address-ipv6address
     */
    readonly ipv6Address: string;
  }
}

/**
 * Properties for defining a \`CfnNetworkInterface\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html
 */
export interface CfnNetworkInterfaceProps {
  /**
   * A description for the network interface.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-description
   */
  readonly description?: string;

  /**
   * If you have instances or ENIs that rely on the IPv6 address not changing, to avoid disrupting traffic to instances or ENIs, you can enable a primary IPv6 address.
   *
   * Enable this option to automatically assign an IPv6 associated with the ENI attached to your instance to be the primary IPv6 address. When you enable an IPv6 address to be a primary IPv6, you cannot disable it. Traffic will be routed to the primary IPv6 address until the instance is terminated or the ENI is detached. If you have multiple IPv6 addresses associated with an ENI and you enable a primary IPv6 address, the first IPv6 address associated with the ENI becomes the primary IPv6 address.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-enableprimaryipv6
   */
  readonly enablePrimaryIpv6?: boolean | cdk.IResolvable;

  /**
   * The security group IDs associated with this network interface.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-groupset
   */
  readonly groupSet?: Array<string>;

  /**
   * The type of network interface.
   *
   * The default is \`interface\` . The supported values are \`efa\` and \`trunk\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-interfacetype
   */
  readonly interfaceType?: string;

  /**
   * The number of IPv6 addresses to assign to a network interface.
   *
   * Amazon EC2 automatically selects the IPv6 addresses from the subnet range. To specify specific IPv6 addresses, use the \`Ipv6Addresses\` property and don't specify this property.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-ipv6addresscount
   */
  readonly ipv6AddressCount?: number;

  /**
   * One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet to associate with the network interface.
   *
   * If you're specifying a number of IPv6 addresses, use the \`Ipv6AddressCount\` property and don't specify this property.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-ipv6addresses
   */
  readonly ipv6Addresses?: Array<CfnNetworkInterface.InstanceIpv6AddressProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * Assigns a single private IP address to the network interface, which is used as the primary private IP address.
   *
   * If you want to specify multiple private IP address, use the \`PrivateIpAddresses\` property.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-privateipaddress
   */
  readonly privateIpAddress?: string;

  /**
   * Assigns private IP addresses to the network interface.
   *
   * You can specify a primary private IP address by setting the value of the \`Primary\` property to \`true\` in the \`PrivateIpAddressSpecification\` property. If you want EC2 to automatically assign private IP addresses, use the \`SecondaryPrivateIpAddressCount\` property and do not specify this property.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-privateipaddresses
   */
  readonly privateIpAddresses?: Array<cdk.IResolvable | CfnNetworkInterface.PrivateIpAddressSpecificationProperty> | cdk.IResolvable;

  /**
   * The number of secondary private IPv4 addresses to assign to a network interface.
   *
   * When you specify a number of secondary IPv4 addresses, Amazon EC2 selects these IP addresses within the subnet's IPv4 CIDR range. You can't specify this option and specify more than one private IP address using \`privateIpAddresses\` .
   *
   * You can't specify a count of private IPv4 addresses if you've specified one of the following: specific private IPv4 addresses, specific IPv4 prefixes, or a count of IPv4 prefixes.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-secondaryprivateipaddresscount
   */
  readonly secondaryPrivateIpAddressCount?: number;

  /**
   * Enable or disable source/destination checks, which ensure that the instance is either the source or the destination of any traffic that it receives.
   *
   * If the value is \`true\` , source/destination checks are enabled; otherwise, they are disabled. The default value is \`true\` . You must disable source/destination checks if the instance runs services such as network address translation, routing, or firewalls.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-sourcedestcheck
   */
  readonly sourceDestCheck?: boolean | cdk.IResolvable;

  /**
   * The ID of the subnet to associate with the network interface.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-subnetid
   */
  readonly subnetId: string;

  /**
   * An arbitrary set of tags (key-value pairs) for this network interface.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a \`PrivateIpAddressSpecificationProperty\`
 *
 * @param properties - the TypeScript properties of a \`PrivateIpAddressSpecificationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInterfacePrivateIpAddressSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("primary", cdk.requiredValidator)(properties.primary));
  errors.collect(cdk.propertyValidator("primary", cdk.validateBoolean)(properties.primary));
  errors.collect(cdk.propertyValidator("privateIpAddress", cdk.requiredValidator)(properties.privateIpAddress));
  errors.collect(cdk.propertyValidator("privateIpAddress", cdk.validateString)(properties.privateIpAddress));
  return errors.wrap("supplied properties not correct for \\"PrivateIpAddressSpecificationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInterfacePrivateIpAddressSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInterfacePrivateIpAddressSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "Primary": cdk.booleanToCloudFormation(properties.primary),
    "PrivateIpAddress": cdk.stringToCloudFormation(properties.privateIpAddress)
  };
}

// @ts-ignore TS6133
function CfnNetworkInterfacePrivateIpAddressSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnNetworkInterface.PrivateIpAddressSpecificationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInterface.PrivateIpAddressSpecificationProperty>();
  ret.addPropertyResult("primary", "Primary", (properties.Primary != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Primary) : undefined));
  ret.addPropertyResult("privateIpAddress", "PrivateIpAddress", (properties.PrivateIpAddress != null ? cfn_parse.FromCloudFormation.getString(properties.PrivateIpAddress) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`InstanceIpv6AddressProperty\`
 *
 * @param properties - the TypeScript properties of a \`InstanceIpv6AddressProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInterfaceInstanceIpv6AddressPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("ipv6Address", cdk.requiredValidator)(properties.ipv6Address));
  errors.collect(cdk.propertyValidator("ipv6Address", cdk.validateString)(properties.ipv6Address));
  return errors.wrap("supplied properties not correct for \\"InstanceIpv6AddressProperty\\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInterfaceInstanceIpv6AddressPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInterfaceInstanceIpv6AddressPropertyValidator(properties).assertSuccess();
  return {
    "Ipv6Address": cdk.stringToCloudFormation(properties.ipv6Address)
  };
}

// @ts-ignore TS6133
function CfnNetworkInterfaceInstanceIpv6AddressPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNetworkInterface.InstanceIpv6AddressProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInterface.InstanceIpv6AddressProperty>();
  ret.addPropertyResult("ipv6Address", "Ipv6Address", (properties.Ipv6Address != null ? cfn_parse.FromCloudFormation.getString(properties.Ipv6Address) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnNetworkInterfaceProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnNetworkInterfaceProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInterfacePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("enablePrimaryIpv6", cdk.validateBoolean)(properties.enablePrimaryIpv6));
  errors.collect(cdk.propertyValidator("groupSet", cdk.listValidator(cdk.validateString))(properties.groupSet));
  errors.collect(cdk.propertyValidator("interfaceType", cdk.validateString)(properties.interfaceType));
  errors.collect(cdk.propertyValidator("ipv6AddressCount", cdk.validateNumber)(properties.ipv6AddressCount));
  errors.collect(cdk.propertyValidator("ipv6Addresses", cdk.listValidator(CfnNetworkInterfaceInstanceIpv6AddressPropertyValidator))(properties.ipv6Addresses));
  errors.collect(cdk.propertyValidator("privateIpAddress", cdk.validateString)(properties.privateIpAddress));
  errors.collect(cdk.propertyValidator("privateIpAddresses", cdk.listValidator(CfnNetworkInterfacePrivateIpAddressSpecificationPropertyValidator))(properties.privateIpAddresses));
  errors.collect(cdk.propertyValidator("secondaryPrivateIpAddressCount", cdk.validateNumber)(properties.secondaryPrivateIpAddressCount));
  errors.collect(cdk.propertyValidator("sourceDestCheck", cdk.validateBoolean)(properties.sourceDestCheck));
  errors.collect(cdk.propertyValidator("subnetId", cdk.requiredValidator)(properties.subnetId));
  errors.collect(cdk.propertyValidator("subnetId", cdk.validateString)(properties.subnetId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnNetworkInterfaceProps\\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInterfacePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInterfacePropsValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "EnablePrimaryIpv6": cdk.booleanToCloudFormation(properties.enablePrimaryIpv6),
    "GroupSet": cdk.listMapper(cdk.stringToCloudFormation)(properties.groupSet),
    "InterfaceType": cdk.stringToCloudFormation(properties.interfaceType),
    "Ipv6AddressCount": cdk.numberToCloudFormation(properties.ipv6AddressCount),
    "Ipv6Addresses": cdk.listMapper(convertCfnNetworkInterfaceInstanceIpv6AddressPropertyToCloudFormation)(properties.ipv6Addresses),
    "PrivateIpAddress": cdk.stringToCloudFormation(properties.privateIpAddress),
    "PrivateIpAddresses": cdk.listMapper(convertCfnNetworkInterfacePrivateIpAddressSpecificationPropertyToCloudFormation)(properties.privateIpAddresses),
    "SecondaryPrivateIpAddressCount": cdk.numberToCloudFormation(properties.secondaryPrivateIpAddressCount),
    "SourceDestCheck": cdk.booleanToCloudFormation(properties.sourceDestCheck),
    "SubnetId": cdk.stringToCloudFormation(properties.subnetId),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnNetworkInterfacePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNetworkInterfaceProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInterfaceProps>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("enablePrimaryIpv6", "EnablePrimaryIpv6", (properties.EnablePrimaryIpv6 != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EnablePrimaryIpv6) : undefined));
  ret.addPropertyResult("groupSet", "GroupSet", (properties.GroupSet != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.GroupSet) : undefined));
  ret.addPropertyResult("interfaceType", "InterfaceType", (properties.InterfaceType != null ? cfn_parse.FromCloudFormation.getString(properties.InterfaceType) : undefined));
  ret.addPropertyResult("ipv6AddressCount", "Ipv6AddressCount", (properties.Ipv6AddressCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.Ipv6AddressCount) : undefined));
  ret.addPropertyResult("ipv6Addresses", "Ipv6Addresses", (properties.Ipv6Addresses != null ? cfn_parse.FromCloudFormation.getArray(CfnNetworkInterfaceInstanceIpv6AddressPropertyFromCloudFormation)(properties.Ipv6Addresses) : undefined));
  ret.addPropertyResult("privateIpAddress", "PrivateIpAddress", (properties.PrivateIpAddress != null ? cfn_parse.FromCloudFormation.getString(properties.PrivateIpAddress) : undefined));
  ret.addPropertyResult("privateIpAddresses", "PrivateIpAddresses", (properties.PrivateIpAddresses != null ? cfn_parse.FromCloudFormation.getArray(CfnNetworkInterfacePrivateIpAddressSpecificationPropertyFromCloudFormation)(properties.PrivateIpAddresses) : undefined));
  ret.addPropertyResult("secondaryPrivateIpAddressCount", "SecondaryPrivateIpAddressCount", (properties.SecondaryPrivateIpAddressCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.SecondaryPrivateIpAddressCount) : undefined));
  ret.addPropertyResult("sourceDestCheck", "SourceDestCheck", (properties.SourceDestCheck != null ? cfn_parse.FromCloudFormation.getBoolean(properties.SourceDestCheck) : undefined));
  ret.addPropertyResult("subnetId", "SubnetId", (properties.SubnetId != null ? cfn_parse.FromCloudFormation.getString(properties.SubnetId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Attaches an elastic network interface (ENI) to an Amazon EC2 instance.
 *
 * You can use this resource type to attach additional network interfaces to an instance without interruption.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfaceattachment.html
 */
export class CfnNetworkInterfaceAttachment extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::NetworkInterfaceAttachment";

  /**
   * Build a CfnNetworkInterfaceAttachment from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnNetworkInterfaceAttachment {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnNetworkInterfaceAttachmentPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnNetworkInterfaceAttachment(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * Whether to delete the network interface when the instance terminates.
   */
  public deleteOnTermination?: boolean | cdk.IResolvable;

  /**
   * The network interface's position in the attachment order.
   */
  public deviceIndex: string;

  /**
   * The ID of the instance to which you will attach the ENI.
   */
  public instanceId: string;

  /**
   * The ID of the ENI that you want to attach.
   */
  public networkInterfaceId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnNetworkInterfaceAttachmentProps) {
    super(scope, id, {
      "type": CfnNetworkInterfaceAttachment.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "deviceIndex", this);
    cdk.requireProperty(props, "instanceId", this);
    cdk.requireProperty(props, "networkInterfaceId", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.deleteOnTermination = props.deleteOnTermination;
    this.deviceIndex = props.deviceIndex;
    this.instanceId = props.instanceId;
    this.networkInterfaceId = props.networkInterfaceId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "deleteOnTermination": this.deleteOnTermination,
      "deviceIndex": this.deviceIndex,
      "instanceId": this.instanceId,
      "networkInterfaceId": this.networkInterfaceId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnNetworkInterfaceAttachment.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnNetworkInterfaceAttachmentPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnNetworkInterfaceAttachment\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfaceattachment.html
 */
export interface CfnNetworkInterfaceAttachmentProps {
  /**
   * Whether to delete the network interface when the instance terminates.
   *
   * By default, this value is set to \`true\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfaceattachment.html#cfn-ec2-networkinterfaceattachment-deleteontermination
   */
  readonly deleteOnTermination?: boolean | cdk.IResolvable;

  /**
   * The network interface's position in the attachment order.
   *
   * For example, the first attached network interface has a \`DeviceIndex\` of 0.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfaceattachment.html#cfn-ec2-networkinterfaceattachment-deviceindex
   */
  readonly deviceIndex: string;

  /**
   * The ID of the instance to which you will attach the ENI.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfaceattachment.html#cfn-ec2-networkinterfaceattachment-instanceid
   */
  readonly instanceId: string;

  /**
   * The ID of the ENI that you want to attach.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfaceattachment.html#cfn-ec2-networkinterfaceattachment-networkinterfaceid
   */
  readonly networkInterfaceId: string;
}

/**
 * Determine whether the given properties match those of a \`CfnNetworkInterfaceAttachmentProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnNetworkInterfaceAttachmentProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInterfaceAttachmentPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("deleteOnTermination", cdk.validateBoolean)(properties.deleteOnTermination));
  errors.collect(cdk.propertyValidator("deviceIndex", cdk.requiredValidator)(properties.deviceIndex));
  errors.collect(cdk.propertyValidator("deviceIndex", cdk.validateString)(properties.deviceIndex));
  errors.collect(cdk.propertyValidator("instanceId", cdk.requiredValidator)(properties.instanceId));
  errors.collect(cdk.propertyValidator("instanceId", cdk.validateString)(properties.instanceId));
  errors.collect(cdk.propertyValidator("networkInterfaceId", cdk.requiredValidator)(properties.networkInterfaceId));
  errors.collect(cdk.propertyValidator("networkInterfaceId", cdk.validateString)(properties.networkInterfaceId));
  return errors.wrap("supplied properties not correct for \\"CfnNetworkInterfaceAttachmentProps\\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInterfaceAttachmentPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInterfaceAttachmentPropsValidator(properties).assertSuccess();
  return {
    "DeleteOnTermination": cdk.booleanToCloudFormation(properties.deleteOnTermination),
    "DeviceIndex": cdk.stringToCloudFormation(properties.deviceIndex),
    "InstanceId": cdk.stringToCloudFormation(properties.instanceId),
    "NetworkInterfaceId": cdk.stringToCloudFormation(properties.networkInterfaceId)
  };
}

// @ts-ignore TS6133
function CfnNetworkInterfaceAttachmentPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNetworkInterfaceAttachmentProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInterfaceAttachmentProps>();
  ret.addPropertyResult("deleteOnTermination", "DeleteOnTermination", (properties.DeleteOnTermination != null ? cfn_parse.FromCloudFormation.getBoolean(properties.DeleteOnTermination) : undefined));
  ret.addPropertyResult("deviceIndex", "DeviceIndex", (properties.DeviceIndex != null ? cfn_parse.FromCloudFormation.getString(properties.DeviceIndex) : undefined));
  ret.addPropertyResult("instanceId", "InstanceId", (properties.InstanceId != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceId) : undefined));
  ret.addPropertyResult("networkInterfaceId", "NetworkInterfaceId", (properties.NetworkInterfaceId != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkInterfaceId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a permission for an Amazon EC2 network interface.
 *
 * For example, you can grant an AWS authorized partner account permission to attach the specified network interface to an instance in their account.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfacepermission.html
 */
export class CfnNetworkInterfacePermission extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::NetworkInterfacePermission";

  /**
   * Build a CfnNetworkInterfacePermission from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnNetworkInterfacePermission {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnNetworkInterfacePermissionPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnNetworkInterfacePermission(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The AWS account ID.
   */
  public awsAccountId: string;

  /**
   * The ID of the network interface.
   */
  public networkInterfaceId: string;

  /**
   * The type of permission to grant: \`INSTANCE-ATTACH\` or \`EIP-ASSOCIATE\` .
   */
  public permission: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnNetworkInterfacePermissionProps) {
    super(scope, id, {
      "type": CfnNetworkInterfacePermission.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "awsAccountId", this);
    cdk.requireProperty(props, "networkInterfaceId", this);
    cdk.requireProperty(props, "permission", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.awsAccountId = props.awsAccountId;
    this.networkInterfaceId = props.networkInterfaceId;
    this.permission = props.permission;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "awsAccountId": this.awsAccountId,
      "networkInterfaceId": this.networkInterfaceId,
      "permission": this.permission
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnNetworkInterfacePermission.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnNetworkInterfacePermissionPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnNetworkInterfacePermission\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfacepermission.html
 */
export interface CfnNetworkInterfacePermissionProps {
  /**
   * The AWS account ID.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfacepermission.html#cfn-ec2-networkinterfacepermission-awsaccountid
   */
  readonly awsAccountId: string;

  /**
   * The ID of the network interface.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfacepermission.html#cfn-ec2-networkinterfacepermission-networkinterfaceid
   */
  readonly networkInterfaceId: string;

  /**
   * The type of permission to grant: \`INSTANCE-ATTACH\` or \`EIP-ASSOCIATE\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfacepermission.html#cfn-ec2-networkinterfacepermission-permission
   */
  readonly permission: string;
}

/**
 * Determine whether the given properties match those of a \`CfnNetworkInterfacePermissionProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnNetworkInterfacePermissionProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInterfacePermissionPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("awsAccountId", cdk.requiredValidator)(properties.awsAccountId));
  errors.collect(cdk.propertyValidator("awsAccountId", cdk.validateString)(properties.awsAccountId));
  errors.collect(cdk.propertyValidator("networkInterfaceId", cdk.requiredValidator)(properties.networkInterfaceId));
  errors.collect(cdk.propertyValidator("networkInterfaceId", cdk.validateString)(properties.networkInterfaceId));
  errors.collect(cdk.propertyValidator("permission", cdk.requiredValidator)(properties.permission));
  errors.collect(cdk.propertyValidator("permission", cdk.validateString)(properties.permission));
  return errors.wrap("supplied properties not correct for \\"CfnNetworkInterfacePermissionProps\\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInterfacePermissionPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInterfacePermissionPropsValidator(properties).assertSuccess();
  return {
    "AwsAccountId": cdk.stringToCloudFormation(properties.awsAccountId),
    "NetworkInterfaceId": cdk.stringToCloudFormation(properties.networkInterfaceId),
    "Permission": cdk.stringToCloudFormation(properties.permission)
  };
}

// @ts-ignore TS6133
function CfnNetworkInterfacePermissionPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNetworkInterfacePermissionProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInterfacePermissionProps>();
  ret.addPropertyResult("awsAccountId", "AwsAccountId", (properties.AwsAccountId != null ? cfn_parse.FromCloudFormation.getString(properties.AwsAccountId) : undefined));
  ret.addPropertyResult("networkInterfaceId", "NetworkInterfaceId", (properties.NetworkInterfaceId != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkInterfaceId) : undefined));
  ret.addPropertyResult("permission", "Permission", (properties.Permission != null ? cfn_parse.FromCloudFormation.getString(properties.Permission) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Describes Infrastructure Performance subscriptions.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkperformancemetricsubscription.html
 */
export class CfnNetworkPerformanceMetricSubscription extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::NetworkPerformanceMetricSubscription";

  /**
   * Build a CfnNetworkPerformanceMetricSubscription from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnNetworkPerformanceMetricSubscription {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnNetworkPerformanceMetricSubscriptionPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnNetworkPerformanceMetricSubscription(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The Region or Availability Zone that's the target for the subscription.
   */
  public destination: string;

  /**
   * The metric used for the subscription.
   */
  public metric: string;

  /**
   * The Region or Availability Zone that's the source for the subscription.
   */
  public source: string;

  /**
   * The statistic used for the subscription.
   */
  public statistic: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnNetworkPerformanceMetricSubscriptionProps) {
    super(scope, id, {
      "type": CfnNetworkPerformanceMetricSubscription.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "destination", this);
    cdk.requireProperty(props, "metric", this);
    cdk.requireProperty(props, "source", this);
    cdk.requireProperty(props, "statistic", this);

    this.destination = props.destination;
    this.metric = props.metric;
    this.source = props.source;
    this.statistic = props.statistic;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "destination": this.destination,
      "metric": this.metric,
      "source": this.source,
      "statistic": this.statistic
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnNetworkPerformanceMetricSubscription.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnNetworkPerformanceMetricSubscriptionPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnNetworkPerformanceMetricSubscription\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkperformancemetricsubscription.html
 */
export interface CfnNetworkPerformanceMetricSubscriptionProps {
  /**
   * The Region or Availability Zone that's the target for the subscription.
   *
   * For example, \`eu-west-1\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkperformancemetricsubscription.html#cfn-ec2-networkperformancemetricsubscription-destination
   */
  readonly destination: string;

  /**
   * The metric used for the subscription.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkperformancemetricsubscription.html#cfn-ec2-networkperformancemetricsubscription-metric
   */
  readonly metric: string;

  /**
   * The Region or Availability Zone that's the source for the subscription.
   *
   * For example, \`us-east-1\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkperformancemetricsubscription.html#cfn-ec2-networkperformancemetricsubscription-source
   */
  readonly source: string;

  /**
   * The statistic used for the subscription.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkperformancemetricsubscription.html#cfn-ec2-networkperformancemetricsubscription-statistic
   */
  readonly statistic: string;
}

/**
 * Determine whether the given properties match those of a \`CfnNetworkPerformanceMetricSubscriptionProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnNetworkPerformanceMetricSubscriptionProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkPerformanceMetricSubscriptionPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("destination", cdk.requiredValidator)(properties.destination));
  errors.collect(cdk.propertyValidator("destination", cdk.validateString)(properties.destination));
  errors.collect(cdk.propertyValidator("metric", cdk.requiredValidator)(properties.metric));
  errors.collect(cdk.propertyValidator("metric", cdk.validateString)(properties.metric));
  errors.collect(cdk.propertyValidator("source", cdk.requiredValidator)(properties.source));
  errors.collect(cdk.propertyValidator("source", cdk.validateString)(properties.source));
  errors.collect(cdk.propertyValidator("statistic", cdk.requiredValidator)(properties.statistic));
  errors.collect(cdk.propertyValidator("statistic", cdk.validateString)(properties.statistic));
  return errors.wrap("supplied properties not correct for \\"CfnNetworkPerformanceMetricSubscriptionProps\\"");
}

// @ts-ignore TS6133
function convertCfnNetworkPerformanceMetricSubscriptionPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkPerformanceMetricSubscriptionPropsValidator(properties).assertSuccess();
  return {
    "Destination": cdk.stringToCloudFormation(properties.destination),
    "Metric": cdk.stringToCloudFormation(properties.metric),
    "Source": cdk.stringToCloudFormation(properties.source),
    "Statistic": cdk.stringToCloudFormation(properties.statistic)
  };
}

// @ts-ignore TS6133
function CfnNetworkPerformanceMetricSubscriptionPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNetworkPerformanceMetricSubscriptionProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkPerformanceMetricSubscriptionProps>();
  ret.addPropertyResult("destination", "Destination", (properties.Destination != null ? cfn_parse.FromCloudFormation.getString(properties.Destination) : undefined));
  ret.addPropertyResult("metric", "Metric", (properties.Metric != null ? cfn_parse.FromCloudFormation.getString(properties.Metric) : undefined));
  ret.addPropertyResult("source", "Source", (properties.Source != null ? cfn_parse.FromCloudFormation.getString(properties.Source) : undefined));
  ret.addPropertyResult("statistic", "Statistic", (properties.Statistic != null ? cfn_parse.FromCloudFormation.getString(properties.Statistic) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a placement group in which to launch instances.
 *
 * The strategy of the placement group determines how the instances are organized within the group.
 *
 * A \`cluster\` placement group is a logical grouping of instances within a single Availability Zone that benefit from low network latency, high network throughput. A \`spread\` placement group places instances on distinct hardware. A \`partition\` placement group places groups of instances in different partitions, where instances in one partition do not share the same hardware with instances in another partition.
 *
 * For more information, see [Placement Groups](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/placement-groups.html) in the *Amazon EC2 User Guide* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-placementgroup.html
 */
export class CfnPlacementGroup extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::PlacementGroup";

  /**
   * Build a CfnPlacementGroup from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnPlacementGroup {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnPlacementGroupPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnPlacementGroup(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The name of the placement group.
   *
   * @cloudformationAttribute GroupName
   */
  public readonly attrGroupName: string;

  /**
   * The number of partitions.
   */
  public partitionCount?: number;

  /**
   * Determines how placement groups spread instances.
   */
  public spreadLevel?: string;

  /**
   * The placement strategy.
   */
  public strategy?: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags to apply to the new placement group.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnPlacementGroupProps = {}) {
    super(scope, id, {
      "type": CfnPlacementGroup.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.attrGroupName = cdk.Token.asString(this.getAtt("GroupName", cdk.ResolutionTypeHint.STRING));
    this.partitionCount = props.partitionCount;
    this.spreadLevel = props.spreadLevel;
    this.strategy = props.strategy;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::PlacementGroup", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "partitionCount": this.partitionCount,
      "spreadLevel": this.spreadLevel,
      "strategy": this.strategy,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnPlacementGroup.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnPlacementGroupPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnPlacementGroup\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-placementgroup.html
 */
export interface CfnPlacementGroupProps {
  /**
   * The number of partitions.
   *
   * Valid only when *Strategy* is set to \`partition\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-placementgroup.html#cfn-ec2-placementgroup-partitioncount
   */
  readonly partitionCount?: number;

  /**
   * Determines how placement groups spread instances.
   *
   * - Host  You can use \`host\` only with Outpost placement groups.
   * - Rack  No usage restrictions.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-placementgroup.html#cfn-ec2-placementgroup-spreadlevel
   */
  readonly spreadLevel?: string;

  /**
   * The placement strategy.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-placementgroup.html#cfn-ec2-placementgroup-strategy
   */
  readonly strategy?: string;

  /**
   * The tags to apply to the new placement group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-placementgroup.html#cfn-ec2-placementgroup-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a \`CfnPlacementGroupProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnPlacementGroupProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnPlacementGroupPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("partitionCount", cdk.validateNumber)(properties.partitionCount));
  errors.collect(cdk.propertyValidator("spreadLevel", cdk.validateString)(properties.spreadLevel));
  errors.collect(cdk.propertyValidator("strategy", cdk.validateString)(properties.strategy));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnPlacementGroupProps\\"");
}

// @ts-ignore TS6133
function convertCfnPlacementGroupPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnPlacementGroupPropsValidator(properties).assertSuccess();
  return {
    "PartitionCount": cdk.numberToCloudFormation(properties.partitionCount),
    "SpreadLevel": cdk.stringToCloudFormation(properties.spreadLevel),
    "Strategy": cdk.stringToCloudFormation(properties.strategy),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnPlacementGroupPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnPlacementGroupProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnPlacementGroupProps>();
  ret.addPropertyResult("partitionCount", "PartitionCount", (properties.PartitionCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.PartitionCount) : undefined));
  ret.addPropertyResult("spreadLevel", "SpreadLevel", (properties.SpreadLevel != null ? cfn_parse.FromCloudFormation.getString(properties.SpreadLevel) : undefined));
  ret.addPropertyResult("strategy", "Strategy", (properties.Strategy != null ? cfn_parse.FromCloudFormation.getString(properties.Strategy) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a managed prefix list.
 *
 * You can add one or more entries to the prefix list. Each entry consists of a CIDR block and an optional description.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-prefixlist.html
 */
export class CfnPrefixList extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::PrefixList";

  /**
   * Build a CfnPrefixList from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnPrefixList {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnPrefixListPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnPrefixList(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ARN of the prefix list. For example, \`arn:aws:ec2:us-east-1:123456789012:prefix-list/pl-0123123123123abcd\` .
   *
   * @cloudformationAttribute Arn
   */
  public readonly attrArn: string;

  /**
   * The ID of the owner of the prefix list. For example, \`123456789012\` .
   *
   * @cloudformationAttribute OwnerId
   */
  public readonly attrOwnerId: string;

  /**
   * The ID of the prefix list. For example, \`pl-0123123123123abcd\` .
   *
   * @cloudformationAttribute PrefixListId
   */
  public readonly attrPrefixListId: string;

  /**
   * The version of the prefix list. For example, \`1\` .
   *
   * @cloudformationAttribute Version
   */
  public readonly attrVersion: number;

  /**
   * The IP address type.
   */
  public addressFamily: string;

  /**
   * One or more entries for the prefix list.
   */
  public entries?: Array<CfnPrefixList.EntryProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * The maximum number of entries for the prefix list.
   */
  public maxEntries: number;

  /**
   * A name for the prefix list.
   */
  public prefixListName: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags for the prefix list.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnPrefixListProps) {
    super(scope, id, {
      "type": CfnPrefixList.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "addressFamily", this);
    cdk.requireProperty(props, "maxEntries", this);
    cdk.requireProperty(props, "prefixListName", this);

    this.attrArn = cdk.Token.asString(this.getAtt("Arn", cdk.ResolutionTypeHint.STRING));
    this.attrOwnerId = cdk.Token.asString(this.getAtt("OwnerId", cdk.ResolutionTypeHint.STRING));
    this.attrPrefixListId = cdk.Token.asString(this.getAtt("PrefixListId", cdk.ResolutionTypeHint.STRING));
    this.attrVersion = cdk.Token.asNumber(this.getAtt("Version", cdk.ResolutionTypeHint.NUMBER));
    this.addressFamily = props.addressFamily;
    this.entries = props.entries;
    this.maxEntries = props.maxEntries;
    this.prefixListName = props.prefixListName;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::PrefixList", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "addressFamily": this.addressFamily,
      "entries": this.entries,
      "maxEntries": this.maxEntries,
      "prefixListName": this.prefixListName,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnPrefixList.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnPrefixListPropsToCloudFormation(props);
  }
}

export namespace CfnPrefixList {
  /**
   * An entry for a prefix list.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-prefixlist-entry.html
   */
  export interface EntryProperty {
    /**
     * The CIDR block.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-prefixlist-entry.html#cfn-ec2-prefixlist-entry-cidr
     */
    readonly cidr: string;

    /**
     * A description for the entry.
     *
     * Constraints: Up to 255 characters in length.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-prefixlist-entry.html#cfn-ec2-prefixlist-entry-description
     */
    readonly description?: string;
  }
}

/**
 * Properties for defining a \`CfnPrefixList\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-prefixlist.html
 */
export interface CfnPrefixListProps {
  /**
   * The IP address type.
   *
   * Valid Values: \`IPv4\` | \`IPv6\`
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-prefixlist.html#cfn-ec2-prefixlist-addressfamily
   */
  readonly addressFamily: string;

  /**
   * One or more entries for the prefix list.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-prefixlist.html#cfn-ec2-prefixlist-entries
   */
  readonly entries?: Array<CfnPrefixList.EntryProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * The maximum number of entries for the prefix list.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-prefixlist.html#cfn-ec2-prefixlist-maxentries
   */
  readonly maxEntries: number;

  /**
   * A name for the prefix list.
   *
   * Constraints: Up to 255 characters in length. The name cannot start with \`com.amazonaws\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-prefixlist.html#cfn-ec2-prefixlist-prefixlistname
   */
  readonly prefixListName: string;

  /**
   * The tags for the prefix list.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-prefixlist.html#cfn-ec2-prefixlist-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a \`EntryProperty\`
 *
 * @param properties - the TypeScript properties of a \`EntryProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnPrefixListEntryPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("cidr", cdk.requiredValidator)(properties.cidr));
  errors.collect(cdk.propertyValidator("cidr", cdk.validateString)(properties.cidr));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  return errors.wrap("supplied properties not correct for \\"EntryProperty\\"");
}

// @ts-ignore TS6133
function convertCfnPrefixListEntryPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnPrefixListEntryPropertyValidator(properties).assertSuccess();
  return {
    "Cidr": cdk.stringToCloudFormation(properties.cidr),
    "Description": cdk.stringToCloudFormation(properties.description)
  };
}

// @ts-ignore TS6133
function CfnPrefixListEntryPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnPrefixList.EntryProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnPrefixList.EntryProperty>();
  ret.addPropertyResult("cidr", "Cidr", (properties.Cidr != null ? cfn_parse.FromCloudFormation.getString(properties.Cidr) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnPrefixListProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnPrefixListProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnPrefixListPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("addressFamily", cdk.requiredValidator)(properties.addressFamily));
  errors.collect(cdk.propertyValidator("addressFamily", cdk.validateString)(properties.addressFamily));
  errors.collect(cdk.propertyValidator("entries", cdk.listValidator(CfnPrefixListEntryPropertyValidator))(properties.entries));
  errors.collect(cdk.propertyValidator("maxEntries", cdk.requiredValidator)(properties.maxEntries));
  errors.collect(cdk.propertyValidator("maxEntries", cdk.validateNumber)(properties.maxEntries));
  errors.collect(cdk.propertyValidator("prefixListName", cdk.requiredValidator)(properties.prefixListName));
  errors.collect(cdk.propertyValidator("prefixListName", cdk.validateString)(properties.prefixListName));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnPrefixListProps\\"");
}

// @ts-ignore TS6133
function convertCfnPrefixListPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnPrefixListPropsValidator(properties).assertSuccess();
  return {
    "AddressFamily": cdk.stringToCloudFormation(properties.addressFamily),
    "Entries": cdk.listMapper(convertCfnPrefixListEntryPropertyToCloudFormation)(properties.entries),
    "MaxEntries": cdk.numberToCloudFormation(properties.maxEntries),
    "PrefixListName": cdk.stringToCloudFormation(properties.prefixListName),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnPrefixListPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnPrefixListProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnPrefixListProps>();
  ret.addPropertyResult("addressFamily", "AddressFamily", (properties.AddressFamily != null ? cfn_parse.FromCloudFormation.getString(properties.AddressFamily) : undefined));
  ret.addPropertyResult("entries", "Entries", (properties.Entries != null ? cfn_parse.FromCloudFormation.getArray(CfnPrefixListEntryPropertyFromCloudFormation)(properties.Entries) : undefined));
  ret.addPropertyResult("maxEntries", "MaxEntries", (properties.MaxEntries != null ? cfn_parse.FromCloudFormation.getNumber(properties.MaxEntries) : undefined));
  ret.addPropertyResult("prefixListName", "PrefixListName", (properties.PrefixListName != null ? cfn_parse.FromCloudFormation.getString(properties.PrefixListName) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a route in a route table.
 *
 * You must specify either \`DestinationCidrBlock\` or \`DestinationIpv6CidrBlock\` , plus the ID of one of the target resources.
 *
 * If you create a route that references a transit gateway in the same template where you create the transit gateway, you must declare a dependency on the transit gateway attachment. The route table cannot use the transit gateway until it has successfully attached to the VPC. Add a [DependsOn Attribute](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-dependson.html) in the \`AWS::EC2::Route\` resource to explicitly declare a dependency on the \`AWS::EC2::TransitGatewayAttachment\` resource.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html
 */
export class CfnRoute extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::Route";

  /**
   * Build a CfnRoute from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnRoute {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnRoutePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnRoute(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The ID of the carrier gateway.
   */
  public carrierGatewayId?: string;

  /**
   * The IPv4 CIDR address block used for the destination match.
   */
  public destinationCidrBlock?: string;

  /**
   * The IPv6 CIDR block used for the destination match.
   */
  public destinationIpv6CidrBlock?: string;

  /**
   * [IPv6 traffic only] The ID of an egress-only internet gateway.
   */
  public egressOnlyInternetGatewayId?: string;

  /**
   * The ID of an internet gateway or virtual private gateway attached to your VPC.
   */
  public gatewayId?: string;

  /**
   * The ID of a NAT instance in your VPC.
   */
  public instanceId?: string;

  /**
   * The ID of the local gateway.
   */
  public localGatewayId?: string;

  /**
   * [IPv4 traffic only] The ID of a NAT gateway.
   */
  public natGatewayId?: string;

  /**
   * The ID of a network interface.
   */
  public networkInterfaceId?: string;

  /**
   * The ID of the route table for the route.
   */
  public routeTableId: string;

  /**
   * The ID of a transit gateway.
   */
  public transitGatewayId?: string;

  /**
   * The ID of a VPC endpoint.
   */
  public vpcEndpointId?: string;

  /**
   * The ID of a VPC peering connection.
   */
  public vpcPeeringConnectionId?: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnRouteProps) {
    super(scope, id, {
      "type": CfnRoute.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "routeTableId", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.carrierGatewayId = props.carrierGatewayId;
    this.destinationCidrBlock = props.destinationCidrBlock;
    this.destinationIpv6CidrBlock = props.destinationIpv6CidrBlock;
    this.egressOnlyInternetGatewayId = props.egressOnlyInternetGatewayId;
    this.gatewayId = props.gatewayId;
    this.instanceId = props.instanceId;
    this.localGatewayId = props.localGatewayId;
    this.natGatewayId = props.natGatewayId;
    this.networkInterfaceId = props.networkInterfaceId;
    this.routeTableId = props.routeTableId;
    this.transitGatewayId = props.transitGatewayId;
    this.vpcEndpointId = props.vpcEndpointId;
    this.vpcPeeringConnectionId = props.vpcPeeringConnectionId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "carrierGatewayId": this.carrierGatewayId,
      "destinationCidrBlock": this.destinationCidrBlock,
      "destinationIpv6CidrBlock": this.destinationIpv6CidrBlock,
      "egressOnlyInternetGatewayId": this.egressOnlyInternetGatewayId,
      "gatewayId": this.gatewayId,
      "instanceId": this.instanceId,
      "localGatewayId": this.localGatewayId,
      "natGatewayId": this.natGatewayId,
      "networkInterfaceId": this.networkInterfaceId,
      "routeTableId": this.routeTableId,
      "transitGatewayId": this.transitGatewayId,
      "vpcEndpointId": this.vpcEndpointId,
      "vpcPeeringConnectionId": this.vpcPeeringConnectionId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnRoute.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnRoutePropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnRoute\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html
 */
export interface CfnRouteProps {
  /**
   * The ID of the carrier gateway.
   *
   * You can only use this option when the VPC contains a subnet which is associated with a Wavelength Zone.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-carriergatewayid
   */
  readonly carrierGatewayId?: string;

  /**
   * The IPv4 CIDR address block used for the destination match.
   *
   * Routing decisions are based on the most specific match. We modify the specified CIDR block to its canonical form; for example, if you specify \`100.68.0.18/18\` , we modify it to \`100.68.0.0/18\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-destinationcidrblock
   */
  readonly destinationCidrBlock?: string;

  /**
   * The IPv6 CIDR block used for the destination match.
   *
   * Routing decisions are based on the most specific match.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-destinationipv6cidrblock
   */
  readonly destinationIpv6CidrBlock?: string;

  /**
   * [IPv6 traffic only] The ID of an egress-only internet gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-egressonlyinternetgatewayid
   */
  readonly egressOnlyInternetGatewayId?: string;

  /**
   * The ID of an internet gateway or virtual private gateway attached to your VPC.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-gatewayid
   */
  readonly gatewayId?: string;

  /**
   * The ID of a NAT instance in your VPC.
   *
   * The operation fails if you specify an instance ID unless exactly one network interface is attached.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-instanceid
   */
  readonly instanceId?: string;

  /**
   * The ID of the local gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-localgatewayid
   */
  readonly localGatewayId?: string;

  /**
   * [IPv4 traffic only] The ID of a NAT gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-natgatewayid
   */
  readonly natGatewayId?: string;

  /**
   * The ID of a network interface.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-networkinterfaceid
   */
  readonly networkInterfaceId?: string;

  /**
   * The ID of the route table for the route.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-routetableid
   */
  readonly routeTableId: string;

  /**
   * The ID of a transit gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-transitgatewayid
   */
  readonly transitGatewayId?: string;

  /**
   * The ID of a VPC endpoint.
   *
   * Supported for Gateway Load Balancer endpoints only.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-vpcendpointid
   */
  readonly vpcEndpointId?: string;

  /**
   * The ID of a VPC peering connection.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-vpcpeeringconnectionid
   */
  readonly vpcPeeringConnectionId?: string;
}

/**
 * Determine whether the given properties match those of a \`CfnRouteProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnRouteProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnRoutePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("carrierGatewayId", cdk.validateString)(properties.carrierGatewayId));
  errors.collect(cdk.propertyValidator("destinationCidrBlock", cdk.validateString)(properties.destinationCidrBlock));
  errors.collect(cdk.propertyValidator("destinationIpv6CidrBlock", cdk.validateString)(properties.destinationIpv6CidrBlock));
  errors.collect(cdk.propertyValidator("egressOnlyInternetGatewayId", cdk.validateString)(properties.egressOnlyInternetGatewayId));
  errors.collect(cdk.propertyValidator("gatewayId", cdk.validateString)(properties.gatewayId));
  errors.collect(cdk.propertyValidator("instanceId", cdk.validateString)(properties.instanceId));
  errors.collect(cdk.propertyValidator("localGatewayId", cdk.validateString)(properties.localGatewayId));
  errors.collect(cdk.propertyValidator("natGatewayId", cdk.validateString)(properties.natGatewayId));
  errors.collect(cdk.propertyValidator("networkInterfaceId", cdk.validateString)(properties.networkInterfaceId));
  errors.collect(cdk.propertyValidator("routeTableId", cdk.requiredValidator)(properties.routeTableId));
  errors.collect(cdk.propertyValidator("routeTableId", cdk.validateString)(properties.routeTableId));
  errors.collect(cdk.propertyValidator("transitGatewayId", cdk.validateString)(properties.transitGatewayId));
  errors.collect(cdk.propertyValidator("vpcEndpointId", cdk.validateString)(properties.vpcEndpointId));
  errors.collect(cdk.propertyValidator("vpcPeeringConnectionId", cdk.validateString)(properties.vpcPeeringConnectionId));
  return errors.wrap("supplied properties not correct for \\"CfnRouteProps\\"");
}

// @ts-ignore TS6133
function convertCfnRoutePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnRoutePropsValidator(properties).assertSuccess();
  return {
    "CarrierGatewayId": cdk.stringToCloudFormation(properties.carrierGatewayId),
    "DestinationCidrBlock": cdk.stringToCloudFormation(properties.destinationCidrBlock),
    "DestinationIpv6CidrBlock": cdk.stringToCloudFormation(properties.destinationIpv6CidrBlock),
    "EgressOnlyInternetGatewayId": cdk.stringToCloudFormation(properties.egressOnlyInternetGatewayId),
    "GatewayId": cdk.stringToCloudFormation(properties.gatewayId),
    "InstanceId": cdk.stringToCloudFormation(properties.instanceId),
    "LocalGatewayId": cdk.stringToCloudFormation(properties.localGatewayId),
    "NatGatewayId": cdk.stringToCloudFormation(properties.natGatewayId),
    "NetworkInterfaceId": cdk.stringToCloudFormation(properties.networkInterfaceId),
    "RouteTableId": cdk.stringToCloudFormation(properties.routeTableId),
    "TransitGatewayId": cdk.stringToCloudFormation(properties.transitGatewayId),
    "VpcEndpointId": cdk.stringToCloudFormation(properties.vpcEndpointId),
    "VpcPeeringConnectionId": cdk.stringToCloudFormation(properties.vpcPeeringConnectionId)
  };
}

// @ts-ignore TS6133
function CfnRoutePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnRouteProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnRouteProps>();
  ret.addPropertyResult("carrierGatewayId", "CarrierGatewayId", (properties.CarrierGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.CarrierGatewayId) : undefined));
  ret.addPropertyResult("destinationCidrBlock", "DestinationCidrBlock", (properties.DestinationCidrBlock != null ? cfn_parse.FromCloudFormation.getString(properties.DestinationCidrBlock) : undefined));
  ret.addPropertyResult("destinationIpv6CidrBlock", "DestinationIpv6CidrBlock", (properties.DestinationIpv6CidrBlock != null ? cfn_parse.FromCloudFormation.getString(properties.DestinationIpv6CidrBlock) : undefined));
  ret.addPropertyResult("egressOnlyInternetGatewayId", "EgressOnlyInternetGatewayId", (properties.EgressOnlyInternetGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.EgressOnlyInternetGatewayId) : undefined));
  ret.addPropertyResult("gatewayId", "GatewayId", (properties.GatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.GatewayId) : undefined));
  ret.addPropertyResult("instanceId", "InstanceId", (properties.InstanceId != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceId) : undefined));
  ret.addPropertyResult("localGatewayId", "LocalGatewayId", (properties.LocalGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.LocalGatewayId) : undefined));
  ret.addPropertyResult("natGatewayId", "NatGatewayId", (properties.NatGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.NatGatewayId) : undefined));
  ret.addPropertyResult("networkInterfaceId", "NetworkInterfaceId", (properties.NetworkInterfaceId != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkInterfaceId) : undefined));
  ret.addPropertyResult("routeTableId", "RouteTableId", (properties.RouteTableId != null ? cfn_parse.FromCloudFormation.getString(properties.RouteTableId) : undefined));
  ret.addPropertyResult("transitGatewayId", "TransitGatewayId", (properties.TransitGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.TransitGatewayId) : undefined));
  ret.addPropertyResult("vpcEndpointId", "VpcEndpointId", (properties.VpcEndpointId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcEndpointId) : undefined));
  ret.addPropertyResult("vpcPeeringConnectionId", "VpcPeeringConnectionId", (properties.VpcPeeringConnectionId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcPeeringConnectionId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a route table for the specified VPC.
 *
 * After you create a route table, you can add routes and associate the table with a subnet.
 *
 * For more information, see [Route Tables](https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_Route_Tables.html) in the *Amazon VPC User Guide* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-routetable.html
 */
export class CfnRouteTable extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::RouteTable";

  /**
   * Build a CfnRouteTable from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnRouteTable {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnRouteTablePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnRouteTable(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the route table.
   *
   * @cloudformationAttribute RouteTableId
   */
  public readonly attrRouteTableId: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * Any tags assigned to the route table.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The ID of the VPC.
   */
  public vpcId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnRouteTableProps) {
    super(scope, id, {
      "type": CfnRouteTable.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "vpcId", this);

    this.attrRouteTableId = cdk.Token.asString(this.getAtt("RouteTableId", cdk.ResolutionTypeHint.STRING));
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::RouteTable", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.vpcId = props.vpcId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "tags": this.tags.renderTags(),
      "vpcId": this.vpcId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnRouteTable.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnRouteTablePropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnRouteTable\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-routetable.html
 */
export interface CfnRouteTableProps {
  /**
   * Any tags assigned to the route table.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-routetable.html#cfn-ec2-routetable-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The ID of the VPC.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-routetable.html#cfn-ec2-routetable-vpcid
   */
  readonly vpcId: string;
}

/**
 * Determine whether the given properties match those of a \`CfnRouteTableProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnRouteTableProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnRouteTablePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("vpcId", cdk.requiredValidator)(properties.vpcId));
  errors.collect(cdk.propertyValidator("vpcId", cdk.validateString)(properties.vpcId));
  return errors.wrap("supplied properties not correct for \\"CfnRouteTableProps\\"");
}

// @ts-ignore TS6133
function convertCfnRouteTablePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnRouteTablePropsValidator(properties).assertSuccess();
  return {
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "VpcId": cdk.stringToCloudFormation(properties.vpcId)
  };
}

// @ts-ignore TS6133
function CfnRouteTablePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnRouteTableProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnRouteTableProps>();
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("vpcId", "VpcId", (properties.VpcId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a security group.
 *
 * To create a security group, use the [VpcId](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group.html#cfn-ec2-securitygroup-vpcid) property to specify the VPC for which to create the security group.
 *
 * If you do not specify an egress rule, we add egress rules that allow IPv4 and IPv6 traffic on all ports and protocols to any destination. We do not add these rules if you specify your own egress rules. If you later remove your egress rules, we restore the default egress rules.
 *
 * This type supports updates. For more information about updating stacks, see [AWS CloudFormation Stacks Updates](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks.html) .
 *
 * > To cross-reference two security groups in the ingress and egress rules of those security groups, use the [AWS::EC2::SecurityGroupEgress](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-security-group-egress.html) and [AWS::EC2::SecurityGroupIngress](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-security-group-ingress.html) resources to define your rules. Do not use the embedded ingress and egress rules in the \`AWS::EC2::SecurityGroup\` . Doing so creates a circular dependency, which AWS CloudFormation doesn't allow.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroup.html
 */
export class CfnSecurityGroup extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::SecurityGroup";

  /**
   * Build a CfnSecurityGroup from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnSecurityGroup {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnSecurityGroupPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnSecurityGroup(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The group ID of the specified security group, such as \`sg-94b3a1f6\` .
   *
   * @cloudformationAttribute GroupId
   */
  public readonly attrGroupId: string;

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The physical ID of the VPC. You can obtain the physical ID by using a reference to an [AWS::EC2::VPC](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html) , such as: \`{ "Ref" : "myVPC" }\` .
   *
   * @cloudformationAttribute VpcId
   */
  public readonly attrVpcId: string;

  /**
   * A description for the security group.
   */
  public groupDescription: string;

  /**
   * The name of the security group.
   */
  public groupName?: string;

  /**
   * The outbound rules associated with the security group.
   */
  public securityGroupEgress?: Array<CfnSecurityGroup.EgressProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * The inbound rules associated with the security group.
   */
  public securityGroupIngress?: Array<CfnSecurityGroup.IngressProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * Any tags assigned to the security group.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The ID of the VPC for the security group.
   */
  public vpcId?: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnSecurityGroupProps) {
    super(scope, id, {
      "type": CfnSecurityGroup.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "groupDescription", this);

    this.attrGroupId = cdk.Token.asString(this.getAtt("GroupId", cdk.ResolutionTypeHint.STRING));
    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.attrVpcId = cdk.Token.asString(this.getAtt("VpcId", cdk.ResolutionTypeHint.STRING));
    this.groupDescription = props.groupDescription;
    this.groupName = props.groupName;
    this.securityGroupEgress = props.securityGroupEgress;
    this.securityGroupIngress = props.securityGroupIngress;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::SecurityGroup", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.vpcId = props.vpcId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "groupDescription": this.groupDescription,
      "groupName": this.groupName,
      "securityGroupEgress": this.securityGroupEgress,
      "securityGroupIngress": this.securityGroupIngress,
      "tags": this.tags.renderTags(),
      "vpcId": this.vpcId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnSecurityGroup.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnSecurityGroupPropsToCloudFormation(props);
  }
}

export namespace CfnSecurityGroup {
  /**
   * Adds an inbound rule to a security group.
   *
   * An inbound rule permits instances to receive traffic from the specified IPv4 or IPv6 CIDR address range, or from the instances associated with the specified security group.
   *
   * You must specify only one of the following properties: \`CidrIp\` , \`CidrIpv6\` , \`SourcePrefixListId\` , \`SourceSecurityGroupId\` , or \`SourceSecurityGroupName\` .
   *
   * You specify a protocol for each rule (for example, TCP). For TCP and UDP, you must also specify a port or port range. For ICMP/ICMPv6, you must also specify the ICMP/ICMPv6 type and code. You can use -1 to mean all types or all codes.
   *
   * You must specify a source security group ( \`SourcePrefixListId\` , \`SourceSecurityGroupId\` , or \`SourceSecurityGroupName\` ) or a CIDR range ( \`CidrIp\` or \`CidrIpv6\` ). If you do not specify one of these parameters, the stack will launch successfully but the rule will not be added to the security group.
   *
   * Rule changes are propagated to instances within the security group as quickly as possible. However, a small delay might occur.
   *
   * The EC2 Security Group Rule is an embedded property of the \`AWS::EC2::SecurityGroup\` type.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-ingress.html
   */
  export interface IngressProperty {
    /**
     * The IPv4 address range, in CIDR format.
     *
     * You must specify a source security group ( \`SourcePrefixListId\` or \`SourceSecurityGroupId\` ) or a CIDR range ( \`CidrIp\` or \`CidrIpv6\` ).
     *
     * For examples of rules that you can add to security groups for specific access scenarios, see [Security group rules for different use cases](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-ingress.html#cfn-ec2-securitygroup-ingress-cidrip
     */
    readonly cidrIp?: string;

    /**
     * The IPv6 address range, in CIDR format.
     *
     * You must specify a source security group ( \`SourcePrefixListId\` or \`SourceSecurityGroupId\` ) or a CIDR range ( \`CidrIp\` or \`CidrIpv6\` ).
     *
     * For examples of rules that you can add to security groups for specific access scenarios, see [Security group rules for different use cases](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-ingress.html#cfn-ec2-securitygroup-ingress-cidripv6
     */
    readonly cidrIpv6?: string;

    /**
     * Updates the description of an ingress (inbound) security group rule.
     *
     * You can replace an existing description, or add a description to a rule that did not have one previously.
     *
     * Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-ingress.html#cfn-ec2-securitygroup-ingress-description
     */
    readonly description?: string;

    /**
     * If the protocol is TCP or UDP, this is the start of the port range.
     *
     * If the protocol is ICMP or ICMPv6, this is the type number. A value of -1 indicates all ICMP/ICMPv6 types. If you specify all ICMP/ICMPv6 types, you must specify all ICMP/ICMPv6 codes.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-ingress.html#cfn-ec2-securitygroup-ingress-fromport
     */
    readonly fromPort?: number;

    /**
     * The IP protocol name ( \`tcp\` , \`udp\` , \`icmp\` , \`icmpv6\` ) or number (see [Protocol Numbers](https://docs.aws.amazon.com/http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml) ).
     *
     * Use \`-1\` to specify all protocols. When authorizing security group rules, specifying \`-1\` or a protocol number other than \`tcp\` , \`udp\` , \`icmp\` , or \`icmpv6\` allows traffic on all ports, regardless of any port range you specify. For \`tcp\` , \`udp\` , and \`icmp\` , you must specify a port range. For \`icmpv6\` , the port range is optional; if you omit the port range, traffic for all types and codes is allowed.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-ingress.html#cfn-ec2-securitygroup-ingress-ipprotocol
     */
    readonly ipProtocol: string;

    /**
     * The ID of a prefix list.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-ingress.html#cfn-ec2-securitygroup-ingress-sourceprefixlistid
     */
    readonly sourcePrefixListId?: string;

    /**
     * The ID of the security group.
     *
     * You must specify either the security group ID or the security group name in the request. For security groups in a nondefault VPC, you must specify the security group ID.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-ingress.html#cfn-ec2-securitygroup-ingress-sourcesecuritygroupid
     */
    readonly sourceSecurityGroupId?: string;

    /**
     * [Default VPC] The name of the source security group.
     *
     * You must specify either the security group ID or the security group name. You can't specify the group name in combination with an IP address range. Creates rules that grant full ICMP, UDP, and TCP access.
     *
     * For security groups in a nondefault VPC, you must specify the group ID.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-ingress.html#cfn-ec2-securitygroup-ingress-sourcesecuritygroupname
     */
    readonly sourceSecurityGroupName?: string;

    /**
     * [nondefault VPC] The AWS account ID for the source security group, if the source security group is in a different account.
     *
     * You can't specify this property with an IP address range. Creates rules that grant full ICMP, UDP, and TCP access.
     *
     * If you specify \`SourceSecurityGroupName\` or \`SourceSecurityGroupId\` and that security group is owned by a different account than the account creating the stack, you must specify the \`SourceSecurityGroupOwnerId\` ; otherwise, this property is optional.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-ingress.html#cfn-ec2-securitygroup-ingress-sourcesecuritygroupownerid
     */
    readonly sourceSecurityGroupOwnerId?: string;

    /**
     * If the protocol is TCP or UDP, this is the end of the port range.
     *
     * If the protocol is ICMP or ICMPv6, this is the code. A value of -1 indicates all ICMP/ICMPv6 codes. If you specify all ICMP/ICMPv6 types, you must specify all ICMP/ICMPv6 codes.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-ingress.html#cfn-ec2-securitygroup-ingress-toport
     */
    readonly toPort?: number;
  }

  /**
   * Adds the specified egress rules to a security group for use with a VPC.
   *
   * An outbound rule permits instances to send traffic to the specified destination IPv4 or IPv6 CIDR address ranges, or to the specified destination security groups for the same VPC.
   *
   * You specify a protocol for each rule (for example, TCP). For the TCP and UDP protocols, you must also specify the destination port or port range. For the ICMP protocol, you must also specify the ICMP type and code. You can use -1 for the type or code to mean all types or all codes.
   *
   * You must specify only one of the following properties: \`CidrIp\` , \`CidrIpv6\` , \`DestinationPrefixListId\` , or \`DestinationSecurityGroupId\` .
   *
   * You must specify a destination security group ( \`DestinationPrefixListId\` or \`DestinationSecurityGroupId\` ) or a CIDR range ( \`CidrIp\` or \`CidrIpv6\` ). If you do not specify one of these parameters, the stack will launch successfully but the rule will not be added to the security group.
   *
   * Rule changes are propagated to affected instances as quickly as possible. However, a small delay might occur.
   *
   * For more information about VPC security group limits, see [Amazon VPC Limits](https://docs.aws.amazon.com/vpc/latest/userguide/amazon-vpc-limits.html) .
   *
   * Use \`SecurityGroup.Ingress\` and \`SecurityGroup.Egress\` only when necessary, typically to allow security groups to reference each other in ingress and egress rules. Otherwise, use the embedded ingress and egress rules of the security group. For more information, see [Amazon EC2 Security Groups](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-network-security.html) .
   *
   * The EC2 Security Group Rule is an embedded property of the \`AWS::EC2::SecurityGroup\` type.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-egress.html
   */
  export interface EgressProperty {
    /**
     * The IPv4 address range, in CIDR format.
     *
     * You must specify a destination security group ( \`DestinationPrefixListId\` or \`DestinationSecurityGroupId\` ) or a CIDR range ( \`CidrIp\` or \`CidrIpv6\` ).
     *
     * For examples of rules that you can add to security groups for specific access scenarios, see [Security group rules for different use cases](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-egress.html#cfn-ec2-securitygroup-egress-cidrip
     */
    readonly cidrIp?: string;

    /**
     * The IPv6 address range, in CIDR format.
     *
     * You must specify a destination security group ( \`DestinationPrefixListId\` or \`DestinationSecurityGroupId\` ) or a CIDR range ( \`CidrIp\` or \`CidrIpv6\` ).
     *
     * For examples of rules that you can add to security groups for specific access scenarios, see [Security group rules for different use cases](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-egress.html#cfn-ec2-securitygroup-egress-cidripv6
     */
    readonly cidrIpv6?: string;

    /**
     * A description for the security group rule.
     *
     * Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-egress.html#cfn-ec2-securitygroup-egress-description
     */
    readonly description?: string;

    /**
     * The prefix list IDs for the destination AWS service.
     *
     * This is the AWS service that you want to access through a VPC endpoint from instances associated with the security group.
     *
     * You must specify a destination security group ( \`DestinationPrefixListId\` or \`DestinationSecurityGroupId\` ) or a CIDR range ( \`CidrIp\` or \`CidrIpv6\` ).
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-egress.html#cfn-ec2-securitygroup-egress-destinationprefixlistid
     */
    readonly destinationPrefixListId?: string;

    /**
     * The ID of the destination VPC security group.
     *
     * You must specify a destination security group ( \`DestinationPrefixListId\` or \`DestinationSecurityGroupId\` ) or a CIDR range ( \`CidrIp\` or \`CidrIpv6\` ).
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-egress.html#cfn-ec2-securitygroup-egress-destinationsecuritygroupid
     */
    readonly destinationSecurityGroupId?: string;

    /**
     * If the protocol is TCP or UDP, this is the start of the port range.
     *
     * If the protocol is ICMP or ICMPv6, this is the type number. A value of -1 indicates all ICMP/ICMPv6 types. If you specify all ICMP/ICMPv6 types, you must specify all ICMP/ICMPv6 codes.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-egress.html#cfn-ec2-securitygroup-egress-fromport
     */
    readonly fromPort?: number;

    /**
     * The IP protocol name ( \`tcp\` , \`udp\` , \`icmp\` , \`icmpv6\` ) or number (see [Protocol Numbers](https://docs.aws.amazon.com/http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml) ).
     *
     * Use \`-1\` to specify all protocols. When authorizing security group rules, specifying \`-1\` or a protocol number other than \`tcp\` , \`udp\` , \`icmp\` , or \`icmpv6\` allows traffic on all ports, regardless of any port range you specify. For \`tcp\` , \`udp\` , and \`icmp\` , you must specify a port range. For \`icmpv6\` , the port range is optional; if you omit the port range, traffic for all types and codes is allowed.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-egress.html#cfn-ec2-securitygroup-egress-ipprotocol
     */
    readonly ipProtocol: string;

    /**
     * If the protocol is TCP or UDP, this is the end of the port range.
     *
     * If the protocol is ICMP or ICMPv6, this is the code. A value of -1 indicates all ICMP/ICMPv6 codes. If you specify all ICMP/ICMPv6 types, you must specify all ICMP/ICMPv6 codes.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-egress.html#cfn-ec2-securitygroup-egress-toport
     */
    readonly toPort?: number;
  }
}

/**
 * Properties for defining a \`CfnSecurityGroup\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroup.html
 */
export interface CfnSecurityGroupProps {
  /**
   * A description for the security group.
   *
   * Constraints: Up to 255 characters in length
   *
   * Valid characters: a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&;{}!$*
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroup.html#cfn-ec2-securitygroup-groupdescription
   */
  readonly groupDescription: string;

  /**
   * The name of the security group.
   *
   * Constraints: Up to 255 characters in length. Cannot start with \`sg-\` .
   *
   * Valid characters: a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&;{}!$*
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroup.html#cfn-ec2-securitygroup-groupname
   */
  readonly groupName?: string;

  /**
   * The outbound rules associated with the security group.
   *
   * There is a short interruption during which you cannot connect to the security group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroup.html#cfn-ec2-securitygroup-securitygroupegress
   */
  readonly securityGroupEgress?: Array<CfnSecurityGroup.EgressProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * The inbound rules associated with the security group.
   *
   * There is a short interruption during which you cannot connect to the security group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroup.html#cfn-ec2-securitygroup-securitygroupingress
   */
  readonly securityGroupIngress?: Array<CfnSecurityGroup.IngressProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * Any tags assigned to the security group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroup.html#cfn-ec2-securitygroup-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The ID of the VPC for the security group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroup.html#cfn-ec2-securitygroup-vpcid
   */
  readonly vpcId?: string;
}

/**
 * Determine whether the given properties match those of a \`IngressProperty\`
 *
 * @param properties - the TypeScript properties of a \`IngressProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSecurityGroupIngressPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("cidrIp", cdk.validateString)(properties.cidrIp));
  errors.collect(cdk.propertyValidator("cidrIpv6", cdk.validateString)(properties.cidrIpv6));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("fromPort", cdk.validateNumber)(properties.fromPort));
  errors.collect(cdk.propertyValidator("ipProtocol", cdk.requiredValidator)(properties.ipProtocol));
  errors.collect(cdk.propertyValidator("ipProtocol", cdk.validateString)(properties.ipProtocol));
  errors.collect(cdk.propertyValidator("sourcePrefixListId", cdk.validateString)(properties.sourcePrefixListId));
  errors.collect(cdk.propertyValidator("sourceSecurityGroupId", cdk.validateString)(properties.sourceSecurityGroupId));
  errors.collect(cdk.propertyValidator("sourceSecurityGroupName", cdk.validateString)(properties.sourceSecurityGroupName));
  errors.collect(cdk.propertyValidator("sourceSecurityGroupOwnerId", cdk.validateString)(properties.sourceSecurityGroupOwnerId));
  errors.collect(cdk.propertyValidator("toPort", cdk.validateNumber)(properties.toPort));
  return errors.wrap("supplied properties not correct for \\"IngressProperty\\"");
}

// @ts-ignore TS6133
function convertCfnSecurityGroupIngressPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSecurityGroupIngressPropertyValidator(properties).assertSuccess();
  return {
    "CidrIp": cdk.stringToCloudFormation(properties.cidrIp),
    "CidrIpv6": cdk.stringToCloudFormation(properties.cidrIpv6),
    "Description": cdk.stringToCloudFormation(properties.description),
    "FromPort": cdk.numberToCloudFormation(properties.fromPort),
    "IpProtocol": cdk.stringToCloudFormation(properties.ipProtocol),
    "SourcePrefixListId": cdk.stringToCloudFormation(properties.sourcePrefixListId),
    "SourceSecurityGroupId": cdk.stringToCloudFormation(properties.sourceSecurityGroupId),
    "SourceSecurityGroupName": cdk.stringToCloudFormation(properties.sourceSecurityGroupName),
    "SourceSecurityGroupOwnerId": cdk.stringToCloudFormation(properties.sourceSecurityGroupOwnerId),
    "ToPort": cdk.numberToCloudFormation(properties.toPort)
  };
}

// @ts-ignore TS6133
function CfnSecurityGroupIngressPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSecurityGroup.IngressProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSecurityGroup.IngressProperty>();
  ret.addPropertyResult("cidrIp", "CidrIp", (properties.CidrIp != null ? cfn_parse.FromCloudFormation.getString(properties.CidrIp) : undefined));
  ret.addPropertyResult("cidrIpv6", "CidrIpv6", (properties.CidrIpv6 != null ? cfn_parse.FromCloudFormation.getString(properties.CidrIpv6) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("fromPort", "FromPort", (properties.FromPort != null ? cfn_parse.FromCloudFormation.getNumber(properties.FromPort) : undefined));
  ret.addPropertyResult("ipProtocol", "IpProtocol", (properties.IpProtocol != null ? cfn_parse.FromCloudFormation.getString(properties.IpProtocol) : undefined));
  ret.addPropertyResult("sourcePrefixListId", "SourcePrefixListId", (properties.SourcePrefixListId != null ? cfn_parse.FromCloudFormation.getString(properties.SourcePrefixListId) : undefined));
  ret.addPropertyResult("sourceSecurityGroupId", "SourceSecurityGroupId", (properties.SourceSecurityGroupId != null ? cfn_parse.FromCloudFormation.getString(properties.SourceSecurityGroupId) : undefined));
  ret.addPropertyResult("sourceSecurityGroupName", "SourceSecurityGroupName", (properties.SourceSecurityGroupName != null ? cfn_parse.FromCloudFormation.getString(properties.SourceSecurityGroupName) : undefined));
  ret.addPropertyResult("sourceSecurityGroupOwnerId", "SourceSecurityGroupOwnerId", (properties.SourceSecurityGroupOwnerId != null ? cfn_parse.FromCloudFormation.getString(properties.SourceSecurityGroupOwnerId) : undefined));
  ret.addPropertyResult("toPort", "ToPort", (properties.ToPort != null ? cfn_parse.FromCloudFormation.getNumber(properties.ToPort) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`EgressProperty\`
 *
 * @param properties - the TypeScript properties of a \`EgressProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSecurityGroupEgressPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("cidrIp", cdk.validateString)(properties.cidrIp));
  errors.collect(cdk.propertyValidator("cidrIpv6", cdk.validateString)(properties.cidrIpv6));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("destinationPrefixListId", cdk.validateString)(properties.destinationPrefixListId));
  errors.collect(cdk.propertyValidator("destinationSecurityGroupId", cdk.validateString)(properties.destinationSecurityGroupId));
  errors.collect(cdk.propertyValidator("fromPort", cdk.validateNumber)(properties.fromPort));
  errors.collect(cdk.propertyValidator("ipProtocol", cdk.requiredValidator)(properties.ipProtocol));
  errors.collect(cdk.propertyValidator("ipProtocol", cdk.validateString)(properties.ipProtocol));
  errors.collect(cdk.propertyValidator("toPort", cdk.validateNumber)(properties.toPort));
  return errors.wrap("supplied properties not correct for \\"EgressProperty\\"");
}

// @ts-ignore TS6133
function convertCfnSecurityGroupEgressPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSecurityGroupEgressPropertyValidator(properties).assertSuccess();
  return {
    "CidrIp": cdk.stringToCloudFormation(properties.cidrIp),
    "CidrIpv6": cdk.stringToCloudFormation(properties.cidrIpv6),
    "Description": cdk.stringToCloudFormation(properties.description),
    "DestinationPrefixListId": cdk.stringToCloudFormation(properties.destinationPrefixListId),
    "DestinationSecurityGroupId": cdk.stringToCloudFormation(properties.destinationSecurityGroupId),
    "FromPort": cdk.numberToCloudFormation(properties.fromPort),
    "IpProtocol": cdk.stringToCloudFormation(properties.ipProtocol),
    "ToPort": cdk.numberToCloudFormation(properties.toPort)
  };
}

// @ts-ignore TS6133
function CfnSecurityGroupEgressPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSecurityGroup.EgressProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSecurityGroup.EgressProperty>();
  ret.addPropertyResult("cidrIp", "CidrIp", (properties.CidrIp != null ? cfn_parse.FromCloudFormation.getString(properties.CidrIp) : undefined));
  ret.addPropertyResult("cidrIpv6", "CidrIpv6", (properties.CidrIpv6 != null ? cfn_parse.FromCloudFormation.getString(properties.CidrIpv6) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("destinationPrefixListId", "DestinationPrefixListId", (properties.DestinationPrefixListId != null ? cfn_parse.FromCloudFormation.getString(properties.DestinationPrefixListId) : undefined));
  ret.addPropertyResult("destinationSecurityGroupId", "DestinationSecurityGroupId", (properties.DestinationSecurityGroupId != null ? cfn_parse.FromCloudFormation.getString(properties.DestinationSecurityGroupId) : undefined));
  ret.addPropertyResult("fromPort", "FromPort", (properties.FromPort != null ? cfn_parse.FromCloudFormation.getNumber(properties.FromPort) : undefined));
  ret.addPropertyResult("ipProtocol", "IpProtocol", (properties.IpProtocol != null ? cfn_parse.FromCloudFormation.getString(properties.IpProtocol) : undefined));
  ret.addPropertyResult("toPort", "ToPort", (properties.ToPort != null ? cfn_parse.FromCloudFormation.getNumber(properties.ToPort) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnSecurityGroupProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnSecurityGroupProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSecurityGroupPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("groupDescription", cdk.requiredValidator)(properties.groupDescription));
  errors.collect(cdk.propertyValidator("groupDescription", cdk.validateString)(properties.groupDescription));
  errors.collect(cdk.propertyValidator("groupName", cdk.validateString)(properties.groupName));
  errors.collect(cdk.propertyValidator("securityGroupEgress", cdk.listValidator(CfnSecurityGroupEgressPropertyValidator))(properties.securityGroupEgress));
  errors.collect(cdk.propertyValidator("securityGroupIngress", cdk.listValidator(CfnSecurityGroupIngressPropertyValidator))(properties.securityGroupIngress));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("vpcId", cdk.validateString)(properties.vpcId));
  return errors.wrap("supplied properties not correct for \\"CfnSecurityGroupProps\\"");
}

// @ts-ignore TS6133
function convertCfnSecurityGroupPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSecurityGroupPropsValidator(properties).assertSuccess();
  return {
    "GroupDescription": cdk.stringToCloudFormation(properties.groupDescription),
    "GroupName": cdk.stringToCloudFormation(properties.groupName),
    "SecurityGroupEgress": cdk.listMapper(convertCfnSecurityGroupEgressPropertyToCloudFormation)(properties.securityGroupEgress),
    "SecurityGroupIngress": cdk.listMapper(convertCfnSecurityGroupIngressPropertyToCloudFormation)(properties.securityGroupIngress),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "VpcId": cdk.stringToCloudFormation(properties.vpcId)
  };
}

// @ts-ignore TS6133
function CfnSecurityGroupPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSecurityGroupProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSecurityGroupProps>();
  ret.addPropertyResult("groupDescription", "GroupDescription", (properties.GroupDescription != null ? cfn_parse.FromCloudFormation.getString(properties.GroupDescription) : undefined));
  ret.addPropertyResult("groupName", "GroupName", (properties.GroupName != null ? cfn_parse.FromCloudFormation.getString(properties.GroupName) : undefined));
  ret.addPropertyResult("securityGroupEgress", "SecurityGroupEgress", (properties.SecurityGroupEgress != null ? cfn_parse.FromCloudFormation.getArray(CfnSecurityGroupEgressPropertyFromCloudFormation)(properties.SecurityGroupEgress) : undefined));
  ret.addPropertyResult("securityGroupIngress", "SecurityGroupIngress", (properties.SecurityGroupIngress != null ? cfn_parse.FromCloudFormation.getArray(CfnSecurityGroupIngressPropertyFromCloudFormation)(properties.SecurityGroupIngress) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("vpcId", "VpcId", (properties.VpcId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Adds the specified egress rules to a security group.
 *
 * An outbound rule permits instances to send traffic to the specified destination IPv4 or IPv6 CIDR address ranges, or to the specified destination security groups for the same VPC.
 *
 * You specify a protocol for each rule (for example, TCP). For the TCP and UDP protocols, you must also specify the destination port or port range. For the ICMP protocol, you must also specify the ICMP type and code. You can use -1 for the type or code to mean all types or all codes.
 *
 * You must specify only one of the following properties: \`CidrIp\` , \`CidrIpv6\` , \`DestinationPrefixListId\` , or \`DestinationSecurityGroupId\` .
 *
 * You must specify a destination security group ( \`DestinationPrefixListId\` or \`DestinationSecurityGroupId\` ) or a CIDR range ( \`CidrIp\` or \`CidrIpv6\` ). If you do not specify one of these parameters, the stack will launch successfully but the rule will not be added to the security group.
 *
 * Rule changes are propagated to affected instances as quickly as possible. However, a small delay might occur.
 *
 * For more information about VPC security group limits, see [Amazon VPC Limits](https://docs.aws.amazon.com/vpc/latest/userguide/amazon-vpc-limits.html) .
 *
 * Use \`AWS::EC2::SecurityGroupIngress\` and \`AWS::EC2::SecurityGroupEgress\` only when necessary, typically to allow security groups to reference each other in ingress and egress rules. Otherwise, use the embedded ingress and egress rules of the security group. For more information, see [Amazon EC2 Security Groups](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-network-security.html) .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupegress.html
 */
export class CfnSecurityGroupEgress extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::SecurityGroupEgress";

  /**
   * Build a CfnSecurityGroupEgress from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnSecurityGroupEgress {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnSecurityGroupEgressPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnSecurityGroupEgress(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The IPv4 address range, in CIDR format.
   */
  public cidrIp?: string;

  /**
   * The IPv6 address range, in CIDR format.
   */
  public cidrIpv6?: string;

  /**
   * The description of an egress (outbound) security group rule.
   */
  public description?: string;

  /**
   * The prefix list IDs for an AWS service.
   */
  public destinationPrefixListId?: string;

  /**
   * The ID of the security group.
   */
  public destinationSecurityGroupId?: string;

  /**
   * If the protocol is TCP or UDP, this is the start of the port range.
   */
  public fromPort?: number;

  /**
   * The ID of the security group.
   */
  public groupId: string;

  /**
   * The IP protocol name ( \`tcp\` , \`udp\` , \`icmp\` , \`icmpv6\` ) or number (see [Protocol Numbers](https://docs.aws.amazon.com/http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml) ).
   */
  public ipProtocol: string;

  /**
   * If the protocol is TCP or UDP, this is the end of the port range.
   */
  public toPort?: number;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnSecurityGroupEgressProps) {
    super(scope, id, {
      "type": CfnSecurityGroupEgress.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "groupId", this);
    cdk.requireProperty(props, "ipProtocol", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.cidrIp = props.cidrIp;
    this.cidrIpv6 = props.cidrIpv6;
    this.description = props.description;
    this.destinationPrefixListId = props.destinationPrefixListId;
    this.destinationSecurityGroupId = props.destinationSecurityGroupId;
    this.fromPort = props.fromPort;
    this.groupId = props.groupId;
    this.ipProtocol = props.ipProtocol;
    this.toPort = props.toPort;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "cidrIp": this.cidrIp,
      "cidrIpv6": this.cidrIpv6,
      "description": this.description,
      "destinationPrefixListId": this.destinationPrefixListId,
      "destinationSecurityGroupId": this.destinationSecurityGroupId,
      "fromPort": this.fromPort,
      "groupId": this.groupId,
      "ipProtocol": this.ipProtocol,
      "toPort": this.toPort
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnSecurityGroupEgress.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnSecurityGroupEgressPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnSecurityGroupEgress\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupegress.html
 */
export interface CfnSecurityGroupEgressProps {
  /**
   * The IPv4 address range, in CIDR format.
   *
   * You must specify a destination security group ( \`DestinationPrefixListId\` or \`DestinationSecurityGroupId\` ) or a CIDR range ( \`CidrIp\` or \`CidrIpv6\` ).
   *
   * For examples of rules that you can add to security groups for specific access scenarios, see [Security group rules for different use cases](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html) in the *Amazon EC2 User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupegress.html#cfn-ec2-securitygroupegress-cidrip
   */
  readonly cidrIp?: string;

  /**
   * The IPv6 address range, in CIDR format.
   *
   * You must specify a destination security group ( \`DestinationPrefixListId\` or \`DestinationSecurityGroupId\` ) or a CIDR range ( \`CidrIp\` or \`CidrIpv6\` ).
   *
   * For examples of rules that you can add to security groups for specific access scenarios, see [Security group rules for different use cases](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html) in the *Amazon EC2 User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupegress.html#cfn-ec2-securitygroupegress-cidripv6
   */
  readonly cidrIpv6?: string;

  /**
   * The description of an egress (outbound) security group rule.
   *
   * Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupegress.html#cfn-ec2-securitygroupegress-description
   */
  readonly description?: string;

  /**
   * The prefix list IDs for an AWS service.
   *
   * This is the AWS service that you want to access through a VPC endpoint from instances associated with the security group.
   *
   * You must specify a destination security group ( \`DestinationPrefixListId\` or \`DestinationSecurityGroupId\` ) or a CIDR range ( \`CidrIp\` or \`CidrIpv6\` ).
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupegress.html#cfn-ec2-securitygroupegress-destinationprefixlistid
   */
  readonly destinationPrefixListId?: string;

  /**
   * The ID of the security group.
   *
   * You must specify a destination security group ( \`DestinationPrefixListId\` or \`DestinationSecurityGroupId\` ) or a CIDR range ( \`CidrIp\` or \`CidrIpv6\` ).
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupegress.html#cfn-ec2-securitygroupegress-destinationsecuritygroupid
   */
  readonly destinationSecurityGroupId?: string;

  /**
   * If the protocol is TCP or UDP, this is the start of the port range.
   *
   * If the protocol is ICMP or ICMPv6, this is the type number. A value of -1 indicates all ICMP/ICMPv6 types. If you specify all ICMP/ICMPv6 types, you must specify all ICMP/ICMPv6 codes.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupegress.html#cfn-ec2-securitygroupegress-fromport
   */
  readonly fromPort?: number;

  /**
   * The ID of the security group.
   *
   * You must specify either the security group ID or the security group name in the request. For security groups in a nondefault VPC, you must specify the security group ID.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupegress.html#cfn-ec2-securitygroupegress-groupid
   */
  readonly groupId: string;

  /**
   * The IP protocol name ( \`tcp\` , \`udp\` , \`icmp\` , \`icmpv6\` ) or number (see [Protocol Numbers](https://docs.aws.amazon.com/http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml) ).
   *
   * Use \`-1\` to specify all protocols. When authorizing security group rules, specifying \`-1\` or a protocol number other than \`tcp\` , \`udp\` , \`icmp\` , or \`icmpv6\` allows traffic on all ports, regardless of any port range you specify. For \`tcp\` , \`udp\` , and \`icmp\` , you must specify a port range. For \`icmpv6\` , the port range is optional; if you omit the port range, traffic for all types and codes is allowed.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupegress.html#cfn-ec2-securitygroupegress-ipprotocol
   */
  readonly ipProtocol: string;

  /**
   * If the protocol is TCP or UDP, this is the end of the port range.
   *
   * If the protocol is ICMP or ICMPv6, this is the code. A value of -1 indicates all ICMP/ICMPv6 codes. If you specify all ICMP/ICMPv6 types, you must specify all ICMP/ICMPv6 codes.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupegress.html#cfn-ec2-securitygroupegress-toport
   */
  readonly toPort?: number;
}

/**
 * Determine whether the given properties match those of a \`CfnSecurityGroupEgressProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnSecurityGroupEgressProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSecurityGroupEgressPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("cidrIp", cdk.validateString)(properties.cidrIp));
  errors.collect(cdk.propertyValidator("cidrIpv6", cdk.validateString)(properties.cidrIpv6));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("destinationPrefixListId", cdk.validateString)(properties.destinationPrefixListId));
  errors.collect(cdk.propertyValidator("destinationSecurityGroupId", cdk.validateString)(properties.destinationSecurityGroupId));
  errors.collect(cdk.propertyValidator("fromPort", cdk.validateNumber)(properties.fromPort));
  errors.collect(cdk.propertyValidator("groupId", cdk.requiredValidator)(properties.groupId));
  errors.collect(cdk.propertyValidator("groupId", cdk.validateString)(properties.groupId));
  errors.collect(cdk.propertyValidator("ipProtocol", cdk.requiredValidator)(properties.ipProtocol));
  errors.collect(cdk.propertyValidator("ipProtocol", cdk.validateString)(properties.ipProtocol));
  errors.collect(cdk.propertyValidator("toPort", cdk.validateNumber)(properties.toPort));
  return errors.wrap("supplied properties not correct for \\"CfnSecurityGroupEgressProps\\"");
}

// @ts-ignore TS6133
function convertCfnSecurityGroupEgressPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSecurityGroupEgressPropsValidator(properties).assertSuccess();
  return {
    "CidrIp": cdk.stringToCloudFormation(properties.cidrIp),
    "CidrIpv6": cdk.stringToCloudFormation(properties.cidrIpv6),
    "Description": cdk.stringToCloudFormation(properties.description),
    "DestinationPrefixListId": cdk.stringToCloudFormation(properties.destinationPrefixListId),
    "DestinationSecurityGroupId": cdk.stringToCloudFormation(properties.destinationSecurityGroupId),
    "FromPort": cdk.numberToCloudFormation(properties.fromPort),
    "GroupId": cdk.stringToCloudFormation(properties.groupId),
    "IpProtocol": cdk.stringToCloudFormation(properties.ipProtocol),
    "ToPort": cdk.numberToCloudFormation(properties.toPort)
  };
}

// @ts-ignore TS6133
function CfnSecurityGroupEgressPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSecurityGroupEgressProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSecurityGroupEgressProps>();
  ret.addPropertyResult("cidrIp", "CidrIp", (properties.CidrIp != null ? cfn_parse.FromCloudFormation.getString(properties.CidrIp) : undefined));
  ret.addPropertyResult("cidrIpv6", "CidrIpv6", (properties.CidrIpv6 != null ? cfn_parse.FromCloudFormation.getString(properties.CidrIpv6) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("destinationPrefixListId", "DestinationPrefixListId", (properties.DestinationPrefixListId != null ? cfn_parse.FromCloudFormation.getString(properties.DestinationPrefixListId) : undefined));
  ret.addPropertyResult("destinationSecurityGroupId", "DestinationSecurityGroupId", (properties.DestinationSecurityGroupId != null ? cfn_parse.FromCloudFormation.getString(properties.DestinationSecurityGroupId) : undefined));
  ret.addPropertyResult("fromPort", "FromPort", (properties.FromPort != null ? cfn_parse.FromCloudFormation.getNumber(properties.FromPort) : undefined));
  ret.addPropertyResult("groupId", "GroupId", (properties.GroupId != null ? cfn_parse.FromCloudFormation.getString(properties.GroupId) : undefined));
  ret.addPropertyResult("ipProtocol", "IpProtocol", (properties.IpProtocol != null ? cfn_parse.FromCloudFormation.getString(properties.IpProtocol) : undefined));
  ret.addPropertyResult("toPort", "ToPort", (properties.ToPort != null ? cfn_parse.FromCloudFormation.getNumber(properties.ToPort) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Adds an inbound rule to a security group.
 *
 * An inbound rule permits instances to receive traffic from the specified IPv4 or IPv6 CIDR address range, or from the instances associated with the specified security group.
 *
 * You must specify only one of the following properties: \`CidrIp\` , \`CidrIpv6\` , \`SourcePrefixListId\` , \`SourceSecurityGroupId\` , or \`SourceSecurityGroupName\` .
 *
 * You specify a protocol for each rule (for example, TCP). For TCP and UDP, you must also specify a port or port range. For ICMP/ICMPv6, you must also specify the ICMP/ICMPv6 type and code. You can use -1 to mean all types or all codes.
 *
 * You must specify a source security group ( \`SourcePrefixListId\` , \`SourceSecurityGroupId\` , or \`SourceSecurityGroupName\` ) or a CIDR range ( \`CidrIp\` or \`CidrIpv6\` ). If you do not specify one of these parameters, the stack will launch successfully but the rule will not be added to the security group.
 *
 * Rule changes are propagated to instances within the security group as quickly as possible. However, a small delay might occur.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html
 */
export class CfnSecurityGroupIngress extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::SecurityGroupIngress";

  /**
   * Build a CfnSecurityGroupIngress from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnSecurityGroupIngress {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnSecurityGroupIngressPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnSecurityGroupIngress(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The IPv4 address range, in CIDR format.
   */
  public cidrIp?: string;

  /**
   * The IPv6 address range, in CIDR format.
   */
  public cidrIpv6?: string;

  /**
   * Updates the description of an ingress (inbound) security group rule.
   */
  public description?: string;

  /**
   * The start of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 type number.
   */
  public fromPort?: number;

  /**
   * The ID of the security group.
   */
  public groupId?: string;

  /**
   * The name of the security group.
   */
  public groupName?: string;

  /**
   * The IP protocol name ( \`tcp\` , \`udp\` , \`icmp\` , \`icmpv6\` ) or number (see [Protocol Numbers](https://docs.aws.amazon.com/http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml) ).
   */
  public ipProtocol: string;

  /**
   * The ID of a prefix list.
   */
  public sourcePrefixListId?: string;

  /**
   * The ID of the security group.
   */
  public sourceSecurityGroupId?: string;

  /**
   * [Default VPC] The name of the source security group.
   */
  public sourceSecurityGroupName?: string;

  /**
   * [nondefault VPC] The AWS account ID for the source security group, if the source security group is in a different account.
   */
  public sourceSecurityGroupOwnerId?: string;

  /**
   * The end of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 code.
   */
  public toPort?: number;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnSecurityGroupIngressProps) {
    super(scope, id, {
      "type": CfnSecurityGroupIngress.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "ipProtocol", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.cidrIp = props.cidrIp;
    this.cidrIpv6 = props.cidrIpv6;
    this.description = props.description;
    this.fromPort = props.fromPort;
    this.groupId = props.groupId;
    this.groupName = props.groupName;
    this.ipProtocol = props.ipProtocol;
    this.sourcePrefixListId = props.sourcePrefixListId;
    this.sourceSecurityGroupId = props.sourceSecurityGroupId;
    this.sourceSecurityGroupName = props.sourceSecurityGroupName;
    this.sourceSecurityGroupOwnerId = props.sourceSecurityGroupOwnerId;
    this.toPort = props.toPort;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "cidrIp": this.cidrIp,
      "cidrIpv6": this.cidrIpv6,
      "description": this.description,
      "fromPort": this.fromPort,
      "groupId": this.groupId,
      "groupName": this.groupName,
      "ipProtocol": this.ipProtocol,
      "sourcePrefixListId": this.sourcePrefixListId,
      "sourceSecurityGroupId": this.sourceSecurityGroupId,
      "sourceSecurityGroupName": this.sourceSecurityGroupName,
      "sourceSecurityGroupOwnerId": this.sourceSecurityGroupOwnerId,
      "toPort": this.toPort
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnSecurityGroupIngress.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnSecurityGroupIngressPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnSecurityGroupIngress\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html
 */
export interface CfnSecurityGroupIngressProps {
  /**
   * The IPv4 address range, in CIDR format.
   *
   * You must specify a source security group ( \`SourcePrefixListId\` or \`SourceSecurityGroupId\` ) or a CIDR range ( \`CidrIp\` or \`CidrIpv6\` ).
   *
   * For examples of rules that you can add to security groups for specific access scenarios, see [Security group rules for different use cases](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html) in the *Amazon EC2 User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html#cfn-ec2-securitygroupingress-cidrip
   */
  readonly cidrIp?: string;

  /**
   * The IPv6 address range, in CIDR format.
   *
   * You must specify a source security group ( \`SourcePrefixListId\` or \`SourceSecurityGroupId\` ) or a CIDR range ( \`CidrIp\` or \`CidrIpv6\` ).
   *
   * For examples of rules that you can add to security groups for specific access scenarios, see [Security group rules for different use cases](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html) in the *Amazon EC2 User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html#cfn-ec2-securitygroupingress-cidripv6
   */
  readonly cidrIpv6?: string;

  /**
   * Updates the description of an ingress (inbound) security group rule.
   *
   * You can replace an existing description, or add a description to a rule that did not have one previously.
   *
   * Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html#cfn-ec2-securitygroupingress-description
   */
  readonly description?: string;

  /**
   * The start of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 type number.
   *
   * A value of \`-1\` indicates all ICMP/ICMPv6 types. If you specify all ICMP/ICMPv6 types, you must specify all codes.
   *
   * Use this for ICMP and any protocol that uses ports.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html#cfn-ec2-securitygroupingress-fromport
   */
  readonly fromPort?: number;

  /**
   * The ID of the security group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html#cfn-ec2-securitygroupingress-groupid
   */
  readonly groupId?: string;

  /**
   * The name of the security group.
   *
   * Constraints: Up to 255 characters in length. Cannot start with \`sg-\` .
   *
   * Valid characters: a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&;{}!$*
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html#cfn-ec2-securitygroupingress-groupname
   */
  readonly groupName?: string;

  /**
   * The IP protocol name ( \`tcp\` , \`udp\` , \`icmp\` , \`icmpv6\` ) or number (see [Protocol Numbers](https://docs.aws.amazon.com/http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml) ).
   *
   * Use \`-1\` to specify all protocols. When authorizing security group rules, specifying \`-1\` or a protocol number other than \`tcp\` , \`udp\` , \`icmp\` , or \`icmpv6\` allows traffic on all ports, regardless of any port range you specify. For \`tcp\` , \`udp\` , and \`icmp\` , you must specify a port range. For \`icmpv6\` , the port range is optional; if you omit the port range, traffic for all types and codes is allowed.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html#cfn-ec2-securitygroupingress-ipprotocol
   */
  readonly ipProtocol: string;

  /**
   * The ID of a prefix list.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html#cfn-ec2-securitygroupingress-sourceprefixlistid
   */
  readonly sourcePrefixListId?: string;

  /**
   * The ID of the security group.
   *
   * You must specify either the security group ID or the security group name. For security groups in a nondefault VPC, you must specify the security group ID.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html#cfn-ec2-securitygroupingress-sourcesecuritygroupid
   */
  readonly sourceSecurityGroupId?: string;

  /**
   * [Default VPC] The name of the source security group.
   *
   * You must specify either the security group ID or the security group name. You can't specify the group name in combination with an IP address range. Creates rules that grant full ICMP, UDP, and TCP access.
   *
   * For security groups in a nondefault VPC, you must specify the group ID.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html#cfn-ec2-securitygroupingress-sourcesecuritygroupname
   */
  readonly sourceSecurityGroupName?: string;

  /**
   * [nondefault VPC] The AWS account ID for the source security group, if the source security group is in a different account.
   *
   * You can't specify this property with an IP address range. Creates rules that grant full ICMP, UDP, and TCP access.
   *
   * If you specify \`SourceSecurityGroupName\` or \`SourceSecurityGroupId\` and that security group is owned by a different account than the account creating the stack, you must specify \`SourceSecurityGroupOwnerId\` ; otherwise, this property is optional.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html#cfn-ec2-securitygroupingress-sourcesecuritygroupownerid
   */
  readonly sourceSecurityGroupOwnerId?: string;

  /**
   * The end of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 code.
   *
   * A value of \`-1\` indicates all ICMP/ICMPv6 codes for the specified ICMP type. If you specify all ICMP/ICMPv6 types, you must specify all codes.
   *
   * Use this for ICMP and any protocol that uses ports.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html#cfn-ec2-securitygroupingress-toport
   */
  readonly toPort?: number;
}

/**
 * Determine whether the given properties match those of a \`CfnSecurityGroupIngressProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnSecurityGroupIngressProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSecurityGroupIngressPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("cidrIp", cdk.validateString)(properties.cidrIp));
  errors.collect(cdk.propertyValidator("cidrIpv6", cdk.validateString)(properties.cidrIpv6));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("fromPort", cdk.validateNumber)(properties.fromPort));
  errors.collect(cdk.propertyValidator("groupId", cdk.validateString)(properties.groupId));
  errors.collect(cdk.propertyValidator("groupName", cdk.validateString)(properties.groupName));
  errors.collect(cdk.propertyValidator("ipProtocol", cdk.requiredValidator)(properties.ipProtocol));
  errors.collect(cdk.propertyValidator("ipProtocol", cdk.validateString)(properties.ipProtocol));
  errors.collect(cdk.propertyValidator("sourcePrefixListId", cdk.validateString)(properties.sourcePrefixListId));
  errors.collect(cdk.propertyValidator("sourceSecurityGroupId", cdk.validateString)(properties.sourceSecurityGroupId));
  errors.collect(cdk.propertyValidator("sourceSecurityGroupName", cdk.validateString)(properties.sourceSecurityGroupName));
  errors.collect(cdk.propertyValidator("sourceSecurityGroupOwnerId", cdk.validateString)(properties.sourceSecurityGroupOwnerId));
  errors.collect(cdk.propertyValidator("toPort", cdk.validateNumber)(properties.toPort));
  return errors.wrap("supplied properties not correct for \\"CfnSecurityGroupIngressProps\\"");
}

// @ts-ignore TS6133
function convertCfnSecurityGroupIngressPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSecurityGroupIngressPropsValidator(properties).assertSuccess();
  return {
    "CidrIp": cdk.stringToCloudFormation(properties.cidrIp),
    "CidrIpv6": cdk.stringToCloudFormation(properties.cidrIpv6),
    "Description": cdk.stringToCloudFormation(properties.description),
    "FromPort": cdk.numberToCloudFormation(properties.fromPort),
    "GroupId": cdk.stringToCloudFormation(properties.groupId),
    "GroupName": cdk.stringToCloudFormation(properties.groupName),
    "IpProtocol": cdk.stringToCloudFormation(properties.ipProtocol),
    "SourcePrefixListId": cdk.stringToCloudFormation(properties.sourcePrefixListId),
    "SourceSecurityGroupId": cdk.stringToCloudFormation(properties.sourceSecurityGroupId),
    "SourceSecurityGroupName": cdk.stringToCloudFormation(properties.sourceSecurityGroupName),
    "SourceSecurityGroupOwnerId": cdk.stringToCloudFormation(properties.sourceSecurityGroupOwnerId),
    "ToPort": cdk.numberToCloudFormation(properties.toPort)
  };
}

// @ts-ignore TS6133
function CfnSecurityGroupIngressPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSecurityGroupIngressProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSecurityGroupIngressProps>();
  ret.addPropertyResult("cidrIp", "CidrIp", (properties.CidrIp != null ? cfn_parse.FromCloudFormation.getString(properties.CidrIp) : undefined));
  ret.addPropertyResult("cidrIpv6", "CidrIpv6", (properties.CidrIpv6 != null ? cfn_parse.FromCloudFormation.getString(properties.CidrIpv6) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("fromPort", "FromPort", (properties.FromPort != null ? cfn_parse.FromCloudFormation.getNumber(properties.FromPort) : undefined));
  ret.addPropertyResult("groupId", "GroupId", (properties.GroupId != null ? cfn_parse.FromCloudFormation.getString(properties.GroupId) : undefined));
  ret.addPropertyResult("groupName", "GroupName", (properties.GroupName != null ? cfn_parse.FromCloudFormation.getString(properties.GroupName) : undefined));
  ret.addPropertyResult("ipProtocol", "IpProtocol", (properties.IpProtocol != null ? cfn_parse.FromCloudFormation.getString(properties.IpProtocol) : undefined));
  ret.addPropertyResult("sourcePrefixListId", "SourcePrefixListId", (properties.SourcePrefixListId != null ? cfn_parse.FromCloudFormation.getString(properties.SourcePrefixListId) : undefined));
  ret.addPropertyResult("sourceSecurityGroupId", "SourceSecurityGroupId", (properties.SourceSecurityGroupId != null ? cfn_parse.FromCloudFormation.getString(properties.SourceSecurityGroupId) : undefined));
  ret.addPropertyResult("sourceSecurityGroupName", "SourceSecurityGroupName", (properties.SourceSecurityGroupName != null ? cfn_parse.FromCloudFormation.getString(properties.SourceSecurityGroupName) : undefined));
  ret.addPropertyResult("sourceSecurityGroupOwnerId", "SourceSecurityGroupOwnerId", (properties.SourceSecurityGroupOwnerId != null ? cfn_parse.FromCloudFormation.getString(properties.SourceSecurityGroupOwnerId) : undefined));
  ret.addPropertyResult("toPort", "ToPort", (properties.ToPort != null ? cfn_parse.FromCloudFormation.getNumber(properties.ToPort) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a Spot Fleet request.
 *
 * The Spot Fleet request specifies the total target capacity and the On-Demand target capacity. Amazon EC2 calculates the difference between the total capacity and On-Demand capacity, and launches the difference as Spot capacity.
 *
 * You can submit a single request that includes multiple launch specifications that vary by instance type, AMI, Availability Zone, or subnet.
 *
 * By default, the Spot Fleet requests Spot Instances in the Spot Instance pool where the price per unit is the lowest. Each launch specification can include its own instance weighting that reflects the value of the instance type to your application workload.
 *
 * Alternatively, you can specify that the Spot Fleet distribute the target capacity across the Spot pools included in its launch specifications. By ensuring that the Spot Instances in your Spot Fleet are in different Spot pools, you can improve the availability of your fleet.
 *
 * You can specify tags for the Spot Fleet request and instances launched by the fleet. You cannot tag other resource types in a Spot Fleet request because only the \`spot-fleet-request\` and \`instance\` resource types are supported.
 *
 * For more information, see [Spot Fleet](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet.html) in the *Amazon EC2 User Guide for Linux Instances* .
 *
 * > We strongly discourage using the RequestSpotFleet API because it is a legacy API with no planned investment. For options for requesting Spot Instances, see [Which is the best Spot request method to use?](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-best-practices.html#which-spot-request-method-to-use) in the *Amazon EC2 User Guide for Linux Instances* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-spotfleet.html
 */
export class CfnSpotFleet extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::SpotFleet";

  /**
   * Build a CfnSpotFleet from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnSpotFleet {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnSpotFleetPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnSpotFleet(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the Spot Fleet.
   *
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * Describes the configuration of a Spot Fleet request.
   */
  public spotFleetRequestConfigData: cdk.IResolvable | CfnSpotFleet.SpotFleetRequestConfigDataProperty;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnSpotFleetProps) {
    super(scope, id, {
      "type": CfnSpotFleet.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "spotFleetRequestConfigData", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.spotFleetRequestConfigData = props.spotFleetRequestConfigData;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "spotFleetRequestConfigData": this.spotFleetRequestConfigData
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnSpotFleet.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnSpotFleetPropsToCloudFormation(props);
  }
}

export namespace CfnSpotFleet {
  /**
   * Specifies the configuration of a Spot Fleet request.
   *
   * For more information, see [Spot Fleet](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet.html) in the *Amazon EC2 User Guide* .
   *
   * You must specify either \`LaunchSpecifications\` or \`LaunchTemplateConfigs\` .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html
   */
  export interface SpotFleetRequestConfigDataProperty {
    /**
     * The strategy that determines how to allocate the target Spot Instance capacity across the Spot Instance pools specified by the Spot Fleet launch configuration.
     *
     * For more information, see [Allocation strategies for Spot Instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-allocation-strategy.html) in the *Amazon EC2 User Guide* .
     *
     * - **priceCapacityOptimized (recommended)** - Spot Fleet identifies the pools with the highest capacity availability for the number of instances that are launching. This means that we will request Spot Instances from the pools that we believe have the lowest chance of interruption in the near term. Spot Fleet then requests Spot Instances from the lowest priced of these pools.
     * - **capacityOptimized** - Spot Fleet identifies the pools with the highest capacity availability for the number of instances that are launching. This means that we will request Spot Instances from the pools that we believe have the lowest chance of interruption in the near term. To give certain instance types a higher chance of launching first, use \`capacityOptimizedPrioritized\` . Set a priority for each instance type by using the \`Priority\` parameter for \`LaunchTemplateOverrides\` . You can assign the same priority to different \`LaunchTemplateOverrides\` . EC2 implements the priorities on a best-effort basis, but optimizes for capacity first. \`capacityOptimizedPrioritized\` is supported only if your Spot Fleet uses a launch template. Note that if the \`OnDemandAllocationStrategy\` is set to \`prioritized\` , the same priority is applied when fulfilling On-Demand capacity.
     * - **diversified** - Spot Fleet requests instances from all of the Spot Instance pools that you specify.
     * - **lowestPrice** - Spot Fleet requests instances from the lowest priced Spot Instance pool that has available capacity. If the lowest priced pool doesn't have available capacity, the Spot Instances come from the next lowest priced pool that has available capacity. If a pool runs out of capacity before fulfilling your desired capacity, Spot Fleet will continue to fulfill your request by drawing from the next lowest priced pool. To ensure that your desired capacity is met, you might receive Spot Instances from several pools. Because this strategy only considers instance price and not capacity availability, it might lead to high interruption rates.
     *
     * Default: \`lowestPrice\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-allocationstrategy
     */
    readonly allocationStrategy?: string;

    /**
     * Reserved.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-context
     */
    readonly context?: string;

    /**
     * Indicates whether running Spot Instances should be terminated if you decrease the target capacity of the Spot Fleet request below the current size of the Spot Fleet.
     *
     * Supported only for fleets of type \`maintain\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-excesscapacityterminationpolicy
     */
    readonly excessCapacityTerminationPolicy?: string;

    /**
     * The Amazon Resource Name (ARN) of an AWS Identity and Access Management (IAM) role that grants the Spot Fleet the permission to request, launch, terminate, and tag instances on your behalf.
     *
     * For more information, see [Spot Fleet Prerequisites](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-requests.html#spot-fleet-prerequisites) in the *Amazon EC2 User Guide for Linux Instances* . Spot Fleet can terminate Spot Instances on your behalf when you cancel its Spot Fleet request or when the Spot Fleet request expires, if you set \`TerminateInstancesWithExpiration\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-iamfleetrole
     */
    readonly iamFleetRole: string;

    /**
     * The behavior when a Spot Instance is interrupted.
     *
     * The default is \`terminate\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-instanceinterruptionbehavior
     */
    readonly instanceInterruptionBehavior?: string;

    /**
     * The number of Spot pools across which to allocate your target Spot capacity.
     *
     * Valid only when Spot *AllocationStrategy* is set to \`lowest-price\` . Spot Fleet selects the cheapest Spot pools and evenly allocates your target Spot capacity across the number of Spot pools that you specify.
     *
     * Note that Spot Fleet attempts to draw Spot Instances from the number of pools that you specify on a best effort basis. If a pool runs out of Spot capacity before fulfilling your target capacity, Spot Fleet will continue to fulfill your request by drawing from the next cheapest pool. To ensure that your target capacity is met, you might receive Spot Instances from more than the number of pools that you specified. Similarly, if most of the pools have no Spot capacity, you might receive your full target capacity from fewer than the number of pools that you specified.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-instancepoolstousecount
     */
    readonly instancePoolsToUseCount?: number;

    /**
     * The launch specifications for the Spot Fleet request.
     *
     * If you specify \`LaunchSpecifications\` , you can't specify \`LaunchTemplateConfigs\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-launchspecifications
     */
    readonly launchSpecifications?: Array<cdk.IResolvable | CfnSpotFleet.SpotFleetLaunchSpecificationProperty> | cdk.IResolvable;

    /**
     * The launch template and overrides.
     *
     * If you specify \`LaunchTemplateConfigs\` , you can't specify \`LaunchSpecifications\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-launchtemplateconfigs
     */
    readonly launchTemplateConfigs?: Array<cdk.IResolvable | CfnSpotFleet.LaunchTemplateConfigProperty> | cdk.IResolvable;

    /**
     * One or more Classic Load Balancers and target groups to attach to the Spot Fleet request.
     *
     * Spot Fleet registers the running Spot Instances with the specified Classic Load Balancers and target groups.
     *
     * With Network Load Balancers, Spot Fleet cannot register instances that have the following instance types: C1, CC1, CC2, CG1, CG2, CR1, CS1, G1, G2, HI1, HS1, M1, M2, M3, and T1.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-loadbalancersconfig
     */
    readonly loadBalancersConfig?: cdk.IResolvable | CfnSpotFleet.LoadBalancersConfigProperty;

    /**
     * The order of the launch template overrides to use in fulfilling On-Demand capacity.
     *
     * If you specify \`lowestPrice\` , Spot Fleet uses price to determine the order, launching the lowest price first. If you specify \`prioritized\` , Spot Fleet uses the priority that you assign to each Spot Fleet launch template override, launching the highest priority first. If you do not specify a value, Spot Fleet defaults to \`lowestPrice\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-ondemandallocationstrategy
     */
    readonly onDemandAllocationStrategy?: string;

    /**
     * The maximum amount per hour for On-Demand Instances that you're willing to pay.
     *
     * You can use the \`onDemandMaxTotalPrice\` parameter, the \`spotMaxTotalPrice\` parameter, or both parameters to ensure that your fleet cost does not exceed your budget. If you set a maximum price per hour for the On-Demand Instances and Spot Instances in your request, Spot Fleet will launch instances until it reaches the maximum amount you're willing to pay. When the maximum amount you're willing to pay is reached, the fleet stops launching instances even if it hasnt met the target capacity.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-ondemandmaxtotalprice
     */
    readonly onDemandMaxTotalPrice?: string;

    /**
     * The number of On-Demand units to request.
     *
     * You can choose to set the target capacity in terms of instances or a performance characteristic that is important to your application workload, such as vCPUs, memory, or I/O. If the request type is \`maintain\` , you can specify a target capacity of 0 and add capacity later.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-ondemandtargetcapacity
     */
    readonly onDemandTargetCapacity?: number;

    /**
     * Indicates whether Spot Fleet should replace unhealthy instances.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-replaceunhealthyinstances
     */
    readonly replaceUnhealthyInstances?: boolean | cdk.IResolvable;

    /**
     * The strategies for managing your Spot Instances that are at an elevated risk of being interrupted.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-spotmaintenancestrategies
     */
    readonly spotMaintenanceStrategies?: cdk.IResolvable | CfnSpotFleet.SpotMaintenanceStrategiesProperty;

    /**
     * The maximum amount per hour for Spot Instances that you're willing to pay.
     *
     * You can use the \`spotdMaxTotalPrice\` parameter, the \`onDemandMaxTotalPrice\` parameter, or both parameters to ensure that your fleet cost does not exceed your budget. If you set a maximum price per hour for the On-Demand Instances and Spot Instances in your request, Spot Fleet will launch instances until it reaches the maximum amount you're willing to pay. When the maximum amount you're willing to pay is reached, the fleet stops launching instances even if it hasnt met the target capacity.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-spotmaxtotalprice
     */
    readonly spotMaxTotalPrice?: string;

    /**
     * The maximum price per unit hour that you are willing to pay for a Spot Instance.
     *
     * We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price.
     *
     * > If you specify a maximum price, your instances will be interrupted more frequently than if you do not specify this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-spotprice
     */
    readonly spotPrice?: string;

    /**
     * The key-value pair for tagging the Spot Fleet request on creation.
     *
     * The value for \`ResourceType\` must be \`spot-fleet-request\` , otherwise the Spot Fleet request fails. To tag instances at launch, specify the tags in the [launch template](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-templates.html#create-launch-template) (valid only if you use \`LaunchTemplateConfigs\` ) or in the \`[SpotFleetTagSpecification](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_SpotFleetTagSpecification.html)\` (valid only if you use \`LaunchSpecifications\` ). For information about tagging after launch, see [Tagging Your Resources](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html#tag-resources) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-tagspecifications
     */
    readonly tagSpecifications?: Array<cdk.IResolvable | CfnSpotFleet.SpotFleetTagSpecificationProperty> | cdk.IResolvable;

    /**
     * The number of units to request for the Spot Fleet.
     *
     * You can choose to set the target capacity in terms of instances or a performance characteristic that is important to your application workload, such as vCPUs, memory, or I/O. If the request type is \`maintain\` , you can specify a target capacity of 0 and add capacity later.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-targetcapacity
     */
    readonly targetCapacity: number;

    /**
     * The unit for the target capacity. \`TargetCapacityUnitType\` can only be specified when \`InstanceRequirements\` is specified.
     *
     * Default: \`units\` (translates to number of instances)
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-targetcapacityunittype
     */
    readonly targetCapacityUnitType?: string;

    /**
     * Indicates whether running Spot Instances are terminated when the Spot Fleet request expires.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-terminateinstanceswithexpiration
     */
    readonly terminateInstancesWithExpiration?: boolean | cdk.IResolvable;

    /**
     * The type of request.
     *
     * Indicates whether the Spot Fleet only requests the target capacity or also attempts to maintain it. When this value is \`request\` , the Spot Fleet only places the required requests. It does not attempt to replenish Spot Instances if capacity is diminished, nor does it submit requests in alternative Spot pools if capacity is not available. When this value is \`maintain\` , the Spot Fleet maintains the target capacity. The Spot Fleet places the required requests to meet capacity and automatically replenishes any interrupted instances. Default: \`maintain\` . \`instant\` is listed but is not used by Spot Fleet.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-type
     */
    readonly type?: string;

    /**
     * The start date and time of the request, in UTC format ( *YYYY* - *MM* - *DD* T *HH* : *MM* : *SS* Z).
     *
     * By default, Amazon EC2 starts fulfilling the request immediately.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-validfrom
     */
    readonly validFrom?: string;

    /**
     * The end date and time of the request, in UTC format ( *YYYY* - *MM* - *DD* T *HH* : *MM* : *SS* Z).
     *
     * After the end date and time, no new Spot Instance requests are placed or able to fulfill the request. If no value is specified, the Spot Fleet request remains until you cancel it.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-validuntil
     */
    readonly validUntil?: string;
  }

  /**
   * Specifies the launch specification for one or more Spot Instances.
   *
   * If you include On-Demand capacity in your fleet request, you can't use \`SpotFleetLaunchSpecification\` ; you must use [LaunchTemplateConfig](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-launchtemplateconfig.html) .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html
   */
  export interface SpotFleetLaunchSpecificationProperty {
    /**
     * One or more block devices that are mapped to the Spot Instances.
     *
     * You can't specify both a snapshot ID and an encryption value. This is because only blank volumes can be encrypted on creation. If a snapshot is the basis for a volume, it is not blank and its encryption status is used for the volume encryption status.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-blockdevicemappings
     */
    readonly blockDeviceMappings?: Array<CfnSpotFleet.BlockDeviceMappingProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * Indicates whether the instances are optimized for EBS I/O.
     *
     * This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance.
     *
     * Default: \`false\`
     *
     * @default - false
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-ebsoptimized
     */
    readonly ebsOptimized?: boolean | cdk.IResolvable;

    /**
     * The IAM instance profile.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-iaminstanceprofile
     */
    readonly iamInstanceProfile?: CfnSpotFleet.IamInstanceProfileSpecificationProperty | cdk.IResolvable;

    /**
     * The ID of the AMI.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-imageid
     */
    readonly imageId: string;

    /**
     * The attributes for the instance types.
     *
     * When you specify instance attributes, Amazon EC2 will identify instance types with those attributes.
     *
     * > If you specify \`InstanceRequirements\` , you can't specify \`InstanceType\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-instancerequirements
     */
    readonly instanceRequirements?: CfnSpotFleet.InstanceRequirementsRequestProperty | cdk.IResolvable;

    /**
     * The instance type.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-instancetype
     */
    readonly instanceType?: string;

    /**
     * The ID of the kernel.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-kernelid
     */
    readonly kernelId?: string;

    /**
     * The name of the key pair.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-keyname
     */
    readonly keyName?: string;

    /**
     * Enable or disable monitoring for the instances.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-monitoring
     */
    readonly monitoring?: cdk.IResolvable | CfnSpotFleet.SpotFleetMonitoringProperty;

    /**
     * One or more network interfaces.
     *
     * If you specify a network interface, you must specify subnet IDs and security group IDs using the network interface.
     *
     * > \`SpotFleetLaunchSpecification\` currently does not support Elastic Fabric Adapter (EFA). To specify an EFA, you must use [LaunchTemplateConfig](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_LaunchTemplateConfig.html) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-networkinterfaces
     */
    readonly networkInterfaces?: Array<CfnSpotFleet.InstanceNetworkInterfaceSpecificationProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The placement information.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-placement
     */
    readonly placement?: cdk.IResolvable | CfnSpotFleet.SpotPlacementProperty;

    /**
     * The ID of the RAM disk.
     *
     * Some kernels require additional drivers at launch. Check the kernel requirements for information about whether you need to specify a RAM disk. To find kernel requirements, refer to the AWS Resource Center and search for the kernel ID.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-ramdiskid
     */
    readonly ramdiskId?: string;

    /**
     * The security groups.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-securitygroups
     */
    readonly securityGroups?: Array<CfnSpotFleet.GroupIdentifierProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The maximum price per unit hour that you are willing to pay for a Spot Instance.
     *
     * We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price.
     *
     * > If you specify a maximum price, your instances will be interrupted more frequently than if you do not specify this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-spotprice
     */
    readonly spotPrice?: string;

    /**
     * The IDs of the subnets in which to launch the instances.
     *
     * To specify multiple subnets, separate them using commas; for example, "subnet-1234abcdeexample1, subnet-0987cdef6example2".
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-subnetid
     */
    readonly subnetId?: string;

    /**
     * The tags to apply during creation.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-tagspecifications
     */
    readonly tagSpecifications?: Array<cdk.IResolvable | CfnSpotFleet.SpotFleetTagSpecificationProperty> | cdk.IResolvable;

    /**
     * The base64-encoded user data that instances use when starting up.
     *
     * User data is limited to 16 KB.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-userdata
     */
    readonly userData?: string;

    /**
     * The number of units provided by the specified instance type.
     *
     * These are the same units that you chose to set the target capacity in terms of instances, or a performance characteristic such as vCPUs, memory, or I/O.
     *
     * If the target capacity divided by this value is not a whole number, Amazon EC2 rounds the number of instances to the next whole number. If this value is not specified, the default is 1.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-weightedcapacity
     */
    readonly weightedCapacity?: number;
  }

  /**
   * Specifies a block device mapping.
   *
   * You can specify \`Ebs\` or \`VirtualName\` , but not both.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-blockdevicemapping.html
   */
  export interface BlockDeviceMappingProperty {
    /**
     * The device name (for example, \`/dev/sdh\` or \`xvdh\` ).
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-blockdevicemapping.html#cfn-ec2-spotfleet-blockdevicemapping-devicename
     */
    readonly deviceName: string;

    /**
     * Parameters used to automatically set up EBS volumes when the instance is launched.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-blockdevicemapping.html#cfn-ec2-spotfleet-blockdevicemapping-ebs
     */
    readonly ebs?: CfnSpotFleet.EbsBlockDeviceProperty | cdk.IResolvable;

    /**
     * To omit the device from the block device mapping, specify an empty string.
     *
     * When this property is specified, the device is removed from the block device mapping regardless of the assigned value.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-blockdevicemapping.html#cfn-ec2-spotfleet-blockdevicemapping-nodevice
     */
    readonly noDevice?: string;

    /**
     * The virtual device name ( \`ephemeral\` N).
     *
     * Instance store volumes are numbered starting from 0. An instance type with 2 available instance store volumes can specify mappings for \`ephemeral0\` and \`ephemeral1\` . The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume.
     *
     * NVMe instance store volumes are automatically enumerated and assigned a device name. Including them in your block device mapping has no effect.
     *
     * Constraints: For M3 instances, you must specify instance store volumes in the block device mapping for the instance. When you launch an M3 instance, we ignore any instance store volumes specified in the block device mapping for the AMI.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-blockdevicemapping.html#cfn-ec2-spotfleet-blockdevicemapping-virtualname
     */
    readonly virtualName?: string;
  }

  /**
   * Describes a block device for an EBS volume.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-ebsblockdevice.html
   */
  export interface EbsBlockDeviceProperty {
    /**
     * Indicates whether the EBS volume is deleted on instance termination.
     *
     * For more information, see [Preserving Amazon EBS volumes on instance termination](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/terminating-instances.html#preserving-volumes-on-termination) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-ebsblockdevice.html#cfn-ec2-spotfleet-ebsblockdevice-deleteontermination
     */
    readonly deleteOnTermination?: boolean | cdk.IResolvable;

    /**
     * Indicates whether the encryption state of an EBS volume is changed while being restored from a backing snapshot.
     *
     * The effect of setting the encryption state to \`true\` depends on the volume origin (new or from a snapshot), starting encryption state, ownership, and whether encryption by default is enabled. For more information, see [Amazon EBS Encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#encryption-parameters) in the *Amazon EC2 User Guide* .
     *
     * In no case can you remove encryption from an encrypted volume.
     *
     * Encrypted volumes can only be attached to instances that support Amazon EBS encryption. For more information, see [Supported Instance Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#EBSEncryption_supported_instances) .
     *
     * This parameter is not returned by [DescribeImageAttribute](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeImageAttribute.html) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-ebsblockdevice.html#cfn-ec2-spotfleet-ebsblockdevice-encrypted
     */
    readonly encrypted?: boolean | cdk.IResolvable;

    /**
     * The number of I/O operations per second (IOPS).
     *
     * For \`gp3\` , \`io1\` , and \`io2\` volumes, this represents the number of IOPS that are provisioned for the volume. For \`gp2\` volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting.
     *
     * The following are the supported values for each volume type:
     *
     * - \`gp3\` : 3,000-16,000 IOPS
     * - \`io1\` : 100-64,000 IOPS
     * - \`io2\` : 100-64,000 IOPS
     *
     * For \`io1\` and \`io2\` volumes, we guarantee 64,000 IOPS only for [Instances built on the Nitro System](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances) . Other instance families guarantee performance up to 32,000 IOPS.
     *
     * This parameter is required for \`io1\` and \`io2\` volumes. The default for \`gp3\` volumes is 3,000 IOPS. This parameter is not supported for \`gp2\` , \`st1\` , \`sc1\` , or \`standard\` volumes.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-ebsblockdevice.html#cfn-ec2-spotfleet-ebsblockdevice-iops
     */
    readonly iops?: number;

    /**
     * The ID of the snapshot.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-ebsblockdevice.html#cfn-ec2-spotfleet-ebsblockdevice-snapshotid
     */
    readonly snapshotId?: string;

    /**
     * The size of the volume, in GiBs.
     *
     * You must specify either a snapshot ID or a volume size. If you specify a snapshot, the default is the snapshot size. You can specify a volume size that is equal to or larger than the snapshot size.
     *
     * The following are the supported volumes sizes for each volume type:
     *
     * - \`gp2\` and \`gp3\` :1-16,384
     * - \`io1\` and \`io2\` : 4-16,384
     * - \`st1\` and \`sc1\` : 125-16,384
     * - \`standard\` : 1-1,024
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-ebsblockdevice.html#cfn-ec2-spotfleet-ebsblockdevice-volumesize
     */
    readonly volumeSize?: number;

    /**
     * The volume type.
     *
     * For more information, see [Amazon EBS volume types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html) in the *Amazon EC2 User Guide* . If the volume type is \`io1\` or \`io2\` , you must specify the IOPS that the volume supports.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-ebsblockdevice.html#cfn-ec2-spotfleet-ebsblockdevice-volumetype
     */
    readonly volumeType?: string;
  }

  /**
   * Describes an IAM instance profile.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-iaminstanceprofilespecification.html
   */
  export interface IamInstanceProfileSpecificationProperty {
    /**
     * The Amazon Resource Name (ARN) of the instance profile.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-iaminstanceprofilespecification.html#cfn-ec2-spotfleet-iaminstanceprofilespecification-arn
     */
    readonly arn?: string;
  }

  /**
   * Describes whether monitoring is enabled.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetmonitoring.html
   */
  export interface SpotFleetMonitoringProperty {
    /**
     * Enables monitoring for the instance.
     *
     * Default: \`false\`
     *
     * @default - false
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetmonitoring.html#cfn-ec2-spotfleet-spotfleetmonitoring-enabled
     */
    readonly enabled?: boolean | cdk.IResolvable;
  }

  /**
   * Describes a network interface.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancenetworkinterfacespecification.html
   */
  export interface InstanceNetworkInterfaceSpecificationProperty {
    /**
     * Indicates whether to assign a public IPv4 address to an instance you launch in a VPC.
     *
     * The public IP address can only be assigned to a network interface for eth0, and can only be assigned to a new network interface, not an existing one. You cannot specify more than one network interface in the request. If launching into a default subnet, the default value is \`true\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancenetworkinterfacespecification.html#cfn-ec2-spotfleet-instancenetworkinterfacespecification-associatepublicipaddress
     */
    readonly associatePublicIpAddress?: boolean | cdk.IResolvable;

    /**
     * Indicates whether the network interface is deleted when the instance is terminated.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancenetworkinterfacespecification.html#cfn-ec2-spotfleet-instancenetworkinterfacespecification-deleteontermination
     */
    readonly deleteOnTermination?: boolean | cdk.IResolvable;

    /**
     * The description of the network interface.
     *
     * Applies only if creating a network interface when launching an instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancenetworkinterfacespecification.html#cfn-ec2-spotfleet-instancenetworkinterfacespecification-description
     */
    readonly description?: string;

    /**
     * The position of the network interface in the attachment order.
     *
     * A primary network interface has a device index of 0.
     *
     * If you specify a network interface when launching an instance, you must specify the device index.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancenetworkinterfacespecification.html#cfn-ec2-spotfleet-instancenetworkinterfacespecification-deviceindex
     */
    readonly deviceIndex?: number;

    /**
     * The IDs of the security groups for the network interface.
     *
     * Applies only if creating a network interface when launching an instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancenetworkinterfacespecification.html#cfn-ec2-spotfleet-instancenetworkinterfacespecification-groups
     */
    readonly groups?: Array<string>;

    /**
     * A number of IPv6 addresses to assign to the network interface.
     *
     * Amazon EC2 chooses the IPv6 addresses from the range of the subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancenetworkinterfacespecification.html#cfn-ec2-spotfleet-instancenetworkinterfacespecification-ipv6addresscount
     */
    readonly ipv6AddressCount?: number;

    /**
     * The IPv6 addresses to assign to the network interface.
     *
     * You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancenetworkinterfacespecification.html#cfn-ec2-spotfleet-instancenetworkinterfacespecification-ipv6addresses
     */
    readonly ipv6Addresses?: Array<CfnSpotFleet.InstanceIpv6AddressProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The ID of the network interface.
     *
     * If you are creating a Spot Fleet, omit this parameter because you cant specify a network interface ID in a launch specification.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancenetworkinterfacespecification.html#cfn-ec2-spotfleet-instancenetworkinterfacespecification-networkinterfaceid
     */
    readonly networkInterfaceId?: string;

    /**
     * The private IPv4 addresses to assign to the network interface.
     *
     * Only one private IPv4 address can be designated as primary. You cannot specify this option if you're launching more than one instance in a [RunInstances](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html) request.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancenetworkinterfacespecification.html#cfn-ec2-spotfleet-instancenetworkinterfacespecification-privateipaddresses
     */
    readonly privateIpAddresses?: Array<cdk.IResolvable | CfnSpotFleet.PrivateIpAddressSpecificationProperty> | cdk.IResolvable;

    /**
     * The number of secondary private IPv4 addresses.
     *
     * You can't specify this option and specify more than one private IP address using the private IP addresses option. You cannot specify this option if you're launching more than one instance in a [RunInstances](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html) request.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancenetworkinterfacespecification.html#cfn-ec2-spotfleet-instancenetworkinterfacespecification-secondaryprivateipaddresscount
     */
    readonly secondaryPrivateIpAddressCount?: number;

    /**
     * The ID of the subnet associated with the network interface.
     *
     * Applies only if creating a network interface when launching an instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancenetworkinterfacespecification.html#cfn-ec2-spotfleet-instancenetworkinterfacespecification-subnetid
     */
    readonly subnetId?: string;
  }

  /**
   * Describes an IPv6 address.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instanceipv6address.html
   */
  export interface InstanceIpv6AddressProperty {
    /**
     * The IPv6 address.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instanceipv6address.html#cfn-ec2-spotfleet-instanceipv6address-ipv6address
     */
    readonly ipv6Address: string;
  }

  /**
   * Describes a secondary private IPv4 address for a network interface.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-privateipaddressspecification.html
   */
  export interface PrivateIpAddressSpecificationProperty {
    /**
     * Indicates whether the private IPv4 address is the primary private IPv4 address.
     *
     * Only one IPv4 address can be designated as primary.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-privateipaddressspecification.html#cfn-ec2-spotfleet-privateipaddressspecification-primary
     */
    readonly primary?: boolean | cdk.IResolvable;

    /**
     * The private IPv4 address.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-privateipaddressspecification.html#cfn-ec2-spotfleet-privateipaddressspecification-privateipaddress
     */
    readonly privateIpAddress: string;
  }

  /**
   * Describes Spot Instance placement.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotplacement.html
   */
  export interface SpotPlacementProperty {
    /**
     * The Availability Zone.
     *
     * To specify multiple Availability Zones, separate them using commas; for example, "us-west-2a, us-west-2b".
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotplacement.html#cfn-ec2-spotfleet-spotplacement-availabilityzone
     */
    readonly availabilityZone?: string;

    /**
     * The name of the placement group.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotplacement.html#cfn-ec2-spotfleet-spotplacement-groupname
     */
    readonly groupName?: string;

    /**
     * The tenancy of the instance (if the instance is running in a VPC).
     *
     * An instance with a tenancy of \`dedicated\` runs on single-tenant hardware. The \`host\` tenancy is not supported for Spot Instances.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotplacement.html#cfn-ec2-spotfleet-spotplacement-tenancy
     */
    readonly tenancy?: string;
  }

  /**
   * Describes a security group.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-groupidentifier.html
   */
  export interface GroupIdentifierProperty {
    /**
     * The ID of the security group.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-groupidentifier.html#cfn-ec2-spotfleet-groupidentifier-groupid
     */
    readonly groupId: string;
  }

  /**
   * The tags for a Spot Fleet resource.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleettagspecification.html
   */
  export interface SpotFleetTagSpecificationProperty {
    /**
     * The type of resource.
     *
     * Currently, the only resource type that is supported is \`instance\` . To tag the Spot Fleet request on creation, use the \`TagSpecifications\` parameter in \`[SpotFleetRequestConfigData](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_SpotFleetRequestConfigData.html)\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleettagspecification.html#cfn-ec2-spotfleet-spotfleettagspecification-resourcetype
     */
    readonly resourceType?: string;

    /**
     * The tags.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleettagspecification.html#cfn-ec2-spotfleet-spotfleettagspecification-tags
     */
    readonly tags?: Array<cdk.CfnTag>;
  }

  /**
   * The attributes for the instance types.
   *
   * When you specify instance attributes, Amazon EC2 will identify instance types with these attributes.
   *
   * When you specify multiple attributes, you get instance types that satisfy all of the specified attributes. If you specify multiple values for an attribute, you get instance types that satisfy any of the specified values.
   *
   * To limit the list of instance types from which Amazon EC2 can identify matching instance types, you can use one of the following parameters, but not both in the same request:
   *
   * - \`AllowedInstanceTypes\` - The instance types to include in the list. All other instance types are ignored, even if they match your specified attributes.
   * - \`ExcludedInstanceTypes\` - The instance types to exclude from the list, even if they match your specified attributes.
   *
   * > You must specify \`VCpuCount\` and \`MemoryMiB\` . All other attributes are optional. Any unspecified optional attribute is set to its default.
   *
   * For more information, see [Attribute-based instance type selection for EC2 Fleet](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html) , [Attribute-based instance type selection for Spot Fleet](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-attribute-based-instance-type-selection.html) , and [Spot placement score](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-placement-score.html) in the *Amazon EC2 User Guide* .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html
   */
  export interface InstanceRequirementsRequestProperty {
    /**
     * The minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips) on an instance.
     *
     * To exclude accelerator-enabled instance types, set \`Max\` to \`0\` .
     *
     * Default: No minimum or maximum limits
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-acceleratorcount
     */
    readonly acceleratorCount?: CfnSpotFleet.AcceleratorCountRequestProperty | cdk.IResolvable;

    /**
     * Indicates whether instance types must have accelerators by specific manufacturers.
     *
     * - For instance types with NVIDIA devices, specify \`nvidia\` .
     * - For instance types with AMD devices, specify \`amd\` .
     * - For instance types with AWS devices, specify \`amazon-web-services\` .
     * - For instance types with Xilinx devices, specify \`xilinx\` .
     *
     * Default: Any manufacturer
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-acceleratormanufacturers
     */
    readonly acceleratorManufacturers?: Array<string>;

    /**
     * The accelerators that must be on the instance type.
     *
     * - For instance types with NVIDIA A100 GPUs, specify \`a100\` .
     * - For instance types with NVIDIA V100 GPUs, specify \`v100\` .
     * - For instance types with NVIDIA K80 GPUs, specify \`k80\` .
     * - For instance types with NVIDIA T4 GPUs, specify \`t4\` .
     * - For instance types with NVIDIA M60 GPUs, specify \`m60\` .
     * - For instance types with AMD Radeon Pro V520 GPUs, specify \`radeon-pro-v520\` .
     * - For instance types with Xilinx VU9P FPGAs, specify \`vu9p\` .
     * - For instance types with AWS Inferentia chips, specify \`inferentia\` .
     * - For instance types with NVIDIA GRID K520 GPUs, specify \`k520\` .
     *
     * Default: Any accelerator
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-acceleratornames
     */
    readonly acceleratorNames?: Array<string>;

    /**
     * The minimum and maximum amount of total accelerator memory, in MiB.
     *
     * Default: No minimum or maximum limits
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-acceleratortotalmemorymib
     */
    readonly acceleratorTotalMemoryMiB?: CfnSpotFleet.AcceleratorTotalMemoryMiBRequestProperty | cdk.IResolvable;

    /**
     * The accelerator types that must be on the instance type.
     *
     * - To include instance types with GPU hardware, specify \`gpu\` .
     * - To include instance types with FPGA hardware, specify \`fpga\` .
     * - To include instance types with inference hardware, specify \`inference\` .
     *
     * Default: Any accelerator type
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-acceleratortypes
     */
    readonly acceleratorTypes?: Array<string>;

    /**
     * The instance types to apply your specified attributes against.
     *
     * All other instance types are ignored, even if they match your specified attributes.
     *
     * You can use strings with one or more wild cards, represented by an asterisk ( \`*\` ), to allow an instance type, size, or generation. The following are examples: \`m5.8xlarge\` , \`c5*.*\` , \`m5a.*\` , \`r*\` , \`*3*\` .
     *
     * For example, if you specify \`c5*\` ,Amazon EC2 will allow the entire C5 instance family, which includes all C5a and C5n instance types. If you specify \`m5a.*\` , Amazon EC2 will allow all the M5a instance types, but not the M5n instance types.
     *
     * > If you specify \`AllowedInstanceTypes\` , you can't specify \`ExcludedInstanceTypes\` .
     *
     * Default: All instance types
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-allowedinstancetypes
     */
    readonly allowedInstanceTypes?: Array<string>;

    /**
     * Indicates whether bare metal instance types must be included, excluded, or required.
     *
     * - To include bare metal instance types, specify \`included\` .
     * - To require only bare metal instance types, specify \`required\` .
     * - To exclude bare metal instance types, specify \`excluded\` .
     *
     * Default: \`excluded\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-baremetal
     */
    readonly bareMetal?: string;

    /**
     * The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps.
     *
     * For more information, see [Amazon EBSoptimized instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html) in the *Amazon EC2 User Guide* .
     *
     * Default: No minimum or maximum limits
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-baselineebsbandwidthmbps
     */
    readonly baselineEbsBandwidthMbps?: CfnSpotFleet.BaselineEbsBandwidthMbpsRequestProperty | cdk.IResolvable;

    /**
     * Indicates whether burstable performance T instance types are included, excluded, or required.
     *
     * For more information, see [Burstable performance instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html) .
     *
     * - To include burstable performance instance types, specify \`included\` .
     * - To require only burstable performance instance types, specify \`required\` .
     * - To exclude burstable performance instance types, specify \`excluded\` .
     *
     * Default: \`excluded\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-burstableperformance
     */
    readonly burstablePerformance?: string;

    /**
     * The CPU manufacturers to include.
     *
     * - For instance types with Intel CPUs, specify \`intel\` .
     * - For instance types with AMD CPUs, specify \`amd\` .
     * - For instance types with AWS CPUs, specify \`amazon-web-services\` .
     *
     * > Don't confuse the CPU manufacturer with the CPU architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template.
     *
     * Default: Any manufacturer
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-cpumanufacturers
     */
    readonly cpuManufacturers?: Array<string>;

    /**
     * The instance types to exclude.
     *
     * You can use strings with one or more wild cards, represented by an asterisk ( \`*\` ), to exclude an instance family, type, size, or generation. The following are examples: \`m5.8xlarge\` , \`c5*.*\` , \`m5a.*\` , \`r*\` , \`*3*\` .
     *
     * For example, if you specify \`c5*\` ,Amazon EC2 will exclude the entire C5 instance family, which includes all C5a and C5n instance types. If you specify \`m5a.*\` , Amazon EC2 will exclude all the M5a instance types, but not the M5n instance types.
     *
     * > If you specify \`ExcludedInstanceTypes\` , you can't specify \`AllowedInstanceTypes\` .
     *
     * Default: No excluded instance types
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-excludedinstancetypes
     */
    readonly excludedInstanceTypes?: Array<string>;

    /**
     * Indicates whether current or previous generation instance types are included.
     *
     * The current generation instance types are recommended for use. Current generation instance types are typically the latest two to three generations in each instance family. For more information, see [Instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the *Amazon EC2 User Guide* .
     *
     * For current generation instance types, specify \`current\` .
     *
     * For previous generation instance types, specify \`previous\` .
     *
     * Default: Current and previous generation instance types
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-instancegenerations
     */
    readonly instanceGenerations?: Array<string>;

    /**
     * Indicates whether instance types with instance store volumes are included, excluded, or required.
     *
     * For more information, [Amazon EC2 instance store](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html) in the *Amazon EC2 User Guide* .
     *
     * - To include instance types with instance store volumes, specify \`included\` .
     * - To require only instance types with instance store volumes, specify \`required\` .
     * - To exclude instance types with instance store volumes, specify \`excluded\` .
     *
     * Default: \`included\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-localstorage
     */
    readonly localStorage?: string;

    /**
     * The type of local storage that is required.
     *
     * - For instance types with hard disk drive (HDD) storage, specify \`hdd\` .
     * - For instance types with solid state drive (SSD) storage, specify \`ssd\` .
     *
     * Default: \`hdd\` and \`ssd\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-localstoragetypes
     */
    readonly localStorageTypes?: Array<string>;

    /**
     * The minimum and maximum amount of memory per vCPU, in GiB.
     *
     * Default: No minimum or maximum limits
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-memorygibpervcpu
     */
    readonly memoryGiBPerVCpu?: cdk.IResolvable | CfnSpotFleet.MemoryGiBPerVCpuRequestProperty;

    /**
     * The minimum and maximum amount of memory, in MiB.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-memorymib
     */
    readonly memoryMiB?: cdk.IResolvable | CfnSpotFleet.MemoryMiBRequestProperty;

    /**
     * The minimum and maximum amount of network bandwidth, in gigabits per second (Gbps).
     *
     * Default: No minimum or maximum limits
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-networkbandwidthgbps
     */
    readonly networkBandwidthGbps?: cdk.IResolvable | CfnSpotFleet.NetworkBandwidthGbpsRequestProperty;

    /**
     * The minimum and maximum number of network interfaces.
     *
     * Default: No minimum or maximum limits
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-networkinterfacecount
     */
    readonly networkInterfaceCount?: cdk.IResolvable | CfnSpotFleet.NetworkInterfaceCountRequestProperty;

    /**
     * The price protection threshold for On-Demand Instances.
     *
     * This is the maximum youll pay for an On-Demand Instance, expressed as a percentage above the least expensive current generation M, C, or R instance type with your specified attributes. When Amazon EC2 selects instance types with your attributes, it excludes instance types priced above your threshold.
     *
     * The parameter accepts an integer, which Amazon EC2 interprets as a percentage.
     *
     * To turn off price protection, specify a high value, such as \`999999\` .
     *
     * This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) and [GetInstanceTypesFromInstanceRequirements](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html) .
     *
     * > If you set \`TargetCapacityUnitType\` to \`vcpu\` or \`memory-mib\` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price.
     *
     * Default: \`20\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-ondemandmaxpricepercentageoverlowestprice
     */
    readonly onDemandMaxPricePercentageOverLowestPrice?: number;

    /**
     * Indicates whether instance types must support hibernation for On-Demand Instances.
     *
     * This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) .
     *
     * Default: \`false\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-requirehibernatesupport
     */
    readonly requireHibernateSupport?: boolean | cdk.IResolvable;

    /**
     * The price protection threshold for Spot Instance.
     *
     * This is the maximum youll pay for an Spot Instance, expressed as a percentage above the least expensive current generation M, C, or R instance type with your specified attributes. When Amazon EC2 selects instance types with your attributes, it excludes instance types priced above your threshold.
     *
     * The parameter accepts an integer, which Amazon EC2 interprets as a percentage.
     *
     * To turn off price protection, specify a high value, such as \`999999\` .
     *
     * This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) and [GetInstanceTypesFromInstanceRequirements](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html) .
     *
     * > If you set \`TargetCapacityUnitType\` to \`vcpu\` or \`memory-mib\` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price.
     *
     * Default: \`100\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-spotmaxpricepercentageoverlowestprice
     */
    readonly spotMaxPricePercentageOverLowestPrice?: number;

    /**
     * The minimum and maximum amount of total local storage, in GB.
     *
     * Default: No minimum or maximum limits
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-totallocalstoragegb
     */
    readonly totalLocalStorageGb?: cdk.IResolvable | CfnSpotFleet.TotalLocalStorageGBRequestProperty;

    /**
     * The minimum and maximum number of vCPUs.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-vcpucount
     */
    readonly vCpuCount?: cdk.IResolvable | CfnSpotFleet.VCpuCountRangeRequestProperty;
  }

  /**
   * The minimum and maximum number of vCPUs.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-vcpucountrangerequest.html
   */
  export interface VCpuCountRangeRequestProperty {
    /**
     * The maximum number of vCPUs.
     *
     * To specify no maximum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-vcpucountrangerequest.html#cfn-ec2-spotfleet-vcpucountrangerequest-max
     */
    readonly max?: number;

    /**
     * The minimum number of vCPUs.
     *
     * To specify no minimum limit, specify \`0\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-vcpucountrangerequest.html#cfn-ec2-spotfleet-vcpucountrangerequest-min
     */
    readonly min?: number;
  }

  /**
   * The minimum and maximum amount of memory, in MiB.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-memorymibrequest.html
   */
  export interface MemoryMiBRequestProperty {
    /**
     * The maximum amount of memory, in MiB.
     *
     * To specify no maximum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-memorymibrequest.html#cfn-ec2-spotfleet-memorymibrequest-max
     */
    readonly max?: number;

    /**
     * The minimum amount of memory, in MiB.
     *
     * To specify no minimum limit, specify \`0\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-memorymibrequest.html#cfn-ec2-spotfleet-memorymibrequest-min
     */
    readonly min?: number;
  }

  /**
   * The minimum and maximum amount of memory per vCPU, in GiB.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-memorygibpervcpurequest.html
   */
  export interface MemoryGiBPerVCpuRequestProperty {
    /**
     * The maximum amount of memory per vCPU, in GiB.
     *
     * To specify no maximum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-memorygibpervcpurequest.html#cfn-ec2-spotfleet-memorygibpervcpurequest-max
     */
    readonly max?: number;

    /**
     * The minimum amount of memory per vCPU, in GiB.
     *
     * To specify no minimum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-memorygibpervcpurequest.html#cfn-ec2-spotfleet-memorygibpervcpurequest-min
     */
    readonly min?: number;
  }

  /**
   * The minimum and maximum amount of network bandwidth, in gigabits per second (Gbps).
   *
   * Default: No minimum or maximum limits
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-networkbandwidthgbpsrequest.html
   */
  export interface NetworkBandwidthGbpsRequestProperty {
    /**
     * The maximum amount of network bandwidth, in Gbps.
     *
     * To specify no maximum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-networkbandwidthgbpsrequest.html#cfn-ec2-spotfleet-networkbandwidthgbpsrequest-max
     */
    readonly max?: number;

    /**
     * The minimum amount of network bandwidth, in Gbps.
     *
     * To specify no minimum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-networkbandwidthgbpsrequest.html#cfn-ec2-spotfleet-networkbandwidthgbpsrequest-min
     */
    readonly min?: number;
  }

  /**
   * The minimum and maximum number of network interfaces.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-networkinterfacecountrequest.html
   */
  export interface NetworkInterfaceCountRequestProperty {
    /**
     * The maximum number of network interfaces.
     *
     * To specify no maximum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-networkinterfacecountrequest.html#cfn-ec2-spotfleet-networkinterfacecountrequest-max
     */
    readonly max?: number;

    /**
     * The minimum number of network interfaces.
     *
     * To specify no minimum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-networkinterfacecountrequest.html#cfn-ec2-spotfleet-networkinterfacecountrequest-min
     */
    readonly min?: number;
  }

  /**
   * The minimum and maximum amount of total local storage, in GB.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-totallocalstoragegbrequest.html
   */
  export interface TotalLocalStorageGBRequestProperty {
    /**
     * The maximum amount of total local storage, in GB.
     *
     * To specify no maximum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-totallocalstoragegbrequest.html#cfn-ec2-spotfleet-totallocalstoragegbrequest-max
     */
    readonly max?: number;

    /**
     * The minimum amount of total local storage, in GB.
     *
     * To specify no minimum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-totallocalstoragegbrequest.html#cfn-ec2-spotfleet-totallocalstoragegbrequest-min
     */
    readonly min?: number;
  }

  /**
   * The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps.
   *
   * For more information, see [Amazon EBSoptimized instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html) in the *Amazon EC2 User Guide* .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-baselineebsbandwidthmbpsrequest.html
   */
  export interface BaselineEbsBandwidthMbpsRequestProperty {
    /**
     * The maximum baseline bandwidth, in Mbps.
     *
     * To specify no maximum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-baselineebsbandwidthmbpsrequest.html#cfn-ec2-spotfleet-baselineebsbandwidthmbpsrequest-max
     */
    readonly max?: number;

    /**
     * The minimum baseline bandwidth, in Mbps.
     *
     * To specify no minimum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-baselineebsbandwidthmbpsrequest.html#cfn-ec2-spotfleet-baselineebsbandwidthmbpsrequest-min
     */
    readonly min?: number;
  }

  /**
   * The minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips) on an instance.
   *
   * To exclude accelerator-enabled instance types, set \`Max\` to \`0\` .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-acceleratorcountrequest.html
   */
  export interface AcceleratorCountRequestProperty {
    /**
     * The maximum number of accelerators.
     *
     * To specify no maximum limit, omit this parameter. To exclude accelerator-enabled instance types, set \`Max\` to \`0\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-acceleratorcountrequest.html#cfn-ec2-spotfleet-acceleratorcountrequest-max
     */
    readonly max?: number;

    /**
     * The minimum number of accelerators.
     *
     * To specify no minimum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-acceleratorcountrequest.html#cfn-ec2-spotfleet-acceleratorcountrequest-min
     */
    readonly min?: number;
  }

  /**
   * The minimum and maximum amount of total accelerator memory, in MiB.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-acceleratortotalmemorymibrequest.html
   */
  export interface AcceleratorTotalMemoryMiBRequestProperty {
    /**
     * The maximum amount of accelerator memory, in MiB.
     *
     * To specify no maximum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-acceleratortotalmemorymibrequest.html#cfn-ec2-spotfleet-acceleratortotalmemorymibrequest-max
     */
    readonly max?: number;

    /**
     * The minimum amount of accelerator memory, in MiB.
     *
     * To specify no minimum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-acceleratortotalmemorymibrequest.html#cfn-ec2-spotfleet-acceleratortotalmemorymibrequest-min
     */
    readonly min?: number;
  }

  /**
   * Specifies a launch template and overrides.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-launchtemplateconfig.html
   */
  export interface LaunchTemplateConfigProperty {
    /**
     * The launch template to use.
     *
     * Make sure that the launch template does not contain the \`NetworkInterfaceId\` parameter because you can't specify a network interface ID in a Spot Fleet.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-launchtemplateconfig.html#cfn-ec2-spotfleet-launchtemplateconfig-launchtemplatespecification
     */
    readonly launchTemplateSpecification?: CfnSpotFleet.FleetLaunchTemplateSpecificationProperty | cdk.IResolvable;

    /**
     * Any parameters that you specify override the same parameters in the launch template.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-launchtemplateconfig.html#cfn-ec2-spotfleet-launchtemplateconfig-overrides
     */
    readonly overrides?: Array<cdk.IResolvable | CfnSpotFleet.LaunchTemplateOverridesProperty> | cdk.IResolvable;
  }

  /**
   * Specifies the launch template to be used by the Spot Fleet request for configuring Amazon EC2 instances.
   *
   * You must specify the following:
   *
   * - The ID or the name of the launch template, but not both.
   * - The version of the launch template.
   *
   * \`FleetLaunchTemplateSpecification\` is a property of the [AWS::EC2::SpotFleet](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-spotfleet.html) resource.
   *
   * For information about creating a launch template, see [AWS::EC2::LaunchTemplate](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html) and [Create a launch template](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-templates.html#create-launch-template) in the *Amazon EC2 User Guide* .
   *
   * For examples of launch templates, see [Examples](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#aws-resource-ec2-launchtemplate--examples) .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-fleetlaunchtemplatespecification.html
   */
  export interface FleetLaunchTemplateSpecificationProperty {
    /**
     * The ID of the launch template.
     *
     * You must specify the \`LaunchTemplateId\` or the \`LaunchTemplateName\` , but not both.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-fleetlaunchtemplatespecification.html#cfn-ec2-spotfleet-fleetlaunchtemplatespecification-launchtemplateid
     */
    readonly launchTemplateId?: string;

    /**
     * The name of the launch template.
     *
     * You must specify the \`LaunchTemplateName\` or the \`LaunchTemplateId\` , but not both.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-fleetlaunchtemplatespecification.html#cfn-ec2-spotfleet-fleetlaunchtemplatespecification-launchtemplatename
     */
    readonly launchTemplateName?: string;

    /**
     * The version number of the launch template.
     *
     * Specifying \`$Latest\` or \`$Default\` for the template version number is not supported. However, you can specify \`LatestVersionNumber\` or \`DefaultVersionNumber\` using the \`Fn::GetAtt\` intrinsic function. For more information, see [Fn::GetAtt](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#aws-resource-ec2-launchtemplate-return-values-fn--getatt) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-fleetlaunchtemplatespecification.html#cfn-ec2-spotfleet-fleetlaunchtemplatespecification-version
     */
    readonly version: string;
  }

  /**
   * Specifies overrides for a launch template.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-launchtemplateoverrides.html
   */
  export interface LaunchTemplateOverridesProperty {
    /**
     * The Availability Zone in which to launch the instances.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-launchtemplateoverrides.html#cfn-ec2-spotfleet-launchtemplateoverrides-availabilityzone
     */
    readonly availabilityZone?: string;

    /**
     * The instance requirements.
     *
     * When you specify instance requirements, Amazon EC2 will identify instance types with the provided requirements, and then use your On-Demand and Spot allocation strategies to launch instances from these instance types, in the same way as when you specify a list of instance types.
     *
     * > If you specify \`InstanceRequirements\` , you can't specify \`InstanceType\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-launchtemplateoverrides.html#cfn-ec2-spotfleet-launchtemplateoverrides-instancerequirements
     */
    readonly instanceRequirements?: CfnSpotFleet.InstanceRequirementsRequestProperty | cdk.IResolvable;

    /**
     * The instance type.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-launchtemplateoverrides.html#cfn-ec2-spotfleet-launchtemplateoverrides-instancetype
     */
    readonly instanceType?: string;

    /**
     * The priority for the launch template override. The highest priority is launched first.
     *
     * If \`OnDemandAllocationStrategy\` is set to \`prioritized\` , Spot Fleet uses priority to determine which launch template override to use first in fulfilling On-Demand capacity.
     *
     * If the Spot \`AllocationStrategy\` is set to \`capacityOptimizedPrioritized\` , Spot Fleet uses priority on a best-effort basis to determine which launch template override to use in fulfilling Spot capacity, but optimizes for capacity first.
     *
     * Valid values are whole numbers starting at \`0\` . The lower the number, the higher the priority. If no number is set, the launch template override has the lowest priority. You can set the same priority for different launch template overrides.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-launchtemplateoverrides.html#cfn-ec2-spotfleet-launchtemplateoverrides-priority
     */
    readonly priority?: number;

    /**
     * The maximum price per unit hour that you are willing to pay for a Spot Instance.
     *
     * We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price.
     *
     * > If you specify a maximum price, your instances will be interrupted more frequently than if you do not specify this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-launchtemplateoverrides.html#cfn-ec2-spotfleet-launchtemplateoverrides-spotprice
     */
    readonly spotPrice?: string;

    /**
     * The ID of the subnet in which to launch the instances.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-launchtemplateoverrides.html#cfn-ec2-spotfleet-launchtemplateoverrides-subnetid
     */
    readonly subnetId?: string;

    /**
     * The number of units provided by the specified instance type.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-launchtemplateoverrides.html#cfn-ec2-spotfleet-launchtemplateoverrides-weightedcapacity
     */
    readonly weightedCapacity?: number;
  }

  /**
   * Specifies the Classic Load Balancers and target groups to attach to a Spot Fleet request.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-loadbalancersconfig.html
   */
  export interface LoadBalancersConfigProperty {
    /**
     * The Classic Load Balancers.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-loadbalancersconfig.html#cfn-ec2-spotfleet-loadbalancersconfig-classicloadbalancersconfig
     */
    readonly classicLoadBalancersConfig?: CfnSpotFleet.ClassicLoadBalancersConfigProperty | cdk.IResolvable;

    /**
     * The target groups.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-loadbalancersconfig.html#cfn-ec2-spotfleet-loadbalancersconfig-targetgroupsconfig
     */
    readonly targetGroupsConfig?: cdk.IResolvable | CfnSpotFleet.TargetGroupsConfigProperty;
  }

  /**
   * Specifies the Classic Load Balancers to attach to a Spot Fleet.
   *
   * Spot Fleet registers the running Spot Instances with these Classic Load Balancers.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-classicloadbalancersconfig.html
   */
  export interface ClassicLoadBalancersConfigProperty {
    /**
     * One or more Classic Load Balancers.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-classicloadbalancersconfig.html#cfn-ec2-spotfleet-classicloadbalancersconfig-classicloadbalancers
     */
    readonly classicLoadBalancers: Array<CfnSpotFleet.ClassicLoadBalancerProperty | cdk.IResolvable> | cdk.IResolvable;
  }

  /**
   * Specifies a Classic Load Balancer.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-classicloadbalancer.html
   */
  export interface ClassicLoadBalancerProperty {
    /**
     * The name of the load balancer.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-classicloadbalancer.html#cfn-ec2-spotfleet-classicloadbalancer-name
     */
    readonly name: string;
  }

  /**
   * Describes the target groups to attach to a Spot Fleet.
   *
   * Spot Fleet registers the running Spot Instances with these target groups.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-targetgroupsconfig.html
   */
  export interface TargetGroupsConfigProperty {
    /**
     * One or more target groups.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-targetgroupsconfig.html#cfn-ec2-spotfleet-targetgroupsconfig-targetgroups
     */
    readonly targetGroups: Array<cdk.IResolvable | CfnSpotFleet.TargetGroupProperty> | cdk.IResolvable;
  }

  /**
   * Describes a load balancer target group.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-targetgroup.html
   */
  export interface TargetGroupProperty {
    /**
     * The Amazon Resource Name (ARN) of the target group.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-targetgroup.html#cfn-ec2-spotfleet-targetgroup-arn
     */
    readonly arn: string;
  }

  /**
   * The strategies for managing your Spot Instances that are at an elevated risk of being interrupted.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotmaintenancestrategies.html
   */
  export interface SpotMaintenanceStrategiesProperty {
    /**
     * The Spot Instance replacement strategy to use when Amazon EC2 emits a signal that your Spot Instance is at an elevated risk of being interrupted.
     *
     * For more information, see [Capacity rebalancing](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-capacity-rebalance.html) in the *Amazon EC2 User Guide for Linux Instances* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotmaintenancestrategies.html#cfn-ec2-spotfleet-spotmaintenancestrategies-capacityrebalance
     */
    readonly capacityRebalance?: cdk.IResolvable | CfnSpotFleet.SpotCapacityRebalanceProperty;
  }

  /**
   * The Spot Instance replacement strategy to use when Amazon EC2 emits a signal that your Spot Instance is at an elevated risk of being interrupted.
   *
   * For more information, see [Capacity rebalancing](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-capacity-rebalance.html) in the *Amazon EC2 User Guide for Linux Instances* .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotcapacityrebalance.html
   */
  export interface SpotCapacityRebalanceProperty {
    /**
     * The replacement strategy to use. Only available for fleets of type \`maintain\` .
     *
     * \`launch\` - Spot Fleet launches a new replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet. Spot Fleet does not terminate the instances that receive a rebalance notification. You can terminate the old instances, or you can leave them running. You are charged for all instances while they are running.
     *
     * \`launch-before-terminate\` - Spot Fleet launches a new replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet, and then, after a delay that you specify (in \`TerminationDelay\` ), terminates the instances that received a rebalance notification.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotcapacityrebalance.html#cfn-ec2-spotfleet-spotcapacityrebalance-replacementstrategy
     */
    readonly replacementStrategy?: string;

    /**
     * The amount of time (in seconds) that Amazon EC2 waits before terminating the old Spot Instance after launching a new replacement Spot Instance.
     *
     * Required when \`ReplacementStrategy\` is set to \`launch-before-terminate\` .
     *
     * Not valid when \`ReplacementStrategy\` is set to \`launch\` .
     *
     * Valid values: Minimum value of \`120\` seconds. Maximum value of \`7200\` seconds.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotcapacityrebalance.html#cfn-ec2-spotfleet-spotcapacityrebalance-terminationdelay
     */
    readonly terminationDelay?: number;
  }
}

/**
 * Properties for defining a \`CfnSpotFleet\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-spotfleet.html
 */
export interface CfnSpotFleetProps {
  /**
   * Describes the configuration of a Spot Fleet request.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-spotfleet.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata
   */
  readonly spotFleetRequestConfigData: cdk.IResolvable | CfnSpotFleet.SpotFleetRequestConfigDataProperty;
}

/**
 * Determine whether the given properties match those of a \`EbsBlockDeviceProperty\`
 *
 * @param properties - the TypeScript properties of a \`EbsBlockDeviceProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetEbsBlockDevicePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("deleteOnTermination", cdk.validateBoolean)(properties.deleteOnTermination));
  errors.collect(cdk.propertyValidator("encrypted", cdk.validateBoolean)(properties.encrypted));
  errors.collect(cdk.propertyValidator("iops", cdk.validateNumber)(properties.iops));
  errors.collect(cdk.propertyValidator("snapshotId", cdk.validateString)(properties.snapshotId));
  errors.collect(cdk.propertyValidator("volumeSize", cdk.validateNumber)(properties.volumeSize));
  errors.collect(cdk.propertyValidator("volumeType", cdk.validateString)(properties.volumeType));
  return errors.wrap("supplied properties not correct for \\"EbsBlockDeviceProperty\\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetEbsBlockDevicePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetEbsBlockDevicePropertyValidator(properties).assertSuccess();
  return {
    "DeleteOnTermination": cdk.booleanToCloudFormation(properties.deleteOnTermination),
    "Encrypted": cdk.booleanToCloudFormation(properties.encrypted),
    "Iops": cdk.numberToCloudFormation(properties.iops),
    "SnapshotId": cdk.stringToCloudFormation(properties.snapshotId),
    "VolumeSize": cdk.numberToCloudFormation(properties.volumeSize),
    "VolumeType": cdk.stringToCloudFormation(properties.volumeType)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetEbsBlockDevicePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSpotFleet.EbsBlockDeviceProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleet.EbsBlockDeviceProperty>();
  ret.addPropertyResult("deleteOnTermination", "DeleteOnTermination", (properties.DeleteOnTermination != null ? cfn_parse.FromCloudFormation.getBoolean(properties.DeleteOnTermination) : undefined));
  ret.addPropertyResult("encrypted", "Encrypted", (properties.Encrypted != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Encrypted) : undefined));
  ret.addPropertyResult("iops", "Iops", (properties.Iops != null ? cfn_parse.FromCloudFormation.getNumber(properties.Iops) : undefined));
  ret.addPropertyResult("snapshotId", "SnapshotId", (properties.SnapshotId != null ? cfn_parse.FromCloudFormation.getString(properties.SnapshotId) : undefined));
  ret.addPropertyResult("volumeSize", "VolumeSize", (properties.VolumeSize != null ? cfn_parse.FromCloudFormation.getNumber(properties.VolumeSize) : undefined));
  ret.addPropertyResult("volumeType", "VolumeType", (properties.VolumeType != null ? cfn_parse.FromCloudFormation.getString(properties.VolumeType) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`BlockDeviceMappingProperty\`
 *
 * @param properties - the TypeScript properties of a \`BlockDeviceMappingProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetBlockDeviceMappingPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("deviceName", cdk.requiredValidator)(properties.deviceName));
  errors.collect(cdk.propertyValidator("deviceName", cdk.validateString)(properties.deviceName));
  errors.collect(cdk.propertyValidator("ebs", CfnSpotFleetEbsBlockDevicePropertyValidator)(properties.ebs));
  errors.collect(cdk.propertyValidator("noDevice", cdk.validateString)(properties.noDevice));
  errors.collect(cdk.propertyValidator("virtualName", cdk.validateString)(properties.virtualName));
  return errors.wrap("supplied properties not correct for \\"BlockDeviceMappingProperty\\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetBlockDeviceMappingPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetBlockDeviceMappingPropertyValidator(properties).assertSuccess();
  return {
    "DeviceName": cdk.stringToCloudFormation(properties.deviceName),
    "Ebs": convertCfnSpotFleetEbsBlockDevicePropertyToCloudFormation(properties.ebs),
    "NoDevice": cdk.stringToCloudFormation(properties.noDevice),
    "VirtualName": cdk.stringToCloudFormation(properties.virtualName)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetBlockDeviceMappingPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSpotFleet.BlockDeviceMappingProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleet.BlockDeviceMappingProperty>();
  ret.addPropertyResult("deviceName", "DeviceName", (properties.DeviceName != null ? cfn_parse.FromCloudFormation.getString(properties.DeviceName) : undefined));
  ret.addPropertyResult("ebs", "Ebs", (properties.Ebs != null ? CfnSpotFleetEbsBlockDevicePropertyFromCloudFormation(properties.Ebs) : undefined));
  ret.addPropertyResult("noDevice", "NoDevice", (properties.NoDevice != null ? cfn_parse.FromCloudFormation.getString(properties.NoDevice) : undefined));
  ret.addPropertyResult("virtualName", "VirtualName", (properties.VirtualName != null ? cfn_parse.FromCloudFormation.getString(properties.VirtualName) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`IamInstanceProfileSpecificationProperty\`
 *
 * @param properties - the TypeScript properties of a \`IamInstanceProfileSpecificationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetIamInstanceProfileSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("arn", cdk.validateString)(properties.arn));
  return errors.wrap("supplied properties not correct for \\"IamInstanceProfileSpecificationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetIamInstanceProfileSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetIamInstanceProfileSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "Arn": cdk.stringToCloudFormation(properties.arn)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetIamInstanceProfileSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSpotFleet.IamInstanceProfileSpecificationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleet.IamInstanceProfileSpecificationProperty>();
  ret.addPropertyResult("arn", "Arn", (properties.Arn != null ? cfn_parse.FromCloudFormation.getString(properties.Arn) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`SpotFleetMonitoringProperty\`
 *
 * @param properties - the TypeScript properties of a \`SpotFleetMonitoringProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetSpotFleetMonitoringPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("enabled", cdk.validateBoolean)(properties.enabled));
  return errors.wrap("supplied properties not correct for \\"SpotFleetMonitoringProperty\\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetSpotFleetMonitoringPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetSpotFleetMonitoringPropertyValidator(properties).assertSuccess();
  return {
    "Enabled": cdk.booleanToCloudFormation(properties.enabled)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetSpotFleetMonitoringPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSpotFleet.SpotFleetMonitoringProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleet.SpotFleetMonitoringProperty>();
  ret.addPropertyResult("enabled", "Enabled", (properties.Enabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Enabled) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`InstanceIpv6AddressProperty\`
 *
 * @param properties - the TypeScript properties of a \`InstanceIpv6AddressProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetInstanceIpv6AddressPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("ipv6Address", cdk.requiredValidator)(properties.ipv6Address));
  errors.collect(cdk.propertyValidator("ipv6Address", cdk.validateString)(properties.ipv6Address));
  return errors.wrap("supplied properties not correct for \\"InstanceIpv6AddressProperty\\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetInstanceIpv6AddressPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetInstanceIpv6AddressPropertyValidator(properties).assertSuccess();
  return {
    "Ipv6Address": cdk.stringToCloudFormation(properties.ipv6Address)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetInstanceIpv6AddressPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSpotFleet.InstanceIpv6AddressProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleet.InstanceIpv6AddressProperty>();
  ret.addPropertyResult("ipv6Address", "Ipv6Address", (properties.Ipv6Address != null ? cfn_parse.FromCloudFormation.getString(properties.Ipv6Address) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`PrivateIpAddressSpecificationProperty\`
 *
 * @param properties - the TypeScript properties of a \`PrivateIpAddressSpecificationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetPrivateIpAddressSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("primary", cdk.validateBoolean)(properties.primary));
  errors.collect(cdk.propertyValidator("privateIpAddress", cdk.requiredValidator)(properties.privateIpAddress));
  errors.collect(cdk.propertyValidator("privateIpAddress", cdk.validateString)(properties.privateIpAddress));
  return errors.wrap("supplied properties not correct for \\"PrivateIpAddressSpecificationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetPrivateIpAddressSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetPrivateIpAddressSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "Primary": cdk.booleanToCloudFormation(properties.primary),
    "PrivateIpAddress": cdk.stringToCloudFormation(properties.privateIpAddress)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetPrivateIpAddressSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSpotFleet.PrivateIpAddressSpecificationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleet.PrivateIpAddressSpecificationProperty>();
  ret.addPropertyResult("primary", "Primary", (properties.Primary != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Primary) : undefined));
  ret.addPropertyResult("privateIpAddress", "PrivateIpAddress", (properties.PrivateIpAddress != null ? cfn_parse.FromCloudFormation.getString(properties.PrivateIpAddress) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`InstanceNetworkInterfaceSpecificationProperty\`
 *
 * @param properties - the TypeScript properties of a \`InstanceNetworkInterfaceSpecificationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetInstanceNetworkInterfaceSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("associatePublicIpAddress", cdk.validateBoolean)(properties.associatePublicIpAddress));
  errors.collect(cdk.propertyValidator("deleteOnTermination", cdk.validateBoolean)(properties.deleteOnTermination));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("deviceIndex", cdk.validateNumber)(properties.deviceIndex));
  errors.collect(cdk.propertyValidator("groups", cdk.listValidator(cdk.validateString))(properties.groups));
  errors.collect(cdk.propertyValidator("ipv6AddressCount", cdk.validateNumber)(properties.ipv6AddressCount));
  errors.collect(cdk.propertyValidator("ipv6Addresses", cdk.listValidator(CfnSpotFleetInstanceIpv6AddressPropertyValidator))(properties.ipv6Addresses));
  errors.collect(cdk.propertyValidator("networkInterfaceId", cdk.validateString)(properties.networkInterfaceId));
  errors.collect(cdk.propertyValidator("privateIpAddresses", cdk.listValidator(CfnSpotFleetPrivateIpAddressSpecificationPropertyValidator))(properties.privateIpAddresses));
  errors.collect(cdk.propertyValidator("secondaryPrivateIpAddressCount", cdk.validateNumber)(properties.secondaryPrivateIpAddressCount));
  errors.collect(cdk.propertyValidator("subnetId", cdk.validateString)(properties.subnetId));
  return errors.wrap("supplied properties not correct for \\"InstanceNetworkInterfaceSpecificationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetInstanceNetworkInterfaceSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetInstanceNetworkInterfaceSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "AssociatePublicIpAddress": cdk.booleanToCloudFormation(properties.associatePublicIpAddress),
    "DeleteOnTermination": cdk.booleanToCloudFormation(properties.deleteOnTermination),
    "Description": cdk.stringToCloudFormation(properties.description),
    "DeviceIndex": cdk.numberToCloudFormation(properties.deviceIndex),
    "Groups": cdk.listMapper(cdk.stringToCloudFormation)(properties.groups),
    "Ipv6AddressCount": cdk.numberToCloudFormation(properties.ipv6AddressCount),
    "Ipv6Addresses": cdk.listMapper(convertCfnSpotFleetInstanceIpv6AddressPropertyToCloudFormation)(properties.ipv6Addresses),
    "NetworkInterfaceId": cdk.stringToCloudFormation(properties.networkInterfaceId),
    "PrivateIpAddresses": cdk.listMapper(convertCfnSpotFleetPrivateIpAddressSpecificationPropertyToCloudFormation)(properties.privateIpAddresses),
    "SecondaryPrivateIpAddressCount": cdk.numberToCloudFormation(properties.secondaryPrivateIpAddressCount),
    "SubnetId": cdk.stringToCloudFormation(properties.subnetId)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetInstanceNetworkInterfaceSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSpotFleet.InstanceNetworkInterfaceSpecificationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleet.InstanceNetworkInterfaceSpecificationProperty>();
  ret.addPropertyResult("associatePublicIpAddress", "AssociatePublicIpAddress", (properties.AssociatePublicIpAddress != null ? cfn_parse.FromCloudFormation.getBoolean(properties.AssociatePublicIpAddress) : undefined));
  ret.addPropertyResult("deleteOnTermination", "DeleteOnTermination", (properties.DeleteOnTermination != null ? cfn_parse.FromCloudFormation.getBoolean(properties.DeleteOnTermination) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("deviceIndex", "DeviceIndex", (properties.DeviceIndex != null ? cfn_parse.FromCloudFormation.getNumber(properties.DeviceIndex) : undefined));
  ret.addPropertyResult("groups", "Groups", (properties.Groups != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.Groups) : undefined));
  ret.addPropertyResult("ipv6AddressCount", "Ipv6AddressCount", (properties.Ipv6AddressCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.Ipv6AddressCount) : undefined));
  ret.addPropertyResult("ipv6Addresses", "Ipv6Addresses", (properties.Ipv6Addresses != null ? cfn_parse.FromCloudFormation.getArray(CfnSpotFleetInstanceIpv6AddressPropertyFromCloudFormation)(properties.Ipv6Addresses) : undefined));
  ret.addPropertyResult("networkInterfaceId", "NetworkInterfaceId", (properties.NetworkInterfaceId != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkInterfaceId) : undefined));
  ret.addPropertyResult("privateIpAddresses", "PrivateIpAddresses", (properties.PrivateIpAddresses != null ? cfn_parse.FromCloudFormation.getArray(CfnSpotFleetPrivateIpAddressSpecificationPropertyFromCloudFormation)(properties.PrivateIpAddresses) : undefined));
  ret.addPropertyResult("secondaryPrivateIpAddressCount", "SecondaryPrivateIpAddressCount", (properties.SecondaryPrivateIpAddressCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.SecondaryPrivateIpAddressCount) : undefined));
  ret.addPropertyResult("subnetId", "SubnetId", (properties.SubnetId != null ? cfn_parse.FromCloudFormation.getString(properties.SubnetId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`SpotPlacementProperty\`
 *
 * @param properties - the TypeScript properties of a \`SpotPlacementProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetSpotPlacementPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("availabilityZone", cdk.validateString)(properties.availabilityZone));
  errors.collect(cdk.propertyValidator("groupName", cdk.validateString)(properties.groupName));
  errors.collect(cdk.propertyValidator("tenancy", cdk.validateString)(properties.tenancy));
  return errors.wrap("supplied properties not correct for \\"SpotPlacementProperty\\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetSpotPlacementPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetSpotPlacementPropertyValidator(properties).assertSuccess();
  return {
    "AvailabilityZone": cdk.stringToCloudFormation(properties.availabilityZone),
    "GroupName": cdk.stringToCloudFormation(properties.groupName),
    "Tenancy": cdk.stringToCloudFormation(properties.tenancy)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetSpotPlacementPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSpotFleet.SpotPlacementProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleet.SpotPlacementProperty>();
  ret.addPropertyResult("availabilityZone", "AvailabilityZone", (properties.AvailabilityZone != null ? cfn_parse.FromCloudFormation.getString(properties.AvailabilityZone) : undefined));
  ret.addPropertyResult("groupName", "GroupName", (properties.GroupName != null ? cfn_parse.FromCloudFormation.getString(properties.GroupName) : undefined));
  ret.addPropertyResult("tenancy", "Tenancy", (properties.Tenancy != null ? cfn_parse.FromCloudFormation.getString(properties.Tenancy) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`GroupIdentifierProperty\`
 *
 * @param properties - the TypeScript properties of a \`GroupIdentifierProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetGroupIdentifierPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("groupId", cdk.requiredValidator)(properties.groupId));
  errors.collect(cdk.propertyValidator("groupId", cdk.validateString)(properties.groupId));
  return errors.wrap("supplied properties not correct for \\"GroupIdentifierProperty\\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetGroupIdentifierPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetGroupIdentifierPropertyValidator(properties).assertSuccess();
  return {
    "GroupId": cdk.stringToCloudFormation(properties.groupId)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetGroupIdentifierPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSpotFleet.GroupIdentifierProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleet.GroupIdentifierProperty>();
  ret.addPropertyResult("groupId", "GroupId", (properties.GroupId != null ? cfn_parse.FromCloudFormation.getString(properties.GroupId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`SpotFleetTagSpecificationProperty\`
 *
 * @param properties - the TypeScript properties of a \`SpotFleetTagSpecificationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetSpotFleetTagSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("resourceType", cdk.validateString)(properties.resourceType));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"SpotFleetTagSpecificationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetSpotFleetTagSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetSpotFleetTagSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "ResourceType": cdk.stringToCloudFormation(properties.resourceType),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetSpotFleetTagSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSpotFleet.SpotFleetTagSpecificationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleet.SpotFleetTagSpecificationProperty>();
  ret.addPropertyResult("resourceType", "ResourceType", (properties.ResourceType != null ? cfn_parse.FromCloudFormation.getString(properties.ResourceType) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`VCpuCountRangeRequestProperty\`
 *
 * @param properties - the TypeScript properties of a \`VCpuCountRangeRequestProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetVCpuCountRangeRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("max", cdk.validateNumber)(properties.max));
  errors.collect(cdk.propertyValidator("min", cdk.validateNumber)(properties.min));
  return errors.wrap("supplied properties not correct for \\"VCpuCountRangeRequestProperty\\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetVCpuCountRangeRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetVCpuCountRangeRequestPropertyValidator(properties).assertSuccess();
  return {
    "Max": cdk.numberToCloudFormation(properties.max),
    "Min": cdk.numberToCloudFormation(properties.min)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetVCpuCountRangeRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSpotFleet.VCpuCountRangeRequestProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleet.VCpuCountRangeRequestProperty>();
  ret.addPropertyResult("max", "Max", (properties.Max != null ? cfn_parse.FromCloudFormation.getNumber(properties.Max) : undefined));
  ret.addPropertyResult("min", "Min", (properties.Min != null ? cfn_parse.FromCloudFormation.getNumber(properties.Min) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`MemoryMiBRequestProperty\`
 *
 * @param properties - the TypeScript properties of a \`MemoryMiBRequestProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetMemoryMiBRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("max", cdk.validateNumber)(properties.max));
  errors.collect(cdk.propertyValidator("min", cdk.validateNumber)(properties.min));
  return errors.wrap("supplied properties not correct for \\"MemoryMiBRequestProperty\\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetMemoryMiBRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetMemoryMiBRequestPropertyValidator(properties).assertSuccess();
  return {
    "Max": cdk.numberToCloudFormation(properties.max),
    "Min": cdk.numberToCloudFormation(properties.min)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetMemoryMiBRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSpotFleet.MemoryMiBRequestProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleet.MemoryMiBRequestProperty>();
  ret.addPropertyResult("max", "Max", (properties.Max != null ? cfn_parse.FromCloudFormation.getNumber(properties.Max) : undefined));
  ret.addPropertyResult("min", "Min", (properties.Min != null ? cfn_parse.FromCloudFormation.getNumber(properties.Min) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`MemoryGiBPerVCpuRequestProperty\`
 *
 * @param properties - the TypeScript properties of a \`MemoryGiBPerVCpuRequestProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetMemoryGiBPerVCpuRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("max", cdk.validateNumber)(properties.max));
  errors.collect(cdk.propertyValidator("min", cdk.validateNumber)(properties.min));
  return errors.wrap("supplied properties not correct for \\"MemoryGiBPerVCpuRequestProperty\\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetMemoryGiBPerVCpuRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetMemoryGiBPerVCpuRequestPropertyValidator(properties).assertSuccess();
  return {
    "Max": cdk.numberToCloudFormation(properties.max),
    "Min": cdk.numberToCloudFormation(properties.min)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetMemoryGiBPerVCpuRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSpotFleet.MemoryGiBPerVCpuRequestProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleet.MemoryGiBPerVCpuRequestProperty>();
  ret.addPropertyResult("max", "Max", (properties.Max != null ? cfn_parse.FromCloudFormation.getNumber(properties.Max) : undefined));
  ret.addPropertyResult("min", "Min", (properties.Min != null ? cfn_parse.FromCloudFormation.getNumber(properties.Min) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`NetworkBandwidthGbpsRequestProperty\`
 *
 * @param properties - the TypeScript properties of a \`NetworkBandwidthGbpsRequestProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetNetworkBandwidthGbpsRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("max", cdk.validateNumber)(properties.max));
  errors.collect(cdk.propertyValidator("min", cdk.validateNumber)(properties.min));
  return errors.wrap("supplied properties not correct for \\"NetworkBandwidthGbpsRequestProperty\\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetNetworkBandwidthGbpsRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetNetworkBandwidthGbpsRequestPropertyValidator(properties).assertSuccess();
  return {
    "Max": cdk.numberToCloudFormation(properties.max),
    "Min": cdk.numberToCloudFormation(properties.min)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetNetworkBandwidthGbpsRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSpotFleet.NetworkBandwidthGbpsRequestProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleet.NetworkBandwidthGbpsRequestProperty>();
  ret.addPropertyResult("max", "Max", (properties.Max != null ? cfn_parse.FromCloudFormation.getNumber(properties.Max) : undefined));
  ret.addPropertyResult("min", "Min", (properties.Min != null ? cfn_parse.FromCloudFormation.getNumber(properties.Min) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`NetworkInterfaceCountRequestProperty\`
 *
 * @param properties - the TypeScript properties of a \`NetworkInterfaceCountRequestProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetNetworkInterfaceCountRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("max", cdk.validateNumber)(properties.max));
  errors.collect(cdk.propertyValidator("min", cdk.validateNumber)(properties.min));
  return errors.wrap("supplied properties not correct for \\"NetworkInterfaceCountRequestProperty\\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetNetworkInterfaceCountRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetNetworkInterfaceCountRequestPropertyValidator(properties).assertSuccess();
  return {
    "Max": cdk.numberToCloudFormation(properties.max),
    "Min": cdk.numberToCloudFormation(properties.min)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetNetworkInterfaceCountRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSpotFleet.NetworkInterfaceCountRequestProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleet.NetworkInterfaceCountRequestProperty>();
  ret.addPropertyResult("max", "Max", (properties.Max != null ? cfn_parse.FromCloudFormation.getNumber(properties.Max) : undefined));
  ret.addPropertyResult("min", "Min", (properties.Min != null ? cfn_parse.FromCloudFormation.getNumber(properties.Min) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`TotalLocalStorageGBRequestProperty\`
 *
 * @param properties - the TypeScript properties of a \`TotalLocalStorageGBRequestProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetTotalLocalStorageGBRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("max", cdk.validateNumber)(properties.max));
  errors.collect(cdk.propertyValidator("min", cdk.validateNumber)(properties.min));
  return errors.wrap("supplied properties not correct for \\"TotalLocalStorageGBRequestProperty\\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetTotalLocalStorageGBRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetTotalLocalStorageGBRequestPropertyValidator(properties).assertSuccess();
  return {
    "Max": cdk.numberToCloudFormation(properties.max),
    "Min": cdk.numberToCloudFormation(properties.min)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetTotalLocalStorageGBRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSpotFleet.TotalLocalStorageGBRequestProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleet.TotalLocalStorageGBRequestProperty>();
  ret.addPropertyResult("max", "Max", (properties.Max != null ? cfn_parse.FromCloudFormation.getNumber(properties.Max) : undefined));
  ret.addPropertyResult("min", "Min", (properties.Min != null ? cfn_parse.FromCloudFormation.getNumber(properties.Min) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`BaselineEbsBandwidthMbpsRequestProperty\`
 *
 * @param properties - the TypeScript properties of a \`BaselineEbsBandwidthMbpsRequestProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetBaselineEbsBandwidthMbpsRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("max", cdk.validateNumber)(properties.max));
  errors.collect(cdk.propertyValidator("min", cdk.validateNumber)(properties.min));
  return errors.wrap("supplied properties not correct for \\"BaselineEbsBandwidthMbpsRequestProperty\\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetBaselineEbsBandwidthMbpsRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetBaselineEbsBandwidthMbpsRequestPropertyValidator(properties).assertSuccess();
  return {
    "Max": cdk.numberToCloudFormation(properties.max),
    "Min": cdk.numberToCloudFormation(properties.min)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetBaselineEbsBandwidthMbpsRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSpotFleet.BaselineEbsBandwidthMbpsRequestProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleet.BaselineEbsBandwidthMbpsRequestProperty>();
  ret.addPropertyResult("max", "Max", (properties.Max != null ? cfn_parse.FromCloudFormation.getNumber(properties.Max) : undefined));
  ret.addPropertyResult("min", "Min", (properties.Min != null ? cfn_parse.FromCloudFormation.getNumber(properties.Min) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`AcceleratorCountRequestProperty\`
 *
 * @param properties - the TypeScript properties of a \`AcceleratorCountRequestProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetAcceleratorCountRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("max", cdk.validateNumber)(properties.max));
  errors.collect(cdk.propertyValidator("min", cdk.validateNumber)(properties.min));
  return errors.wrap("supplied properties not correct for \\"AcceleratorCountRequestProperty\\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetAcceleratorCountRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetAcceleratorCountRequestPropertyValidator(properties).assertSuccess();
  return {
    "Max": cdk.numberToCloudFormation(properties.max),
    "Min": cdk.numberToCloudFormation(properties.min)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetAcceleratorCountRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSpotFleet.AcceleratorCountRequestProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleet.AcceleratorCountRequestProperty>();
  ret.addPropertyResult("max", "Max", (properties.Max != null ? cfn_parse.FromCloudFormation.getNumber(properties.Max) : undefined));
  ret.addPropertyResult("min", "Min", (properties.Min != null ? cfn_parse.FromCloudFormation.getNumber(properties.Min) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`AcceleratorTotalMemoryMiBRequestProperty\`
 *
 * @param properties - the TypeScript properties of a \`AcceleratorTotalMemoryMiBRequestProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetAcceleratorTotalMemoryMiBRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("max", cdk.validateNumber)(properties.max));
  errors.collect(cdk.propertyValidator("min", cdk.validateNumber)(properties.min));
  return errors.wrap("supplied properties not correct for \\"AcceleratorTotalMemoryMiBRequestProperty\\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetAcceleratorTotalMemoryMiBRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetAcceleratorTotalMemoryMiBRequestPropertyValidator(properties).assertSuccess();
  return {
    "Max": cdk.numberToCloudFormation(properties.max),
    "Min": cdk.numberToCloudFormation(properties.min)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetAcceleratorTotalMemoryMiBRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSpotFleet.AcceleratorTotalMemoryMiBRequestProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleet.AcceleratorTotalMemoryMiBRequestProperty>();
  ret.addPropertyResult("max", "Max", (properties.Max != null ? cfn_parse.FromCloudFormation.getNumber(properties.Max) : undefined));
  ret.addPropertyResult("min", "Min", (properties.Min != null ? cfn_parse.FromCloudFormation.getNumber(properties.Min) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`InstanceRequirementsRequestProperty\`
 *
 * @param properties - the TypeScript properties of a \`InstanceRequirementsRequestProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetInstanceRequirementsRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("acceleratorCount", CfnSpotFleetAcceleratorCountRequestPropertyValidator)(properties.acceleratorCount));
  errors.collect(cdk.propertyValidator("acceleratorManufacturers", cdk.listValidator(cdk.validateString))(properties.acceleratorManufacturers));
  errors.collect(cdk.propertyValidator("acceleratorNames", cdk.listValidator(cdk.validateString))(properties.acceleratorNames));
  errors.collect(cdk.propertyValidator("acceleratorTotalMemoryMiB", CfnSpotFleetAcceleratorTotalMemoryMiBRequestPropertyValidator)(properties.acceleratorTotalMemoryMiB));
  errors.collect(cdk.propertyValidator("acceleratorTypes", cdk.listValidator(cdk.validateString))(properties.acceleratorTypes));
  errors.collect(cdk.propertyValidator("allowedInstanceTypes", cdk.listValidator(cdk.validateString))(properties.allowedInstanceTypes));
  errors.collect(cdk.propertyValidator("bareMetal", cdk.validateString)(properties.bareMetal));
  errors.collect(cdk.propertyValidator("baselineEbsBandwidthMbps", CfnSpotFleetBaselineEbsBandwidthMbpsRequestPropertyValidator)(properties.baselineEbsBandwidthMbps));
  errors.collect(cdk.propertyValidator("burstablePerformance", cdk.validateString)(properties.burstablePerformance));
  errors.collect(cdk.propertyValidator("cpuManufacturers", cdk.listValidator(cdk.validateString))(properties.cpuManufacturers));
  errors.collect(cdk.propertyValidator("excludedInstanceTypes", cdk.listValidator(cdk.validateString))(properties.excludedInstanceTypes));
  errors.collect(cdk.propertyValidator("instanceGenerations", cdk.listValidator(cdk.validateString))(properties.instanceGenerations));
  errors.collect(cdk.propertyValidator("localStorage", cdk.validateString)(properties.localStorage));
  errors.collect(cdk.propertyValidator("localStorageTypes", cdk.listValidator(cdk.validateString))(properties.localStorageTypes));
  errors.collect(cdk.propertyValidator("memoryGiBPerVCpu", CfnSpotFleetMemoryGiBPerVCpuRequestPropertyValidator)(properties.memoryGiBPerVCpu));
  errors.collect(cdk.propertyValidator("memoryMiB", CfnSpotFleetMemoryMiBRequestPropertyValidator)(properties.memoryMiB));
  errors.collect(cdk.propertyValidator("networkBandwidthGbps", CfnSpotFleetNetworkBandwidthGbpsRequestPropertyValidator)(properties.networkBandwidthGbps));
  errors.collect(cdk.propertyValidator("networkInterfaceCount", CfnSpotFleetNetworkInterfaceCountRequestPropertyValidator)(properties.networkInterfaceCount));
  errors.collect(cdk.propertyValidator("onDemandMaxPricePercentageOverLowestPrice", cdk.validateNumber)(properties.onDemandMaxPricePercentageOverLowestPrice));
  errors.collect(cdk.propertyValidator("requireHibernateSupport", cdk.validateBoolean)(properties.requireHibernateSupport));
  errors.collect(cdk.propertyValidator("spotMaxPricePercentageOverLowestPrice", cdk.validateNumber)(properties.spotMaxPricePercentageOverLowestPrice));
  errors.collect(cdk.propertyValidator("totalLocalStorageGb", CfnSpotFleetTotalLocalStorageGBRequestPropertyValidator)(properties.totalLocalStorageGb));
  errors.collect(cdk.propertyValidator("vCpuCount", CfnSpotFleetVCpuCountRangeRequestPropertyValidator)(properties.vCpuCount));
  return errors.wrap("supplied properties not correct for \\"InstanceRequirementsRequestProperty\\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetInstanceRequirementsRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetInstanceRequirementsRequestPropertyValidator(properties).assertSuccess();
  return {
    "AcceleratorCount": convertCfnSpotFleetAcceleratorCountRequestPropertyToCloudFormation(properties.acceleratorCount),
    "AcceleratorManufacturers": cdk.listMapper(cdk.stringToCloudFormation)(properties.acceleratorManufacturers),
    "AcceleratorNames": cdk.listMapper(cdk.stringToCloudFormation)(properties.acceleratorNames),
    "AcceleratorTotalMemoryMiB": convertCfnSpotFleetAcceleratorTotalMemoryMiBRequestPropertyToCloudFormation(properties.acceleratorTotalMemoryMiB),
    "AcceleratorTypes": cdk.listMapper(cdk.stringToCloudFormation)(properties.acceleratorTypes),
    "AllowedInstanceTypes": cdk.listMapper(cdk.stringToCloudFormation)(properties.allowedInstanceTypes),
    "BareMetal": cdk.stringToCloudFormation(properties.bareMetal),
    "BaselineEbsBandwidthMbps": convertCfnSpotFleetBaselineEbsBandwidthMbpsRequestPropertyToCloudFormation(properties.baselineEbsBandwidthMbps),
    "BurstablePerformance": cdk.stringToCloudFormation(properties.burstablePerformance),
    "CpuManufacturers": cdk.listMapper(cdk.stringToCloudFormation)(properties.cpuManufacturers),
    "ExcludedInstanceTypes": cdk.listMapper(cdk.stringToCloudFormation)(properties.excludedInstanceTypes),
    "InstanceGenerations": cdk.listMapper(cdk.stringToCloudFormation)(properties.instanceGenerations),
    "LocalStorage": cdk.stringToCloudFormation(properties.localStorage),
    "LocalStorageTypes": cdk.listMapper(cdk.stringToCloudFormation)(properties.localStorageTypes),
    "MemoryGiBPerVCpu": convertCfnSpotFleetMemoryGiBPerVCpuRequestPropertyToCloudFormation(properties.memoryGiBPerVCpu),
    "MemoryMiB": convertCfnSpotFleetMemoryMiBRequestPropertyToCloudFormation(properties.memoryMiB),
    "NetworkBandwidthGbps": convertCfnSpotFleetNetworkBandwidthGbpsRequestPropertyToCloudFormation(properties.networkBandwidthGbps),
    "NetworkInterfaceCount": convertCfnSpotFleetNetworkInterfaceCountRequestPropertyToCloudFormation(properties.networkInterfaceCount),
    "OnDemandMaxPricePercentageOverLowestPrice": cdk.numberToCloudFormation(properties.onDemandMaxPricePercentageOverLowestPrice),
    "RequireHibernateSupport": cdk.booleanToCloudFormation(properties.requireHibernateSupport),
    "SpotMaxPricePercentageOverLowestPrice": cdk.numberToCloudFormation(properties.spotMaxPricePercentageOverLowestPrice),
    "TotalLocalStorageGB": convertCfnSpotFleetTotalLocalStorageGBRequestPropertyToCloudFormation(properties.totalLocalStorageGb),
    "VCpuCount": convertCfnSpotFleetVCpuCountRangeRequestPropertyToCloudFormation(properties.vCpuCount)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetInstanceRequirementsRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSpotFleet.InstanceRequirementsRequestProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleet.InstanceRequirementsRequestProperty>();
  ret.addPropertyResult("acceleratorCount", "AcceleratorCount", (properties.AcceleratorCount != null ? CfnSpotFleetAcceleratorCountRequestPropertyFromCloudFormation(properties.AcceleratorCount) : undefined));
  ret.addPropertyResult("acceleratorManufacturers", "AcceleratorManufacturers", (properties.AcceleratorManufacturers != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.AcceleratorManufacturers) : undefined));
  ret.addPropertyResult("acceleratorNames", "AcceleratorNames", (properties.AcceleratorNames != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.AcceleratorNames) : undefined));
  ret.addPropertyResult("acceleratorTotalMemoryMiB", "AcceleratorTotalMemoryMiB", (properties.AcceleratorTotalMemoryMiB != null ? CfnSpotFleetAcceleratorTotalMemoryMiBRequestPropertyFromCloudFormation(properties.AcceleratorTotalMemoryMiB) : undefined));
  ret.addPropertyResult("acceleratorTypes", "AcceleratorTypes", (properties.AcceleratorTypes != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.AcceleratorTypes) : undefined));
  ret.addPropertyResult("allowedInstanceTypes", "AllowedInstanceTypes", (properties.AllowedInstanceTypes != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.AllowedInstanceTypes) : undefined));
  ret.addPropertyResult("bareMetal", "BareMetal", (properties.BareMetal != null ? cfn_parse.FromCloudFormation.getString(properties.BareMetal) : undefined));
  ret.addPropertyResult("baselineEbsBandwidthMbps", "BaselineEbsBandwidthMbps", (properties.BaselineEbsBandwidthMbps != null ? CfnSpotFleetBaselineEbsBandwidthMbpsRequestPropertyFromCloudFormation(properties.BaselineEbsBandwidthMbps) : undefined));
  ret.addPropertyResult("burstablePerformance", "BurstablePerformance", (properties.BurstablePerformance != null ? cfn_parse.FromCloudFormation.getString(properties.BurstablePerformance) : undefined));
  ret.addPropertyResult("cpuManufacturers", "CpuManufacturers", (properties.CpuManufacturers != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.CpuManufacturers) : undefined));
  ret.addPropertyResult("excludedInstanceTypes", "ExcludedInstanceTypes", (properties.ExcludedInstanceTypes != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.ExcludedInstanceTypes) : undefined));
  ret.addPropertyResult("instanceGenerations", "InstanceGenerations", (properties.InstanceGenerations != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.InstanceGenerations) : undefined));
  ret.addPropertyResult("localStorage", "LocalStorage", (properties.LocalStorage != null ? cfn_parse.FromCloudFormation.getString(properties.LocalStorage) : undefined));
  ret.addPropertyResult("localStorageTypes", "LocalStorageTypes", (properties.LocalStorageTypes != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.LocalStorageTypes) : undefined));
  ret.addPropertyResult("memoryGiBPerVCpu", "MemoryGiBPerVCpu", (properties.MemoryGiBPerVCpu != null ? CfnSpotFleetMemoryGiBPerVCpuRequestPropertyFromCloudFormation(properties.MemoryGiBPerVCpu) : undefined));
  ret.addPropertyResult("memoryMiB", "MemoryMiB", (properties.MemoryMiB != null ? CfnSpotFleetMemoryMiBRequestPropertyFromCloudFormation(properties.MemoryMiB) : undefined));
  ret.addPropertyResult("networkBandwidthGbps", "NetworkBandwidthGbps", (properties.NetworkBandwidthGbps != null ? CfnSpotFleetNetworkBandwidthGbpsRequestPropertyFromCloudFormation(properties.NetworkBandwidthGbps) : undefined));
  ret.addPropertyResult("networkInterfaceCount", "NetworkInterfaceCount", (properties.NetworkInterfaceCount != null ? CfnSpotFleetNetworkInterfaceCountRequestPropertyFromCloudFormation(properties.NetworkInterfaceCount) : undefined));
  ret.addPropertyResult("onDemandMaxPricePercentageOverLowestPrice", "OnDemandMaxPricePercentageOverLowestPrice", (properties.OnDemandMaxPricePercentageOverLowestPrice != null ? cfn_parse.FromCloudFormation.getNumber(properties.OnDemandMaxPricePercentageOverLowestPrice) : undefined));
  ret.addPropertyResult("requireHibernateSupport", "RequireHibernateSupport", (properties.RequireHibernateSupport != null ? cfn_parse.FromCloudFormation.getBoolean(properties.RequireHibernateSupport) : undefined));
  ret.addPropertyResult("spotMaxPricePercentageOverLowestPrice", "SpotMaxPricePercentageOverLowestPrice", (properties.SpotMaxPricePercentageOverLowestPrice != null ? cfn_parse.FromCloudFormation.getNumber(properties.SpotMaxPricePercentageOverLowestPrice) : undefined));
  ret.addPropertyResult("totalLocalStorageGb", "TotalLocalStorageGB", (properties.TotalLocalStorageGB != null ? CfnSpotFleetTotalLocalStorageGBRequestPropertyFromCloudFormation(properties.TotalLocalStorageGB) : undefined));
  ret.addPropertyResult("vCpuCount", "VCpuCount", (properties.VCpuCount != null ? CfnSpotFleetVCpuCountRangeRequestPropertyFromCloudFormation(properties.VCpuCount) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`SpotFleetLaunchSpecificationProperty\`
 *
 * @param properties - the TypeScript properties of a \`SpotFleetLaunchSpecificationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetSpotFleetLaunchSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("blockDeviceMappings", cdk.listValidator(CfnSpotFleetBlockDeviceMappingPropertyValidator))(properties.blockDeviceMappings));
  errors.collect(cdk.propertyValidator("ebsOptimized", cdk.validateBoolean)(properties.ebsOptimized));
  errors.collect(cdk.propertyValidator("iamInstanceProfile", CfnSpotFleetIamInstanceProfileSpecificationPropertyValidator)(properties.iamInstanceProfile));
  errors.collect(cdk.propertyValidator("imageId", cdk.requiredValidator)(properties.imageId));
  errors.collect(cdk.propertyValidator("imageId", cdk.validateString)(properties.imageId));
  errors.collect(cdk.propertyValidator("instanceRequirements", CfnSpotFleetInstanceRequirementsRequestPropertyValidator)(properties.instanceRequirements));
  errors.collect(cdk.propertyValidator("instanceType", cdk.validateString)(properties.instanceType));
  errors.collect(cdk.propertyValidator("kernelId", cdk.validateString)(properties.kernelId));
  errors.collect(cdk.propertyValidator("keyName", cdk.validateString)(properties.keyName));
  errors.collect(cdk.propertyValidator("monitoring", CfnSpotFleetSpotFleetMonitoringPropertyValidator)(properties.monitoring));
  errors.collect(cdk.propertyValidator("networkInterfaces", cdk.listValidator(CfnSpotFleetInstanceNetworkInterfaceSpecificationPropertyValidator))(properties.networkInterfaces));
  errors.collect(cdk.propertyValidator("placement", CfnSpotFleetSpotPlacementPropertyValidator)(properties.placement));
  errors.collect(cdk.propertyValidator("ramdiskId", cdk.validateString)(properties.ramdiskId));
  errors.collect(cdk.propertyValidator("securityGroups", cdk.listValidator(CfnSpotFleetGroupIdentifierPropertyValidator))(properties.securityGroups));
  errors.collect(cdk.propertyValidator("spotPrice", cdk.validateString)(properties.spotPrice));
  errors.collect(cdk.propertyValidator("subnetId", cdk.validateString)(properties.subnetId));
  errors.collect(cdk.propertyValidator("tagSpecifications", cdk.listValidator(CfnSpotFleetSpotFleetTagSpecificationPropertyValidator))(properties.tagSpecifications));
  errors.collect(cdk.propertyValidator("userData", cdk.validateString)(properties.userData));
  errors.collect(cdk.propertyValidator("weightedCapacity", cdk.validateNumber)(properties.weightedCapacity));
  return errors.wrap("supplied properties not correct for \\"SpotFleetLaunchSpecificationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetSpotFleetLaunchSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetSpotFleetLaunchSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "BlockDeviceMappings": cdk.listMapper(convertCfnSpotFleetBlockDeviceMappingPropertyToCloudFormation)(properties.blockDeviceMappings),
    "EbsOptimized": cdk.booleanToCloudFormation(properties.ebsOptimized),
    "IamInstanceProfile": convertCfnSpotFleetIamInstanceProfileSpecificationPropertyToCloudFormation(properties.iamInstanceProfile),
    "ImageId": cdk.stringToCloudFormation(properties.imageId),
    "InstanceRequirements": convertCfnSpotFleetInstanceRequirementsRequestPropertyToCloudFormation(properties.instanceRequirements),
    "InstanceType": cdk.stringToCloudFormation(properties.instanceType),
    "KernelId": cdk.stringToCloudFormation(properties.kernelId),
    "KeyName": cdk.stringToCloudFormation(properties.keyName),
    "Monitoring": convertCfnSpotFleetSpotFleetMonitoringPropertyToCloudFormation(properties.monitoring),
    "NetworkInterfaces": cdk.listMapper(convertCfnSpotFleetInstanceNetworkInterfaceSpecificationPropertyToCloudFormation)(properties.networkInterfaces),
    "Placement": convertCfnSpotFleetSpotPlacementPropertyToCloudFormation(properties.placement),
    "RamdiskId": cdk.stringToCloudFormation(properties.ramdiskId),
    "SecurityGroups": cdk.listMapper(convertCfnSpotFleetGroupIdentifierPropertyToCloudFormation)(properties.securityGroups),
    "SpotPrice": cdk.stringToCloudFormation(properties.spotPrice),
    "SubnetId": cdk.stringToCloudFormation(properties.subnetId),
    "TagSpecifications": cdk.listMapper(convertCfnSpotFleetSpotFleetTagSpecificationPropertyToCloudFormation)(properties.tagSpecifications),
    "UserData": cdk.stringToCloudFormation(properties.userData),
    "WeightedCapacity": cdk.numberToCloudFormation(properties.weightedCapacity)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetSpotFleetLaunchSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSpotFleet.SpotFleetLaunchSpecificationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleet.SpotFleetLaunchSpecificationProperty>();
  ret.addPropertyResult("blockDeviceMappings", "BlockDeviceMappings", (properties.BlockDeviceMappings != null ? cfn_parse.FromCloudFormation.getArray(CfnSpotFleetBlockDeviceMappingPropertyFromCloudFormation)(properties.BlockDeviceMappings) : undefined));
  ret.addPropertyResult("ebsOptimized", "EbsOptimized", (properties.EbsOptimized != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EbsOptimized) : undefined));
  ret.addPropertyResult("iamInstanceProfile", "IamInstanceProfile", (properties.IamInstanceProfile != null ? CfnSpotFleetIamInstanceProfileSpecificationPropertyFromCloudFormation(properties.IamInstanceProfile) : undefined));
  ret.addPropertyResult("imageId", "ImageId", (properties.ImageId != null ? cfn_parse.FromCloudFormation.getString(properties.ImageId) : undefined));
  ret.addPropertyResult("instanceRequirements", "InstanceRequirements", (properties.InstanceRequirements != null ? CfnSpotFleetInstanceRequirementsRequestPropertyFromCloudFormation(properties.InstanceRequirements) : undefined));
  ret.addPropertyResult("instanceType", "InstanceType", (properties.InstanceType != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceType) : undefined));
  ret.addPropertyResult("kernelId", "KernelId", (properties.KernelId != null ? cfn_parse.FromCloudFormation.getString(properties.KernelId) : undefined));
  ret.addPropertyResult("keyName", "KeyName", (properties.KeyName != null ? cfn_parse.FromCloudFormation.getString(properties.KeyName) : undefined));
  ret.addPropertyResult("monitoring", "Monitoring", (properties.Monitoring != null ? CfnSpotFleetSpotFleetMonitoringPropertyFromCloudFormation(properties.Monitoring) : undefined));
  ret.addPropertyResult("networkInterfaces", "NetworkInterfaces", (properties.NetworkInterfaces != null ? cfn_parse.FromCloudFormation.getArray(CfnSpotFleetInstanceNetworkInterfaceSpecificationPropertyFromCloudFormation)(properties.NetworkInterfaces) : undefined));
  ret.addPropertyResult("placement", "Placement", (properties.Placement != null ? CfnSpotFleetSpotPlacementPropertyFromCloudFormation(properties.Placement) : undefined));
  ret.addPropertyResult("ramdiskId", "RamdiskId", (properties.RamdiskId != null ? cfn_parse.FromCloudFormation.getString(properties.RamdiskId) : undefined));
  ret.addPropertyResult("securityGroups", "SecurityGroups", (properties.SecurityGroups != null ? cfn_parse.FromCloudFormation.getArray(CfnSpotFleetGroupIdentifierPropertyFromCloudFormation)(properties.SecurityGroups) : undefined));
  ret.addPropertyResult("spotPrice", "SpotPrice", (properties.SpotPrice != null ? cfn_parse.FromCloudFormation.getString(properties.SpotPrice) : undefined));
  ret.addPropertyResult("subnetId", "SubnetId", (properties.SubnetId != null ? cfn_parse.FromCloudFormation.getString(properties.SubnetId) : undefined));
  ret.addPropertyResult("tagSpecifications", "TagSpecifications", (properties.TagSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnSpotFleetSpotFleetTagSpecificationPropertyFromCloudFormation)(properties.TagSpecifications) : undefined));
  ret.addPropertyResult("userData", "UserData", (properties.UserData != null ? cfn_parse.FromCloudFormation.getString(properties.UserData) : undefined));
  ret.addPropertyResult("weightedCapacity", "WeightedCapacity", (properties.WeightedCapacity != null ? cfn_parse.FromCloudFormation.getNumber(properties.WeightedCapacity) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`FleetLaunchTemplateSpecificationProperty\`
 *
 * @param properties - the TypeScript properties of a \`FleetLaunchTemplateSpecificationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetFleetLaunchTemplateSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("launchTemplateId", cdk.validateString)(properties.launchTemplateId));
  errors.collect(cdk.propertyValidator("launchTemplateName", cdk.validateString)(properties.launchTemplateName));
  errors.collect(cdk.propertyValidator("version", cdk.requiredValidator)(properties.version));
  errors.collect(cdk.propertyValidator("version", cdk.validateString)(properties.version));
  return errors.wrap("supplied properties not correct for \\"FleetLaunchTemplateSpecificationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetFleetLaunchTemplateSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetFleetLaunchTemplateSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "LaunchTemplateId": cdk.stringToCloudFormation(properties.launchTemplateId),
    "LaunchTemplateName": cdk.stringToCloudFormation(properties.launchTemplateName),
    "Version": cdk.stringToCloudFormation(properties.version)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetFleetLaunchTemplateSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSpotFleet.FleetLaunchTemplateSpecificationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleet.FleetLaunchTemplateSpecificationProperty>();
  ret.addPropertyResult("launchTemplateId", "LaunchTemplateId", (properties.LaunchTemplateId != null ? cfn_parse.FromCloudFormation.getString(properties.LaunchTemplateId) : undefined));
  ret.addPropertyResult("launchTemplateName", "LaunchTemplateName", (properties.LaunchTemplateName != null ? cfn_parse.FromCloudFormation.getString(properties.LaunchTemplateName) : undefined));
  ret.addPropertyResult("version", "Version", (properties.Version != null ? cfn_parse.FromCloudFormation.getString(properties.Version) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`LaunchTemplateOverridesProperty\`
 *
 * @param properties - the TypeScript properties of a \`LaunchTemplateOverridesProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetLaunchTemplateOverridesPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("availabilityZone", cdk.validateString)(properties.availabilityZone));
  errors.collect(cdk.propertyValidator("instanceRequirements", CfnSpotFleetInstanceRequirementsRequestPropertyValidator)(properties.instanceRequirements));
  errors.collect(cdk.propertyValidator("instanceType", cdk.validateString)(properties.instanceType));
  errors.collect(cdk.propertyValidator("priority", cdk.validateNumber)(properties.priority));
  errors.collect(cdk.propertyValidator("spotPrice", cdk.validateString)(properties.spotPrice));
  errors.collect(cdk.propertyValidator("subnetId", cdk.validateString)(properties.subnetId));
  errors.collect(cdk.propertyValidator("weightedCapacity", cdk.validateNumber)(properties.weightedCapacity));
  return errors.wrap("supplied properties not correct for \\"LaunchTemplateOverridesProperty\\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetLaunchTemplateOverridesPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetLaunchTemplateOverridesPropertyValidator(properties).assertSuccess();
  return {
    "AvailabilityZone": cdk.stringToCloudFormation(properties.availabilityZone),
    "InstanceRequirements": convertCfnSpotFleetInstanceRequirementsRequestPropertyToCloudFormation(properties.instanceRequirements),
    "InstanceType": cdk.stringToCloudFormation(properties.instanceType),
    "Priority": cdk.numberToCloudFormation(properties.priority),
    "SpotPrice": cdk.stringToCloudFormation(properties.spotPrice),
    "SubnetId": cdk.stringToCloudFormation(properties.subnetId),
    "WeightedCapacity": cdk.numberToCloudFormation(properties.weightedCapacity)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetLaunchTemplateOverridesPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSpotFleet.LaunchTemplateOverridesProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleet.LaunchTemplateOverridesProperty>();
  ret.addPropertyResult("availabilityZone", "AvailabilityZone", (properties.AvailabilityZone != null ? cfn_parse.FromCloudFormation.getString(properties.AvailabilityZone) : undefined));
  ret.addPropertyResult("instanceRequirements", "InstanceRequirements", (properties.InstanceRequirements != null ? CfnSpotFleetInstanceRequirementsRequestPropertyFromCloudFormation(properties.InstanceRequirements) : undefined));
  ret.addPropertyResult("instanceType", "InstanceType", (properties.InstanceType != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceType) : undefined));
  ret.addPropertyResult("priority", "Priority", (properties.Priority != null ? cfn_parse.FromCloudFormation.getNumber(properties.Priority) : undefined));
  ret.addPropertyResult("spotPrice", "SpotPrice", (properties.SpotPrice != null ? cfn_parse.FromCloudFormation.getString(properties.SpotPrice) : undefined));
  ret.addPropertyResult("subnetId", "SubnetId", (properties.SubnetId != null ? cfn_parse.FromCloudFormation.getString(properties.SubnetId) : undefined));
  ret.addPropertyResult("weightedCapacity", "WeightedCapacity", (properties.WeightedCapacity != null ? cfn_parse.FromCloudFormation.getNumber(properties.WeightedCapacity) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`LaunchTemplateConfigProperty\`
 *
 * @param properties - the TypeScript properties of a \`LaunchTemplateConfigProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetLaunchTemplateConfigPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("launchTemplateSpecification", CfnSpotFleetFleetLaunchTemplateSpecificationPropertyValidator)(properties.launchTemplateSpecification));
  errors.collect(cdk.propertyValidator("overrides", cdk.listValidator(CfnSpotFleetLaunchTemplateOverridesPropertyValidator))(properties.overrides));
  return errors.wrap("supplied properties not correct for \\"LaunchTemplateConfigProperty\\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetLaunchTemplateConfigPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetLaunchTemplateConfigPropertyValidator(properties).assertSuccess();
  return {
    "LaunchTemplateSpecification": convertCfnSpotFleetFleetLaunchTemplateSpecificationPropertyToCloudFormation(properties.launchTemplateSpecification),
    "Overrides": cdk.listMapper(convertCfnSpotFleetLaunchTemplateOverridesPropertyToCloudFormation)(properties.overrides)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetLaunchTemplateConfigPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSpotFleet.LaunchTemplateConfigProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleet.LaunchTemplateConfigProperty>();
  ret.addPropertyResult("launchTemplateSpecification", "LaunchTemplateSpecification", (properties.LaunchTemplateSpecification != null ? CfnSpotFleetFleetLaunchTemplateSpecificationPropertyFromCloudFormation(properties.LaunchTemplateSpecification) : undefined));
  ret.addPropertyResult("overrides", "Overrides", (properties.Overrides != null ? cfn_parse.FromCloudFormation.getArray(CfnSpotFleetLaunchTemplateOverridesPropertyFromCloudFormation)(properties.Overrides) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ClassicLoadBalancerProperty\`
 *
 * @param properties - the TypeScript properties of a \`ClassicLoadBalancerProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetClassicLoadBalancerPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("name", cdk.requiredValidator)(properties.name));
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  return errors.wrap("supplied properties not correct for \\"ClassicLoadBalancerProperty\\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetClassicLoadBalancerPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetClassicLoadBalancerPropertyValidator(properties).assertSuccess();
  return {
    "Name": cdk.stringToCloudFormation(properties.name)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetClassicLoadBalancerPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSpotFleet.ClassicLoadBalancerProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleet.ClassicLoadBalancerProperty>();
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ClassicLoadBalancersConfigProperty\`
 *
 * @param properties - the TypeScript properties of a \`ClassicLoadBalancersConfigProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetClassicLoadBalancersConfigPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("classicLoadBalancers", cdk.requiredValidator)(properties.classicLoadBalancers));
  errors.collect(cdk.propertyValidator("classicLoadBalancers", cdk.listValidator(CfnSpotFleetClassicLoadBalancerPropertyValidator))(properties.classicLoadBalancers));
  return errors.wrap("supplied properties not correct for \\"ClassicLoadBalancersConfigProperty\\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetClassicLoadBalancersConfigPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetClassicLoadBalancersConfigPropertyValidator(properties).assertSuccess();
  return {
    "ClassicLoadBalancers": cdk.listMapper(convertCfnSpotFleetClassicLoadBalancerPropertyToCloudFormation)(properties.classicLoadBalancers)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetClassicLoadBalancersConfigPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSpotFleet.ClassicLoadBalancersConfigProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleet.ClassicLoadBalancersConfigProperty>();
  ret.addPropertyResult("classicLoadBalancers", "ClassicLoadBalancers", (properties.ClassicLoadBalancers != null ? cfn_parse.FromCloudFormation.getArray(CfnSpotFleetClassicLoadBalancerPropertyFromCloudFormation)(properties.ClassicLoadBalancers) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`TargetGroupProperty\`
 *
 * @param properties - the TypeScript properties of a \`TargetGroupProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetTargetGroupPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("arn", cdk.requiredValidator)(properties.arn));
  errors.collect(cdk.propertyValidator("arn", cdk.validateString)(properties.arn));
  return errors.wrap("supplied properties not correct for \\"TargetGroupProperty\\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetTargetGroupPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetTargetGroupPropertyValidator(properties).assertSuccess();
  return {
    "Arn": cdk.stringToCloudFormation(properties.arn)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetTargetGroupPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSpotFleet.TargetGroupProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleet.TargetGroupProperty>();
  ret.addPropertyResult("arn", "Arn", (properties.Arn != null ? cfn_parse.FromCloudFormation.getString(properties.Arn) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`TargetGroupsConfigProperty\`
 *
 * @param properties - the TypeScript properties of a \`TargetGroupsConfigProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetTargetGroupsConfigPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("targetGroups", cdk.requiredValidator)(properties.targetGroups));
  errors.collect(cdk.propertyValidator("targetGroups", cdk.listValidator(CfnSpotFleetTargetGroupPropertyValidator))(properties.targetGroups));
  return errors.wrap("supplied properties not correct for \\"TargetGroupsConfigProperty\\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetTargetGroupsConfigPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetTargetGroupsConfigPropertyValidator(properties).assertSuccess();
  return {
    "TargetGroups": cdk.listMapper(convertCfnSpotFleetTargetGroupPropertyToCloudFormation)(properties.targetGroups)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetTargetGroupsConfigPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSpotFleet.TargetGroupsConfigProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleet.TargetGroupsConfigProperty>();
  ret.addPropertyResult("targetGroups", "TargetGroups", (properties.TargetGroups != null ? cfn_parse.FromCloudFormation.getArray(CfnSpotFleetTargetGroupPropertyFromCloudFormation)(properties.TargetGroups) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`LoadBalancersConfigProperty\`
 *
 * @param properties - the TypeScript properties of a \`LoadBalancersConfigProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetLoadBalancersConfigPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("classicLoadBalancersConfig", CfnSpotFleetClassicLoadBalancersConfigPropertyValidator)(properties.classicLoadBalancersConfig));
  errors.collect(cdk.propertyValidator("targetGroupsConfig", CfnSpotFleetTargetGroupsConfigPropertyValidator)(properties.targetGroupsConfig));
  return errors.wrap("supplied properties not correct for \\"LoadBalancersConfigProperty\\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetLoadBalancersConfigPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetLoadBalancersConfigPropertyValidator(properties).assertSuccess();
  return {
    "ClassicLoadBalancersConfig": convertCfnSpotFleetClassicLoadBalancersConfigPropertyToCloudFormation(properties.classicLoadBalancersConfig),
    "TargetGroupsConfig": convertCfnSpotFleetTargetGroupsConfigPropertyToCloudFormation(properties.targetGroupsConfig)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetLoadBalancersConfigPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSpotFleet.LoadBalancersConfigProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleet.LoadBalancersConfigProperty>();
  ret.addPropertyResult("classicLoadBalancersConfig", "ClassicLoadBalancersConfig", (properties.ClassicLoadBalancersConfig != null ? CfnSpotFleetClassicLoadBalancersConfigPropertyFromCloudFormation(properties.ClassicLoadBalancersConfig) : undefined));
  ret.addPropertyResult("targetGroupsConfig", "TargetGroupsConfig", (properties.TargetGroupsConfig != null ? CfnSpotFleetTargetGroupsConfigPropertyFromCloudFormation(properties.TargetGroupsConfig) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`SpotCapacityRebalanceProperty\`
 *
 * @param properties - the TypeScript properties of a \`SpotCapacityRebalanceProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetSpotCapacityRebalancePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("replacementStrategy", cdk.validateString)(properties.replacementStrategy));
  errors.collect(cdk.propertyValidator("terminationDelay", cdk.validateNumber)(properties.terminationDelay));
  return errors.wrap("supplied properties not correct for \\"SpotCapacityRebalanceProperty\\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetSpotCapacityRebalancePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetSpotCapacityRebalancePropertyValidator(properties).assertSuccess();
  return {
    "ReplacementStrategy": cdk.stringToCloudFormation(properties.replacementStrategy),
    "TerminationDelay": cdk.numberToCloudFormation(properties.terminationDelay)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetSpotCapacityRebalancePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSpotFleet.SpotCapacityRebalanceProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleet.SpotCapacityRebalanceProperty>();
  ret.addPropertyResult("replacementStrategy", "ReplacementStrategy", (properties.ReplacementStrategy != null ? cfn_parse.FromCloudFormation.getString(properties.ReplacementStrategy) : undefined));
  ret.addPropertyResult("terminationDelay", "TerminationDelay", (properties.TerminationDelay != null ? cfn_parse.FromCloudFormation.getNumber(properties.TerminationDelay) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`SpotMaintenanceStrategiesProperty\`
 *
 * @param properties - the TypeScript properties of a \`SpotMaintenanceStrategiesProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetSpotMaintenanceStrategiesPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("capacityRebalance", CfnSpotFleetSpotCapacityRebalancePropertyValidator)(properties.capacityRebalance));
  return errors.wrap("supplied properties not correct for \\"SpotMaintenanceStrategiesProperty\\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetSpotMaintenanceStrategiesPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetSpotMaintenanceStrategiesPropertyValidator(properties).assertSuccess();
  return {
    "CapacityRebalance": convertCfnSpotFleetSpotCapacityRebalancePropertyToCloudFormation(properties.capacityRebalance)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetSpotMaintenanceStrategiesPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSpotFleet.SpotMaintenanceStrategiesProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleet.SpotMaintenanceStrategiesProperty>();
  ret.addPropertyResult("capacityRebalance", "CapacityRebalance", (properties.CapacityRebalance != null ? CfnSpotFleetSpotCapacityRebalancePropertyFromCloudFormation(properties.CapacityRebalance) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`SpotFleetRequestConfigDataProperty\`
 *
 * @param properties - the TypeScript properties of a \`SpotFleetRequestConfigDataProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetSpotFleetRequestConfigDataPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("allocationStrategy", cdk.validateString)(properties.allocationStrategy));
  errors.collect(cdk.propertyValidator("context", cdk.validateString)(properties.context));
  errors.collect(cdk.propertyValidator("excessCapacityTerminationPolicy", cdk.validateString)(properties.excessCapacityTerminationPolicy));
  errors.collect(cdk.propertyValidator("iamFleetRole", cdk.requiredValidator)(properties.iamFleetRole));
  errors.collect(cdk.propertyValidator("iamFleetRole", cdk.validateString)(properties.iamFleetRole));
  errors.collect(cdk.propertyValidator("instanceInterruptionBehavior", cdk.validateString)(properties.instanceInterruptionBehavior));
  errors.collect(cdk.propertyValidator("instancePoolsToUseCount", cdk.validateNumber)(properties.instancePoolsToUseCount));
  errors.collect(cdk.propertyValidator("launchSpecifications", cdk.listValidator(CfnSpotFleetSpotFleetLaunchSpecificationPropertyValidator))(properties.launchSpecifications));
  errors.collect(cdk.propertyValidator("launchTemplateConfigs", cdk.listValidator(CfnSpotFleetLaunchTemplateConfigPropertyValidator))(properties.launchTemplateConfigs));
  errors.collect(cdk.propertyValidator("loadBalancersConfig", CfnSpotFleetLoadBalancersConfigPropertyValidator)(properties.loadBalancersConfig));
  errors.collect(cdk.propertyValidator("onDemandAllocationStrategy", cdk.validateString)(properties.onDemandAllocationStrategy));
  errors.collect(cdk.propertyValidator("onDemandMaxTotalPrice", cdk.validateString)(properties.onDemandMaxTotalPrice));
  errors.collect(cdk.propertyValidator("onDemandTargetCapacity", cdk.validateNumber)(properties.onDemandTargetCapacity));
  errors.collect(cdk.propertyValidator("replaceUnhealthyInstances", cdk.validateBoolean)(properties.replaceUnhealthyInstances));
  errors.collect(cdk.propertyValidator("spotMaintenanceStrategies", CfnSpotFleetSpotMaintenanceStrategiesPropertyValidator)(properties.spotMaintenanceStrategies));
  errors.collect(cdk.propertyValidator("spotMaxTotalPrice", cdk.validateString)(properties.spotMaxTotalPrice));
  errors.collect(cdk.propertyValidator("spotPrice", cdk.validateString)(properties.spotPrice));
  errors.collect(cdk.propertyValidator("tagSpecifications", cdk.listValidator(CfnSpotFleetSpotFleetTagSpecificationPropertyValidator))(properties.tagSpecifications));
  errors.collect(cdk.propertyValidator("targetCapacity", cdk.requiredValidator)(properties.targetCapacity));
  errors.collect(cdk.propertyValidator("targetCapacity", cdk.validateNumber)(properties.targetCapacity));
  errors.collect(cdk.propertyValidator("targetCapacityUnitType", cdk.validateString)(properties.targetCapacityUnitType));
  errors.collect(cdk.propertyValidator("terminateInstancesWithExpiration", cdk.validateBoolean)(properties.terminateInstancesWithExpiration));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  errors.collect(cdk.propertyValidator("validFrom", cdk.validateString)(properties.validFrom));
  errors.collect(cdk.propertyValidator("validUntil", cdk.validateString)(properties.validUntil));
  return errors.wrap("supplied properties not correct for \\"SpotFleetRequestConfigDataProperty\\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetSpotFleetRequestConfigDataPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetSpotFleetRequestConfigDataPropertyValidator(properties).assertSuccess();
  return {
    "AllocationStrategy": cdk.stringToCloudFormation(properties.allocationStrategy),
    "Context": cdk.stringToCloudFormation(properties.context),
    "ExcessCapacityTerminationPolicy": cdk.stringToCloudFormation(properties.excessCapacityTerminationPolicy),
    "IamFleetRole": cdk.stringToCloudFormation(properties.iamFleetRole),
    "InstanceInterruptionBehavior": cdk.stringToCloudFormation(properties.instanceInterruptionBehavior),
    "InstancePoolsToUseCount": cdk.numberToCloudFormation(properties.instancePoolsToUseCount),
    "LaunchSpecifications": cdk.listMapper(convertCfnSpotFleetSpotFleetLaunchSpecificationPropertyToCloudFormation)(properties.launchSpecifications),
    "LaunchTemplateConfigs": cdk.listMapper(convertCfnSpotFleetLaunchTemplateConfigPropertyToCloudFormation)(properties.launchTemplateConfigs),
    "LoadBalancersConfig": convertCfnSpotFleetLoadBalancersConfigPropertyToCloudFormation(properties.loadBalancersConfig),
    "OnDemandAllocationStrategy": cdk.stringToCloudFormation(properties.onDemandAllocationStrategy),
    "OnDemandMaxTotalPrice": cdk.stringToCloudFormation(properties.onDemandMaxTotalPrice),
    "OnDemandTargetCapacity": cdk.numberToCloudFormation(properties.onDemandTargetCapacity),
    "ReplaceUnhealthyInstances": cdk.booleanToCloudFormation(properties.replaceUnhealthyInstances),
    "SpotMaintenanceStrategies": convertCfnSpotFleetSpotMaintenanceStrategiesPropertyToCloudFormation(properties.spotMaintenanceStrategies),
    "SpotMaxTotalPrice": cdk.stringToCloudFormation(properties.spotMaxTotalPrice),
    "SpotPrice": cdk.stringToCloudFormation(properties.spotPrice),
    "TagSpecifications": cdk.listMapper(convertCfnSpotFleetSpotFleetTagSpecificationPropertyToCloudFormation)(properties.tagSpecifications),
    "TargetCapacity": cdk.numberToCloudFormation(properties.targetCapacity),
    "TargetCapacityUnitType": cdk.stringToCloudFormation(properties.targetCapacityUnitType),
    "TerminateInstancesWithExpiration": cdk.booleanToCloudFormation(properties.terminateInstancesWithExpiration),
    "Type": cdk.stringToCloudFormation(properties.type),
    "ValidFrom": cdk.stringToCloudFormation(properties.validFrom),
    "ValidUntil": cdk.stringToCloudFormation(properties.validUntil)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetSpotFleetRequestConfigDataPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSpotFleet.SpotFleetRequestConfigDataProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleet.SpotFleetRequestConfigDataProperty>();
  ret.addPropertyResult("allocationStrategy", "AllocationStrategy", (properties.AllocationStrategy != null ? cfn_parse.FromCloudFormation.getString(properties.AllocationStrategy) : undefined));
  ret.addPropertyResult("context", "Context", (properties.Context != null ? cfn_parse.FromCloudFormation.getString(properties.Context) : undefined));
  ret.addPropertyResult("excessCapacityTerminationPolicy", "ExcessCapacityTerminationPolicy", (properties.ExcessCapacityTerminationPolicy != null ? cfn_parse.FromCloudFormation.getString(properties.ExcessCapacityTerminationPolicy) : undefined));
  ret.addPropertyResult("iamFleetRole", "IamFleetRole", (properties.IamFleetRole != null ? cfn_parse.FromCloudFormation.getString(properties.IamFleetRole) : undefined));
  ret.addPropertyResult("instanceInterruptionBehavior", "InstanceInterruptionBehavior", (properties.InstanceInterruptionBehavior != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceInterruptionBehavior) : undefined));
  ret.addPropertyResult("instancePoolsToUseCount", "InstancePoolsToUseCount", (properties.InstancePoolsToUseCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.InstancePoolsToUseCount) : undefined));
  ret.addPropertyResult("launchSpecifications", "LaunchSpecifications", (properties.LaunchSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnSpotFleetSpotFleetLaunchSpecificationPropertyFromCloudFormation)(properties.LaunchSpecifications) : undefined));
  ret.addPropertyResult("launchTemplateConfigs", "LaunchTemplateConfigs", (properties.LaunchTemplateConfigs != null ? cfn_parse.FromCloudFormation.getArray(CfnSpotFleetLaunchTemplateConfigPropertyFromCloudFormation)(properties.LaunchTemplateConfigs) : undefined));
  ret.addPropertyResult("loadBalancersConfig", "LoadBalancersConfig", (properties.LoadBalancersConfig != null ? CfnSpotFleetLoadBalancersConfigPropertyFromCloudFormation(properties.LoadBalancersConfig) : undefined));
  ret.addPropertyResult("onDemandAllocationStrategy", "OnDemandAllocationStrategy", (properties.OnDemandAllocationStrategy != null ? cfn_parse.FromCloudFormation.getString(properties.OnDemandAllocationStrategy) : undefined));
  ret.addPropertyResult("onDemandMaxTotalPrice", "OnDemandMaxTotalPrice", (properties.OnDemandMaxTotalPrice != null ? cfn_parse.FromCloudFormation.getString(properties.OnDemandMaxTotalPrice) : undefined));
  ret.addPropertyResult("onDemandTargetCapacity", "OnDemandTargetCapacity", (properties.OnDemandTargetCapacity != null ? cfn_parse.FromCloudFormation.getNumber(properties.OnDemandTargetCapacity) : undefined));
  ret.addPropertyResult("replaceUnhealthyInstances", "ReplaceUnhealthyInstances", (properties.ReplaceUnhealthyInstances != null ? cfn_parse.FromCloudFormation.getBoolean(properties.ReplaceUnhealthyInstances) : undefined));
  ret.addPropertyResult("spotMaintenanceStrategies", "SpotMaintenanceStrategies", (properties.SpotMaintenanceStrategies != null ? CfnSpotFleetSpotMaintenanceStrategiesPropertyFromCloudFormation(properties.SpotMaintenanceStrategies) : undefined));
  ret.addPropertyResult("spotMaxTotalPrice", "SpotMaxTotalPrice", (properties.SpotMaxTotalPrice != null ? cfn_parse.FromCloudFormation.getString(properties.SpotMaxTotalPrice) : undefined));
  ret.addPropertyResult("spotPrice", "SpotPrice", (properties.SpotPrice != null ? cfn_parse.FromCloudFormation.getString(properties.SpotPrice) : undefined));
  ret.addPropertyResult("tagSpecifications", "TagSpecifications", (properties.TagSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnSpotFleetSpotFleetTagSpecificationPropertyFromCloudFormation)(properties.TagSpecifications) : undefined));
  ret.addPropertyResult("targetCapacity", "TargetCapacity", (properties.TargetCapacity != null ? cfn_parse.FromCloudFormation.getNumber(properties.TargetCapacity) : undefined));
  ret.addPropertyResult("targetCapacityUnitType", "TargetCapacityUnitType", (properties.TargetCapacityUnitType != null ? cfn_parse.FromCloudFormation.getString(properties.TargetCapacityUnitType) : undefined));
  ret.addPropertyResult("terminateInstancesWithExpiration", "TerminateInstancesWithExpiration", (properties.TerminateInstancesWithExpiration != null ? cfn_parse.FromCloudFormation.getBoolean(properties.TerminateInstancesWithExpiration) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addPropertyResult("validFrom", "ValidFrom", (properties.ValidFrom != null ? cfn_parse.FromCloudFormation.getString(properties.ValidFrom) : undefined));
  ret.addPropertyResult("validUntil", "ValidUntil", (properties.ValidUntil != null ? cfn_parse.FromCloudFormation.getString(properties.ValidUntil) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnSpotFleetProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnSpotFleetProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("spotFleetRequestConfigData", cdk.requiredValidator)(properties.spotFleetRequestConfigData));
  errors.collect(cdk.propertyValidator("spotFleetRequestConfigData", CfnSpotFleetSpotFleetRequestConfigDataPropertyValidator)(properties.spotFleetRequestConfigData));
  return errors.wrap("supplied properties not correct for \\"CfnSpotFleetProps\\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetPropsValidator(properties).assertSuccess();
  return {
    "SpotFleetRequestConfigData": convertCfnSpotFleetSpotFleetRequestConfigDataPropertyToCloudFormation(properties.spotFleetRequestConfigData)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSpotFleetProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleetProps>();
  ret.addPropertyResult("spotFleetRequestConfigData", "SpotFleetRequestConfigData", (properties.SpotFleetRequestConfigData != null ? CfnSpotFleetSpotFleetRequestConfigDataPropertyFromCloudFormation(properties.SpotFleetRequestConfigData) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a subnet for the specified VPC.
 *
 * For an IPv4 only subnet, specify an IPv4 CIDR block. If the VPC has an IPv6 CIDR block, you can create an IPv6 only subnet or a dual stack subnet instead. For an IPv6 only subnet, specify an IPv6 CIDR block. For a dual stack subnet, specify both an IPv4 CIDR block and an IPv6 CIDR block.
 *
 * For more information, see [Subnets for your VPC](https://docs.aws.amazon.com/vpc/latest/userguide/configure-subnets.html) in the *Amazon VPC User Guide* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html
 */
export class CfnSubnet extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::Subnet";

  /**
   * Build a CfnSubnet from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnSubnet {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnSubnetPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnSubnet(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The Availability Zone of this subnet. For example, \`us-east-1a\` .
   *
   * @cloudformationAttribute AvailabilityZone
   */
  public readonly attrAvailabilityZone: string;

  /**
   * The Availability Zone ID of this subnet. For example, \`use1-az1\` .
   *
   * @cloudformationAttribute AvailabilityZoneId
   */
  public readonly attrAvailabilityZoneId: string;

  /**
   * The IPv4 CIDR blocks that are associated with the subnet.
   *
   * @cloudformationAttribute CidrBlock
   */
  public readonly attrCidrBlock: string;

  /**
   * The IPv6 CIDR blocks that are associated with the subnet.
   *
   * @cloudformationAttribute Ipv6CidrBlocks
   */
  public readonly attrIpv6CidrBlocks: Array<string>;

  /**
   * The ID of the network ACL that is associated with the subnet's VPC, such as \`acl-5fb85d36\` .
   *
   * @cloudformationAttribute NetworkAclAssociationId
   */
  public readonly attrNetworkAclAssociationId: string;

  /**
   * The Amazon Resource Name (ARN) of the Outpost.
   *
   * @cloudformationAttribute OutpostArn
   */
  public readonly attrOutpostArn: string;

  /**
   * The ID of the subnet.
   *
   * @cloudformationAttribute SubnetId
   */
  public readonly attrSubnetId: string;

  /**
   * The ID of the subnet's VPC, such as \`vpc-11ad4878\` .
   *
   * @cloudformationAttribute VpcId
   */
  public readonly attrVpcId: string;

  /**
   * Indicates whether a network interface created in this subnet receives an IPv6 address. The default value is \`false\` .
   */
  public assignIpv6AddressOnCreation?: boolean | cdk.IResolvable;

  /**
   * The Availability Zone of the subnet.
   */
  public availabilityZone?: string;

  /**
   * The AZ ID of the subnet.
   */
  public availabilityZoneId?: string;

  /**
   * The IPv4 CIDR block assigned to the subnet.
   */
  public cidrBlock?: string;

  /**
   * Indicates whether DNS queries made to the Amazon-provided DNS Resolver in this subnet should return synthetic IPv6 addresses for IPv4-only destinations.
   */
  public enableDns64?: boolean | cdk.IResolvable;

  /**
   * The IPv6 CIDR block.
   */
  public ipv6CidrBlock?: string;

  /**
   * Indicates whether this is an IPv6 only subnet.
   */
  public ipv6Native?: boolean | cdk.IResolvable;

  /**
   * Indicates whether instances launched in this subnet receive a public IPv4 address.
   */
  public mapPublicIpOnLaunch?: boolean | cdk.IResolvable;

  /**
   * The Amazon Resource Name (ARN) of the Outpost.
   */
  public outpostArn?: string;

  /**
   * The hostname type for EC2 instances launched into this subnet and how DNS A and AAAA record queries to the instances should be handled.
   */
  public privateDnsNameOptionsOnLaunch?: any | cdk.IResolvable;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * Any tags assigned to the subnet.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The ID of the VPC the subnet is in.
   */
  public vpcId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnSubnetProps) {
    super(scope, id, {
      "type": CfnSubnet.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "vpcId", this);

    this.attrAvailabilityZone = cdk.Token.asString(this.getAtt("AvailabilityZone", cdk.ResolutionTypeHint.STRING));
    this.attrAvailabilityZoneId = cdk.Token.asString(this.getAtt("AvailabilityZoneId", cdk.ResolutionTypeHint.STRING));
    this.attrCidrBlock = cdk.Token.asString(this.getAtt("CidrBlock", cdk.ResolutionTypeHint.STRING));
    this.attrIpv6CidrBlocks = cdk.Token.asList(this.getAtt("Ipv6CidrBlocks", cdk.ResolutionTypeHint.STRING_LIST));
    this.attrNetworkAclAssociationId = cdk.Token.asString(this.getAtt("NetworkAclAssociationId", cdk.ResolutionTypeHint.STRING));
    this.attrOutpostArn = cdk.Token.asString(this.getAtt("OutpostArn", cdk.ResolutionTypeHint.STRING));
    this.attrSubnetId = cdk.Token.asString(this.getAtt("SubnetId", cdk.ResolutionTypeHint.STRING));
    this.attrVpcId = cdk.Token.asString(this.getAtt("VpcId", cdk.ResolutionTypeHint.STRING));
    this.assignIpv6AddressOnCreation = props.assignIpv6AddressOnCreation;
    this.availabilityZone = props.availabilityZone;
    this.availabilityZoneId = props.availabilityZoneId;
    this.cidrBlock = props.cidrBlock;
    this.enableDns64 = props.enableDns64;
    this.ipv6CidrBlock = props.ipv6CidrBlock;
    this.ipv6Native = props.ipv6Native;
    this.mapPublicIpOnLaunch = props.mapPublicIpOnLaunch;
    this.outpostArn = props.outpostArn;
    this.privateDnsNameOptionsOnLaunch = props.privateDnsNameOptionsOnLaunch;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::Subnet", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.vpcId = props.vpcId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "assignIpv6AddressOnCreation": this.assignIpv6AddressOnCreation,
      "availabilityZone": this.availabilityZone,
      "availabilityZoneId": this.availabilityZoneId,
      "cidrBlock": this.cidrBlock,
      "enableDns64": this.enableDns64,
      "ipv6CidrBlock": this.ipv6CidrBlock,
      "ipv6Native": this.ipv6Native,
      "mapPublicIpOnLaunch": this.mapPublicIpOnLaunch,
      "outpostArn": this.outpostArn,
      "privateDnsNameOptionsOnLaunch": this.privateDnsNameOptionsOnLaunch,
      "tags": this.tags.renderTags(),
      "vpcId": this.vpcId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnSubnet.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnSubnetPropsToCloudFormation(props);
  }
}

export namespace CfnSubnet {
  /**
   * Describes the options for instance hostnames.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-subnet-privatednsnameoptionsonlaunch.html
   */
  export interface PrivateDnsNameOptionsOnLaunchProperty {
    /**
     * Indicates whether to respond to DNS queries for instance hostname with DNS AAAA records.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-subnet-privatednsnameoptionsonlaunch.html#cfn-ec2-subnet-privatednsnameoptionsonlaunch-enableresourcenamednsaaaarecord
     */
    readonly enableResourceNameDnsAaaaRecord?: boolean | cdk.IResolvable;

    /**
     * Indicates whether to respond to DNS queries for instance hostnames with DNS A records.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-subnet-privatednsnameoptionsonlaunch.html#cfn-ec2-subnet-privatednsnameoptionsonlaunch-enableresourcenamednsarecord
     */
    readonly enableResourceNameDnsARecord?: boolean | cdk.IResolvable;

    /**
     * The type of hostname for EC2 instances.
     *
     * For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 only subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-subnet-privatednsnameoptionsonlaunch.html#cfn-ec2-subnet-privatednsnameoptionsonlaunch-hostnametype
     */
    readonly hostnameType?: string;
  }
}

/**
 * Properties for defining a \`CfnSubnet\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html
 */
export interface CfnSubnetProps {
  /**
   * Indicates whether a network interface created in this subnet receives an IPv6 address. The default value is \`false\` .
   *
   * If you specify \`AssignIpv6AddressOnCreation\` , you must also specify \`Ipv6CidrBlock\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-assignipv6addressoncreation
   */
  readonly assignIpv6AddressOnCreation?: boolean | cdk.IResolvable;

  /**
   * The Availability Zone of the subnet.
   *
   * If you update this property, you must also update the \`CidrBlock\` property.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-availabilityzone
   */
  readonly availabilityZone?: string;

  /**
   * The AZ ID of the subnet.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-availabilityzoneid
   */
  readonly availabilityZoneId?: string;

  /**
   * The IPv4 CIDR block assigned to the subnet.
   *
   * If you update this property, we create a new subnet, and then delete the existing one.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-cidrblock
   */
  readonly cidrBlock?: string;

  /**
   * Indicates whether DNS queries made to the Amazon-provided DNS Resolver in this subnet should return synthetic IPv6 addresses for IPv4-only destinations.
   *
   * For more information, see [DNS64 and NAT64](https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html#nat-gateway-nat64-dns64) in the *Amazon Virtual Private Cloud User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-enabledns64
   */
  readonly enableDns64?: boolean | cdk.IResolvable;

  /**
   * The IPv6 CIDR block.
   *
   * If you specify \`AssignIpv6AddressOnCreation\` , you must also specify \`Ipv6CidrBlock\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-ipv6cidrblock
   */
  readonly ipv6CidrBlock?: string;

  /**
   * Indicates whether this is an IPv6 only subnet.
   *
   * For more information, see [Subnet basics](https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Subnets.html#subnet-basics) in the *Amazon Virtual Private Cloud User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-ipv6native
   */
  readonly ipv6Native?: boolean | cdk.IResolvable;

  /**
   * Indicates whether instances launched in this subnet receive a public IPv4 address.
   *
   * The default value is \`false\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-mappubliciponlaunch
   */
  readonly mapPublicIpOnLaunch?: boolean | cdk.IResolvable;

  /**
   * The Amazon Resource Name (ARN) of the Outpost.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-outpostarn
   */
  readonly outpostArn?: string;

  /**
   * The hostname type for EC2 instances launched into this subnet and how DNS A and AAAA record queries to the instances should be handled.
   *
   * For more information, see [Amazon EC2 instance hostname types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html) in the *Amazon Elastic Compute Cloud User Guide* .
   *
   * Available options:
   *
   * - EnableResourceNameDnsAAAARecord (true | false)
   * - EnableResourceNameDnsARecord (true | false)
   * - HostnameType (ip-name | resource-name)
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-privatednsnameoptionsonlaunch
   */
  readonly privateDnsNameOptionsOnLaunch?: any | cdk.IResolvable;

  /**
   * Any tags assigned to the subnet.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The ID of the VPC the subnet is in.
   *
   * If you update this property, you must also update the \`CidrBlock\` property.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-vpcid
   */
  readonly vpcId: string;
}

/**
 * Determine whether the given properties match those of a \`PrivateDnsNameOptionsOnLaunchProperty\`
 *
 * @param properties - the TypeScript properties of a \`PrivateDnsNameOptionsOnLaunchProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSubnetPrivateDnsNameOptionsOnLaunchPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("enableResourceNameDnsAaaaRecord", cdk.validateBoolean)(properties.enableResourceNameDnsAaaaRecord));
  errors.collect(cdk.propertyValidator("enableResourceNameDnsARecord", cdk.validateBoolean)(properties.enableResourceNameDnsARecord));
  errors.collect(cdk.propertyValidator("hostnameType", cdk.validateString)(properties.hostnameType));
  return errors.wrap("supplied properties not correct for \\"PrivateDnsNameOptionsOnLaunchProperty\\"");
}

// @ts-ignore TS6133
function convertCfnSubnetPrivateDnsNameOptionsOnLaunchPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSubnetPrivateDnsNameOptionsOnLaunchPropertyValidator(properties).assertSuccess();
  return {
    "EnableResourceNameDnsAAAARecord": cdk.booleanToCloudFormation(properties.enableResourceNameDnsAaaaRecord),
    "EnableResourceNameDnsARecord": cdk.booleanToCloudFormation(properties.enableResourceNameDnsARecord),
    "HostnameType": cdk.stringToCloudFormation(properties.hostnameType)
  };
}

// @ts-ignore TS6133
function CfnSubnetPrivateDnsNameOptionsOnLaunchPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSubnet.PrivateDnsNameOptionsOnLaunchProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSubnet.PrivateDnsNameOptionsOnLaunchProperty>();
  ret.addPropertyResult("enableResourceNameDnsAaaaRecord", "EnableResourceNameDnsAAAARecord", (properties.EnableResourceNameDnsAAAARecord != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EnableResourceNameDnsAAAARecord) : undefined));
  ret.addPropertyResult("enableResourceNameDnsARecord", "EnableResourceNameDnsARecord", (properties.EnableResourceNameDnsARecord != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EnableResourceNameDnsARecord) : undefined));
  ret.addPropertyResult("hostnameType", "HostnameType", (properties.HostnameType != null ? cfn_parse.FromCloudFormation.getString(properties.HostnameType) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnSubnetProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnSubnetProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSubnetPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("assignIpv6AddressOnCreation", cdk.validateBoolean)(properties.assignIpv6AddressOnCreation));
  errors.collect(cdk.propertyValidator("availabilityZone", cdk.validateString)(properties.availabilityZone));
  errors.collect(cdk.propertyValidator("availabilityZoneId", cdk.validateString)(properties.availabilityZoneId));
  errors.collect(cdk.propertyValidator("cidrBlock", cdk.validateString)(properties.cidrBlock));
  errors.collect(cdk.propertyValidator("enableDns64", cdk.validateBoolean)(properties.enableDns64));
  errors.collect(cdk.propertyValidator("ipv6CidrBlock", cdk.validateString)(properties.ipv6CidrBlock));
  errors.collect(cdk.propertyValidator("ipv6Native", cdk.validateBoolean)(properties.ipv6Native));
  errors.collect(cdk.propertyValidator("mapPublicIpOnLaunch", cdk.validateBoolean)(properties.mapPublicIpOnLaunch));
  errors.collect(cdk.propertyValidator("outpostArn", cdk.validateString)(properties.outpostArn));
  errors.collect(cdk.propertyValidator("privateDnsNameOptionsOnLaunch", cdk.validateObject)(properties.privateDnsNameOptionsOnLaunch));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("vpcId", cdk.requiredValidator)(properties.vpcId));
  errors.collect(cdk.propertyValidator("vpcId", cdk.validateString)(properties.vpcId));
  return errors.wrap("supplied properties not correct for \\"CfnSubnetProps\\"");
}

// @ts-ignore TS6133
function convertCfnSubnetPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSubnetPropsValidator(properties).assertSuccess();
  return {
    "AssignIpv6AddressOnCreation": cdk.booleanToCloudFormation(properties.assignIpv6AddressOnCreation),
    "AvailabilityZone": cdk.stringToCloudFormation(properties.availabilityZone),
    "AvailabilityZoneId": cdk.stringToCloudFormation(properties.availabilityZoneId),
    "CidrBlock": cdk.stringToCloudFormation(properties.cidrBlock),
    "EnableDns64": cdk.booleanToCloudFormation(properties.enableDns64),
    "Ipv6CidrBlock": cdk.stringToCloudFormation(properties.ipv6CidrBlock),
    "Ipv6Native": cdk.booleanToCloudFormation(properties.ipv6Native),
    "MapPublicIpOnLaunch": cdk.booleanToCloudFormation(properties.mapPublicIpOnLaunch),
    "OutpostArn": cdk.stringToCloudFormation(properties.outpostArn),
    "PrivateDnsNameOptionsOnLaunch": cdk.objectToCloudFormation(properties.privateDnsNameOptionsOnLaunch),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "VpcId": cdk.stringToCloudFormation(properties.vpcId)
  };
}

// @ts-ignore TS6133
function CfnSubnetPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSubnetProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSubnetProps>();
  ret.addPropertyResult("assignIpv6AddressOnCreation", "AssignIpv6AddressOnCreation", (properties.AssignIpv6AddressOnCreation != null ? cfn_parse.FromCloudFormation.getBoolean(properties.AssignIpv6AddressOnCreation) : undefined));
  ret.addPropertyResult("availabilityZone", "AvailabilityZone", (properties.AvailabilityZone != null ? cfn_parse.FromCloudFormation.getString(properties.AvailabilityZone) : undefined));
  ret.addPropertyResult("availabilityZoneId", "AvailabilityZoneId", (properties.AvailabilityZoneId != null ? cfn_parse.FromCloudFormation.getString(properties.AvailabilityZoneId) : undefined));
  ret.addPropertyResult("cidrBlock", "CidrBlock", (properties.CidrBlock != null ? cfn_parse.FromCloudFormation.getString(properties.CidrBlock) : undefined));
  ret.addPropertyResult("enableDns64", "EnableDns64", (properties.EnableDns64 != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EnableDns64) : undefined));
  ret.addPropertyResult("ipv6CidrBlock", "Ipv6CidrBlock", (properties.Ipv6CidrBlock != null ? cfn_parse.FromCloudFormation.getString(properties.Ipv6CidrBlock) : undefined));
  ret.addPropertyResult("ipv6Native", "Ipv6Native", (properties.Ipv6Native != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Ipv6Native) : undefined));
  ret.addPropertyResult("mapPublicIpOnLaunch", "MapPublicIpOnLaunch", (properties.MapPublicIpOnLaunch != null ? cfn_parse.FromCloudFormation.getBoolean(properties.MapPublicIpOnLaunch) : undefined));
  ret.addPropertyResult("outpostArn", "OutpostArn", (properties.OutpostArn != null ? cfn_parse.FromCloudFormation.getString(properties.OutpostArn) : undefined));
  ret.addPropertyResult("privateDnsNameOptionsOnLaunch", "PrivateDnsNameOptionsOnLaunch", (properties.PrivateDnsNameOptionsOnLaunch != null ? cfn_parse.FromCloudFormation.getAny(properties.PrivateDnsNameOptionsOnLaunch) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("vpcId", "VpcId", (properties.VpcId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Associates a CIDR block with your subnet.
 *
 * You can associate a single IPv6 CIDR block with your subnet. An IPv6 CIDR block must have a prefix length of /64.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetcidrblock.html
 */
export class CfnSubnetCidrBlock extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::SubnetCidrBlock";

  /**
   * Build a CfnSubnetCidrBlock from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnSubnetCidrBlock {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnSubnetCidrBlockPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnSubnetCidrBlock(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the association.
   *
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The IPv6 network range for the subnet, in CIDR notation. The subnet size must use a /64 prefix length.
   */
  public ipv6CidrBlock: string;

  /**
   * The ID of the subnet.
   */
  public subnetId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnSubnetCidrBlockProps) {
    super(scope, id, {
      "type": CfnSubnetCidrBlock.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "ipv6CidrBlock", this);
    cdk.requireProperty(props, "subnetId", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.ipv6CidrBlock = props.ipv6CidrBlock;
    this.subnetId = props.subnetId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "ipv6CidrBlock": this.ipv6CidrBlock,
      "subnetId": this.subnetId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnSubnetCidrBlock.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnSubnetCidrBlockPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnSubnetCidrBlock\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetcidrblock.html
 */
export interface CfnSubnetCidrBlockProps {
  /**
   * The IPv6 network range for the subnet, in CIDR notation. The subnet size must use a /64 prefix length.
   *
   * This parameter is required for an IPv6 only subnet.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetcidrblock.html#cfn-ec2-subnetcidrblock-ipv6cidrblock
   */
  readonly ipv6CidrBlock: string;

  /**
   * The ID of the subnet.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetcidrblock.html#cfn-ec2-subnetcidrblock-subnetid
   */
  readonly subnetId: string;
}

/**
 * Determine whether the given properties match those of a \`CfnSubnetCidrBlockProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnSubnetCidrBlockProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSubnetCidrBlockPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("ipv6CidrBlock", cdk.requiredValidator)(properties.ipv6CidrBlock));
  errors.collect(cdk.propertyValidator("ipv6CidrBlock", cdk.validateString)(properties.ipv6CidrBlock));
  errors.collect(cdk.propertyValidator("subnetId", cdk.requiredValidator)(properties.subnetId));
  errors.collect(cdk.propertyValidator("subnetId", cdk.validateString)(properties.subnetId));
  return errors.wrap("supplied properties not correct for \\"CfnSubnetCidrBlockProps\\"");
}

// @ts-ignore TS6133
function convertCfnSubnetCidrBlockPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSubnetCidrBlockPropsValidator(properties).assertSuccess();
  return {
    "Ipv6CidrBlock": cdk.stringToCloudFormation(properties.ipv6CidrBlock),
    "SubnetId": cdk.stringToCloudFormation(properties.subnetId)
  };
}

// @ts-ignore TS6133
function CfnSubnetCidrBlockPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSubnetCidrBlockProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSubnetCidrBlockProps>();
  ret.addPropertyResult("ipv6CidrBlock", "Ipv6CidrBlock", (properties.Ipv6CidrBlock != null ? cfn_parse.FromCloudFormation.getString(properties.Ipv6CidrBlock) : undefined));
  ret.addPropertyResult("subnetId", "SubnetId", (properties.SubnetId != null ? cfn_parse.FromCloudFormation.getString(properties.SubnetId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Associates a subnet with a network ACL. For more information, see [ReplaceNetworkAclAssociation](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/ApiReference-query-ReplaceNetworkAclAssociation.html) in the *Amazon EC2 API Reference* .
 *
 * When \`AWS::EC2::SubnetNetworkAclAssociation\` resources are created during create or update operations, AWS CloudFormation adopts existing resources that share the same key properties (the properties that contribute to uniquely identify the resource). However, if the operation fails and rolls back, AWS CloudFormation deletes the previously out-of-band resources. You can protect against this behavior by using \`Retain\` deletion policies. For more information, see [DeletionPolicy Attribute](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html) .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetnetworkaclassociation.html
 */
export class CfnSubnetNetworkAclAssociation extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::SubnetNetworkAclAssociation";

  /**
   * Build a CfnSubnetNetworkAclAssociation from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnSubnetNetworkAclAssociation {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnSubnetNetworkAclAssociationPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnSubnetNetworkAclAssociation(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * Returns the value of this object's AssociationId property.
   *
   * @cloudformationAttribute AssociationId
   */
  public readonly attrAssociationId: string;

  /**
   * The ID of the network ACL.
   */
  public networkAclId: string;

  /**
   * The ID of the subnet.
   */
  public subnetId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnSubnetNetworkAclAssociationProps) {
    super(scope, id, {
      "type": CfnSubnetNetworkAclAssociation.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "networkAclId", this);
    cdk.requireProperty(props, "subnetId", this);

    this.attrAssociationId = cdk.Token.asString(this.getAtt("AssociationId", cdk.ResolutionTypeHint.STRING));
    this.networkAclId = props.networkAclId;
    this.subnetId = props.subnetId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "networkAclId": this.networkAclId,
      "subnetId": this.subnetId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnSubnetNetworkAclAssociation.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnSubnetNetworkAclAssociationPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnSubnetNetworkAclAssociation\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetnetworkaclassociation.html
 */
export interface CfnSubnetNetworkAclAssociationProps {
  /**
   * The ID of the network ACL.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetnetworkaclassociation.html#cfn-ec2-subnetnetworkaclassociation-networkaclid
   */
  readonly networkAclId: string;

  /**
   * The ID of the subnet.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetnetworkaclassociation.html#cfn-ec2-subnetnetworkaclassociation-subnetid
   */
  readonly subnetId: string;
}

/**
 * Determine whether the given properties match those of a \`CfnSubnetNetworkAclAssociationProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnSubnetNetworkAclAssociationProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSubnetNetworkAclAssociationPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("networkAclId", cdk.requiredValidator)(properties.networkAclId));
  errors.collect(cdk.propertyValidator("networkAclId", cdk.validateString)(properties.networkAclId));
  errors.collect(cdk.propertyValidator("subnetId", cdk.requiredValidator)(properties.subnetId));
  errors.collect(cdk.propertyValidator("subnetId", cdk.validateString)(properties.subnetId));
  return errors.wrap("supplied properties not correct for \\"CfnSubnetNetworkAclAssociationProps\\"");
}

// @ts-ignore TS6133
function convertCfnSubnetNetworkAclAssociationPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSubnetNetworkAclAssociationPropsValidator(properties).assertSuccess();
  return {
    "NetworkAclId": cdk.stringToCloudFormation(properties.networkAclId),
    "SubnetId": cdk.stringToCloudFormation(properties.subnetId)
  };
}

// @ts-ignore TS6133
function CfnSubnetNetworkAclAssociationPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSubnetNetworkAclAssociationProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSubnetNetworkAclAssociationProps>();
  ret.addPropertyResult("networkAclId", "NetworkAclId", (properties.NetworkAclId != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkAclId) : undefined));
  ret.addPropertyResult("subnetId", "SubnetId", (properties.SubnetId != null ? cfn_parse.FromCloudFormation.getString(properties.SubnetId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Associates a subnet with a route table.
 *
 * The subnet and route table must be in the same VPC. This association causes traffic originating from the subnet to be routed according to the routes in the route table. A route table can be associated with multiple subnets. To create a route table, see [AWS::EC2::RouteTable](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-routetable.html) .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetroutetableassociation.html
 */
export class CfnSubnetRouteTableAssociation extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::SubnetRouteTableAssociation";

  /**
   * Build a CfnSubnetRouteTableAssociation from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnSubnetRouteTableAssociation {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnSubnetRouteTableAssociationPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnSubnetRouteTableAssociation(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the subnet route table association.
   *
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The ID of the route table.
   */
  public routeTableId: string;

  /**
   * The ID of the subnet.
   */
  public subnetId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnSubnetRouteTableAssociationProps) {
    super(scope, id, {
      "type": CfnSubnetRouteTableAssociation.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "routeTableId", this);
    cdk.requireProperty(props, "subnetId", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.routeTableId = props.routeTableId;
    this.subnetId = props.subnetId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "routeTableId": this.routeTableId,
      "subnetId": this.subnetId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnSubnetRouteTableAssociation.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnSubnetRouteTableAssociationPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnSubnetRouteTableAssociation\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetroutetableassociation.html
 */
export interface CfnSubnetRouteTableAssociationProps {
  /**
   * The ID of the route table.
   *
   * The physical ID changes when the route table ID is changed.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetroutetableassociation.html#cfn-ec2-subnetroutetableassociation-routetableid
   */
  readonly routeTableId: string;

  /**
   * The ID of the subnet.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetroutetableassociation.html#cfn-ec2-subnetroutetableassociation-subnetid
   */
  readonly subnetId: string;
}

/**
 * Determine whether the given properties match those of a \`CfnSubnetRouteTableAssociationProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnSubnetRouteTableAssociationProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSubnetRouteTableAssociationPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("routeTableId", cdk.requiredValidator)(properties.routeTableId));
  errors.collect(cdk.propertyValidator("routeTableId", cdk.validateString)(properties.routeTableId));
  errors.collect(cdk.propertyValidator("subnetId", cdk.requiredValidator)(properties.subnetId));
  errors.collect(cdk.propertyValidator("subnetId", cdk.validateString)(properties.subnetId));
  return errors.wrap("supplied properties not correct for \\"CfnSubnetRouteTableAssociationProps\\"");
}

// @ts-ignore TS6133
function convertCfnSubnetRouteTableAssociationPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSubnetRouteTableAssociationPropsValidator(properties).assertSuccess();
  return {
    "RouteTableId": cdk.stringToCloudFormation(properties.routeTableId),
    "SubnetId": cdk.stringToCloudFormation(properties.subnetId)
  };
}

// @ts-ignore TS6133
function CfnSubnetRouteTableAssociationPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSubnetRouteTableAssociationProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSubnetRouteTableAssociationProps>();
  ret.addPropertyResult("routeTableId", "RouteTableId", (properties.RouteTableId != null ? cfn_parse.FromCloudFormation.getString(properties.RouteTableId) : undefined));
  ret.addPropertyResult("subnetId", "SubnetId", (properties.SubnetId != null ? cfn_parse.FromCloudFormation.getString(properties.SubnetId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a Traffic Mirror filter.
 *
 * A Traffic Mirror filter is a set of rules that defines the traffic to mirror.
 *
 * By default, no traffic is mirrored. To mirror traffic, use [AWS::EC2::TrafficMirrorFilterRule](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html) to add Traffic Mirror rules to the filter. The rules you add define what traffic gets mirrored.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilter.html
 */
export class CfnTrafficMirrorFilter extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::TrafficMirrorFilter";

  /**
   * Build a CfnTrafficMirrorFilter from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnTrafficMirrorFilter {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnTrafficMirrorFilterPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnTrafficMirrorFilter(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The description of the Traffic Mirror filter.
   */
  public description?: string;

  /**
   * The network service traffic that is associated with the Traffic Mirror filter.
   */
  public networkServices?: Array<string>;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags to assign to a Traffic Mirror filter.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnTrafficMirrorFilterProps = {}) {
    super(scope, id, {
      "type": CfnTrafficMirrorFilter.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.description = props.description;
    this.networkServices = props.networkServices;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::TrafficMirrorFilter", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "description": this.description,
      "networkServices": this.networkServices,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnTrafficMirrorFilter.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnTrafficMirrorFilterPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnTrafficMirrorFilter\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilter.html
 */
export interface CfnTrafficMirrorFilterProps {
  /**
   * The description of the Traffic Mirror filter.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilter.html#cfn-ec2-trafficmirrorfilter-description
   */
  readonly description?: string;

  /**
   * The network service traffic that is associated with the Traffic Mirror filter.
   *
   * Valid values are \`amazon-dns\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilter.html#cfn-ec2-trafficmirrorfilter-networkservices
   */
  readonly networkServices?: Array<string>;

  /**
   * The tags to assign to a Traffic Mirror filter.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilter.html#cfn-ec2-trafficmirrorfilter-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a \`CfnTrafficMirrorFilterProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnTrafficMirrorFilterProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTrafficMirrorFilterPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("networkServices", cdk.listValidator(cdk.validateString))(properties.networkServices));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnTrafficMirrorFilterProps\\"");
}

// @ts-ignore TS6133
function convertCfnTrafficMirrorFilterPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTrafficMirrorFilterPropsValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "NetworkServices": cdk.listMapper(cdk.stringToCloudFormation)(properties.networkServices),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnTrafficMirrorFilterPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnTrafficMirrorFilterProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTrafficMirrorFilterProps>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("networkServices", "NetworkServices", (properties.NetworkServices != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.NetworkServices) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Creates a Traffic Mirror filter rule.
 *
 * A Traffic Mirror rule defines the Traffic Mirror source traffic to mirror.
 *
 * You need the Traffic Mirror filter ID when you create the rule.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html
 */
export class CfnTrafficMirrorFilterRule extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::TrafficMirrorFilterRule";

  /**
   * Build a CfnTrafficMirrorFilterRule from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnTrafficMirrorFilterRule {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnTrafficMirrorFilterRulePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnTrafficMirrorFilterRule(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The description of the Traffic Mirror rule.
   */
  public description?: string;

  /**
   * The destination CIDR block to assign to the Traffic Mirror rule.
   */
  public destinationCidrBlock: string;

  /**
   * The destination port range.
   */
  public destinationPortRange?: cdk.IResolvable | CfnTrafficMirrorFilterRule.TrafficMirrorPortRangeProperty;

  /**
   * The protocol, for example UDP, to assign to the Traffic Mirror rule.
   */
  public protocol?: number;

  /**
   * The action to take on the filtered traffic.
   */
  public ruleAction: string;

  /**
   * The number of the Traffic Mirror rule.
   */
  public ruleNumber: number;

  /**
   * The source CIDR block to assign to the Traffic Mirror rule.
   */
  public sourceCidrBlock: string;

  /**
   * The source port range.
   */
  public sourcePortRange?: cdk.IResolvable | CfnTrafficMirrorFilterRule.TrafficMirrorPortRangeProperty;

  /**
   * The type of traffic.
   */
  public trafficDirection: string;

  /**
   * The ID of the filter that this rule is associated with.
   */
  public trafficMirrorFilterId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnTrafficMirrorFilterRuleProps) {
    super(scope, id, {
      "type": CfnTrafficMirrorFilterRule.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "destinationCidrBlock", this);
    cdk.requireProperty(props, "ruleAction", this);
    cdk.requireProperty(props, "ruleNumber", this);
    cdk.requireProperty(props, "sourceCidrBlock", this);
    cdk.requireProperty(props, "trafficDirection", this);
    cdk.requireProperty(props, "trafficMirrorFilterId", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.description = props.description;
    this.destinationCidrBlock = props.destinationCidrBlock;
    this.destinationPortRange = props.destinationPortRange;
    this.protocol = props.protocol;
    this.ruleAction = props.ruleAction;
    this.ruleNumber = props.ruleNumber;
    this.sourceCidrBlock = props.sourceCidrBlock;
    this.sourcePortRange = props.sourcePortRange;
    this.trafficDirection = props.trafficDirection;
    this.trafficMirrorFilterId = props.trafficMirrorFilterId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "description": this.description,
      "destinationCidrBlock": this.destinationCidrBlock,
      "destinationPortRange": this.destinationPortRange,
      "protocol": this.protocol,
      "ruleAction": this.ruleAction,
      "ruleNumber": this.ruleNumber,
      "sourceCidrBlock": this.sourceCidrBlock,
      "sourcePortRange": this.sourcePortRange,
      "trafficDirection": this.trafficDirection,
      "trafficMirrorFilterId": this.trafficMirrorFilterId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnTrafficMirrorFilterRule.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnTrafficMirrorFilterRulePropsToCloudFormation(props);
  }
}

export namespace CfnTrafficMirrorFilterRule {
  /**
   * Describes the Traffic Mirror port range.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-trafficmirrorfilterrule-trafficmirrorportrange.html
   */
  export interface TrafficMirrorPortRangeProperty {
    /**
     * The start of the Traffic Mirror port range.
     *
     * This applies to the TCP and UDP protocols.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-trafficmirrorfilterrule-trafficmirrorportrange.html#cfn-ec2-trafficmirrorfilterrule-trafficmirrorportrange-fromport
     */
    readonly fromPort: number;

    /**
     * The end of the Traffic Mirror port range.
     *
     * This applies to the TCP and UDP protocols.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-trafficmirrorfilterrule-trafficmirrorportrange.html#cfn-ec2-trafficmirrorfilterrule-trafficmirrorportrange-toport
     */
    readonly toPort: number;
  }
}

/**
 * Properties for defining a \`CfnTrafficMirrorFilterRule\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html
 */
export interface CfnTrafficMirrorFilterRuleProps {
  /**
   * The description of the Traffic Mirror rule.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-description
   */
  readonly description?: string;

  /**
   * The destination CIDR block to assign to the Traffic Mirror rule.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-destinationcidrblock
   */
  readonly destinationCidrBlock: string;

  /**
   * The destination port range.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-destinationportrange
   */
  readonly destinationPortRange?: cdk.IResolvable | CfnTrafficMirrorFilterRule.TrafficMirrorPortRangeProperty;

  /**
   * The protocol, for example UDP, to assign to the Traffic Mirror rule.
   *
   * For information about the protocol value, see [Protocol Numbers](https://docs.aws.amazon.com/https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml) on the Internet Assigned Numbers Authority (IANA) website.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-protocol
   */
  readonly protocol?: number;

  /**
   * The action to take on the filtered traffic.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-ruleaction
   */
  readonly ruleAction: string;

  /**
   * The number of the Traffic Mirror rule.
   *
   * This number must be unique for each Traffic Mirror rule in a given direction. The rules are processed in ascending order by rule number.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-rulenumber
   */
  readonly ruleNumber: number;

  /**
   * The source CIDR block to assign to the Traffic Mirror rule.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-sourcecidrblock
   */
  readonly sourceCidrBlock: string;

  /**
   * The source port range.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-sourceportrange
   */
  readonly sourcePortRange?: cdk.IResolvable | CfnTrafficMirrorFilterRule.TrafficMirrorPortRangeProperty;

  /**
   * The type of traffic.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-trafficdirection
   */
  readonly trafficDirection: string;

  /**
   * The ID of the filter that this rule is associated with.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-trafficmirrorfilterid
   */
  readonly trafficMirrorFilterId: string;
}

/**
 * Determine whether the given properties match those of a \`TrafficMirrorPortRangeProperty\`
 *
 * @param properties - the TypeScript properties of a \`TrafficMirrorPortRangeProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTrafficMirrorFilterRuleTrafficMirrorPortRangePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("fromPort", cdk.requiredValidator)(properties.fromPort));
  errors.collect(cdk.propertyValidator("fromPort", cdk.validateNumber)(properties.fromPort));
  errors.collect(cdk.propertyValidator("toPort", cdk.requiredValidator)(properties.toPort));
  errors.collect(cdk.propertyValidator("toPort", cdk.validateNumber)(properties.toPort));
  return errors.wrap("supplied properties not correct for \\"TrafficMirrorPortRangeProperty\\"");
}

// @ts-ignore TS6133
function convertCfnTrafficMirrorFilterRuleTrafficMirrorPortRangePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTrafficMirrorFilterRuleTrafficMirrorPortRangePropertyValidator(properties).assertSuccess();
  return {
    "FromPort": cdk.numberToCloudFormation(properties.fromPort),
    "ToPort": cdk.numberToCloudFormation(properties.toPort)
  };
}

// @ts-ignore TS6133
function CfnTrafficMirrorFilterRuleTrafficMirrorPortRangePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnTrafficMirrorFilterRule.TrafficMirrorPortRangeProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTrafficMirrorFilterRule.TrafficMirrorPortRangeProperty>();
  ret.addPropertyResult("fromPort", "FromPort", (properties.FromPort != null ? cfn_parse.FromCloudFormation.getNumber(properties.FromPort) : undefined));
  ret.addPropertyResult("toPort", "ToPort", (properties.ToPort != null ? cfn_parse.FromCloudFormation.getNumber(properties.ToPort) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnTrafficMirrorFilterRuleProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnTrafficMirrorFilterRuleProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTrafficMirrorFilterRulePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("destinationCidrBlock", cdk.requiredValidator)(properties.destinationCidrBlock));
  errors.collect(cdk.propertyValidator("destinationCidrBlock", cdk.validateString)(properties.destinationCidrBlock));
  errors.collect(cdk.propertyValidator("destinationPortRange", CfnTrafficMirrorFilterRuleTrafficMirrorPortRangePropertyValidator)(properties.destinationPortRange));
  errors.collect(cdk.propertyValidator("protocol", cdk.validateNumber)(properties.protocol));
  errors.collect(cdk.propertyValidator("ruleAction", cdk.requiredValidator)(properties.ruleAction));
  errors.collect(cdk.propertyValidator("ruleAction", cdk.validateString)(properties.ruleAction));
  errors.collect(cdk.propertyValidator("ruleNumber", cdk.requiredValidator)(properties.ruleNumber));
  errors.collect(cdk.propertyValidator("ruleNumber", cdk.validateNumber)(properties.ruleNumber));
  errors.collect(cdk.propertyValidator("sourceCidrBlock", cdk.requiredValidator)(properties.sourceCidrBlock));
  errors.collect(cdk.propertyValidator("sourceCidrBlock", cdk.validateString)(properties.sourceCidrBlock));
  errors.collect(cdk.propertyValidator("sourcePortRange", CfnTrafficMirrorFilterRuleTrafficMirrorPortRangePropertyValidator)(properties.sourcePortRange));
  errors.collect(cdk.propertyValidator("trafficDirection", cdk.requiredValidator)(properties.trafficDirection));
  errors.collect(cdk.propertyValidator("trafficDirection", cdk.validateString)(properties.trafficDirection));
  errors.collect(cdk.propertyValidator("trafficMirrorFilterId", cdk.requiredValidator)(properties.trafficMirrorFilterId));
  errors.collect(cdk.propertyValidator("trafficMirrorFilterId", cdk.validateString)(properties.trafficMirrorFilterId));
  return errors.wrap("supplied properties not correct for \\"CfnTrafficMirrorFilterRuleProps\\"");
}

// @ts-ignore TS6133
function convertCfnTrafficMirrorFilterRulePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTrafficMirrorFilterRulePropsValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "DestinationCidrBlock": cdk.stringToCloudFormation(properties.destinationCidrBlock),
    "DestinationPortRange": convertCfnTrafficMirrorFilterRuleTrafficMirrorPortRangePropertyToCloudFormation(properties.destinationPortRange),
    "Protocol": cdk.numberToCloudFormation(properties.protocol),
    "RuleAction": cdk.stringToCloudFormation(properties.ruleAction),
    "RuleNumber": cdk.numberToCloudFormation(properties.ruleNumber),
    "SourceCidrBlock": cdk.stringToCloudFormation(properties.sourceCidrBlock),
    "SourcePortRange": convertCfnTrafficMirrorFilterRuleTrafficMirrorPortRangePropertyToCloudFormation(properties.sourcePortRange),
    "TrafficDirection": cdk.stringToCloudFormation(properties.trafficDirection),
    "TrafficMirrorFilterId": cdk.stringToCloudFormation(properties.trafficMirrorFilterId)
  };
}

// @ts-ignore TS6133
function CfnTrafficMirrorFilterRulePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnTrafficMirrorFilterRuleProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTrafficMirrorFilterRuleProps>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("destinationCidrBlock", "DestinationCidrBlock", (properties.DestinationCidrBlock != null ? cfn_parse.FromCloudFormation.getString(properties.DestinationCidrBlock) : undefined));
  ret.addPropertyResult("destinationPortRange", "DestinationPortRange", (properties.DestinationPortRange != null ? CfnTrafficMirrorFilterRuleTrafficMirrorPortRangePropertyFromCloudFormation(properties.DestinationPortRange) : undefined));
  ret.addPropertyResult("protocol", "Protocol", (properties.Protocol != null ? cfn_parse.FromCloudFormation.getNumber(properties.Protocol) : undefined));
  ret.addPropertyResult("ruleAction", "RuleAction", (properties.RuleAction != null ? cfn_parse.FromCloudFormation.getString(properties.RuleAction) : undefined));
  ret.addPropertyResult("ruleNumber", "RuleNumber", (properties.RuleNumber != null ? cfn_parse.FromCloudFormation.getNumber(properties.RuleNumber) : undefined));
  ret.addPropertyResult("sourceCidrBlock", "SourceCidrBlock", (properties.SourceCidrBlock != null ? cfn_parse.FromCloudFormation.getString(properties.SourceCidrBlock) : undefined));
  ret.addPropertyResult("sourcePortRange", "SourcePortRange", (properties.SourcePortRange != null ? CfnTrafficMirrorFilterRuleTrafficMirrorPortRangePropertyFromCloudFormation(properties.SourcePortRange) : undefined));
  ret.addPropertyResult("trafficDirection", "TrafficDirection", (properties.TrafficDirection != null ? cfn_parse.FromCloudFormation.getString(properties.TrafficDirection) : undefined));
  ret.addPropertyResult("trafficMirrorFilterId", "TrafficMirrorFilterId", (properties.TrafficMirrorFilterId != null ? cfn_parse.FromCloudFormation.getString(properties.TrafficMirrorFilterId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Creates a Traffic Mirror session.
 *
 * A Traffic Mirror session actively copies packets from a Traffic Mirror source to a Traffic Mirror target. Create a filter, and then assign it to the session to define a subset of the traffic to mirror, for example all TCP traffic.
 *
 * The Traffic Mirror source and the Traffic Mirror target (monitoring appliances) can be in the same VPC, or in a different VPC connected via VPC peering or a transit gateway.
 *
 * By default, no traffic is mirrored. Use [AWS::EC2::TrafficMirrorFilterRule](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html) to specify filter rules that specify the traffic to mirror.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html
 */
export class CfnTrafficMirrorSession extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::TrafficMirrorSession";

  /**
   * Build a CfnTrafficMirrorSession from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnTrafficMirrorSession {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnTrafficMirrorSessionPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnTrafficMirrorSession(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The description of the Traffic Mirror session.
   */
  public description?: string;

  /**
   * The ID of the source network interface.
   */
  public networkInterfaceId: string;

  /**
   * The number of bytes in each packet to mirror.
   */
  public packetLength?: number;

  /**
   * The session number determines the order in which sessions are evaluated when an interface is used by multiple sessions.
   */
  public sessionNumber: number;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags to assign to a Traffic Mirror session.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The ID of the Traffic Mirror filter.
   */
  public trafficMirrorFilterId: string;

  /**
   * The ID of the Traffic Mirror target.
   */
  public trafficMirrorTargetId: string;

  /**
   * The VXLAN ID for the Traffic Mirror session.
   */
  public virtualNetworkId?: number;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnTrafficMirrorSessionProps) {
    super(scope, id, {
      "type": CfnTrafficMirrorSession.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "networkInterfaceId", this);
    cdk.requireProperty(props, "sessionNumber", this);
    cdk.requireProperty(props, "trafficMirrorFilterId", this);
    cdk.requireProperty(props, "trafficMirrorTargetId", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.description = props.description;
    this.networkInterfaceId = props.networkInterfaceId;
    this.packetLength = props.packetLength;
    this.sessionNumber = props.sessionNumber;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::TrafficMirrorSession", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.trafficMirrorFilterId = props.trafficMirrorFilterId;
    this.trafficMirrorTargetId = props.trafficMirrorTargetId;
    this.virtualNetworkId = props.virtualNetworkId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "description": this.description,
      "networkInterfaceId": this.networkInterfaceId,
      "packetLength": this.packetLength,
      "sessionNumber": this.sessionNumber,
      "tags": this.tags.renderTags(),
      "trafficMirrorFilterId": this.trafficMirrorFilterId,
      "trafficMirrorTargetId": this.trafficMirrorTargetId,
      "virtualNetworkId": this.virtualNetworkId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnTrafficMirrorSession.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnTrafficMirrorSessionPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnTrafficMirrorSession\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html
 */
export interface CfnTrafficMirrorSessionProps {
  /**
   * The description of the Traffic Mirror session.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html#cfn-ec2-trafficmirrorsession-description
   */
  readonly description?: string;

  /**
   * The ID of the source network interface.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html#cfn-ec2-trafficmirrorsession-networkinterfaceid
   */
  readonly networkInterfaceId: string;

  /**
   * The number of bytes in each packet to mirror.
   *
   * These are bytes after the VXLAN header. Do not specify this parameter when you want to mirror the entire packet. To mirror a subset of the packet, set this to the length (in bytes) that you want to mirror. For example, if you set this value to 100, then the first 100 bytes that meet the filter criteria are copied to the target.
   *
   * If you do not want to mirror the entire packet, use the \`PacketLength\` parameter to specify the number of bytes in each packet to mirror.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html#cfn-ec2-trafficmirrorsession-packetlength
   */
  readonly packetLength?: number;

  /**
   * The session number determines the order in which sessions are evaluated when an interface is used by multiple sessions.
   *
   * The first session with a matching filter is the one that mirrors the packets.
   *
   * Valid values are 1-32766.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html#cfn-ec2-trafficmirrorsession-sessionnumber
   */
  readonly sessionNumber: number;

  /**
   * The tags to assign to a Traffic Mirror session.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html#cfn-ec2-trafficmirrorsession-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The ID of the Traffic Mirror filter.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html#cfn-ec2-trafficmirrorsession-trafficmirrorfilterid
   */
  readonly trafficMirrorFilterId: string;

  /**
   * The ID of the Traffic Mirror target.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html#cfn-ec2-trafficmirrorsession-trafficmirrortargetid
   */
  readonly trafficMirrorTargetId: string;

  /**
   * The VXLAN ID for the Traffic Mirror session.
   *
   * For more information about the VXLAN protocol, see [RFC 7348](https://docs.aws.amazon.com/https://tools.ietf.org/html/rfc7348) . If you do not specify a \`VirtualNetworkId\` , an account-wide unique id is chosen at random.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html#cfn-ec2-trafficmirrorsession-virtualnetworkid
   */
  readonly virtualNetworkId?: number;
}

/**
 * Determine whether the given properties match those of a \`CfnTrafficMirrorSessionProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnTrafficMirrorSessionProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTrafficMirrorSessionPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("networkInterfaceId", cdk.requiredValidator)(properties.networkInterfaceId));
  errors.collect(cdk.propertyValidator("networkInterfaceId", cdk.validateString)(properties.networkInterfaceId));
  errors.collect(cdk.propertyValidator("packetLength", cdk.validateNumber)(properties.packetLength));
  errors.collect(cdk.propertyValidator("sessionNumber", cdk.requiredValidator)(properties.sessionNumber));
  errors.collect(cdk.propertyValidator("sessionNumber", cdk.validateNumber)(properties.sessionNumber));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("trafficMirrorFilterId", cdk.requiredValidator)(properties.trafficMirrorFilterId));
  errors.collect(cdk.propertyValidator("trafficMirrorFilterId", cdk.validateString)(properties.trafficMirrorFilterId));
  errors.collect(cdk.propertyValidator("trafficMirrorTargetId", cdk.requiredValidator)(properties.trafficMirrorTargetId));
  errors.collect(cdk.propertyValidator("trafficMirrorTargetId", cdk.validateString)(properties.trafficMirrorTargetId));
  errors.collect(cdk.propertyValidator("virtualNetworkId", cdk.validateNumber)(properties.virtualNetworkId));
  return errors.wrap("supplied properties not correct for \\"CfnTrafficMirrorSessionProps\\"");
}

// @ts-ignore TS6133
function convertCfnTrafficMirrorSessionPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTrafficMirrorSessionPropsValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "NetworkInterfaceId": cdk.stringToCloudFormation(properties.networkInterfaceId),
    "PacketLength": cdk.numberToCloudFormation(properties.packetLength),
    "SessionNumber": cdk.numberToCloudFormation(properties.sessionNumber),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "TrafficMirrorFilterId": cdk.stringToCloudFormation(properties.trafficMirrorFilterId),
    "TrafficMirrorTargetId": cdk.stringToCloudFormation(properties.trafficMirrorTargetId),
    "VirtualNetworkId": cdk.numberToCloudFormation(properties.virtualNetworkId)
  };
}

// @ts-ignore TS6133
function CfnTrafficMirrorSessionPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnTrafficMirrorSessionProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTrafficMirrorSessionProps>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("networkInterfaceId", "NetworkInterfaceId", (properties.NetworkInterfaceId != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkInterfaceId) : undefined));
  ret.addPropertyResult("packetLength", "PacketLength", (properties.PacketLength != null ? cfn_parse.FromCloudFormation.getNumber(properties.PacketLength) : undefined));
  ret.addPropertyResult("sessionNumber", "SessionNumber", (properties.SessionNumber != null ? cfn_parse.FromCloudFormation.getNumber(properties.SessionNumber) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("trafficMirrorFilterId", "TrafficMirrorFilterId", (properties.TrafficMirrorFilterId != null ? cfn_parse.FromCloudFormation.getString(properties.TrafficMirrorFilterId) : undefined));
  ret.addPropertyResult("trafficMirrorTargetId", "TrafficMirrorTargetId", (properties.TrafficMirrorTargetId != null ? cfn_parse.FromCloudFormation.getString(properties.TrafficMirrorTargetId) : undefined));
  ret.addPropertyResult("virtualNetworkId", "VirtualNetworkId", (properties.VirtualNetworkId != null ? cfn_parse.FromCloudFormation.getNumber(properties.VirtualNetworkId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a target for your Traffic Mirror session.
 *
 * A Traffic Mirror target is the destination for mirrored traffic. The Traffic Mirror source and the Traffic Mirror target (monitoring appliances) can be in the same VPC, or in different VPCs connected via VPC peering or a transit gateway.
 *
 * A Traffic Mirror target can be a network interface, a Network Load Balancer, or a Gateway Load Balancer endpoint.
 *
 * To use the target in a Traffic Mirror session, use [AWS::EC2::TrafficMirrorSession](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html) .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrortarget.html
 */
export class CfnTrafficMirrorTarget extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::TrafficMirrorTarget";

  /**
   * Build a CfnTrafficMirrorTarget from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnTrafficMirrorTarget {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnTrafficMirrorTargetPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnTrafficMirrorTarget(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The description of the Traffic Mirror target.
   */
  public description?: string;

  /**
   * The ID of the Gateway Load Balancer endpoint.
   */
  public gatewayLoadBalancerEndpointId?: string;

  /**
   * The network interface ID that is associated with the target.
   */
  public networkInterfaceId?: string;

  /**
   * The Amazon Resource Name (ARN) of the Network Load Balancer that is associated with the target.
   */
  public networkLoadBalancerArn?: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags to assign to the Traffic Mirror target.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnTrafficMirrorTargetProps = {}) {
    super(scope, id, {
      "type": CfnTrafficMirrorTarget.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.description = props.description;
    this.gatewayLoadBalancerEndpointId = props.gatewayLoadBalancerEndpointId;
    this.networkInterfaceId = props.networkInterfaceId;
    this.networkLoadBalancerArn = props.networkLoadBalancerArn;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::TrafficMirrorTarget", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "description": this.description,
      "gatewayLoadBalancerEndpointId": this.gatewayLoadBalancerEndpointId,
      "networkInterfaceId": this.networkInterfaceId,
      "networkLoadBalancerArn": this.networkLoadBalancerArn,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnTrafficMirrorTarget.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnTrafficMirrorTargetPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnTrafficMirrorTarget\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrortarget.html
 */
export interface CfnTrafficMirrorTargetProps {
  /**
   * The description of the Traffic Mirror target.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrortarget.html#cfn-ec2-trafficmirrortarget-description
   */
  readonly description?: string;

  /**
   * The ID of the Gateway Load Balancer endpoint.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrortarget.html#cfn-ec2-trafficmirrortarget-gatewayloadbalancerendpointid
   */
  readonly gatewayLoadBalancerEndpointId?: string;

  /**
   * The network interface ID that is associated with the target.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrortarget.html#cfn-ec2-trafficmirrortarget-networkinterfaceid
   */
  readonly networkInterfaceId?: string;

  /**
   * The Amazon Resource Name (ARN) of the Network Load Balancer that is associated with the target.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrortarget.html#cfn-ec2-trafficmirrortarget-networkloadbalancerarn
   */
  readonly networkLoadBalancerArn?: string;

  /**
   * The tags to assign to the Traffic Mirror target.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrortarget.html#cfn-ec2-trafficmirrortarget-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a \`CfnTrafficMirrorTargetProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnTrafficMirrorTargetProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTrafficMirrorTargetPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("gatewayLoadBalancerEndpointId", cdk.validateString)(properties.gatewayLoadBalancerEndpointId));
  errors.collect(cdk.propertyValidator("networkInterfaceId", cdk.validateString)(properties.networkInterfaceId));
  errors.collect(cdk.propertyValidator("networkLoadBalancerArn", cdk.validateString)(properties.networkLoadBalancerArn));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnTrafficMirrorTargetProps\\"");
}

// @ts-ignore TS6133
function convertCfnTrafficMirrorTargetPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTrafficMirrorTargetPropsValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "GatewayLoadBalancerEndpointId": cdk.stringToCloudFormation(properties.gatewayLoadBalancerEndpointId),
    "NetworkInterfaceId": cdk.stringToCloudFormation(properties.networkInterfaceId),
    "NetworkLoadBalancerArn": cdk.stringToCloudFormation(properties.networkLoadBalancerArn),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnTrafficMirrorTargetPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnTrafficMirrorTargetProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTrafficMirrorTargetProps>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("gatewayLoadBalancerEndpointId", "GatewayLoadBalancerEndpointId", (properties.GatewayLoadBalancerEndpointId != null ? cfn_parse.FromCloudFormation.getString(properties.GatewayLoadBalancerEndpointId) : undefined));
  ret.addPropertyResult("networkInterfaceId", "NetworkInterfaceId", (properties.NetworkInterfaceId != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkInterfaceId) : undefined));
  ret.addPropertyResult("networkLoadBalancerArn", "NetworkLoadBalancerArn", (properties.NetworkLoadBalancerArn != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkLoadBalancerArn) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a transit gateway.
 *
 * You can use a transit gateway to interconnect your virtual private clouds (VPC) and on-premises networks. After the transit gateway enters the \`available\` state, you can attach your VPCs and VPN connections to the transit gateway.
 *
 * To attach your VPCs, use [AWS::EC2::TransitGatewayAttachment](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayattachment.html) .
 *
 * To attach a VPN connection, use [AWS::EC2::CustomerGateway](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customer-gateway.html) to create a customer gateway and specify the ID of the customer gateway and the ID of the transit gateway in a call to [AWS::EC2::VPNConnection](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpn-connection.html) .
 *
 * When you create a transit gateway, we create a default transit gateway route table and use it as the default association route table and the default propagation route table. You can use [AWS::EC2::TransitGatewayRouteTable](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetable.html) to create additional transit gateway route tables. If you disable automatic route propagation, we do not create a default transit gateway route table. You can use [AWS::EC2::TransitGatewayRouteTablePropagation](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetablepropagation.html) to propagate routes from a resource attachment to a transit gateway route table. If you disable automatic associations, you can use [AWS::EC2::TransitGatewayRouteTableAssociation](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetableassociation.html) to associate a resource attachment with a transit gateway route table.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html
 */
export class CfnTransitGateway extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::TransitGateway";

  /**
   * Build a CfnTransitGateway from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnTransitGateway {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnTransitGatewayPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnTransitGateway(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the transit gateway.
   *
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * A private Autonomous System Number (ASN) for the Amazon side of a BGP session.
   */
  public amazonSideAsn?: number;

  /**
   * The ID of the default association route table.
   */
  public associationDefaultRouteTableId?: string;

  /**
   * Enable or disable automatic acceptance of attachment requests.
   */
  public autoAcceptSharedAttachments?: string;

  /**
   * Enable or disable automatic association with the default association route table.
   */
  public defaultRouteTableAssociation?: string;

  /**
   * Enable or disable automatic propagation of routes to the default propagation route table.
   */
  public defaultRouteTablePropagation?: string;

  /**
   * The description of the transit gateway.
   */
  public description?: string;

  /**
   * Enable or disable DNS support.
   */
  public dnsSupport?: string;

  /**
   * Indicates whether multicast is enabled on the transit gateway.
   */
  public multicastSupport?: string;

  /**
   * The ID of the default propagation route table.
   */
  public propagationDefaultRouteTableId?: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags for the transit gateway.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The transit gateway CIDR blocks.
   */
  public transitGatewayCidrBlocks?: Array<string>;

  /**
   * Enable or disable Equal Cost Multipath Protocol support.
   */
  public vpnEcmpSupport?: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnTransitGatewayProps = {}) {
    super(scope, id, {
      "type": CfnTransitGateway.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.amazonSideAsn = props.amazonSideAsn;
    this.associationDefaultRouteTableId = props.associationDefaultRouteTableId;
    this.autoAcceptSharedAttachments = props.autoAcceptSharedAttachments;
    this.defaultRouteTableAssociation = props.defaultRouteTableAssociation;
    this.defaultRouteTablePropagation = props.defaultRouteTablePropagation;
    this.description = props.description;
    this.dnsSupport = props.dnsSupport;
    this.multicastSupport = props.multicastSupport;
    this.propagationDefaultRouteTableId = props.propagationDefaultRouteTableId;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::TransitGateway", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.transitGatewayCidrBlocks = props.transitGatewayCidrBlocks;
    this.vpnEcmpSupport = props.vpnEcmpSupport;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "amazonSideAsn": this.amazonSideAsn,
      "associationDefaultRouteTableId": this.associationDefaultRouteTableId,
      "autoAcceptSharedAttachments": this.autoAcceptSharedAttachments,
      "defaultRouteTableAssociation": this.defaultRouteTableAssociation,
      "defaultRouteTablePropagation": this.defaultRouteTablePropagation,
      "description": this.description,
      "dnsSupport": this.dnsSupport,
      "multicastSupport": this.multicastSupport,
      "propagationDefaultRouteTableId": this.propagationDefaultRouteTableId,
      "tags": this.tags.renderTags(),
      "transitGatewayCidrBlocks": this.transitGatewayCidrBlocks,
      "vpnEcmpSupport": this.vpnEcmpSupport
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnTransitGateway.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnTransitGatewayPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnTransitGateway\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html
 */
export interface CfnTransitGatewayProps {
  /**
   * A private Autonomous System Number (ASN) for the Amazon side of a BGP session.
   *
   * The range is 64512 to 65534 for 16-bit ASNs. The default is 64512.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-amazonsideasn
   */
  readonly amazonSideAsn?: number;

  /**
   * The ID of the default association route table.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-associationdefaultroutetableid
   */
  readonly associationDefaultRouteTableId?: string;

  /**
   * Enable or disable automatic acceptance of attachment requests.
   *
   * Disabled by default.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-autoacceptsharedattachments
   */
  readonly autoAcceptSharedAttachments?: string;

  /**
   * Enable or disable automatic association with the default association route table.
   *
   * Enabled by default.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-defaultroutetableassociation
   */
  readonly defaultRouteTableAssociation?: string;

  /**
   * Enable or disable automatic propagation of routes to the default propagation route table.
   *
   * Enabled by default.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-defaultroutetablepropagation
   */
  readonly defaultRouteTablePropagation?: string;

  /**
   * The description of the transit gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-description
   */
  readonly description?: string;

  /**
   * Enable or disable DNS support.
   *
   * Enabled by default.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-dnssupport
   */
  readonly dnsSupport?: string;

  /**
   * Indicates whether multicast is enabled on the transit gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-multicastsupport
   */
  readonly multicastSupport?: string;

  /**
   * The ID of the default propagation route table.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-propagationdefaultroutetableid
   */
  readonly propagationDefaultRouteTableId?: string;

  /**
   * The tags for the transit gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The transit gateway CIDR blocks.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-transitgatewaycidrblocks
   */
  readonly transitGatewayCidrBlocks?: Array<string>;

  /**
   * Enable or disable Equal Cost Multipath Protocol support.
   *
   * Enabled by default.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-vpnecmpsupport
   */
  readonly vpnEcmpSupport?: string;
}

/**
 * Determine whether the given properties match those of a \`CfnTransitGatewayProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnTransitGatewayProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTransitGatewayPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("amazonSideAsn", cdk.validateNumber)(properties.amazonSideAsn));
  errors.collect(cdk.propertyValidator("associationDefaultRouteTableId", cdk.validateString)(properties.associationDefaultRouteTableId));
  errors.collect(cdk.propertyValidator("autoAcceptSharedAttachments", cdk.validateString)(properties.autoAcceptSharedAttachments));
  errors.collect(cdk.propertyValidator("defaultRouteTableAssociation", cdk.validateString)(properties.defaultRouteTableAssociation));
  errors.collect(cdk.propertyValidator("defaultRouteTablePropagation", cdk.validateString)(properties.defaultRouteTablePropagation));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("dnsSupport", cdk.validateString)(properties.dnsSupport));
  errors.collect(cdk.propertyValidator("multicastSupport", cdk.validateString)(properties.multicastSupport));
  errors.collect(cdk.propertyValidator("propagationDefaultRouteTableId", cdk.validateString)(properties.propagationDefaultRouteTableId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("transitGatewayCidrBlocks", cdk.listValidator(cdk.validateString))(properties.transitGatewayCidrBlocks));
  errors.collect(cdk.propertyValidator("vpnEcmpSupport", cdk.validateString)(properties.vpnEcmpSupport));
  return errors.wrap("supplied properties not correct for \\"CfnTransitGatewayProps\\"");
}

// @ts-ignore TS6133
function convertCfnTransitGatewayPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTransitGatewayPropsValidator(properties).assertSuccess();
  return {
    "AmazonSideAsn": cdk.numberToCloudFormation(properties.amazonSideAsn),
    "AssociationDefaultRouteTableId": cdk.stringToCloudFormation(properties.associationDefaultRouteTableId),
    "AutoAcceptSharedAttachments": cdk.stringToCloudFormation(properties.autoAcceptSharedAttachments),
    "DefaultRouteTableAssociation": cdk.stringToCloudFormation(properties.defaultRouteTableAssociation),
    "DefaultRouteTablePropagation": cdk.stringToCloudFormation(properties.defaultRouteTablePropagation),
    "Description": cdk.stringToCloudFormation(properties.description),
    "DnsSupport": cdk.stringToCloudFormation(properties.dnsSupport),
    "MulticastSupport": cdk.stringToCloudFormation(properties.multicastSupport),
    "PropagationDefaultRouteTableId": cdk.stringToCloudFormation(properties.propagationDefaultRouteTableId),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "TransitGatewayCidrBlocks": cdk.listMapper(cdk.stringToCloudFormation)(properties.transitGatewayCidrBlocks),
    "VpnEcmpSupport": cdk.stringToCloudFormation(properties.vpnEcmpSupport)
  };
}

// @ts-ignore TS6133
function CfnTransitGatewayPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnTransitGatewayProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTransitGatewayProps>();
  ret.addPropertyResult("amazonSideAsn", "AmazonSideAsn", (properties.AmazonSideAsn != null ? cfn_parse.FromCloudFormation.getNumber(properties.AmazonSideAsn) : undefined));
  ret.addPropertyResult("associationDefaultRouteTableId", "AssociationDefaultRouteTableId", (properties.AssociationDefaultRouteTableId != null ? cfn_parse.FromCloudFormation.getString(properties.AssociationDefaultRouteTableId) : undefined));
  ret.addPropertyResult("autoAcceptSharedAttachments", "AutoAcceptSharedAttachments", (properties.AutoAcceptSharedAttachments != null ? cfn_parse.FromCloudFormation.getString(properties.AutoAcceptSharedAttachments) : undefined));
  ret.addPropertyResult("defaultRouteTableAssociation", "DefaultRouteTableAssociation", (properties.DefaultRouteTableAssociation != null ? cfn_parse.FromCloudFormation.getString(properties.DefaultRouteTableAssociation) : undefined));
  ret.addPropertyResult("defaultRouteTablePropagation", "DefaultRouteTablePropagation", (properties.DefaultRouteTablePropagation != null ? cfn_parse.FromCloudFormation.getString(properties.DefaultRouteTablePropagation) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("dnsSupport", "DnsSupport", (properties.DnsSupport != null ? cfn_parse.FromCloudFormation.getString(properties.DnsSupport) : undefined));
  ret.addPropertyResult("multicastSupport", "MulticastSupport", (properties.MulticastSupport != null ? cfn_parse.FromCloudFormation.getString(properties.MulticastSupport) : undefined));
  ret.addPropertyResult("propagationDefaultRouteTableId", "PropagationDefaultRouteTableId", (properties.PropagationDefaultRouteTableId != null ? cfn_parse.FromCloudFormation.getString(properties.PropagationDefaultRouteTableId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("transitGatewayCidrBlocks", "TransitGatewayCidrBlocks", (properties.TransitGatewayCidrBlocks != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.TransitGatewayCidrBlocks) : undefined));
  ret.addPropertyResult("vpnEcmpSupport", "VpnEcmpSupport", (properties.VpnEcmpSupport != null ? cfn_parse.FromCloudFormation.getString(properties.VpnEcmpSupport) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Attaches a VPC to a transit gateway.
 *
 * If you attach a VPC with a CIDR range that overlaps the CIDR range of a VPC that is already attached, the new VPC CIDR range is not propagated to the default propagation route table.
 *
 * To send VPC traffic to an attached transit gateway, add a route to the VPC route table using [AWS::EC2::Route](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html) .
 *
 * To update tags for a VPC attachment after creation without replacing the attachment, use [AWS::EC2::TransitGatewayVpcAttachment](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html) instead.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayattachment.html
 */
export class CfnTransitGatewayAttachment extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::TransitGatewayAttachment";

  /**
   * Build a CfnTransitGatewayAttachment from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnTransitGatewayAttachment {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnTransitGatewayAttachmentPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnTransitGatewayAttachment(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the attachment.
   *
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The VPC attachment options, in JSON or YAML.
   */
  public options?: any | cdk.IResolvable;

  /**
   * The IDs of one or more subnets.
   */
  public subnetIds: Array<string>;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags for the attachment.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The ID of the transit gateway.
   */
  public transitGatewayId: string;

  /**
   * The ID of the VPC.
   */
  public vpcId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnTransitGatewayAttachmentProps) {
    super(scope, id, {
      "type": CfnTransitGatewayAttachment.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "subnetIds", this);
    cdk.requireProperty(props, "transitGatewayId", this);
    cdk.requireProperty(props, "vpcId", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.options = props.options;
    this.subnetIds = props.subnetIds;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::TransitGatewayAttachment", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.transitGatewayId = props.transitGatewayId;
    this.vpcId = props.vpcId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "options": this.options,
      "subnetIds": this.subnetIds,
      "tags": this.tags.renderTags(),
      "transitGatewayId": this.transitGatewayId,
      "vpcId": this.vpcId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnTransitGatewayAttachment.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnTransitGatewayAttachmentPropsToCloudFormation(props);
  }
}

export namespace CfnTransitGatewayAttachment {
  /**
   * Describes the VPC attachment options.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayattachment-options.html
   */
  export interface OptionsProperty {
    /**
     * Indicates whether appliance mode support is enabled.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayattachment-options.html#cfn-ec2-transitgatewayattachment-options-appliancemodesupport
     */
    readonly applianceModeSupport?: string;

    /**
     * Indicates whether DNS support is enabled.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayattachment-options.html#cfn-ec2-transitgatewayattachment-options-dnssupport
     */
    readonly dnsSupport?: string;

    /**
     * Indicates whether IPv6 support is disabled.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayattachment-options.html#cfn-ec2-transitgatewayattachment-options-ipv6support
     */
    readonly ipv6Support?: string;
  }
}

/**
 * Properties for defining a \`CfnTransitGatewayAttachment\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayattachment.html
 */
export interface CfnTransitGatewayAttachmentProps {
  /**
   * The VPC attachment options, in JSON or YAML.
   *
   * - \`ApplianceModeSupport\` - Set to \`enable\` or \`disable\` . The default is \`disable\` .
   * - \`DnsSupport\` - Set to \`enable\` or \`disable\` . The default is \`enable\` .
   * - \`Ipv6Support\` - Set to \`enable\` or \`disable\` . The default is \`disable\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayattachment.html#cfn-ec2-transitgatewayattachment-options
   */
  readonly options?: any | cdk.IResolvable;

  /**
   * The IDs of one or more subnets.
   *
   * You can specify only one subnet per Availability Zone. You must specify at least one subnet, but we recommend that you specify two subnets for better availability. The transit gateway uses one IP address from each specified subnet.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayattachment.html#cfn-ec2-transitgatewayattachment-subnetids
   */
  readonly subnetIds: Array<string>;

  /**
   * The tags for the attachment.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayattachment.html#cfn-ec2-transitgatewayattachment-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The ID of the transit gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayattachment.html#cfn-ec2-transitgatewayattachment-transitgatewayid
   */
  readonly transitGatewayId: string;

  /**
   * The ID of the VPC.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayattachment.html#cfn-ec2-transitgatewayattachment-vpcid
   */
  readonly vpcId: string;
}

/**
 * Determine whether the given properties match those of a \`OptionsProperty\`
 *
 * @param properties - the TypeScript properties of a \`OptionsProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTransitGatewayAttachmentOptionsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("applianceModeSupport", cdk.validateString)(properties.applianceModeSupport));
  errors.collect(cdk.propertyValidator("dnsSupport", cdk.validateString)(properties.dnsSupport));
  errors.collect(cdk.propertyValidator("ipv6Support", cdk.validateString)(properties.ipv6Support));
  return errors.wrap("supplied properties not correct for \\"OptionsProperty\\"");
}

// @ts-ignore TS6133
function convertCfnTransitGatewayAttachmentOptionsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTransitGatewayAttachmentOptionsPropertyValidator(properties).assertSuccess();
  return {
    "ApplianceModeSupport": cdk.stringToCloudFormation(properties.applianceModeSupport),
    "DnsSupport": cdk.stringToCloudFormation(properties.dnsSupport),
    "Ipv6Support": cdk.stringToCloudFormation(properties.ipv6Support)
  };
}

// @ts-ignore TS6133
function CfnTransitGatewayAttachmentOptionsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnTransitGatewayAttachment.OptionsProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTransitGatewayAttachment.OptionsProperty>();
  ret.addPropertyResult("applianceModeSupport", "ApplianceModeSupport", (properties.ApplianceModeSupport != null ? cfn_parse.FromCloudFormation.getString(properties.ApplianceModeSupport) : undefined));
  ret.addPropertyResult("dnsSupport", "DnsSupport", (properties.DnsSupport != null ? cfn_parse.FromCloudFormation.getString(properties.DnsSupport) : undefined));
  ret.addPropertyResult("ipv6Support", "Ipv6Support", (properties.Ipv6Support != null ? cfn_parse.FromCloudFormation.getString(properties.Ipv6Support) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnTransitGatewayAttachmentProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnTransitGatewayAttachmentProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTransitGatewayAttachmentPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("options", cdk.validateObject)(properties.options));
  errors.collect(cdk.propertyValidator("subnetIds", cdk.requiredValidator)(properties.subnetIds));
  errors.collect(cdk.propertyValidator("subnetIds", cdk.listValidator(cdk.validateString))(properties.subnetIds));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("transitGatewayId", cdk.requiredValidator)(properties.transitGatewayId));
  errors.collect(cdk.propertyValidator("transitGatewayId", cdk.validateString)(properties.transitGatewayId));
  errors.collect(cdk.propertyValidator("vpcId", cdk.requiredValidator)(properties.vpcId));
  errors.collect(cdk.propertyValidator("vpcId", cdk.validateString)(properties.vpcId));
  return errors.wrap("supplied properties not correct for \\"CfnTransitGatewayAttachmentProps\\"");
}

// @ts-ignore TS6133
function convertCfnTransitGatewayAttachmentPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTransitGatewayAttachmentPropsValidator(properties).assertSuccess();
  return {
    "Options": cdk.objectToCloudFormation(properties.options),
    "SubnetIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.subnetIds),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "TransitGatewayId": cdk.stringToCloudFormation(properties.transitGatewayId),
    "VpcId": cdk.stringToCloudFormation(properties.vpcId)
  };
}

// @ts-ignore TS6133
function CfnTransitGatewayAttachmentPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnTransitGatewayAttachmentProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTransitGatewayAttachmentProps>();
  ret.addPropertyResult("options", "Options", (properties.Options != null ? cfn_parse.FromCloudFormation.getAny(properties.Options) : undefined));
  ret.addPropertyResult("subnetIds", "SubnetIds", (properties.SubnetIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SubnetIds) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("transitGatewayId", "TransitGatewayId", (properties.TransitGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.TransitGatewayId) : undefined));
  ret.addPropertyResult("vpcId", "VpcId", (properties.VpcId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Creates a Connect attachment from a specified transit gateway attachment.
 *
 * A Connect attachment is a GRE-based tunnel attachment that you can use to establish a connection between a transit gateway and an appliance.
 *
 * A Connect attachment uses an existing VPC or AWS Direct Connect attachment as the underlying transport mechanism.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayconnect.html
 */
export class CfnTransitGatewayConnect extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::TransitGatewayConnect";

  /**
   * Build a CfnTransitGatewayConnect from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnTransitGatewayConnect {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnTransitGatewayConnectPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnTransitGatewayConnect(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The creation time.
   *
   * @cloudformationAttribute CreationTime
   */
  public readonly attrCreationTime: string;

  /**
   * The state of the attachment.
   *
   * @cloudformationAttribute State
   */
  public readonly attrState: string;

  /**
   * The ID of the transit gateway attachment.
   *
   * @cloudformationAttribute TransitGatewayAttachmentId
   */
  public readonly attrTransitGatewayAttachmentId: string;

  /**
   * The ID of the transit gateway.
   *
   * @cloudformationAttribute TransitGatewayId
   */
  public readonly attrTransitGatewayId: string;

  /**
   * The Connect attachment options.
   */
  public options: cdk.IResolvable | CfnTransitGatewayConnect.TransitGatewayConnectOptionsProperty;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags for the attachment.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The ID of the attachment from which the Connect attachment was created.
   */
  public transportTransitGatewayAttachmentId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnTransitGatewayConnectProps) {
    super(scope, id, {
      "type": CfnTransitGatewayConnect.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "options", this);
    cdk.requireProperty(props, "transportTransitGatewayAttachmentId", this);

    this.attrCreationTime = cdk.Token.asString(this.getAtt("CreationTime", cdk.ResolutionTypeHint.STRING));
    this.attrState = cdk.Token.asString(this.getAtt("State", cdk.ResolutionTypeHint.STRING));
    this.attrTransitGatewayAttachmentId = cdk.Token.asString(this.getAtt("TransitGatewayAttachmentId", cdk.ResolutionTypeHint.STRING));
    this.attrTransitGatewayId = cdk.Token.asString(this.getAtt("TransitGatewayId", cdk.ResolutionTypeHint.STRING));
    this.options = props.options;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::TransitGatewayConnect", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.transportTransitGatewayAttachmentId = props.transportTransitGatewayAttachmentId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "options": this.options,
      "tags": this.tags.renderTags(),
      "transportTransitGatewayAttachmentId": this.transportTransitGatewayAttachmentId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnTransitGatewayConnect.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnTransitGatewayConnectPropsToCloudFormation(props);
  }
}

export namespace CfnTransitGatewayConnect {
  /**
   * Describes the Connect attachment options.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayconnect-transitgatewayconnectoptions.html
   */
  export interface TransitGatewayConnectOptionsProperty {
    /**
     * The tunnel protocol.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayconnect-transitgatewayconnectoptions.html#cfn-ec2-transitgatewayconnect-transitgatewayconnectoptions-protocol
     */
    readonly protocol?: string;
  }
}

/**
 * Properties for defining a \`CfnTransitGatewayConnect\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayconnect.html
 */
export interface CfnTransitGatewayConnectProps {
  /**
   * The Connect attachment options.
   *
   * - protocol (gre)
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayconnect.html#cfn-ec2-transitgatewayconnect-options
   */
  readonly options: cdk.IResolvable | CfnTransitGatewayConnect.TransitGatewayConnectOptionsProperty;

  /**
   * The tags for the attachment.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayconnect.html#cfn-ec2-transitgatewayconnect-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The ID of the attachment from which the Connect attachment was created.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayconnect.html#cfn-ec2-transitgatewayconnect-transporttransitgatewayattachmentid
   */
  readonly transportTransitGatewayAttachmentId: string;
}

/**
 * Determine whether the given properties match those of a \`TransitGatewayConnectOptionsProperty\`
 *
 * @param properties - the TypeScript properties of a \`TransitGatewayConnectOptionsProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTransitGatewayConnectTransitGatewayConnectOptionsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("protocol", cdk.validateString)(properties.protocol));
  return errors.wrap("supplied properties not correct for \\"TransitGatewayConnectOptionsProperty\\"");
}

// @ts-ignore TS6133
function convertCfnTransitGatewayConnectTransitGatewayConnectOptionsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTransitGatewayConnectTransitGatewayConnectOptionsPropertyValidator(properties).assertSuccess();
  return {
    "Protocol": cdk.stringToCloudFormation(properties.protocol)
  };
}

// @ts-ignore TS6133
function CfnTransitGatewayConnectTransitGatewayConnectOptionsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnTransitGatewayConnect.TransitGatewayConnectOptionsProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTransitGatewayConnect.TransitGatewayConnectOptionsProperty>();
  ret.addPropertyResult("protocol", "Protocol", (properties.Protocol != null ? cfn_parse.FromCloudFormation.getString(properties.Protocol) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnTransitGatewayConnectProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnTransitGatewayConnectProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTransitGatewayConnectPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("options", cdk.requiredValidator)(properties.options));
  errors.collect(cdk.propertyValidator("options", CfnTransitGatewayConnectTransitGatewayConnectOptionsPropertyValidator)(properties.options));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("transportTransitGatewayAttachmentId", cdk.requiredValidator)(properties.transportTransitGatewayAttachmentId));
  errors.collect(cdk.propertyValidator("transportTransitGatewayAttachmentId", cdk.validateString)(properties.transportTransitGatewayAttachmentId));
  return errors.wrap("supplied properties not correct for \\"CfnTransitGatewayConnectProps\\"");
}

// @ts-ignore TS6133
function convertCfnTransitGatewayConnectPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTransitGatewayConnectPropsValidator(properties).assertSuccess();
  return {
    "Options": convertCfnTransitGatewayConnectTransitGatewayConnectOptionsPropertyToCloudFormation(properties.options),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "TransportTransitGatewayAttachmentId": cdk.stringToCloudFormation(properties.transportTransitGatewayAttachmentId)
  };
}

// @ts-ignore TS6133
function CfnTransitGatewayConnectPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnTransitGatewayConnectProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTransitGatewayConnectProps>();
  ret.addPropertyResult("options", "Options", (properties.Options != null ? CfnTransitGatewayConnectTransitGatewayConnectOptionsPropertyFromCloudFormation(properties.Options) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("transportTransitGatewayAttachmentId", "TransportTransitGatewayAttachmentId", (properties.TransportTransitGatewayAttachmentId != null ? cfn_parse.FromCloudFormation.getString(properties.TransportTransitGatewayAttachmentId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Creates a multicast domain using the specified transit gateway.
 *
 * The transit gateway must be in the available state before you create a domain.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomain.html
 */
export class CfnTransitGatewayMulticastDomain extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::TransitGatewayMulticastDomain";

  /**
   * Build a CfnTransitGatewayMulticastDomain from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnTransitGatewayMulticastDomain {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnTransitGatewayMulticastDomainPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnTransitGatewayMulticastDomain(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The time the multicast domain was created.
   *
   * @cloudformationAttribute CreationTime
   */
  public readonly attrCreationTime: string;

  /**
   * The state of the multicast domain.
   *
   * @cloudformationAttribute State
   */
  public readonly attrState: string;

  /**
   * The Amazon Resource Name (ARN) of the multicast domain.
   *
   * @cloudformationAttribute TransitGatewayMulticastDomainArn
   */
  public readonly attrTransitGatewayMulticastDomainArn: string;

  /**
   * The ID of the multicast domain.
   *
   * @cloudformationAttribute TransitGatewayMulticastDomainId
   */
  public readonly attrTransitGatewayMulticastDomainId: string;

  /**
   * The options for the transit gateway multicast domain.
   */
  public options?: any | cdk.IResolvable;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags for the transit gateway multicast domain.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The ID of the transit gateway.
   */
  public transitGatewayId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnTransitGatewayMulticastDomainProps) {
    super(scope, id, {
      "type": CfnTransitGatewayMulticastDomain.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "transitGatewayId", this);

    this.attrCreationTime = cdk.Token.asString(this.getAtt("CreationTime", cdk.ResolutionTypeHint.STRING));
    this.attrState = cdk.Token.asString(this.getAtt("State", cdk.ResolutionTypeHint.STRING));
    this.attrTransitGatewayMulticastDomainArn = cdk.Token.asString(this.getAtt("TransitGatewayMulticastDomainArn", cdk.ResolutionTypeHint.STRING));
    this.attrTransitGatewayMulticastDomainId = cdk.Token.asString(this.getAtt("TransitGatewayMulticastDomainId", cdk.ResolutionTypeHint.STRING));
    this.options = props.options;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::TransitGatewayMulticastDomain", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.transitGatewayId = props.transitGatewayId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "options": this.options,
      "tags": this.tags.renderTags(),
      "transitGatewayId": this.transitGatewayId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnTransitGatewayMulticastDomain.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnTransitGatewayMulticastDomainPropsToCloudFormation(props);
  }
}

export namespace CfnTransitGatewayMulticastDomain {
  /**
   * The options for the transit gateway multicast domain.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewaymulticastdomain-options.html
   */
  export interface OptionsProperty {
    /**
     * Indicates whether to automatically accept cross-account subnet associations that are associated with the transit gateway multicast domain.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewaymulticastdomain-options.html#cfn-ec2-transitgatewaymulticastdomain-options-autoacceptsharedassociations
     */
    readonly autoAcceptSharedAssociations?: string;

    /**
     * Specify whether to enable Internet Group Management Protocol (IGMP) version 2 for the transit gateway multicast domain.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewaymulticastdomain-options.html#cfn-ec2-transitgatewaymulticastdomain-options-igmpv2support
     */
    readonly igmpv2Support?: string;

    /**
     * Specify whether to enable support for statically configuring multicast group sources for a domain.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewaymulticastdomain-options.html#cfn-ec2-transitgatewaymulticastdomain-options-staticsourcessupport
     */
    readonly staticSourcesSupport?: string;
  }
}

/**
 * Properties for defining a \`CfnTransitGatewayMulticastDomain\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomain.html
 */
export interface CfnTransitGatewayMulticastDomainProps {
  /**
   * The options for the transit gateway multicast domain.
   *
   * - AutoAcceptSharedAssociations (enable | disable)
   * - Igmpv2Support (enable | disable)
   * - StaticSourcesSupport (enable | disable)
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomain.html#cfn-ec2-transitgatewaymulticastdomain-options
   */
  readonly options?: any | cdk.IResolvable;

  /**
   * The tags for the transit gateway multicast domain.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomain.html#cfn-ec2-transitgatewaymulticastdomain-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The ID of the transit gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomain.html#cfn-ec2-transitgatewaymulticastdomain-transitgatewayid
   */
  readonly transitGatewayId: string;
}

/**
 * Determine whether the given properties match those of a \`OptionsProperty\`
 *
 * @param properties - the TypeScript properties of a \`OptionsProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTransitGatewayMulticastDomainOptionsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("autoAcceptSharedAssociations", cdk.validateString)(properties.autoAcceptSharedAssociations));
  errors.collect(cdk.propertyValidator("igmpv2Support", cdk.validateString)(properties.igmpv2Support));
  errors.collect(cdk.propertyValidator("staticSourcesSupport", cdk.validateString)(properties.staticSourcesSupport));
  return errors.wrap("supplied properties not correct for \\"OptionsProperty\\"");
}

// @ts-ignore TS6133
function convertCfnTransitGatewayMulticastDomainOptionsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTransitGatewayMulticastDomainOptionsPropertyValidator(properties).assertSuccess();
  return {
    "AutoAcceptSharedAssociations": cdk.stringToCloudFormation(properties.autoAcceptSharedAssociations),
    "Igmpv2Support": cdk.stringToCloudFormation(properties.igmpv2Support),
    "StaticSourcesSupport": cdk.stringToCloudFormation(properties.staticSourcesSupport)
  };
}

// @ts-ignore TS6133
function CfnTransitGatewayMulticastDomainOptionsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnTransitGatewayMulticastDomain.OptionsProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTransitGatewayMulticastDomain.OptionsProperty>();
  ret.addPropertyResult("autoAcceptSharedAssociations", "AutoAcceptSharedAssociations", (properties.AutoAcceptSharedAssociations != null ? cfn_parse.FromCloudFormation.getString(properties.AutoAcceptSharedAssociations) : undefined));
  ret.addPropertyResult("igmpv2Support", "Igmpv2Support", (properties.Igmpv2Support != null ? cfn_parse.FromCloudFormation.getString(properties.Igmpv2Support) : undefined));
  ret.addPropertyResult("staticSourcesSupport", "StaticSourcesSupport", (properties.StaticSourcesSupport != null ? cfn_parse.FromCloudFormation.getString(properties.StaticSourcesSupport) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnTransitGatewayMulticastDomainProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnTransitGatewayMulticastDomainProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTransitGatewayMulticastDomainPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("options", cdk.validateObject)(properties.options));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("transitGatewayId", cdk.requiredValidator)(properties.transitGatewayId));
  errors.collect(cdk.propertyValidator("transitGatewayId", cdk.validateString)(properties.transitGatewayId));
  return errors.wrap("supplied properties not correct for \\"CfnTransitGatewayMulticastDomainProps\\"");
}

// @ts-ignore TS6133
function convertCfnTransitGatewayMulticastDomainPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTransitGatewayMulticastDomainPropsValidator(properties).assertSuccess();
  return {
    "Options": cdk.objectToCloudFormation(properties.options),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "TransitGatewayId": cdk.stringToCloudFormation(properties.transitGatewayId)
  };
}

// @ts-ignore TS6133
function CfnTransitGatewayMulticastDomainPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnTransitGatewayMulticastDomainProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTransitGatewayMulticastDomainProps>();
  ret.addPropertyResult("options", "Options", (properties.Options != null ? cfn_parse.FromCloudFormation.getAny(properties.Options) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("transitGatewayId", "TransitGatewayId", (properties.TransitGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.TransitGatewayId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Associates the specified subnets and transit gateway attachments with the specified transit gateway multicast domain.
 *
 * The transit gateway attachment must be in the available state before you can add a resource.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomainassociation.html
 */
export class CfnTransitGatewayMulticastDomainAssociation extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::TransitGatewayMulticastDomainAssociation";

  /**
   * Build a CfnTransitGatewayMulticastDomainAssociation from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnTransitGatewayMulticastDomainAssociation {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnTransitGatewayMulticastDomainAssociationPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnTransitGatewayMulticastDomainAssociation(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the resource.
   *
   * @cloudformationAttribute ResourceId
   */
  public readonly attrResourceId: string;

  /**
   * The type of resource, for example a VPC attachment.
   *
   * @cloudformationAttribute ResourceType
   */
  public readonly attrResourceType: string;

  /**
   * The state of the resource.
   *
   * @cloudformationAttribute State
   */
  public readonly attrState: string;

  /**
   * The IDs of the subnets to associate with the transit gateway multicast domain.
   */
  public subnetId: string;

  /**
   * The ID of the transit gateway attachment.
   */
  public transitGatewayAttachmentId: string;

  /**
   * The ID of the transit gateway multicast domain.
   */
  public transitGatewayMulticastDomainId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnTransitGatewayMulticastDomainAssociationProps) {
    super(scope, id, {
      "type": CfnTransitGatewayMulticastDomainAssociation.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "subnetId", this);
    cdk.requireProperty(props, "transitGatewayAttachmentId", this);
    cdk.requireProperty(props, "transitGatewayMulticastDomainId", this);

    this.attrResourceId = cdk.Token.asString(this.getAtt("ResourceId", cdk.ResolutionTypeHint.STRING));
    this.attrResourceType = cdk.Token.asString(this.getAtt("ResourceType", cdk.ResolutionTypeHint.STRING));
    this.attrState = cdk.Token.asString(this.getAtt("State", cdk.ResolutionTypeHint.STRING));
    this.subnetId = props.subnetId;
    this.transitGatewayAttachmentId = props.transitGatewayAttachmentId;
    this.transitGatewayMulticastDomainId = props.transitGatewayMulticastDomainId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "subnetId": this.subnetId,
      "transitGatewayAttachmentId": this.transitGatewayAttachmentId,
      "transitGatewayMulticastDomainId": this.transitGatewayMulticastDomainId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnTransitGatewayMulticastDomainAssociation.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnTransitGatewayMulticastDomainAssociationPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnTransitGatewayMulticastDomainAssociation\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomainassociation.html
 */
export interface CfnTransitGatewayMulticastDomainAssociationProps {
  /**
   * The IDs of the subnets to associate with the transit gateway multicast domain.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomainassociation.html#cfn-ec2-transitgatewaymulticastdomainassociation-subnetid
   */
  readonly subnetId: string;

  /**
   * The ID of the transit gateway attachment.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomainassociation.html#cfn-ec2-transitgatewaymulticastdomainassociation-transitgatewayattachmentid
   */
  readonly transitGatewayAttachmentId: string;

  /**
   * The ID of the transit gateway multicast domain.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomainassociation.html#cfn-ec2-transitgatewaymulticastdomainassociation-transitgatewaymulticastdomainid
   */
  readonly transitGatewayMulticastDomainId: string;
}

/**
 * Determine whether the given properties match those of a \`CfnTransitGatewayMulticastDomainAssociationProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnTransitGatewayMulticastDomainAssociationProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTransitGatewayMulticastDomainAssociationPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("subnetId", cdk.requiredValidator)(properties.subnetId));
  errors.collect(cdk.propertyValidator("subnetId", cdk.validateString)(properties.subnetId));
  errors.collect(cdk.propertyValidator("transitGatewayAttachmentId", cdk.requiredValidator)(properties.transitGatewayAttachmentId));
  errors.collect(cdk.propertyValidator("transitGatewayAttachmentId", cdk.validateString)(properties.transitGatewayAttachmentId));
  errors.collect(cdk.propertyValidator("transitGatewayMulticastDomainId", cdk.requiredValidator)(properties.transitGatewayMulticastDomainId));
  errors.collect(cdk.propertyValidator("transitGatewayMulticastDomainId", cdk.validateString)(properties.transitGatewayMulticastDomainId));
  return errors.wrap("supplied properties not correct for \\"CfnTransitGatewayMulticastDomainAssociationProps\\"");
}

// @ts-ignore TS6133
function convertCfnTransitGatewayMulticastDomainAssociationPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTransitGatewayMulticastDomainAssociationPropsValidator(properties).assertSuccess();
  return {
    "SubnetId": cdk.stringToCloudFormation(properties.subnetId),
    "TransitGatewayAttachmentId": cdk.stringToCloudFormation(properties.transitGatewayAttachmentId),
    "TransitGatewayMulticastDomainId": cdk.stringToCloudFormation(properties.transitGatewayMulticastDomainId)
  };
}

// @ts-ignore TS6133
function CfnTransitGatewayMulticastDomainAssociationPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnTransitGatewayMulticastDomainAssociationProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTransitGatewayMulticastDomainAssociationProps>();
  ret.addPropertyResult("subnetId", "SubnetId", (properties.SubnetId != null ? cfn_parse.FromCloudFormation.getString(properties.SubnetId) : undefined));
  ret.addPropertyResult("transitGatewayAttachmentId", "TransitGatewayAttachmentId", (properties.TransitGatewayAttachmentId != null ? cfn_parse.FromCloudFormation.getString(properties.TransitGatewayAttachmentId) : undefined));
  ret.addPropertyResult("transitGatewayMulticastDomainId", "TransitGatewayMulticastDomainId", (properties.TransitGatewayMulticastDomainId != null ? cfn_parse.FromCloudFormation.getString(properties.TransitGatewayMulticastDomainId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Registers members (network interfaces) with the transit gateway multicast group.
 *
 * A member is a network interface associated with a supported EC2 instance that receives multicast traffic. For information about supported instances, see [Multicast Consideration](https://docs.aws.amazon.com/vpc/latest/tgw/transit-gateway-limits.html#multicast-limits) in *Amazon VPC Transit Gateways* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupmember.html
 */
export class CfnTransitGatewayMulticastGroupMember extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::TransitGatewayMulticastGroupMember";

  /**
   * Build a CfnTransitGatewayMulticastGroupMember from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnTransitGatewayMulticastGroupMember {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnTransitGatewayMulticastGroupMemberPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnTransitGatewayMulticastGroupMember(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * Information about the registered transit gateway multicast domain group members.
   *
   * @cloudformationAttribute GroupMember
   */
  public readonly attrGroupMember: cdk.IResolvable;

  /**
   * Indicates that the resource is a transit gateway multicast domain group member.
   *
   * @cloudformationAttribute GroupSource
   */
  public readonly attrGroupSource: cdk.IResolvable;

  /**
   * The type of group member, for example static.
   *
   * @cloudformationAttribute MemberType
   */
  public readonly attrMemberType: string;

  /**
   * The ID of the resource.
   *
   * @cloudformationAttribute ResourceId
   */
  public readonly attrResourceId: string;

  /**
   * The type of resource, for example a VPC attachment.
   *
   * @cloudformationAttribute ResourceType
   */
  public readonly attrResourceType: string;

  /**
   * The type of source.
   *
   * @cloudformationAttribute SourceType
   */
  public readonly attrSourceType: string;

  /**
   * The ID of the subnet.
   *
   * @cloudformationAttribute SubnetId
   */
  public readonly attrSubnetId: string;

  /**
   * The ID of the transit gateway attachment.
   *
   * @cloudformationAttribute TransitGatewayAttachmentId
   */
  public readonly attrTransitGatewayAttachmentId: string;

  /**
   * The IP address assigned to the transit gateway multicast group.
   */
  public groupIpAddress: string;

  /**
   * The group members' network interface IDs to register with the transit gateway multicast group.
   */
  public networkInterfaceId: string;

  /**
   * The ID of the transit gateway multicast domain.
   */
  public transitGatewayMulticastDomainId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnTransitGatewayMulticastGroupMemberProps) {
    super(scope, id, {
      "type": CfnTransitGatewayMulticastGroupMember.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "groupIpAddress", this);
    cdk.requireProperty(props, "networkInterfaceId", this);
    cdk.requireProperty(props, "transitGatewayMulticastDomainId", this);

    this.attrGroupMember = this.getAtt("GroupMember");
    this.attrGroupSource = this.getAtt("GroupSource");
    this.attrMemberType = cdk.Token.asString(this.getAtt("MemberType", cdk.ResolutionTypeHint.STRING));
    this.attrResourceId = cdk.Token.asString(this.getAtt("ResourceId", cdk.ResolutionTypeHint.STRING));
    this.attrResourceType = cdk.Token.asString(this.getAtt("ResourceType", cdk.ResolutionTypeHint.STRING));
    this.attrSourceType = cdk.Token.asString(this.getAtt("SourceType", cdk.ResolutionTypeHint.STRING));
    this.attrSubnetId = cdk.Token.asString(this.getAtt("SubnetId", cdk.ResolutionTypeHint.STRING));
    this.attrTransitGatewayAttachmentId = cdk.Token.asString(this.getAtt("TransitGatewayAttachmentId", cdk.ResolutionTypeHint.STRING));
    this.groupIpAddress = props.groupIpAddress;
    this.networkInterfaceId = props.networkInterfaceId;
    this.transitGatewayMulticastDomainId = props.transitGatewayMulticastDomainId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "groupIpAddress": this.groupIpAddress,
      "networkInterfaceId": this.networkInterfaceId,
      "transitGatewayMulticastDomainId": this.transitGatewayMulticastDomainId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnTransitGatewayMulticastGroupMember.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnTransitGatewayMulticastGroupMemberPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnTransitGatewayMulticastGroupMember\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupmember.html
 */
export interface CfnTransitGatewayMulticastGroupMemberProps {
  /**
   * The IP address assigned to the transit gateway multicast group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupmember.html#cfn-ec2-transitgatewaymulticastgroupmember-groupipaddress
   */
  readonly groupIpAddress: string;

  /**
   * The group members' network interface IDs to register with the transit gateway multicast group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupmember.html#cfn-ec2-transitgatewaymulticastgroupmember-networkinterfaceid
   */
  readonly networkInterfaceId: string;

  /**
   * The ID of the transit gateway multicast domain.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupmember.html#cfn-ec2-transitgatewaymulticastgroupmember-transitgatewaymulticastdomainid
   */
  readonly transitGatewayMulticastDomainId: string;
}

/**
 * Determine whether the given properties match those of a \`CfnTransitGatewayMulticastGroupMemberProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnTransitGatewayMulticastGroupMemberProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTransitGatewayMulticastGroupMemberPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("groupIpAddress", cdk.requiredValidator)(properties.groupIpAddress));
  errors.collect(cdk.propertyValidator("groupIpAddress", cdk.validateString)(properties.groupIpAddress));
  errors.collect(cdk.propertyValidator("networkInterfaceId", cdk.requiredValidator)(properties.networkInterfaceId));
  errors.collect(cdk.propertyValidator("networkInterfaceId", cdk.validateString)(properties.networkInterfaceId));
  errors.collect(cdk.propertyValidator("transitGatewayMulticastDomainId", cdk.requiredValidator)(properties.transitGatewayMulticastDomainId));
  errors.collect(cdk.propertyValidator("transitGatewayMulticastDomainId", cdk.validateString)(properties.transitGatewayMulticastDomainId));
  return errors.wrap("supplied properties not correct for \\"CfnTransitGatewayMulticastGroupMemberProps\\"");
}

// @ts-ignore TS6133
function convertCfnTransitGatewayMulticastGroupMemberPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTransitGatewayMulticastGroupMemberPropsValidator(properties).assertSuccess();
  return {
    "GroupIpAddress": cdk.stringToCloudFormation(properties.groupIpAddress),
    "NetworkInterfaceId": cdk.stringToCloudFormation(properties.networkInterfaceId),
    "TransitGatewayMulticastDomainId": cdk.stringToCloudFormation(properties.transitGatewayMulticastDomainId)
  };
}

// @ts-ignore TS6133
function CfnTransitGatewayMulticastGroupMemberPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnTransitGatewayMulticastGroupMemberProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTransitGatewayMulticastGroupMemberProps>();
  ret.addPropertyResult("groupIpAddress", "GroupIpAddress", (properties.GroupIpAddress != null ? cfn_parse.FromCloudFormation.getString(properties.GroupIpAddress) : undefined));
  ret.addPropertyResult("networkInterfaceId", "NetworkInterfaceId", (properties.NetworkInterfaceId != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkInterfaceId) : undefined));
  ret.addPropertyResult("transitGatewayMulticastDomainId", "TransitGatewayMulticastDomainId", (properties.TransitGatewayMulticastDomainId != null ? cfn_parse.FromCloudFormation.getString(properties.TransitGatewayMulticastDomainId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Registers sources (network interfaces) with the specified transit gateway multicast domain.
 *
 * A multicast source is a network interface attached to a supported instance that sends multicast traffic. For information about supported instances, see [Multicast Considerations](https://docs.aws.amazon.com/vpc/latest/tgw/transit-gateway-limits.html#multicast-limits) in *Amazon VPC Transit Gateways* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupsource.html
 */
export class CfnTransitGatewayMulticastGroupSource extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::TransitGatewayMulticastGroupSource";

  /**
   * Build a CfnTransitGatewayMulticastGroupSource from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnTransitGatewayMulticastGroupSource {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnTransitGatewayMulticastGroupSourcePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnTransitGatewayMulticastGroupSource(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * Information about the registered transit gateway multicast domain group members.
   *
   * @cloudformationAttribute GroupMember
   */
  public readonly attrGroupMember: cdk.IResolvable;

  /**
   * Indicates that the resource is a transit gateway group member.
   *
   * @cloudformationAttribute GroupSource
   */
  public readonly attrGroupSource: cdk.IResolvable;

  /**
   * The type of group member, for example static.
   *
   * @cloudformationAttribute MemberType
   */
  public readonly attrMemberType: string;

  /**
   * The ID of the resource.
   *
   * @cloudformationAttribute ResourceId
   */
  public readonly attrResourceId: string;

  /**
   * The type of resource, for example a VPC attachment.
   *
   * @cloudformationAttribute ResourceType
   */
  public readonly attrResourceType: string;

  /**
   * The type of source.
   *
   * @cloudformationAttribute SourceType
   */
  public readonly attrSourceType: string;

  /**
   * The ID of the subnet.
   *
   * @cloudformationAttribute SubnetId
   */
  public readonly attrSubnetId: string;

  /**
   * The ID of the transit gateway attachment.
   *
   * @cloudformationAttribute TransitGatewayAttachmentId
   */
  public readonly attrTransitGatewayAttachmentId: string;

  /**
   * The IP address assigned to the transit gateway multicast group.
   */
  public groupIpAddress: string;

  /**
   * The group sources' network interface IDs to register with the transit gateway multicast group.
   */
  public networkInterfaceId: string;

  /**
   * The ID of the transit gateway multicast domain.
   */
  public transitGatewayMulticastDomainId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnTransitGatewayMulticastGroupSourceProps) {
    super(scope, id, {
      "type": CfnTransitGatewayMulticastGroupSource.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "groupIpAddress", this);
    cdk.requireProperty(props, "networkInterfaceId", this);
    cdk.requireProperty(props, "transitGatewayMulticastDomainId", this);

    this.attrGroupMember = this.getAtt("GroupMember");
    this.attrGroupSource = this.getAtt("GroupSource");
    this.attrMemberType = cdk.Token.asString(this.getAtt("MemberType", cdk.ResolutionTypeHint.STRING));
    this.attrResourceId = cdk.Token.asString(this.getAtt("ResourceId", cdk.ResolutionTypeHint.STRING));
    this.attrResourceType = cdk.Token.asString(this.getAtt("ResourceType", cdk.ResolutionTypeHint.STRING));
    this.attrSourceType = cdk.Token.asString(this.getAtt("SourceType", cdk.ResolutionTypeHint.STRING));
    this.attrSubnetId = cdk.Token.asString(this.getAtt("SubnetId", cdk.ResolutionTypeHint.STRING));
    this.attrTransitGatewayAttachmentId = cdk.Token.asString(this.getAtt("TransitGatewayAttachmentId", cdk.ResolutionTypeHint.STRING));
    this.groupIpAddress = props.groupIpAddress;
    this.networkInterfaceId = props.networkInterfaceId;
    this.transitGatewayMulticastDomainId = props.transitGatewayMulticastDomainId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "groupIpAddress": this.groupIpAddress,
      "networkInterfaceId": this.networkInterfaceId,
      "transitGatewayMulticastDomainId": this.transitGatewayMulticastDomainId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnTransitGatewayMulticastGroupSource.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnTransitGatewayMulticastGroupSourcePropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnTransitGatewayMulticastGroupSource\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupsource.html
 */
export interface CfnTransitGatewayMulticastGroupSourceProps {
  /**
   * The IP address assigned to the transit gateway multicast group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupsource.html#cfn-ec2-transitgatewaymulticastgroupsource-groupipaddress
   */
  readonly groupIpAddress: string;

  /**
   * The group sources' network interface IDs to register with the transit gateway multicast group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupsource.html#cfn-ec2-transitgatewaymulticastgroupsource-networkinterfaceid
   */
  readonly networkInterfaceId: string;

  /**
   * The ID of the transit gateway multicast domain.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupsource.html#cfn-ec2-transitgatewaymulticastgroupsource-transitgatewaymulticastdomainid
   */
  readonly transitGatewayMulticastDomainId: string;
}

/**
 * Determine whether the given properties match those of a \`CfnTransitGatewayMulticastGroupSourceProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnTransitGatewayMulticastGroupSourceProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTransitGatewayMulticastGroupSourcePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("groupIpAddress", cdk.requiredValidator)(properties.groupIpAddress));
  errors.collect(cdk.propertyValidator("groupIpAddress", cdk.validateString)(properties.groupIpAddress));
  errors.collect(cdk.propertyValidator("networkInterfaceId", cdk.requiredValidator)(properties.networkInterfaceId));
  errors.collect(cdk.propertyValidator("networkInterfaceId", cdk.validateString)(properties.networkInterfaceId));
  errors.collect(cdk.propertyValidator("transitGatewayMulticastDomainId", cdk.requiredValidator)(properties.transitGatewayMulticastDomainId));
  errors.collect(cdk.propertyValidator("transitGatewayMulticastDomainId", cdk.validateString)(properties.transitGatewayMulticastDomainId));
  return errors.wrap("supplied properties not correct for \\"CfnTransitGatewayMulticastGroupSourceProps\\"");
}

// @ts-ignore TS6133
function convertCfnTransitGatewayMulticastGroupSourcePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTransitGatewayMulticastGroupSourcePropsValidator(properties).assertSuccess();
  return {
    "GroupIpAddress": cdk.stringToCloudFormation(properties.groupIpAddress),
    "NetworkInterfaceId": cdk.stringToCloudFormation(properties.networkInterfaceId),
    "TransitGatewayMulticastDomainId": cdk.stringToCloudFormation(properties.transitGatewayMulticastDomainId)
  };
}

// @ts-ignore TS6133
function CfnTransitGatewayMulticastGroupSourcePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnTransitGatewayMulticastGroupSourceProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTransitGatewayMulticastGroupSourceProps>();
  ret.addPropertyResult("groupIpAddress", "GroupIpAddress", (properties.GroupIpAddress != null ? cfn_parse.FromCloudFormation.getString(properties.GroupIpAddress) : undefined));
  ret.addPropertyResult("networkInterfaceId", "NetworkInterfaceId", (properties.NetworkInterfaceId != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkInterfaceId) : undefined));
  ret.addPropertyResult("transitGatewayMulticastDomainId", "TransitGatewayMulticastDomainId", (properties.TransitGatewayMulticastDomainId != null ? cfn_parse.FromCloudFormation.getString(properties.TransitGatewayMulticastDomainId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Requests a transit gateway peering attachment between the specified transit gateway (requester) and a peer transit gateway (accepter).
 *
 * The peer transit gateway can be in your account or a different AWS account .
 *
 * After you create the peering attachment, the owner of the accepter transit gateway must accept the attachment request.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html
 */
export class CfnTransitGatewayPeeringAttachment extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::TransitGatewayPeeringAttachment";

  /**
   * Build a CfnTransitGatewayPeeringAttachment from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnTransitGatewayPeeringAttachment {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnTransitGatewayPeeringAttachmentPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnTransitGatewayPeeringAttachment(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The time the transit gateway peering attachment was created.
   *
   * @cloudformationAttribute CreationTime
   */
  public readonly attrCreationTime: string;

  /**
   * The state of the transit gateway peering attachment. Note that the \`initiating\` state has been deprecated.
   *
   * @cloudformationAttribute State
   */
  public readonly attrState: string;

  /**
   * The status of the transit gateway peering attachment.
   *
   * @cloudformationAttribute Status
   */
  public readonly attrStatus: cdk.IResolvable;

  /**
   * The status code.
   *
   * @cloudformationAttribute Status.Code
   */
  public readonly attrStatusCode: string;

  /**
   * The status message.
   *
   * @cloudformationAttribute Status.Message
   */
  public readonly attrStatusMessage: string;

  /**
   * The ID of the transit gateway peering attachment.
   *
   * @cloudformationAttribute TransitGatewayAttachmentId
   */
  public readonly attrTransitGatewayAttachmentId: string;

  /**
   * The ID of the AWS account that owns the transit gateway.
   */
  public peerAccountId: string;

  /**
   * The Region of the transit gateway.
   */
  public peerRegion: string;

  /**
   * The ID of the transit gateway.
   */
  public peerTransitGatewayId: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags for the transit gateway peering attachment.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The ID of the transit gateway peering attachment.
   */
  public transitGatewayId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnTransitGatewayPeeringAttachmentProps) {
    super(scope, id, {
      "type": CfnTransitGatewayPeeringAttachment.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "peerAccountId", this);
    cdk.requireProperty(props, "peerRegion", this);
    cdk.requireProperty(props, "peerTransitGatewayId", this);
    cdk.requireProperty(props, "transitGatewayId", this);

    this.attrCreationTime = cdk.Token.asString(this.getAtt("CreationTime", cdk.ResolutionTypeHint.STRING));
    this.attrState = cdk.Token.asString(this.getAtt("State", cdk.ResolutionTypeHint.STRING));
    this.attrStatus = this.getAtt("Status");
    this.attrStatusCode = cdk.Token.asString(this.getAtt("Status.Code", cdk.ResolutionTypeHint.STRING));
    this.attrStatusMessage = cdk.Token.asString(this.getAtt("Status.Message", cdk.ResolutionTypeHint.STRING));
    this.attrTransitGatewayAttachmentId = cdk.Token.asString(this.getAtt("TransitGatewayAttachmentId", cdk.ResolutionTypeHint.STRING));
    this.peerAccountId = props.peerAccountId;
    this.peerRegion = props.peerRegion;
    this.peerTransitGatewayId = props.peerTransitGatewayId;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::TransitGatewayPeeringAttachment", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.transitGatewayId = props.transitGatewayId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "peerAccountId": this.peerAccountId,
      "peerRegion": this.peerRegion,
      "peerTransitGatewayId": this.peerTransitGatewayId,
      "tags": this.tags.renderTags(),
      "transitGatewayId": this.transitGatewayId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnTransitGatewayPeeringAttachment.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnTransitGatewayPeeringAttachmentPropsToCloudFormation(props);
  }
}

export namespace CfnTransitGatewayPeeringAttachment {
  /**
   * The status of the transit gateway peering attachment.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewaypeeringattachment-peeringattachmentstatus.html
   */
  export interface PeeringAttachmentStatusProperty {
    /**
     * The status code.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewaypeeringattachment-peeringattachmentstatus.html#cfn-ec2-transitgatewaypeeringattachment-peeringattachmentstatus-code
     */
    readonly code?: string;

    /**
     * The status message, if applicable.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewaypeeringattachment-peeringattachmentstatus.html#cfn-ec2-transitgatewaypeeringattachment-peeringattachmentstatus-message
     */
    readonly message?: string;
  }
}

/**
 * Properties for defining a \`CfnTransitGatewayPeeringAttachment\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html
 */
export interface CfnTransitGatewayPeeringAttachmentProps {
  /**
   * The ID of the AWS account that owns the transit gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-peeraccountid
   */
  readonly peerAccountId: string;

  /**
   * The Region of the transit gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-peerregion
   */
  readonly peerRegion: string;

  /**
   * The ID of the transit gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-peertransitgatewayid
   */
  readonly peerTransitGatewayId: string;

  /**
   * The tags for the transit gateway peering attachment.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The ID of the transit gateway peering attachment.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-transitgatewayid
   */
  readonly transitGatewayId: string;
}

/**
 * Determine whether the given properties match those of a \`PeeringAttachmentStatusProperty\`
 *
 * @param properties - the TypeScript properties of a \`PeeringAttachmentStatusProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTransitGatewayPeeringAttachmentPeeringAttachmentStatusPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("code", cdk.validateString)(properties.code));
  errors.collect(cdk.propertyValidator("message", cdk.validateString)(properties.message));
  return errors.wrap("supplied properties not correct for \\"PeeringAttachmentStatusProperty\\"");
}

// @ts-ignore TS6133
function convertCfnTransitGatewayPeeringAttachmentPeeringAttachmentStatusPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTransitGatewayPeeringAttachmentPeeringAttachmentStatusPropertyValidator(properties).assertSuccess();
  return {
    "Code": cdk.stringToCloudFormation(properties.code),
    "Message": cdk.stringToCloudFormation(properties.message)
  };
}

// @ts-ignore TS6133
function CfnTransitGatewayPeeringAttachmentPeeringAttachmentStatusPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnTransitGatewayPeeringAttachment.PeeringAttachmentStatusProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTransitGatewayPeeringAttachment.PeeringAttachmentStatusProperty>();
  ret.addPropertyResult("code", "Code", (properties.Code != null ? cfn_parse.FromCloudFormation.getString(properties.Code) : undefined));
  ret.addPropertyResult("message", "Message", (properties.Message != null ? cfn_parse.FromCloudFormation.getString(properties.Message) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnTransitGatewayPeeringAttachmentProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnTransitGatewayPeeringAttachmentProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTransitGatewayPeeringAttachmentPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("peerAccountId", cdk.requiredValidator)(properties.peerAccountId));
  errors.collect(cdk.propertyValidator("peerAccountId", cdk.validateString)(properties.peerAccountId));
  errors.collect(cdk.propertyValidator("peerRegion", cdk.requiredValidator)(properties.peerRegion));
  errors.collect(cdk.propertyValidator("peerRegion", cdk.validateString)(properties.peerRegion));
  errors.collect(cdk.propertyValidator("peerTransitGatewayId", cdk.requiredValidator)(properties.peerTransitGatewayId));
  errors.collect(cdk.propertyValidator("peerTransitGatewayId", cdk.validateString)(properties.peerTransitGatewayId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("transitGatewayId", cdk.requiredValidator)(properties.transitGatewayId));
  errors.collect(cdk.propertyValidator("transitGatewayId", cdk.validateString)(properties.transitGatewayId));
  return errors.wrap("supplied properties not correct for \\"CfnTransitGatewayPeeringAttachmentProps\\"");
}

// @ts-ignore TS6133
function convertCfnTransitGatewayPeeringAttachmentPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTransitGatewayPeeringAttachmentPropsValidator(properties).assertSuccess();
  return {
    "PeerAccountId": cdk.stringToCloudFormation(properties.peerAccountId),
    "PeerRegion": cdk.stringToCloudFormation(properties.peerRegion),
    "PeerTransitGatewayId": cdk.stringToCloudFormation(properties.peerTransitGatewayId),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "TransitGatewayId": cdk.stringToCloudFormation(properties.transitGatewayId)
  };
}

// @ts-ignore TS6133
function CfnTransitGatewayPeeringAttachmentPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnTransitGatewayPeeringAttachmentProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTransitGatewayPeeringAttachmentProps>();
  ret.addPropertyResult("peerAccountId", "PeerAccountId", (properties.PeerAccountId != null ? cfn_parse.FromCloudFormation.getString(properties.PeerAccountId) : undefined));
  ret.addPropertyResult("peerRegion", "PeerRegion", (properties.PeerRegion != null ? cfn_parse.FromCloudFormation.getString(properties.PeerRegion) : undefined));
  ret.addPropertyResult("peerTransitGatewayId", "PeerTransitGatewayId", (properties.PeerTransitGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.PeerTransitGatewayId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("transitGatewayId", "TransitGatewayId", (properties.TransitGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.TransitGatewayId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a static route for a transit gateway route table.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroute.html
 */
export class CfnTransitGatewayRoute extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::TransitGatewayRoute";

  /**
   * Build a CfnTransitGatewayRoute from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnTransitGatewayRoute {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnTransitGatewayRoutePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnTransitGatewayRoute(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * Indicates whether to drop traffic that matches this route.
   */
  public blackhole?: boolean | cdk.IResolvable;

  /**
   * The CIDR block used for destination matches.
   */
  public destinationCidrBlock?: string;

  /**
   * The ID of the attachment.
   */
  public transitGatewayAttachmentId?: string;

  /**
   * The ID of the transit gateway route table.
   */
  public transitGatewayRouteTableId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnTransitGatewayRouteProps) {
    super(scope, id, {
      "type": CfnTransitGatewayRoute.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "transitGatewayRouteTableId", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.blackhole = props.blackhole;
    this.destinationCidrBlock = props.destinationCidrBlock;
    this.transitGatewayAttachmentId = props.transitGatewayAttachmentId;
    this.transitGatewayRouteTableId = props.transitGatewayRouteTableId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "blackhole": this.blackhole,
      "destinationCidrBlock": this.destinationCidrBlock,
      "transitGatewayAttachmentId": this.transitGatewayAttachmentId,
      "transitGatewayRouteTableId": this.transitGatewayRouteTableId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnTransitGatewayRoute.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnTransitGatewayRoutePropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnTransitGatewayRoute\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroute.html
 */
export interface CfnTransitGatewayRouteProps {
  /**
   * Indicates whether to drop traffic that matches this route.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroute.html#cfn-ec2-transitgatewayroute-blackhole
   */
  readonly blackhole?: boolean | cdk.IResolvable;

  /**
   * The CIDR block used for destination matches.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroute.html#cfn-ec2-transitgatewayroute-destinationcidrblock
   */
  readonly destinationCidrBlock?: string;

  /**
   * The ID of the attachment.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroute.html#cfn-ec2-transitgatewayroute-transitgatewayattachmentid
   */
  readonly transitGatewayAttachmentId?: string;

  /**
   * The ID of the transit gateway route table.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroute.html#cfn-ec2-transitgatewayroute-transitgatewayroutetableid
   */
  readonly transitGatewayRouteTableId: string;
}

/**
 * Determine whether the given properties match those of a \`CfnTransitGatewayRouteProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnTransitGatewayRouteProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTransitGatewayRoutePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("blackhole", cdk.validateBoolean)(properties.blackhole));
  errors.collect(cdk.propertyValidator("destinationCidrBlock", cdk.validateString)(properties.destinationCidrBlock));
  errors.collect(cdk.propertyValidator("transitGatewayAttachmentId", cdk.validateString)(properties.transitGatewayAttachmentId));
  errors.collect(cdk.propertyValidator("transitGatewayRouteTableId", cdk.requiredValidator)(properties.transitGatewayRouteTableId));
  errors.collect(cdk.propertyValidator("transitGatewayRouteTableId", cdk.validateString)(properties.transitGatewayRouteTableId));
  return errors.wrap("supplied properties not correct for \\"CfnTransitGatewayRouteProps\\"");
}

// @ts-ignore TS6133
function convertCfnTransitGatewayRoutePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTransitGatewayRoutePropsValidator(properties).assertSuccess();
  return {
    "Blackhole": cdk.booleanToCloudFormation(properties.blackhole),
    "DestinationCidrBlock": cdk.stringToCloudFormation(properties.destinationCidrBlock),
    "TransitGatewayAttachmentId": cdk.stringToCloudFormation(properties.transitGatewayAttachmentId),
    "TransitGatewayRouteTableId": cdk.stringToCloudFormation(properties.transitGatewayRouteTableId)
  };
}

// @ts-ignore TS6133
function CfnTransitGatewayRoutePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnTransitGatewayRouteProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTransitGatewayRouteProps>();
  ret.addPropertyResult("blackhole", "Blackhole", (properties.Blackhole != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Blackhole) : undefined));
  ret.addPropertyResult("destinationCidrBlock", "DestinationCidrBlock", (properties.DestinationCidrBlock != null ? cfn_parse.FromCloudFormation.getString(properties.DestinationCidrBlock) : undefined));
  ret.addPropertyResult("transitGatewayAttachmentId", "TransitGatewayAttachmentId", (properties.TransitGatewayAttachmentId != null ? cfn_parse.FromCloudFormation.getString(properties.TransitGatewayAttachmentId) : undefined));
  ret.addPropertyResult("transitGatewayRouteTableId", "TransitGatewayRouteTableId", (properties.TransitGatewayRouteTableId != null ? cfn_parse.FromCloudFormation.getString(properties.TransitGatewayRouteTableId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a route table for a transit gateway.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetable.html
 */
export class CfnTransitGatewayRouteTable extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::TransitGatewayRouteTable";

  /**
   * Build a CfnTransitGatewayRouteTable from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnTransitGatewayRouteTable {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnTransitGatewayRouteTablePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnTransitGatewayRouteTable(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * Any tags assigned to the route table.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The ID of the transit gateway.
   */
  public transitGatewayId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnTransitGatewayRouteTableProps) {
    super(scope, id, {
      "type": CfnTransitGatewayRouteTable.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "transitGatewayId", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::TransitGatewayRouteTable", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.transitGatewayId = props.transitGatewayId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "tags": this.tags.renderTags(),
      "transitGatewayId": this.transitGatewayId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnTransitGatewayRouteTable.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnTransitGatewayRouteTablePropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnTransitGatewayRouteTable\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetable.html
 */
export interface CfnTransitGatewayRouteTableProps {
  /**
   * Any tags assigned to the route table.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetable.html#cfn-ec2-transitgatewayroutetable-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The ID of the transit gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetable.html#cfn-ec2-transitgatewayroutetable-transitgatewayid
   */
  readonly transitGatewayId: string;
}

/**
 * Determine whether the given properties match those of a \`CfnTransitGatewayRouteTableProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnTransitGatewayRouteTableProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTransitGatewayRouteTablePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("transitGatewayId", cdk.requiredValidator)(properties.transitGatewayId));
  errors.collect(cdk.propertyValidator("transitGatewayId", cdk.validateString)(properties.transitGatewayId));
  return errors.wrap("supplied properties not correct for \\"CfnTransitGatewayRouteTableProps\\"");
}

// @ts-ignore TS6133
function convertCfnTransitGatewayRouteTablePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTransitGatewayRouteTablePropsValidator(properties).assertSuccess();
  return {
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "TransitGatewayId": cdk.stringToCloudFormation(properties.transitGatewayId)
  };
}

// @ts-ignore TS6133
function CfnTransitGatewayRouteTablePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnTransitGatewayRouteTableProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTransitGatewayRouteTableProps>();
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("transitGatewayId", "TransitGatewayId", (properties.TransitGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.TransitGatewayId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Associates the specified attachment with the specified transit gateway route table.
 *
 * You can associate one route table with an attachment.
 *
 * Before you can update the route table associated with an attachment, you must disassociate the transit gateway route table that is currently associated with the attachment. First update the stack to remove the associated transit gateway route table, and then update the stack with the ID of the new transit gateway route table to associate.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetableassociation.html
 */
export class CfnTransitGatewayRouteTableAssociation extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::TransitGatewayRouteTableAssociation";

  /**
   * Build a CfnTransitGatewayRouteTableAssociation from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnTransitGatewayRouteTableAssociation {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnTransitGatewayRouteTableAssociationPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnTransitGatewayRouteTableAssociation(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The ID of the attachment.
   */
  public transitGatewayAttachmentId: string;

  /**
   * The ID of the route table for the transit gateway.
   */
  public transitGatewayRouteTableId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnTransitGatewayRouteTableAssociationProps) {
    super(scope, id, {
      "type": CfnTransitGatewayRouteTableAssociation.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "transitGatewayAttachmentId", this);
    cdk.requireProperty(props, "transitGatewayRouteTableId", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.transitGatewayAttachmentId = props.transitGatewayAttachmentId;
    this.transitGatewayRouteTableId = props.transitGatewayRouteTableId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "transitGatewayAttachmentId": this.transitGatewayAttachmentId,
      "transitGatewayRouteTableId": this.transitGatewayRouteTableId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnTransitGatewayRouteTableAssociation.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnTransitGatewayRouteTableAssociationPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnTransitGatewayRouteTableAssociation\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetableassociation.html
 */
export interface CfnTransitGatewayRouteTableAssociationProps {
  /**
   * The ID of the attachment.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetableassociation.html#cfn-ec2-transitgatewayroutetableassociation-transitgatewayattachmentid
   */
  readonly transitGatewayAttachmentId: string;

  /**
   * The ID of the route table for the transit gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetableassociation.html#cfn-ec2-transitgatewayroutetableassociation-transitgatewayroutetableid
   */
  readonly transitGatewayRouteTableId: string;
}

/**
 * Determine whether the given properties match those of a \`CfnTransitGatewayRouteTableAssociationProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnTransitGatewayRouteTableAssociationProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTransitGatewayRouteTableAssociationPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("transitGatewayAttachmentId", cdk.requiredValidator)(properties.transitGatewayAttachmentId));
  errors.collect(cdk.propertyValidator("transitGatewayAttachmentId", cdk.validateString)(properties.transitGatewayAttachmentId));
  errors.collect(cdk.propertyValidator("transitGatewayRouteTableId", cdk.requiredValidator)(properties.transitGatewayRouteTableId));
  errors.collect(cdk.propertyValidator("transitGatewayRouteTableId", cdk.validateString)(properties.transitGatewayRouteTableId));
  return errors.wrap("supplied properties not correct for \\"CfnTransitGatewayRouteTableAssociationProps\\"");
}

// @ts-ignore TS6133
function convertCfnTransitGatewayRouteTableAssociationPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTransitGatewayRouteTableAssociationPropsValidator(properties).assertSuccess();
  return {
    "TransitGatewayAttachmentId": cdk.stringToCloudFormation(properties.transitGatewayAttachmentId),
    "TransitGatewayRouteTableId": cdk.stringToCloudFormation(properties.transitGatewayRouteTableId)
  };
}

// @ts-ignore TS6133
function CfnTransitGatewayRouteTableAssociationPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnTransitGatewayRouteTableAssociationProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTransitGatewayRouteTableAssociationProps>();
  ret.addPropertyResult("transitGatewayAttachmentId", "TransitGatewayAttachmentId", (properties.TransitGatewayAttachmentId != null ? cfn_parse.FromCloudFormation.getString(properties.TransitGatewayAttachmentId) : undefined));
  ret.addPropertyResult("transitGatewayRouteTableId", "TransitGatewayRouteTableId", (properties.TransitGatewayRouteTableId != null ? cfn_parse.FromCloudFormation.getString(properties.TransitGatewayRouteTableId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Enables the specified attachment to propagate routes to the specified propagation route table.
 *
 * For more information about enabling transit gateway route propagation, see [EnableTransitGatewayRouteTablePropagation](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_EnableTransitGatewayRouteTablePropagation.html) in the *Amazon EC2 API Reference* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetablepropagation.html
 */
export class CfnTransitGatewayRouteTablePropagation extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::TransitGatewayRouteTablePropagation";

  /**
   * Build a CfnTransitGatewayRouteTablePropagation from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnTransitGatewayRouteTablePropagation {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnTransitGatewayRouteTablePropagationPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnTransitGatewayRouteTablePropagation(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The ID of the attachment.
   */
  public transitGatewayAttachmentId: string;

  /**
   * The ID of the propagation route table.
   */
  public transitGatewayRouteTableId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnTransitGatewayRouteTablePropagationProps) {
    super(scope, id, {
      "type": CfnTransitGatewayRouteTablePropagation.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "transitGatewayAttachmentId", this);
    cdk.requireProperty(props, "transitGatewayRouteTableId", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.transitGatewayAttachmentId = props.transitGatewayAttachmentId;
    this.transitGatewayRouteTableId = props.transitGatewayRouteTableId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "transitGatewayAttachmentId": this.transitGatewayAttachmentId,
      "transitGatewayRouteTableId": this.transitGatewayRouteTableId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnTransitGatewayRouteTablePropagation.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnTransitGatewayRouteTablePropagationPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnTransitGatewayRouteTablePropagation\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetablepropagation.html
 */
export interface CfnTransitGatewayRouteTablePropagationProps {
  /**
   * The ID of the attachment.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetablepropagation.html#cfn-ec2-transitgatewayroutetablepropagation-transitgatewayattachmentid
   */
  readonly transitGatewayAttachmentId: string;

  /**
   * The ID of the propagation route table.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetablepropagation.html#cfn-ec2-transitgatewayroutetablepropagation-transitgatewayroutetableid
   */
  readonly transitGatewayRouteTableId: string;
}

/**
 * Determine whether the given properties match those of a \`CfnTransitGatewayRouteTablePropagationProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnTransitGatewayRouteTablePropagationProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTransitGatewayRouteTablePropagationPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("transitGatewayAttachmentId", cdk.requiredValidator)(properties.transitGatewayAttachmentId));
  errors.collect(cdk.propertyValidator("transitGatewayAttachmentId", cdk.validateString)(properties.transitGatewayAttachmentId));
  errors.collect(cdk.propertyValidator("transitGatewayRouteTableId", cdk.requiredValidator)(properties.transitGatewayRouteTableId));
  errors.collect(cdk.propertyValidator("transitGatewayRouteTableId", cdk.validateString)(properties.transitGatewayRouteTableId));
  return errors.wrap("supplied properties not correct for \\"CfnTransitGatewayRouteTablePropagationProps\\"");
}

// @ts-ignore TS6133
function convertCfnTransitGatewayRouteTablePropagationPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTransitGatewayRouteTablePropagationPropsValidator(properties).assertSuccess();
  return {
    "TransitGatewayAttachmentId": cdk.stringToCloudFormation(properties.transitGatewayAttachmentId),
    "TransitGatewayRouteTableId": cdk.stringToCloudFormation(properties.transitGatewayRouteTableId)
  };
}

// @ts-ignore TS6133
function CfnTransitGatewayRouteTablePropagationPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnTransitGatewayRouteTablePropagationProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTransitGatewayRouteTablePropagationProps>();
  ret.addPropertyResult("transitGatewayAttachmentId", "TransitGatewayAttachmentId", (properties.TransitGatewayAttachmentId != null ? cfn_parse.FromCloudFormation.getString(properties.TransitGatewayAttachmentId) : undefined));
  ret.addPropertyResult("transitGatewayRouteTableId", "TransitGatewayRouteTableId", (properties.TransitGatewayRouteTableId != null ? cfn_parse.FromCloudFormation.getString(properties.TransitGatewayRouteTableId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a VPC attachment.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html
 */
export class CfnTransitGatewayVpcAttachment extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::TransitGatewayVpcAttachment";

  /**
   * Build a CfnTransitGatewayVpcAttachment from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnTransitGatewayVpcAttachment {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnTransitGatewayVpcAttachmentPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnTransitGatewayVpcAttachment(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the attachment.
   *
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The IDs of one or more subnets to add.
   */
  public addSubnetIds?: Array<string>;

  /**
   * The VPC attachment options, in JSON or YAML.
   */
  public options?: any | cdk.IResolvable;

  /**
   * The IDs of one or more subnets to remove.
   */
  public removeSubnetIds?: Array<string>;

  /**
   * The IDs of the subnets.
   */
  public subnetIds: Array<string>;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags for the VPC attachment.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The ID of the transit gateway.
   */
  public transitGatewayId: string;

  /**
   * The ID of the VPC.
   */
  public vpcId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnTransitGatewayVpcAttachmentProps) {
    super(scope, id, {
      "type": CfnTransitGatewayVpcAttachment.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "subnetIds", this);
    cdk.requireProperty(props, "transitGatewayId", this);
    cdk.requireProperty(props, "vpcId", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.addSubnetIds = props.addSubnetIds;
    this.options = props.options;
    this.removeSubnetIds = props.removeSubnetIds;
    this.subnetIds = props.subnetIds;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::TransitGatewayVpcAttachment", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.transitGatewayId = props.transitGatewayId;
    this.vpcId = props.vpcId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "addSubnetIds": this.addSubnetIds,
      "options": this.options,
      "removeSubnetIds": this.removeSubnetIds,
      "subnetIds": this.subnetIds,
      "tags": this.tags.renderTags(),
      "transitGatewayId": this.transitGatewayId,
      "vpcId": this.vpcId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnTransitGatewayVpcAttachment.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnTransitGatewayVpcAttachmentPropsToCloudFormation(props);
  }
}

export namespace CfnTransitGatewayVpcAttachment {
  /**
   * Describes the VPC attachment options.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayvpcattachment-options.html
   */
  export interface OptionsProperty {
    /**
     * Indicates whether appliance mode support is enabled.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayvpcattachment-options.html#cfn-ec2-transitgatewayvpcattachment-options-appliancemodesupport
     */
    readonly applianceModeSupport?: string;

    /**
     * Indicates whether DNS support is enabled.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayvpcattachment-options.html#cfn-ec2-transitgatewayvpcattachment-options-dnssupport
     */
    readonly dnsSupport?: string;

    /**
     * Indicates whether IPv6 support is disabled.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayvpcattachment-options.html#cfn-ec2-transitgatewayvpcattachment-options-ipv6support
     */
    readonly ipv6Support?: string;
  }
}

/**
 * Properties for defining a \`CfnTransitGatewayVpcAttachment\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html
 */
export interface CfnTransitGatewayVpcAttachmentProps {
  /**
   * The IDs of one or more subnets to add.
   *
   * You can specify at most one subnet per Availability Zone.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-addsubnetids
   */
  readonly addSubnetIds?: Array<string>;

  /**
   * The VPC attachment options, in JSON or YAML.
   *
   * - \`ApplianceModeSupport\` - Set to \`enable\` or \`disable\` . The default is \`disable\` .
   * - \`DnsSupport\` - Set to \`enable\` or \`disable\` . The default is \`enable\` .
   * - \`Ipv6Support\` - Set to \`enable\` or \`disable\` . The default is \`disable\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-options
   */
  readonly options?: any | cdk.IResolvable;

  /**
   * The IDs of one or more subnets to remove.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-removesubnetids
   */
  readonly removeSubnetIds?: Array<string>;

  /**
   * The IDs of the subnets.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-subnetids
   */
  readonly subnetIds: Array<string>;

  /**
   * The tags for the VPC attachment.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The ID of the transit gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-transitgatewayid
   */
  readonly transitGatewayId: string;

  /**
   * The ID of the VPC.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-vpcid
   */
  readonly vpcId: string;
}

/**
 * Determine whether the given properties match those of a \`OptionsProperty\`
 *
 * @param properties - the TypeScript properties of a \`OptionsProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTransitGatewayVpcAttachmentOptionsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("applianceModeSupport", cdk.validateString)(properties.applianceModeSupport));
  errors.collect(cdk.propertyValidator("dnsSupport", cdk.validateString)(properties.dnsSupport));
  errors.collect(cdk.propertyValidator("ipv6Support", cdk.validateString)(properties.ipv6Support));
  return errors.wrap("supplied properties not correct for \\"OptionsProperty\\"");
}

// @ts-ignore TS6133
function convertCfnTransitGatewayVpcAttachmentOptionsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTransitGatewayVpcAttachmentOptionsPropertyValidator(properties).assertSuccess();
  return {
    "ApplianceModeSupport": cdk.stringToCloudFormation(properties.applianceModeSupport),
    "DnsSupport": cdk.stringToCloudFormation(properties.dnsSupport),
    "Ipv6Support": cdk.stringToCloudFormation(properties.ipv6Support)
  };
}

// @ts-ignore TS6133
function CfnTransitGatewayVpcAttachmentOptionsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnTransitGatewayVpcAttachment.OptionsProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTransitGatewayVpcAttachment.OptionsProperty>();
  ret.addPropertyResult("applianceModeSupport", "ApplianceModeSupport", (properties.ApplianceModeSupport != null ? cfn_parse.FromCloudFormation.getString(properties.ApplianceModeSupport) : undefined));
  ret.addPropertyResult("dnsSupport", "DnsSupport", (properties.DnsSupport != null ? cfn_parse.FromCloudFormation.getString(properties.DnsSupport) : undefined));
  ret.addPropertyResult("ipv6Support", "Ipv6Support", (properties.Ipv6Support != null ? cfn_parse.FromCloudFormation.getString(properties.Ipv6Support) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnTransitGatewayVpcAttachmentProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnTransitGatewayVpcAttachmentProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTransitGatewayVpcAttachmentPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("addSubnetIds", cdk.listValidator(cdk.validateString))(properties.addSubnetIds));
  errors.collect(cdk.propertyValidator("options", cdk.validateObject)(properties.options));
  errors.collect(cdk.propertyValidator("removeSubnetIds", cdk.listValidator(cdk.validateString))(properties.removeSubnetIds));
  errors.collect(cdk.propertyValidator("subnetIds", cdk.requiredValidator)(properties.subnetIds));
  errors.collect(cdk.propertyValidator("subnetIds", cdk.listValidator(cdk.validateString))(properties.subnetIds));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("transitGatewayId", cdk.requiredValidator)(properties.transitGatewayId));
  errors.collect(cdk.propertyValidator("transitGatewayId", cdk.validateString)(properties.transitGatewayId));
  errors.collect(cdk.propertyValidator("vpcId", cdk.requiredValidator)(properties.vpcId));
  errors.collect(cdk.propertyValidator("vpcId", cdk.validateString)(properties.vpcId));
  return errors.wrap("supplied properties not correct for \\"CfnTransitGatewayVpcAttachmentProps\\"");
}

// @ts-ignore TS6133
function convertCfnTransitGatewayVpcAttachmentPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTransitGatewayVpcAttachmentPropsValidator(properties).assertSuccess();
  return {
    "AddSubnetIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.addSubnetIds),
    "Options": cdk.objectToCloudFormation(properties.options),
    "RemoveSubnetIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.removeSubnetIds),
    "SubnetIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.subnetIds),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "TransitGatewayId": cdk.stringToCloudFormation(properties.transitGatewayId),
    "VpcId": cdk.stringToCloudFormation(properties.vpcId)
  };
}

// @ts-ignore TS6133
function CfnTransitGatewayVpcAttachmentPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnTransitGatewayVpcAttachmentProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTransitGatewayVpcAttachmentProps>();
  ret.addPropertyResult("addSubnetIds", "AddSubnetIds", (properties.AddSubnetIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.AddSubnetIds) : undefined));
  ret.addPropertyResult("options", "Options", (properties.Options != null ? cfn_parse.FromCloudFormation.getAny(properties.Options) : undefined));
  ret.addPropertyResult("removeSubnetIds", "RemoveSubnetIds", (properties.RemoveSubnetIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.RemoveSubnetIds) : undefined));
  ret.addPropertyResult("subnetIds", "SubnetIds", (properties.SubnetIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SubnetIds) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("transitGatewayId", "TransitGatewayId", (properties.TransitGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.TransitGatewayId) : undefined));
  ret.addPropertyResult("vpcId", "VpcId", (properties.VpcId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * An AWS Verified Access endpoint specifies the application that AWS Verified Access provides access to.
 *
 * It must be attached to an AWS Verified Access group. An AWS Verified Access endpoint must also have an attached access policy before you attached it to a group.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html
 */
export class CfnVerifiedAccessEndpoint extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::VerifiedAccessEndpoint";

  /**
   * Build a CfnVerifiedAccessEndpoint from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnVerifiedAccessEndpoint {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnVerifiedAccessEndpointPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnVerifiedAccessEndpoint(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The creation time.
   *
   * @cloudformationAttribute CreationTime
   */
  public readonly attrCreationTime: string;

  /**
   * Use this to construct the redirect URI to add to your OIDC provider's allow list.
   *
   * @cloudformationAttribute DeviceValidationDomain
   */
  public readonly attrDeviceValidationDomain: string;

  /**
   * The DNS name generated for the endpoint.
   *
   * @cloudformationAttribute EndpointDomain
   */
  public readonly attrEndpointDomain: string;

  /**
   * The last updated time.
   *
   * @cloudformationAttribute LastUpdatedTime
   */
  public readonly attrLastUpdatedTime: string;

  /**
   * The endpoint status.
   *
   * @cloudformationAttribute Status
   */
  public readonly attrStatus: string;

  /**
   * The ID of the Verified Access endpoint.
   *
   * @cloudformationAttribute VerifiedAccessEndpointId
   */
  public readonly attrVerifiedAccessEndpointId: string;

  /**
   * The instance identifier.
   *
   * @cloudformationAttribute VerifiedAccessInstanceId
   */
  public readonly attrVerifiedAccessInstanceId: string;

  /**
   * The DNS name for users to reach your application.
   */
  public applicationDomain: string;

  /**
   * The type of attachment used to provide connectivity between the AWS Verified Access endpoint and the application.
   */
  public attachmentType: string;

  /**
   * A description for the AWS Verified Access endpoint.
   */
  public description?: string;

  /**
   * The ARN of a public TLS/SSL certificate imported into or created with ACM.
   */
  public domainCertificateArn: string;

  /**
   * A custom identifier that is prepended to the DNS name that is generated for the endpoint.
   */
  public endpointDomainPrefix: string;

  /**
   * The type of AWS Verified Access endpoint.
   */
  public endpointType: string;

  /**
   * The load balancer details if creating the AWS Verified Access endpoint as \`load-balancer\` type.
   */
  public loadBalancerOptions?: cdk.IResolvable | CfnVerifiedAccessEndpoint.LoadBalancerOptionsProperty;

  /**
   * The options for network-interface type endpoint.
   */
  public networkInterfaceOptions?: cdk.IResolvable | CfnVerifiedAccessEndpoint.NetworkInterfaceOptionsProperty;

  /**
   * The Verified Access policy document.
   */
  public policyDocument?: string;

  /**
   * The status of the Verified Access policy.
   */
  public policyEnabled?: boolean | cdk.IResolvable;

  /**
   * The IDs of the security groups for the endpoint.
   */
  public securityGroupIds?: Array<string>;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The ID of the AWS Verified Access group.
   */
  public verifiedAccessGroupId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnVerifiedAccessEndpointProps) {
    super(scope, id, {
      "type": CfnVerifiedAccessEndpoint.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "applicationDomain", this);
    cdk.requireProperty(props, "attachmentType", this);
    cdk.requireProperty(props, "domainCertificateArn", this);
    cdk.requireProperty(props, "endpointDomainPrefix", this);
    cdk.requireProperty(props, "endpointType", this);
    cdk.requireProperty(props, "verifiedAccessGroupId", this);

    this.attrCreationTime = cdk.Token.asString(this.getAtt("CreationTime", cdk.ResolutionTypeHint.STRING));
    this.attrDeviceValidationDomain = cdk.Token.asString(this.getAtt("DeviceValidationDomain", cdk.ResolutionTypeHint.STRING));
    this.attrEndpointDomain = cdk.Token.asString(this.getAtt("EndpointDomain", cdk.ResolutionTypeHint.STRING));
    this.attrLastUpdatedTime = cdk.Token.asString(this.getAtt("LastUpdatedTime", cdk.ResolutionTypeHint.STRING));
    this.attrStatus = cdk.Token.asString(this.getAtt("Status", cdk.ResolutionTypeHint.STRING));
    this.attrVerifiedAccessEndpointId = cdk.Token.asString(this.getAtt("VerifiedAccessEndpointId", cdk.ResolutionTypeHint.STRING));
    this.attrVerifiedAccessInstanceId = cdk.Token.asString(this.getAtt("VerifiedAccessInstanceId", cdk.ResolutionTypeHint.STRING));
    this.applicationDomain = props.applicationDomain;
    this.attachmentType = props.attachmentType;
    this.description = props.description;
    this.domainCertificateArn = props.domainCertificateArn;
    this.endpointDomainPrefix = props.endpointDomainPrefix;
    this.endpointType = props.endpointType;
    this.loadBalancerOptions = props.loadBalancerOptions;
    this.networkInterfaceOptions = props.networkInterfaceOptions;
    this.policyDocument = props.policyDocument;
    this.policyEnabled = props.policyEnabled;
    this.securityGroupIds = props.securityGroupIds;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::VerifiedAccessEndpoint", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.verifiedAccessGroupId = props.verifiedAccessGroupId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "applicationDomain": this.applicationDomain,
      "attachmentType": this.attachmentType,
      "description": this.description,
      "domainCertificateArn": this.domainCertificateArn,
      "endpointDomainPrefix": this.endpointDomainPrefix,
      "endpointType": this.endpointType,
      "loadBalancerOptions": this.loadBalancerOptions,
      "networkInterfaceOptions": this.networkInterfaceOptions,
      "policyDocument": this.policyDocument,
      "policyEnabled": this.policyEnabled,
      "securityGroupIds": this.securityGroupIds,
      "tags": this.tags.renderTags(),
      "verifiedAccessGroupId": this.verifiedAccessGroupId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnVerifiedAccessEndpoint.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnVerifiedAccessEndpointPropsToCloudFormation(props);
  }
}

export namespace CfnVerifiedAccessEndpoint {
  /**
   * Describes the network interface options when creating an AWS Verified Access endpoint using the \`network-interface\` type.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-networkinterfaceoptions.html
   */
  export interface NetworkInterfaceOptionsProperty {
    /**
     * The ID of the network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-networkinterfaceoptions.html#cfn-ec2-verifiedaccessendpoint-networkinterfaceoptions-networkinterfaceid
     */
    readonly networkInterfaceId?: string;

    /**
     * The IP port number.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-networkinterfaceoptions.html#cfn-ec2-verifiedaccessendpoint-networkinterfaceoptions-port
     */
    readonly port?: number;

    /**
     * The IP protocol.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-networkinterfaceoptions.html#cfn-ec2-verifiedaccessendpoint-networkinterfaceoptions-protocol
     */
    readonly protocol?: string;
  }

  /**
   * Describes the load balancer options when creating an AWS Verified Access endpoint using the \`load-balancer\` type.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-loadbalanceroptions.html
   */
  export interface LoadBalancerOptionsProperty {
    /**
     * The ARN of the load balancer.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-loadbalanceroptions.html#cfn-ec2-verifiedaccessendpoint-loadbalanceroptions-loadbalancerarn
     */
    readonly loadBalancerArn?: string;

    /**
     * The IP port number.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-loadbalanceroptions.html#cfn-ec2-verifiedaccessendpoint-loadbalanceroptions-port
     */
    readonly port?: number;

    /**
     * The IP protocol.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-loadbalanceroptions.html#cfn-ec2-verifiedaccessendpoint-loadbalanceroptions-protocol
     */
    readonly protocol?: string;

    /**
     * The IDs of the subnets.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-loadbalanceroptions.html#cfn-ec2-verifiedaccessendpoint-loadbalanceroptions-subnetids
     */
    readonly subnetIds?: Array<string>;
  }
}

/**
 * Properties for defining a \`CfnVerifiedAccessEndpoint\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html
 */
export interface CfnVerifiedAccessEndpointProps {
  /**
   * The DNS name for users to reach your application.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-applicationdomain
   */
  readonly applicationDomain: string;

  /**
   * The type of attachment used to provide connectivity between the AWS Verified Access endpoint and the application.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-attachmenttype
   */
  readonly attachmentType: string;

  /**
   * A description for the AWS Verified Access endpoint.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-description
   */
  readonly description?: string;

  /**
   * The ARN of a public TLS/SSL certificate imported into or created with ACM.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-domaincertificatearn
   */
  readonly domainCertificateArn: string;

  /**
   * A custom identifier that is prepended to the DNS name that is generated for the endpoint.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-endpointdomainprefix
   */
  readonly endpointDomainPrefix: string;

  /**
   * The type of AWS Verified Access endpoint.
   *
   * Incoming application requests will be sent to an IP address, load balancer or a network interface depending on the endpoint type specified.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-endpointtype
   */
  readonly endpointType: string;

  /**
   * The load balancer details if creating the AWS Verified Access endpoint as \`load-balancer\` type.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-loadbalanceroptions
   */
  readonly loadBalancerOptions?: cdk.IResolvable | CfnVerifiedAccessEndpoint.LoadBalancerOptionsProperty;

  /**
   * The options for network-interface type endpoint.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-networkinterfaceoptions
   */
  readonly networkInterfaceOptions?: cdk.IResolvable | CfnVerifiedAccessEndpoint.NetworkInterfaceOptionsProperty;

  /**
   * The Verified Access policy document.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-policydocument
   */
  readonly policyDocument?: string;

  /**
   * The status of the Verified Access policy.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-policyenabled
   */
  readonly policyEnabled?: boolean | cdk.IResolvable;

  /**
   * The IDs of the security groups for the endpoint.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-securitygroupids
   */
  readonly securityGroupIds?: Array<string>;

  /**
   * The tags.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The ID of the AWS Verified Access group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-verifiedaccessgroupid
   */
  readonly verifiedAccessGroupId: string;
}

/**
 * Determine whether the given properties match those of a \`NetworkInterfaceOptionsProperty\`
 *
 * @param properties - the TypeScript properties of a \`NetworkInterfaceOptionsProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVerifiedAccessEndpointNetworkInterfaceOptionsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("networkInterfaceId", cdk.validateString)(properties.networkInterfaceId));
  errors.collect(cdk.propertyValidator("port", cdk.validateNumber)(properties.port));
  errors.collect(cdk.propertyValidator("protocol", cdk.validateString)(properties.protocol));
  return errors.wrap("supplied properties not correct for \\"NetworkInterfaceOptionsProperty\\"");
}

// @ts-ignore TS6133
function convertCfnVerifiedAccessEndpointNetworkInterfaceOptionsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVerifiedAccessEndpointNetworkInterfaceOptionsPropertyValidator(properties).assertSuccess();
  return {
    "NetworkInterfaceId": cdk.stringToCloudFormation(properties.networkInterfaceId),
    "Port": cdk.numberToCloudFormation(properties.port),
    "Protocol": cdk.stringToCloudFormation(properties.protocol)
  };
}

// @ts-ignore TS6133
function CfnVerifiedAccessEndpointNetworkInterfaceOptionsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnVerifiedAccessEndpoint.NetworkInterfaceOptionsProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVerifiedAccessEndpoint.NetworkInterfaceOptionsProperty>();
  ret.addPropertyResult("networkInterfaceId", "NetworkInterfaceId", (properties.NetworkInterfaceId != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkInterfaceId) : undefined));
  ret.addPropertyResult("port", "Port", (properties.Port != null ? cfn_parse.FromCloudFormation.getNumber(properties.Port) : undefined));
  ret.addPropertyResult("protocol", "Protocol", (properties.Protocol != null ? cfn_parse.FromCloudFormation.getString(properties.Protocol) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`LoadBalancerOptionsProperty\`
 *
 * @param properties - the TypeScript properties of a \`LoadBalancerOptionsProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVerifiedAccessEndpointLoadBalancerOptionsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("loadBalancerArn", cdk.validateString)(properties.loadBalancerArn));
  errors.collect(cdk.propertyValidator("port", cdk.validateNumber)(properties.port));
  errors.collect(cdk.propertyValidator("protocol", cdk.validateString)(properties.protocol));
  errors.collect(cdk.propertyValidator("subnetIds", cdk.listValidator(cdk.validateString))(properties.subnetIds));
  return errors.wrap("supplied properties not correct for \\"LoadBalancerOptionsProperty\\"");
}

// @ts-ignore TS6133
function convertCfnVerifiedAccessEndpointLoadBalancerOptionsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVerifiedAccessEndpointLoadBalancerOptionsPropertyValidator(properties).assertSuccess();
  return {
    "LoadBalancerArn": cdk.stringToCloudFormation(properties.loadBalancerArn),
    "Port": cdk.numberToCloudFormation(properties.port),
    "Protocol": cdk.stringToCloudFormation(properties.protocol),
    "SubnetIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.subnetIds)
  };
}

// @ts-ignore TS6133
function CfnVerifiedAccessEndpointLoadBalancerOptionsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnVerifiedAccessEndpoint.LoadBalancerOptionsProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVerifiedAccessEndpoint.LoadBalancerOptionsProperty>();
  ret.addPropertyResult("loadBalancerArn", "LoadBalancerArn", (properties.LoadBalancerArn != null ? cfn_parse.FromCloudFormation.getString(properties.LoadBalancerArn) : undefined));
  ret.addPropertyResult("port", "Port", (properties.Port != null ? cfn_parse.FromCloudFormation.getNumber(properties.Port) : undefined));
  ret.addPropertyResult("protocol", "Protocol", (properties.Protocol != null ? cfn_parse.FromCloudFormation.getString(properties.Protocol) : undefined));
  ret.addPropertyResult("subnetIds", "SubnetIds", (properties.SubnetIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SubnetIds) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnVerifiedAccessEndpointProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnVerifiedAccessEndpointProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVerifiedAccessEndpointPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("applicationDomain", cdk.requiredValidator)(properties.applicationDomain));
  errors.collect(cdk.propertyValidator("applicationDomain", cdk.validateString)(properties.applicationDomain));
  errors.collect(cdk.propertyValidator("attachmentType", cdk.requiredValidator)(properties.attachmentType));
  errors.collect(cdk.propertyValidator("attachmentType", cdk.validateString)(properties.attachmentType));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("domainCertificateArn", cdk.requiredValidator)(properties.domainCertificateArn));
  errors.collect(cdk.propertyValidator("domainCertificateArn", cdk.validateString)(properties.domainCertificateArn));
  errors.collect(cdk.propertyValidator("endpointDomainPrefix", cdk.requiredValidator)(properties.endpointDomainPrefix));
  errors.collect(cdk.propertyValidator("endpointDomainPrefix", cdk.validateString)(properties.endpointDomainPrefix));
  errors.collect(cdk.propertyValidator("endpointType", cdk.requiredValidator)(properties.endpointType));
  errors.collect(cdk.propertyValidator("endpointType", cdk.validateString)(properties.endpointType));
  errors.collect(cdk.propertyValidator("loadBalancerOptions", CfnVerifiedAccessEndpointLoadBalancerOptionsPropertyValidator)(properties.loadBalancerOptions));
  errors.collect(cdk.propertyValidator("networkInterfaceOptions", CfnVerifiedAccessEndpointNetworkInterfaceOptionsPropertyValidator)(properties.networkInterfaceOptions));
  errors.collect(cdk.propertyValidator("policyDocument", cdk.validateString)(properties.policyDocument));
  errors.collect(cdk.propertyValidator("policyEnabled", cdk.validateBoolean)(properties.policyEnabled));
  errors.collect(cdk.propertyValidator("securityGroupIds", cdk.listValidator(cdk.validateString))(properties.securityGroupIds));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("verifiedAccessGroupId", cdk.requiredValidator)(properties.verifiedAccessGroupId));
  errors.collect(cdk.propertyValidator("verifiedAccessGroupId", cdk.validateString)(properties.verifiedAccessGroupId));
  return errors.wrap("supplied properties not correct for \\"CfnVerifiedAccessEndpointProps\\"");
}

// @ts-ignore TS6133
function convertCfnVerifiedAccessEndpointPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVerifiedAccessEndpointPropsValidator(properties).assertSuccess();
  return {
    "ApplicationDomain": cdk.stringToCloudFormation(properties.applicationDomain),
    "AttachmentType": cdk.stringToCloudFormation(properties.attachmentType),
    "Description": cdk.stringToCloudFormation(properties.description),
    "DomainCertificateArn": cdk.stringToCloudFormation(properties.domainCertificateArn),
    "EndpointDomainPrefix": cdk.stringToCloudFormation(properties.endpointDomainPrefix),
    "EndpointType": cdk.stringToCloudFormation(properties.endpointType),
    "LoadBalancerOptions": convertCfnVerifiedAccessEndpointLoadBalancerOptionsPropertyToCloudFormation(properties.loadBalancerOptions),
    "NetworkInterfaceOptions": convertCfnVerifiedAccessEndpointNetworkInterfaceOptionsPropertyToCloudFormation(properties.networkInterfaceOptions),
    "PolicyDocument": cdk.stringToCloudFormation(properties.policyDocument),
    "PolicyEnabled": cdk.booleanToCloudFormation(properties.policyEnabled),
    "SecurityGroupIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.securityGroupIds),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "VerifiedAccessGroupId": cdk.stringToCloudFormation(properties.verifiedAccessGroupId)
  };
}

// @ts-ignore TS6133
function CfnVerifiedAccessEndpointPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnVerifiedAccessEndpointProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVerifiedAccessEndpointProps>();
  ret.addPropertyResult("applicationDomain", "ApplicationDomain", (properties.ApplicationDomain != null ? cfn_parse.FromCloudFormation.getString(properties.ApplicationDomain) : undefined));
  ret.addPropertyResult("attachmentType", "AttachmentType", (properties.AttachmentType != null ? cfn_parse.FromCloudFormation.getString(properties.AttachmentType) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("domainCertificateArn", "DomainCertificateArn", (properties.DomainCertificateArn != null ? cfn_parse.FromCloudFormation.getString(properties.DomainCertificateArn) : undefined));
  ret.addPropertyResult("endpointDomainPrefix", "EndpointDomainPrefix", (properties.EndpointDomainPrefix != null ? cfn_parse.FromCloudFormation.getString(properties.EndpointDomainPrefix) : undefined));
  ret.addPropertyResult("endpointType", "EndpointType", (properties.EndpointType != null ? cfn_parse.FromCloudFormation.getString(properties.EndpointType) : undefined));
  ret.addPropertyResult("loadBalancerOptions", "LoadBalancerOptions", (properties.LoadBalancerOptions != null ? CfnVerifiedAccessEndpointLoadBalancerOptionsPropertyFromCloudFormation(properties.LoadBalancerOptions) : undefined));
  ret.addPropertyResult("networkInterfaceOptions", "NetworkInterfaceOptions", (properties.NetworkInterfaceOptions != null ? CfnVerifiedAccessEndpointNetworkInterfaceOptionsPropertyFromCloudFormation(properties.NetworkInterfaceOptions) : undefined));
  ret.addPropertyResult("policyDocument", "PolicyDocument", (properties.PolicyDocument != null ? cfn_parse.FromCloudFormation.getString(properties.PolicyDocument) : undefined));
  ret.addPropertyResult("policyEnabled", "PolicyEnabled", (properties.PolicyEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.PolicyEnabled) : undefined));
  ret.addPropertyResult("securityGroupIds", "SecurityGroupIds", (properties.SecurityGroupIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecurityGroupIds) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("verifiedAccessGroupId", "VerifiedAccessGroupId", (properties.VerifiedAccessGroupId != null ? cfn_parse.FromCloudFormation.getString(properties.VerifiedAccessGroupId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Describes a Verified Access group.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessgroup.html
 */
export class CfnVerifiedAccessGroup extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::VerifiedAccessGroup";

  /**
   * Build a CfnVerifiedAccessGroup from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnVerifiedAccessGroup {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnVerifiedAccessGroupPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnVerifiedAccessGroup(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The creation time.
   *
   * @cloudformationAttribute CreationTime
   */
  public readonly attrCreationTime: string;

  /**
   * The last updated time.
   *
   * @cloudformationAttribute LastUpdatedTime
   */
  public readonly attrLastUpdatedTime: string;

  /**
   * The ID of the AWS account that owns the group.
   *
   * @cloudformationAttribute Owner
   */
  public readonly attrOwner: string;

  /**
   * The ARN of the Verified Access group.
   *
   * @cloudformationAttribute VerifiedAccessGroupArn
   */
  public readonly attrVerifiedAccessGroupArn: string;

  /**
   * The ID of the Verified Access group.
   *
   * @cloudformationAttribute VerifiedAccessGroupId
   */
  public readonly attrVerifiedAccessGroupId: string;

  /**
   * A description for the AWS Verified Access group.
   */
  public description?: string;

  /**
   * The Verified Access policy document.
   */
  public policyDocument?: string;

  /**
   * The status of the Verified Access policy.
   */
  public policyEnabled?: boolean | cdk.IResolvable;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The ID of the AWS Verified Access instance.
   */
  public verifiedAccessInstanceId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnVerifiedAccessGroupProps) {
    super(scope, id, {
      "type": CfnVerifiedAccessGroup.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "verifiedAccessInstanceId", this);

    this.attrCreationTime = cdk.Token.asString(this.getAtt("CreationTime", cdk.ResolutionTypeHint.STRING));
    this.attrLastUpdatedTime = cdk.Token.asString(this.getAtt("LastUpdatedTime", cdk.ResolutionTypeHint.STRING));
    this.attrOwner = cdk.Token.asString(this.getAtt("Owner", cdk.ResolutionTypeHint.STRING));
    this.attrVerifiedAccessGroupArn = cdk.Token.asString(this.getAtt("VerifiedAccessGroupArn", cdk.ResolutionTypeHint.STRING));
    this.attrVerifiedAccessGroupId = cdk.Token.asString(this.getAtt("VerifiedAccessGroupId", cdk.ResolutionTypeHint.STRING));
    this.description = props.description;
    this.policyDocument = props.policyDocument;
    this.policyEnabled = props.policyEnabled;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::VerifiedAccessGroup", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.verifiedAccessInstanceId = props.verifiedAccessInstanceId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "description": this.description,
      "policyDocument": this.policyDocument,
      "policyEnabled": this.policyEnabled,
      "tags": this.tags.renderTags(),
      "verifiedAccessInstanceId": this.verifiedAccessInstanceId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnVerifiedAccessGroup.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnVerifiedAccessGroupPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnVerifiedAccessGroup\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessgroup.html
 */
export interface CfnVerifiedAccessGroupProps {
  /**
   * A description for the AWS Verified Access group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessgroup.html#cfn-ec2-verifiedaccessgroup-description
   */
  readonly description?: string;

  /**
   * The Verified Access policy document.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessgroup.html#cfn-ec2-verifiedaccessgroup-policydocument
   */
  readonly policyDocument?: string;

  /**
   * The status of the Verified Access policy.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessgroup.html#cfn-ec2-verifiedaccessgroup-policyenabled
   */
  readonly policyEnabled?: boolean | cdk.IResolvable;

  /**
   * The tags.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessgroup.html#cfn-ec2-verifiedaccessgroup-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The ID of the AWS Verified Access instance.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessgroup.html#cfn-ec2-verifiedaccessgroup-verifiedaccessinstanceid
   */
  readonly verifiedAccessInstanceId: string;
}

/**
 * Determine whether the given properties match those of a \`CfnVerifiedAccessGroupProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnVerifiedAccessGroupProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVerifiedAccessGroupPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("policyDocument", cdk.validateString)(properties.policyDocument));
  errors.collect(cdk.propertyValidator("policyEnabled", cdk.validateBoolean)(properties.policyEnabled));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("verifiedAccessInstanceId", cdk.requiredValidator)(properties.verifiedAccessInstanceId));
  errors.collect(cdk.propertyValidator("verifiedAccessInstanceId", cdk.validateString)(properties.verifiedAccessInstanceId));
  return errors.wrap("supplied properties not correct for \\"CfnVerifiedAccessGroupProps\\"");
}

// @ts-ignore TS6133
function convertCfnVerifiedAccessGroupPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVerifiedAccessGroupPropsValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "PolicyDocument": cdk.stringToCloudFormation(properties.policyDocument),
    "PolicyEnabled": cdk.booleanToCloudFormation(properties.policyEnabled),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "VerifiedAccessInstanceId": cdk.stringToCloudFormation(properties.verifiedAccessInstanceId)
  };
}

// @ts-ignore TS6133
function CfnVerifiedAccessGroupPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnVerifiedAccessGroupProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVerifiedAccessGroupProps>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("policyDocument", "PolicyDocument", (properties.PolicyDocument != null ? cfn_parse.FromCloudFormation.getString(properties.PolicyDocument) : undefined));
  ret.addPropertyResult("policyEnabled", "PolicyEnabled", (properties.PolicyEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.PolicyEnabled) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("verifiedAccessInstanceId", "VerifiedAccessInstanceId", (properties.VerifiedAccessInstanceId != null ? cfn_parse.FromCloudFormation.getString(properties.VerifiedAccessInstanceId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Describes a Verified Access instance.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessinstance.html
 */
export class CfnVerifiedAccessInstance extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::VerifiedAccessInstance";

  /**
   * Build a CfnVerifiedAccessInstance from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnVerifiedAccessInstance {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnVerifiedAccessInstancePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnVerifiedAccessInstance(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The creation time.
   *
   * @cloudformationAttribute CreationTime
   */
  public readonly attrCreationTime: string;

  /**
   * The last updated time.
   *
   * @cloudformationAttribute LastUpdatedTime
   */
  public readonly attrLastUpdatedTime: string;

  /**
   * The ID of the Verified Access instance.
   *
   * @cloudformationAttribute VerifiedAccessInstanceId
   */
  public readonly attrVerifiedAccessInstanceId: string;

  /**
   * A description for the AWS Verified Access instance.
   */
  public description?: string;

  /**
   * The current logging configuration for the Verified Access instances.
   */
  public loggingConfigurations?: cdk.IResolvable | CfnVerifiedAccessInstance.VerifiedAccessLogsProperty;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The IDs of the AWS Verified Access trust providers.
   */
  public verifiedAccessTrustProviderIds?: Array<string>;

  /**
   * The IDs of the AWS Verified Access trust providers.
   */
  public verifiedAccessTrustProviders?: Array<cdk.IResolvable | CfnVerifiedAccessInstance.VerifiedAccessTrustProviderProperty> | cdk.IResolvable;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnVerifiedAccessInstanceProps = {}) {
    super(scope, id, {
      "type": CfnVerifiedAccessInstance.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.attrCreationTime = cdk.Token.asString(this.getAtt("CreationTime", cdk.ResolutionTypeHint.STRING));
    this.attrLastUpdatedTime = cdk.Token.asString(this.getAtt("LastUpdatedTime", cdk.ResolutionTypeHint.STRING));
    this.attrVerifiedAccessInstanceId = cdk.Token.asString(this.getAtt("VerifiedAccessInstanceId", cdk.ResolutionTypeHint.STRING));
    this.description = props.description;
    this.loggingConfigurations = props.loggingConfigurations;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::VerifiedAccessInstance", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.verifiedAccessTrustProviderIds = props.verifiedAccessTrustProviderIds;
    this.verifiedAccessTrustProviders = props.verifiedAccessTrustProviders;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "description": this.description,
      "loggingConfigurations": this.loggingConfigurations,
      "tags": this.tags.renderTags(),
      "verifiedAccessTrustProviderIds": this.verifiedAccessTrustProviderIds,
      "verifiedAccessTrustProviders": this.verifiedAccessTrustProviders
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnVerifiedAccessInstance.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnVerifiedAccessInstancePropsToCloudFormation(props);
  }
}

export namespace CfnVerifiedAccessInstance {
  /**
   * Describes a Verified Access trust provider.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-verifiedaccesstrustprovider.html
   */
  export interface VerifiedAccessTrustProviderProperty {
    /**
     * A description for the AWS Verified Access trust provider.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccessinstance-verifiedaccesstrustprovider-description
     */
    readonly description?: string;

    /**
     * The type of device-based trust provider.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccessinstance-verifiedaccesstrustprovider-devicetrustprovidertype
     */
    readonly deviceTrustProviderType?: string;

    /**
     * The type of Verified Access trust provider.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccessinstance-verifiedaccesstrustprovider-trustprovidertype
     */
    readonly trustProviderType?: string;

    /**
     * The type of user-based trust provider.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccessinstance-verifiedaccesstrustprovider-usertrustprovidertype
     */
    readonly userTrustProviderType?: string;

    /**
     * The ID of the AWS Verified Access trust provider.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccessinstance-verifiedaccesstrustprovider-verifiedaccesstrustproviderid
     */
    readonly verifiedAccessTrustProviderId?: string;
  }

  /**
   * Describes the options for Verified Access logs.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-verifiedaccesslogs.html
   */
  export interface VerifiedAccessLogsProperty {
    /**
     * CloudWatch Logs logging destination.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-verifiedaccesslogs.html#cfn-ec2-verifiedaccessinstance-verifiedaccesslogs-cloudwatchlogs
     */
    readonly cloudWatchLogs?: CfnVerifiedAccessInstance.CloudWatchLogsProperty | cdk.IResolvable;

    /**
     * Include trust data sent by trust providers into the logs.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-verifiedaccesslogs.html#cfn-ec2-verifiedaccessinstance-verifiedaccesslogs-includetrustcontext
     */
    readonly includeTrustContext?: boolean | cdk.IResolvable;

    /**
     * Kinesis logging destination.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-verifiedaccesslogs.html#cfn-ec2-verifiedaccessinstance-verifiedaccesslogs-kinesisdatafirehose
     */
    readonly kinesisDataFirehose?: cdk.IResolvable | CfnVerifiedAccessInstance.KinesisDataFirehoseProperty;

    /**
     * The logging version to use.
     *
     * Valid values: \`ocsf-0.1\` | \`ocsf-1.0.0-rc.2\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-verifiedaccesslogs.html#cfn-ec2-verifiedaccessinstance-verifiedaccesslogs-logversion
     */
    readonly logVersion?: string;

    /**
     * Amazon S3 logging options.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-verifiedaccesslogs.html#cfn-ec2-verifiedaccessinstance-verifiedaccesslogs-s3
     */
    readonly s3?: cdk.IResolvable | CfnVerifiedAccessInstance.S3Property;
  }

  /**
   * Options for CloudWatch Logs as a logging destination.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-cloudwatchlogs.html
   */
  export interface CloudWatchLogsProperty {
    /**
     * Indicates whether logging is enabled.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-cloudwatchlogs.html#cfn-ec2-verifiedaccessinstance-cloudwatchlogs-enabled
     */
    readonly enabled?: boolean | cdk.IResolvable;

    /**
     * The ID of the CloudWatch Logs log group.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-cloudwatchlogs.html#cfn-ec2-verifiedaccessinstance-cloudwatchlogs-loggroup
     */
    readonly logGroup?: string;
  }

  /**
   * Options for Kinesis as a logging destination.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-kinesisdatafirehose.html
   */
  export interface KinesisDataFirehoseProperty {
    /**
     * The ID of the delivery stream.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-kinesisdatafirehose.html#cfn-ec2-verifiedaccessinstance-kinesisdatafirehose-deliverystream
     */
    readonly deliveryStream?: string;

    /**
     * Indicates whether logging is enabled.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-kinesisdatafirehose.html#cfn-ec2-verifiedaccessinstance-kinesisdatafirehose-enabled
     */
    readonly enabled?: boolean | cdk.IResolvable;
  }

  /**
   * Options for Amazon S3 as a logging destination.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-s3.html
   */
  export interface S3Property {
    /**
     * The bucket name.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-s3.html#cfn-ec2-verifiedaccessinstance-s3-bucketname
     */
    readonly bucketName?: string;

    /**
     * The AWS account number that owns the bucket.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-s3.html#cfn-ec2-verifiedaccessinstance-s3-bucketowner
     */
    readonly bucketOwner?: string;

    /**
     * Indicates whether logging is enabled.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-s3.html#cfn-ec2-verifiedaccessinstance-s3-enabled
     */
    readonly enabled?: boolean | cdk.IResolvable;

    /**
     * The bucket prefix.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-s3.html#cfn-ec2-verifiedaccessinstance-s3-prefix
     */
    readonly prefix?: string;
  }
}

/**
 * Properties for defining a \`CfnVerifiedAccessInstance\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessinstance.html
 */
export interface CfnVerifiedAccessInstanceProps {
  /**
   * A description for the AWS Verified Access instance.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessinstance.html#cfn-ec2-verifiedaccessinstance-description
   */
  readonly description?: string;

  /**
   * The current logging configuration for the Verified Access instances.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessinstance.html#cfn-ec2-verifiedaccessinstance-loggingconfigurations
   */
  readonly loggingConfigurations?: cdk.IResolvable | CfnVerifiedAccessInstance.VerifiedAccessLogsProperty;

  /**
   * The tags.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessinstance.html#cfn-ec2-verifiedaccessinstance-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The IDs of the AWS Verified Access trust providers.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessinstance.html#cfn-ec2-verifiedaccessinstance-verifiedaccesstrustproviderids
   */
  readonly verifiedAccessTrustProviderIds?: Array<string>;

  /**
   * The IDs of the AWS Verified Access trust providers.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessinstance.html#cfn-ec2-verifiedaccessinstance-verifiedaccesstrustproviders
   */
  readonly verifiedAccessTrustProviders?: Array<cdk.IResolvable | CfnVerifiedAccessInstance.VerifiedAccessTrustProviderProperty> | cdk.IResolvable;
}

/**
 * Determine whether the given properties match those of a \`VerifiedAccessTrustProviderProperty\`
 *
 * @param properties - the TypeScript properties of a \`VerifiedAccessTrustProviderProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVerifiedAccessInstanceVerifiedAccessTrustProviderPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("deviceTrustProviderType", cdk.validateString)(properties.deviceTrustProviderType));
  errors.collect(cdk.propertyValidator("trustProviderType", cdk.validateString)(properties.trustProviderType));
  errors.collect(cdk.propertyValidator("userTrustProviderType", cdk.validateString)(properties.userTrustProviderType));
  errors.collect(cdk.propertyValidator("verifiedAccessTrustProviderId", cdk.validateString)(properties.verifiedAccessTrustProviderId));
  return errors.wrap("supplied properties not correct for \\"VerifiedAccessTrustProviderProperty\\"");
}

// @ts-ignore TS6133
function convertCfnVerifiedAccessInstanceVerifiedAccessTrustProviderPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVerifiedAccessInstanceVerifiedAccessTrustProviderPropertyValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "DeviceTrustProviderType": cdk.stringToCloudFormation(properties.deviceTrustProviderType),
    "TrustProviderType": cdk.stringToCloudFormation(properties.trustProviderType),
    "UserTrustProviderType": cdk.stringToCloudFormation(properties.userTrustProviderType),
    "VerifiedAccessTrustProviderId": cdk.stringToCloudFormation(properties.verifiedAccessTrustProviderId)
  };
}

// @ts-ignore TS6133
function CfnVerifiedAccessInstanceVerifiedAccessTrustProviderPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnVerifiedAccessInstance.VerifiedAccessTrustProviderProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVerifiedAccessInstance.VerifiedAccessTrustProviderProperty>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("deviceTrustProviderType", "DeviceTrustProviderType", (properties.DeviceTrustProviderType != null ? cfn_parse.FromCloudFormation.getString(properties.DeviceTrustProviderType) : undefined));
  ret.addPropertyResult("trustProviderType", "TrustProviderType", (properties.TrustProviderType != null ? cfn_parse.FromCloudFormation.getString(properties.TrustProviderType) : undefined));
  ret.addPropertyResult("userTrustProviderType", "UserTrustProviderType", (properties.UserTrustProviderType != null ? cfn_parse.FromCloudFormation.getString(properties.UserTrustProviderType) : undefined));
  ret.addPropertyResult("verifiedAccessTrustProviderId", "VerifiedAccessTrustProviderId", (properties.VerifiedAccessTrustProviderId != null ? cfn_parse.FromCloudFormation.getString(properties.VerifiedAccessTrustProviderId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CloudWatchLogsProperty\`
 *
 * @param properties - the TypeScript properties of a \`CloudWatchLogsProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVerifiedAccessInstanceCloudWatchLogsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("enabled", cdk.validateBoolean)(properties.enabled));
  errors.collect(cdk.propertyValidator("logGroup", cdk.validateString)(properties.logGroup));
  return errors.wrap("supplied properties not correct for \\"CloudWatchLogsProperty\\"");
}

// @ts-ignore TS6133
function convertCfnVerifiedAccessInstanceCloudWatchLogsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVerifiedAccessInstanceCloudWatchLogsPropertyValidator(properties).assertSuccess();
  return {
    "Enabled": cdk.booleanToCloudFormation(properties.enabled),
    "LogGroup": cdk.stringToCloudFormation(properties.logGroup)
  };
}

// @ts-ignore TS6133
function CfnVerifiedAccessInstanceCloudWatchLogsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnVerifiedAccessInstance.CloudWatchLogsProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVerifiedAccessInstance.CloudWatchLogsProperty>();
  ret.addPropertyResult("enabled", "Enabled", (properties.Enabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Enabled) : undefined));
  ret.addPropertyResult("logGroup", "LogGroup", (properties.LogGroup != null ? cfn_parse.FromCloudFormation.getString(properties.LogGroup) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`KinesisDataFirehoseProperty\`
 *
 * @param properties - the TypeScript properties of a \`KinesisDataFirehoseProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVerifiedAccessInstanceKinesisDataFirehosePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("deliveryStream", cdk.validateString)(properties.deliveryStream));
  errors.collect(cdk.propertyValidator("enabled", cdk.validateBoolean)(properties.enabled));
  return errors.wrap("supplied properties not correct for \\"KinesisDataFirehoseProperty\\"");
}

// @ts-ignore TS6133
function convertCfnVerifiedAccessInstanceKinesisDataFirehosePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVerifiedAccessInstanceKinesisDataFirehosePropertyValidator(properties).assertSuccess();
  return {
    "DeliveryStream": cdk.stringToCloudFormation(properties.deliveryStream),
    "Enabled": cdk.booleanToCloudFormation(properties.enabled)
  };
}

// @ts-ignore TS6133
function CfnVerifiedAccessInstanceKinesisDataFirehosePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnVerifiedAccessInstance.KinesisDataFirehoseProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVerifiedAccessInstance.KinesisDataFirehoseProperty>();
  ret.addPropertyResult("deliveryStream", "DeliveryStream", (properties.DeliveryStream != null ? cfn_parse.FromCloudFormation.getString(properties.DeliveryStream) : undefined));
  ret.addPropertyResult("enabled", "Enabled", (properties.Enabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Enabled) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`S3Property\`
 *
 * @param properties - the TypeScript properties of a \`S3Property\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVerifiedAccessInstanceS3PropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("bucketName", cdk.validateString)(properties.bucketName));
  errors.collect(cdk.propertyValidator("bucketOwner", cdk.validateString)(properties.bucketOwner));
  errors.collect(cdk.propertyValidator("enabled", cdk.validateBoolean)(properties.enabled));
  errors.collect(cdk.propertyValidator("prefix", cdk.validateString)(properties.prefix));
  return errors.wrap("supplied properties not correct for \\"S3Property\\"");
}

// @ts-ignore TS6133
function convertCfnVerifiedAccessInstanceS3PropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVerifiedAccessInstanceS3PropertyValidator(properties).assertSuccess();
  return {
    "BucketName": cdk.stringToCloudFormation(properties.bucketName),
    "BucketOwner": cdk.stringToCloudFormation(properties.bucketOwner),
    "Enabled": cdk.booleanToCloudFormation(properties.enabled),
    "Prefix": cdk.stringToCloudFormation(properties.prefix)
  };
}

// @ts-ignore TS6133
function CfnVerifiedAccessInstanceS3PropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnVerifiedAccessInstance.S3Property> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVerifiedAccessInstance.S3Property>();
  ret.addPropertyResult("bucketName", "BucketName", (properties.BucketName != null ? cfn_parse.FromCloudFormation.getString(properties.BucketName) : undefined));
  ret.addPropertyResult("bucketOwner", "BucketOwner", (properties.BucketOwner != null ? cfn_parse.FromCloudFormation.getString(properties.BucketOwner) : undefined));
  ret.addPropertyResult("enabled", "Enabled", (properties.Enabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Enabled) : undefined));
  ret.addPropertyResult("prefix", "Prefix", (properties.Prefix != null ? cfn_parse.FromCloudFormation.getString(properties.Prefix) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`VerifiedAccessLogsProperty\`
 *
 * @param properties - the TypeScript properties of a \`VerifiedAccessLogsProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVerifiedAccessInstanceVerifiedAccessLogsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("cloudWatchLogs", CfnVerifiedAccessInstanceCloudWatchLogsPropertyValidator)(properties.cloudWatchLogs));
  errors.collect(cdk.propertyValidator("includeTrustContext", cdk.validateBoolean)(properties.includeTrustContext));
  errors.collect(cdk.propertyValidator("kinesisDataFirehose", CfnVerifiedAccessInstanceKinesisDataFirehosePropertyValidator)(properties.kinesisDataFirehose));
  errors.collect(cdk.propertyValidator("logVersion", cdk.validateString)(properties.logVersion));
  errors.collect(cdk.propertyValidator("s3", CfnVerifiedAccessInstanceS3PropertyValidator)(properties.s3));
  return errors.wrap("supplied properties not correct for \\"VerifiedAccessLogsProperty\\"");
}

// @ts-ignore TS6133
function convertCfnVerifiedAccessInstanceVerifiedAccessLogsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVerifiedAccessInstanceVerifiedAccessLogsPropertyValidator(properties).assertSuccess();
  return {
    "CloudWatchLogs": convertCfnVerifiedAccessInstanceCloudWatchLogsPropertyToCloudFormation(properties.cloudWatchLogs),
    "IncludeTrustContext": cdk.booleanToCloudFormation(properties.includeTrustContext),
    "KinesisDataFirehose": convertCfnVerifiedAccessInstanceKinesisDataFirehosePropertyToCloudFormation(properties.kinesisDataFirehose),
    "LogVersion": cdk.stringToCloudFormation(properties.logVersion),
    "S3": convertCfnVerifiedAccessInstanceS3PropertyToCloudFormation(properties.s3)
  };
}

// @ts-ignore TS6133
function CfnVerifiedAccessInstanceVerifiedAccessLogsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnVerifiedAccessInstance.VerifiedAccessLogsProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVerifiedAccessInstance.VerifiedAccessLogsProperty>();
  ret.addPropertyResult("cloudWatchLogs", "CloudWatchLogs", (properties.CloudWatchLogs != null ? CfnVerifiedAccessInstanceCloudWatchLogsPropertyFromCloudFormation(properties.CloudWatchLogs) : undefined));
  ret.addPropertyResult("includeTrustContext", "IncludeTrustContext", (properties.IncludeTrustContext != null ? cfn_parse.FromCloudFormation.getBoolean(properties.IncludeTrustContext) : undefined));
  ret.addPropertyResult("kinesisDataFirehose", "KinesisDataFirehose", (properties.KinesisDataFirehose != null ? CfnVerifiedAccessInstanceKinesisDataFirehosePropertyFromCloudFormation(properties.KinesisDataFirehose) : undefined));
  ret.addPropertyResult("logVersion", "LogVersion", (properties.LogVersion != null ? cfn_parse.FromCloudFormation.getString(properties.LogVersion) : undefined));
  ret.addPropertyResult("s3", "S3", (properties.S3 != null ? CfnVerifiedAccessInstanceS3PropertyFromCloudFormation(properties.S3) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnVerifiedAccessInstanceProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnVerifiedAccessInstanceProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVerifiedAccessInstancePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("loggingConfigurations", CfnVerifiedAccessInstanceVerifiedAccessLogsPropertyValidator)(properties.loggingConfigurations));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("verifiedAccessTrustProviderIds", cdk.listValidator(cdk.validateString))(properties.verifiedAccessTrustProviderIds));
  errors.collect(cdk.propertyValidator("verifiedAccessTrustProviders", cdk.listValidator(CfnVerifiedAccessInstanceVerifiedAccessTrustProviderPropertyValidator))(properties.verifiedAccessTrustProviders));
  return errors.wrap("supplied properties not correct for \\"CfnVerifiedAccessInstanceProps\\"");
}

// @ts-ignore TS6133
function convertCfnVerifiedAccessInstancePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVerifiedAccessInstancePropsValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "LoggingConfigurations": convertCfnVerifiedAccessInstanceVerifiedAccessLogsPropertyToCloudFormation(properties.loggingConfigurations),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "VerifiedAccessTrustProviderIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.verifiedAccessTrustProviderIds),
    "VerifiedAccessTrustProviders": cdk.listMapper(convertCfnVerifiedAccessInstanceVerifiedAccessTrustProviderPropertyToCloudFormation)(properties.verifiedAccessTrustProviders)
  };
}

// @ts-ignore TS6133
function CfnVerifiedAccessInstancePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnVerifiedAccessInstanceProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVerifiedAccessInstanceProps>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("loggingConfigurations", "LoggingConfigurations", (properties.LoggingConfigurations != null ? CfnVerifiedAccessInstanceVerifiedAccessLogsPropertyFromCloudFormation(properties.LoggingConfigurations) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("verifiedAccessTrustProviderIds", "VerifiedAccessTrustProviderIds", (properties.VerifiedAccessTrustProviderIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.VerifiedAccessTrustProviderIds) : undefined));
  ret.addPropertyResult("verifiedAccessTrustProviders", "VerifiedAccessTrustProviders", (properties.VerifiedAccessTrustProviders != null ? cfn_parse.FromCloudFormation.getArray(CfnVerifiedAccessInstanceVerifiedAccessTrustProviderPropertyFromCloudFormation)(properties.VerifiedAccessTrustProviders) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Describes a Verified Access trust provider.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccesstrustprovider.html
 */
export class CfnVerifiedAccessTrustProvider extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::VerifiedAccessTrustProvider";

  /**
   * Build a CfnVerifiedAccessTrustProvider from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnVerifiedAccessTrustProvider {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnVerifiedAccessTrustProviderPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnVerifiedAccessTrustProvider(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The creation time.
   *
   * @cloudformationAttribute CreationTime
   */
  public readonly attrCreationTime: string;

  /**
   * The last updated time.
   *
   * @cloudformationAttribute LastUpdatedTime
   */
  public readonly attrLastUpdatedTime: string;

  /**
   * The ID of the Verified Access trust provider.
   *
   * @cloudformationAttribute VerifiedAccessTrustProviderId
   */
  public readonly attrVerifiedAccessTrustProviderId: string;

  /**
   * A description for the AWS Verified Access trust provider.
   */
  public description?: string;

  /**
   * The options for device-identity trust provider.
   */
  public deviceOptions?: CfnVerifiedAccessTrustProvider.DeviceOptionsProperty | cdk.IResolvable;

  /**
   * The type of device-based trust provider.
   */
  public deviceTrustProviderType?: string;

  /**
   * The options for an OpenID Connect-compatible user-identity trust provider.
   */
  public oidcOptions?: cdk.IResolvable | CfnVerifiedAccessTrustProvider.OidcOptionsProperty;

  /**
   * The identifier to be used when working with policy rules.
   */
  public policyReferenceName: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The type of Verified Access trust provider.
   */
  public trustProviderType: string;

  /**
   * The type of user-based trust provider.
   */
  public userTrustProviderType?: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnVerifiedAccessTrustProviderProps) {
    super(scope, id, {
      "type": CfnVerifiedAccessTrustProvider.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "policyReferenceName", this);
    cdk.requireProperty(props, "trustProviderType", this);

    this.attrCreationTime = cdk.Token.asString(this.getAtt("CreationTime", cdk.ResolutionTypeHint.STRING));
    this.attrLastUpdatedTime = cdk.Token.asString(this.getAtt("LastUpdatedTime", cdk.ResolutionTypeHint.STRING));
    this.attrVerifiedAccessTrustProviderId = cdk.Token.asString(this.getAtt("VerifiedAccessTrustProviderId", cdk.ResolutionTypeHint.STRING));
    this.description = props.description;
    this.deviceOptions = props.deviceOptions;
    this.deviceTrustProviderType = props.deviceTrustProviderType;
    this.oidcOptions = props.oidcOptions;
    this.policyReferenceName = props.policyReferenceName;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::VerifiedAccessTrustProvider", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.trustProviderType = props.trustProviderType;
    this.userTrustProviderType = props.userTrustProviderType;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "description": this.description,
      "deviceOptions": this.deviceOptions,
      "deviceTrustProviderType": this.deviceTrustProviderType,
      "oidcOptions": this.oidcOptions,
      "policyReferenceName": this.policyReferenceName,
      "tags": this.tags.renderTags(),
      "trustProviderType": this.trustProviderType,
      "userTrustProviderType": this.userTrustProviderType
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnVerifiedAccessTrustProvider.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnVerifiedAccessTrustProviderPropsToCloudFormation(props);
  }
}

export namespace CfnVerifiedAccessTrustProvider {
  /**
   * Describes the options for an OpenID Connect-compatible user-identity trust provider.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-oidcoptions.html
   */
  export interface OidcOptionsProperty {
    /**
     * The OIDC authorization endpoint.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-oidcoptions.html#cfn-ec2-verifiedaccesstrustprovider-oidcoptions-authorizationendpoint
     */
    readonly authorizationEndpoint?: string;

    /**
     * The client identifier.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-oidcoptions.html#cfn-ec2-verifiedaccesstrustprovider-oidcoptions-clientid
     */
    readonly clientId?: string;

    /**
     * The client secret.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-oidcoptions.html#cfn-ec2-verifiedaccesstrustprovider-oidcoptions-clientsecret
     */
    readonly clientSecret?: string;

    /**
     * The OIDC issuer.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-oidcoptions.html#cfn-ec2-verifiedaccesstrustprovider-oidcoptions-issuer
     */
    readonly issuer?: string;

    /**
     * The OpenID Connect (OIDC) scope specified.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-oidcoptions.html#cfn-ec2-verifiedaccesstrustprovider-oidcoptions-scope
     */
    readonly scope?: string;

    /**
     * The OIDC token endpoint.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-oidcoptions.html#cfn-ec2-verifiedaccesstrustprovider-oidcoptions-tokenendpoint
     */
    readonly tokenEndpoint?: string;

    /**
     * The OIDC user info endpoint.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-oidcoptions.html#cfn-ec2-verifiedaccesstrustprovider-oidcoptions-userinfoendpoint
     */
    readonly userInfoEndpoint?: string;
  }

  /**
   * Describes the options for an AWS Verified Access device-identity based trust provider.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-deviceoptions.html
   */
  export interface DeviceOptionsProperty {
    /**
     * The ID of the tenant application with the device-identity provider.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-deviceoptions.html#cfn-ec2-verifiedaccesstrustprovider-deviceoptions-tenantid
     */
    readonly tenantId?: string;
  }
}

/**
 * Properties for defining a \`CfnVerifiedAccessTrustProvider\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccesstrustprovider.html
 */
export interface CfnVerifiedAccessTrustProviderProps {
  /**
   * A description for the AWS Verified Access trust provider.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccesstrustprovider-description
   */
  readonly description?: string;

  /**
   * The options for device-identity trust provider.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccesstrustprovider-deviceoptions
   */
  readonly deviceOptions?: CfnVerifiedAccessTrustProvider.DeviceOptionsProperty | cdk.IResolvable;

  /**
   * The type of device-based trust provider.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccesstrustprovider-devicetrustprovidertype
   */
  readonly deviceTrustProviderType?: string;

  /**
   * The options for an OpenID Connect-compatible user-identity trust provider.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccesstrustprovider-oidcoptions
   */
  readonly oidcOptions?: cdk.IResolvable | CfnVerifiedAccessTrustProvider.OidcOptionsProperty;

  /**
   * The identifier to be used when working with policy rules.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccesstrustprovider-policyreferencename
   */
  readonly policyReferenceName: string;

  /**
   * The tags.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccesstrustprovider-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The type of Verified Access trust provider.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccesstrustprovider-trustprovidertype
   */
  readonly trustProviderType: string;

  /**
   * The type of user-based trust provider.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccesstrustprovider-usertrustprovidertype
   */
  readonly userTrustProviderType?: string;
}

/**
 * Determine whether the given properties match those of a \`OidcOptionsProperty\`
 *
 * @param properties - the TypeScript properties of a \`OidcOptionsProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVerifiedAccessTrustProviderOidcOptionsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("authorizationEndpoint", cdk.validateString)(properties.authorizationEndpoint));
  errors.collect(cdk.propertyValidator("clientId", cdk.validateString)(properties.clientId));
  errors.collect(cdk.propertyValidator("clientSecret", cdk.validateString)(properties.clientSecret));
  errors.collect(cdk.propertyValidator("issuer", cdk.validateString)(properties.issuer));
  errors.collect(cdk.propertyValidator("scope", cdk.validateString)(properties.scope));
  errors.collect(cdk.propertyValidator("tokenEndpoint", cdk.validateString)(properties.tokenEndpoint));
  errors.collect(cdk.propertyValidator("userInfoEndpoint", cdk.validateString)(properties.userInfoEndpoint));
  return errors.wrap("supplied properties not correct for \\"OidcOptionsProperty\\"");
}

// @ts-ignore TS6133
function convertCfnVerifiedAccessTrustProviderOidcOptionsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVerifiedAccessTrustProviderOidcOptionsPropertyValidator(properties).assertSuccess();
  return {
    "AuthorizationEndpoint": cdk.stringToCloudFormation(properties.authorizationEndpoint),
    "ClientId": cdk.stringToCloudFormation(properties.clientId),
    "ClientSecret": cdk.stringToCloudFormation(properties.clientSecret),
    "Issuer": cdk.stringToCloudFormation(properties.issuer),
    "Scope": cdk.stringToCloudFormation(properties.scope),
    "TokenEndpoint": cdk.stringToCloudFormation(properties.tokenEndpoint),
    "UserInfoEndpoint": cdk.stringToCloudFormation(properties.userInfoEndpoint)
  };
}

// @ts-ignore TS6133
function CfnVerifiedAccessTrustProviderOidcOptionsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnVerifiedAccessTrustProvider.OidcOptionsProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVerifiedAccessTrustProvider.OidcOptionsProperty>();
  ret.addPropertyResult("authorizationEndpoint", "AuthorizationEndpoint", (properties.AuthorizationEndpoint != null ? cfn_parse.FromCloudFormation.getString(properties.AuthorizationEndpoint) : undefined));
  ret.addPropertyResult("clientId", "ClientId", (properties.ClientId != null ? cfn_parse.FromCloudFormation.getString(properties.ClientId) : undefined));
  ret.addPropertyResult("clientSecret", "ClientSecret", (properties.ClientSecret != null ? cfn_parse.FromCloudFormation.getString(properties.ClientSecret) : undefined));
  ret.addPropertyResult("issuer", "Issuer", (properties.Issuer != null ? cfn_parse.FromCloudFormation.getString(properties.Issuer) : undefined));
  ret.addPropertyResult("scope", "Scope", (properties.Scope != null ? cfn_parse.FromCloudFormation.getString(properties.Scope) : undefined));
  ret.addPropertyResult("tokenEndpoint", "TokenEndpoint", (properties.TokenEndpoint != null ? cfn_parse.FromCloudFormation.getString(properties.TokenEndpoint) : undefined));
  ret.addPropertyResult("userInfoEndpoint", "UserInfoEndpoint", (properties.UserInfoEndpoint != null ? cfn_parse.FromCloudFormation.getString(properties.UserInfoEndpoint) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`DeviceOptionsProperty\`
 *
 * @param properties - the TypeScript properties of a \`DeviceOptionsProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVerifiedAccessTrustProviderDeviceOptionsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("tenantId", cdk.validateString)(properties.tenantId));
  return errors.wrap("supplied properties not correct for \\"DeviceOptionsProperty\\"");
}

// @ts-ignore TS6133
function convertCfnVerifiedAccessTrustProviderDeviceOptionsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVerifiedAccessTrustProviderDeviceOptionsPropertyValidator(properties).assertSuccess();
  return {
    "TenantId": cdk.stringToCloudFormation(properties.tenantId)
  };
}

// @ts-ignore TS6133
function CfnVerifiedAccessTrustProviderDeviceOptionsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnVerifiedAccessTrustProvider.DeviceOptionsProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVerifiedAccessTrustProvider.DeviceOptionsProperty>();
  ret.addPropertyResult("tenantId", "TenantId", (properties.TenantId != null ? cfn_parse.FromCloudFormation.getString(properties.TenantId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnVerifiedAccessTrustProviderProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnVerifiedAccessTrustProviderProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVerifiedAccessTrustProviderPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("deviceOptions", CfnVerifiedAccessTrustProviderDeviceOptionsPropertyValidator)(properties.deviceOptions));
  errors.collect(cdk.propertyValidator("deviceTrustProviderType", cdk.validateString)(properties.deviceTrustProviderType));
  errors.collect(cdk.propertyValidator("oidcOptions", CfnVerifiedAccessTrustProviderOidcOptionsPropertyValidator)(properties.oidcOptions));
  errors.collect(cdk.propertyValidator("policyReferenceName", cdk.requiredValidator)(properties.policyReferenceName));
  errors.collect(cdk.propertyValidator("policyReferenceName", cdk.validateString)(properties.policyReferenceName));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("trustProviderType", cdk.requiredValidator)(properties.trustProviderType));
  errors.collect(cdk.propertyValidator("trustProviderType", cdk.validateString)(properties.trustProviderType));
  errors.collect(cdk.propertyValidator("userTrustProviderType", cdk.validateString)(properties.userTrustProviderType));
  return errors.wrap("supplied properties not correct for \\"CfnVerifiedAccessTrustProviderProps\\"");
}

// @ts-ignore TS6133
function convertCfnVerifiedAccessTrustProviderPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVerifiedAccessTrustProviderPropsValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "DeviceOptions": convertCfnVerifiedAccessTrustProviderDeviceOptionsPropertyToCloudFormation(properties.deviceOptions),
    "DeviceTrustProviderType": cdk.stringToCloudFormation(properties.deviceTrustProviderType),
    "OidcOptions": convertCfnVerifiedAccessTrustProviderOidcOptionsPropertyToCloudFormation(properties.oidcOptions),
    "PolicyReferenceName": cdk.stringToCloudFormation(properties.policyReferenceName),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "TrustProviderType": cdk.stringToCloudFormation(properties.trustProviderType),
    "UserTrustProviderType": cdk.stringToCloudFormation(properties.userTrustProviderType)
  };
}

// @ts-ignore TS6133
function CfnVerifiedAccessTrustProviderPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnVerifiedAccessTrustProviderProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVerifiedAccessTrustProviderProps>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("deviceOptions", "DeviceOptions", (properties.DeviceOptions != null ? CfnVerifiedAccessTrustProviderDeviceOptionsPropertyFromCloudFormation(properties.DeviceOptions) : undefined));
  ret.addPropertyResult("deviceTrustProviderType", "DeviceTrustProviderType", (properties.DeviceTrustProviderType != null ? cfn_parse.FromCloudFormation.getString(properties.DeviceTrustProviderType) : undefined));
  ret.addPropertyResult("oidcOptions", "OidcOptions", (properties.OidcOptions != null ? CfnVerifiedAccessTrustProviderOidcOptionsPropertyFromCloudFormation(properties.OidcOptions) : undefined));
  ret.addPropertyResult("policyReferenceName", "PolicyReferenceName", (properties.PolicyReferenceName != null ? cfn_parse.FromCloudFormation.getString(properties.PolicyReferenceName) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("trustProviderType", "TrustProviderType", (properties.TrustProviderType != null ? cfn_parse.FromCloudFormation.getString(properties.TrustProviderType) : undefined));
  ret.addPropertyResult("userTrustProviderType", "UserTrustProviderType", (properties.UserTrustProviderType != null ? cfn_parse.FromCloudFormation.getString(properties.UserTrustProviderType) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies an Amazon Elastic Block Store (Amazon EBS) volume.
 *
 * You can attach the volume to an instance in the same Availability Zone using [AWS::EC2::VolumeAttachment](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ebs-volumeattachment.html) .
 *
 * When you use AWS CloudFormation to update an Amazon EBS volume that modifies \`Iops\` , \`Size\` , or \`VolumeType\` , there is a cooldown period before another operation can occur. This can cause your stack to report being in \`UPDATE_IN_PROGRESS\` or \`UPDATE_ROLLBACK_IN_PROGRESS\` for long periods of time.
 *
 * Amazon EBS does not support sizing down an Amazon EBS volume. AWS CloudFormation does not attempt to modify an Amazon EBS volume to a smaller size on rollback.
 *
 * Some common scenarios when you might encounter a cooldown period for Amazon EBS include:
 *
 * - You successfully update an Amazon EBS volume and the update succeeds. When you attempt another update within the cooldown window, that update will be subject to a cooldown period.
 * - You successfully update an Amazon EBS volume and the update succeeds but another change in your \`update-stack\` call fails. The rollback will be subject to a cooldown period.
 *
 * For more information on the cooldown period, see [Requirements when modifying volumes](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/modify-volume-requirements.html) .
 *
 * *DeletionPolicy attribute*
 *
 * To control how AWS CloudFormation handles the volume when the stack is deleted, set a deletion policy for your volume. You can choose to retain the volume, to delete the volume, or to create a snapshot of the volume. For more information, see [DeletionPolicy attribute](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html) .
 *
 * > If you set a deletion policy that creates a snapshot, all tags on the volume are included in the snapshot.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html
 */
export class CfnVolume extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::Volume";

  /**
   * Build a CfnVolume from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnVolume {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnVolumePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnVolume(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the volume.
   *
   * @cloudformationAttribute VolumeId
   */
  public readonly attrVolumeId: string;

  /**
   * Indicates whether the volume is auto-enabled for I/O operations.
   */
  public autoEnableIo?: boolean | cdk.IResolvable;

  /**
   * The ID of the Availability Zone in which to create the volume.
   */
  public availabilityZone: string;

  /**
   * Indicates whether the volume should be encrypted.
   */
  public encrypted?: boolean | cdk.IResolvable;

  /**
   * The number of I/O operations per second (IOPS).
   */
  public iops?: number;

  /**
   * The identifier of the AWS KMS key to use for Amazon EBS encryption.
   */
  public kmsKeyId?: string;

  /**
   * Indicates whether Amazon EBS Multi-Attach is enabled.
   */
  public multiAttachEnabled?: boolean | cdk.IResolvable;

  /**
   * The Amazon Resource Name (ARN) of the Outpost.
   */
  public outpostArn?: string;

  /**
   * The size of the volume, in GiBs.
   */
  public size?: number;

  /**
   * The snapshot from which to create the volume.
   */
  public snapshotId?: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags to apply to the volume during creation.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The throughput to provision for a volume, with a maximum of 1,000 MiB/s.
   */
  public throughput?: number;

  /**
   * The volume type. This parameter can be one of the following values:.
   */
  public volumeType?: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnVolumeProps) {
    super(scope, id, {
      "type": CfnVolume.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "availabilityZone", this);

    this.attrVolumeId = cdk.Token.asString(this.getAtt("VolumeId", cdk.ResolutionTypeHint.STRING));
    this.autoEnableIo = props.autoEnableIo;
    this.availabilityZone = props.availabilityZone;
    this.encrypted = props.encrypted;
    this.iops = props.iops;
    this.kmsKeyId = props.kmsKeyId;
    this.multiAttachEnabled = props.multiAttachEnabled;
    this.outpostArn = props.outpostArn;
    this.size = props.size;
    this.snapshotId = props.snapshotId;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::Volume", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.throughput = props.throughput;
    this.volumeType = props.volumeType;
    if ((this.node.scope != null && cdk.Resource.isResource(this.node.scope))) {
      this.node.addValidation({
        "validate": () => ((this.cfnOptions.deletionPolicy === undefined) ? ["'AWS::EC2::Volume' is a stateful resource type, and you must specify a Removal Policy for it. Call 'resource.applyRemovalPolicy()'."] : [])
      });
    }
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "autoEnableIo": this.autoEnableIo,
      "availabilityZone": this.availabilityZone,
      "encrypted": this.encrypted,
      "iops": this.iops,
      "kmsKeyId": this.kmsKeyId,
      "multiAttachEnabled": this.multiAttachEnabled,
      "outpostArn": this.outpostArn,
      "size": this.size,
      "snapshotId": this.snapshotId,
      "tags": this.tags.renderTags(),
      "throughput": this.throughput,
      "volumeType": this.volumeType
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnVolume.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnVolumePropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnVolume\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html
 */
export interface CfnVolumeProps {
  /**
   * Indicates whether the volume is auto-enabled for I/O operations.
   *
   * By default, Amazon EBS disables I/O to the volume from attached EC2 instances when it determines that a volume's data is potentially inconsistent. If the consistency of the volume is not a concern, and you prefer that the volume be made available immediately if it's impaired, you can configure the volume to automatically enable I/O.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-autoenableio
   */
  readonly autoEnableIo?: boolean | cdk.IResolvable;

  /**
   * The ID of the Availability Zone in which to create the volume.
   *
   * For example, \`us-east-1a\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-availabilityzone
   */
  readonly availabilityZone: string;

  /**
   * Indicates whether the volume should be encrypted.
   *
   * The effect of setting the encryption state to \`true\` depends on the volume origin (new or from a snapshot), starting encryption state, ownership, and whether encryption by default is enabled. For more information, see [Encryption by default](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#encryption-by-default) in the *Amazon Elastic Compute Cloud User Guide* .
   *
   * Encrypted Amazon EBS volumes must be attached to instances that support Amazon EBS encryption. For more information, see [Supported instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#EBSEncryption_supported_instances) .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-encrypted
   */
  readonly encrypted?: boolean | cdk.IResolvable;

  /**
   * The number of I/O operations per second (IOPS).
   *
   * For \`gp3\` , \`io1\` , and \`io2\` volumes, this represents the number of IOPS that are provisioned for the volume. For \`gp2\` volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting.
   *
   * The following are the supported values for each volume type:
   *
   * - \`gp3\` : 3,000-16,000 IOPS
   * - \`io1\` : 100-64,000 IOPS
   * - \`io2\` : 100-64,000 IOPS
   *
   * \`io1\` and \`io2\` volumes support up to 64,000 IOPS only on [Instances built on the Nitro System](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances) . Other instance families support performance up to 32,000 IOPS.
   *
   * This parameter is required for \`io1\` and \`io2\` volumes. The default for \`gp3\` volumes is 3,000 IOPS. This parameter is not supported for \`gp2\` , \`st1\` , \`sc1\` , or \`standard\` volumes.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-iops
   */
  readonly iops?: number;

  /**
   * The identifier of the AWS KMS key to use for Amazon EBS encryption.
   *
   * If \`KmsKeyId\` is specified, the encrypted state must be \`true\` .
   *
   * If you omit this property and your account is enabled for encryption by default, or *Encrypted* is set to \`true\` , then the volume is encrypted using the default key specified for your account. If your account does not have a default key, then the volume is encrypted using the AWS managed key .
   *
   * Alternatively, if you want to specify a different key, you can specify one of the following:
   *
   * - Key ID. For example, 1234abcd-12ab-34cd-56ef-1234567890ab.
   * - Key alias. Specify the alias for the key, prefixed with \`alias/\` . For example, for a key with the alias \`my_cmk\` , use \`alias/my_cmk\` . Or to specify the AWS managed key , use \`alias/aws/ebs\` .
   * - Key ARN. For example, arn:aws:kms:us-east-1:012345678910:key/1234abcd-12ab-34cd-56ef-1234567890ab.
   * - Alias ARN. For example, arn:aws:kms:us-east-1:012345678910:alias/ExampleAlias.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-kmskeyid
   */
  readonly kmsKeyId?: string;

  /**
   * Indicates whether Amazon EBS Multi-Attach is enabled.
   *
   * AWS CloudFormation does not currently support updating a single-attach volume to be multi-attach enabled, updating a multi-attach enabled volume to be single-attach, or updating the size or number of I/O operations per second (IOPS) of a multi-attach enabled volume.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-multiattachenabled
   */
  readonly multiAttachEnabled?: boolean | cdk.IResolvable;

  /**
   * The Amazon Resource Name (ARN) of the Outpost.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-outpostarn
   */
  readonly outpostArn?: string;

  /**
   * The size of the volume, in GiBs.
   *
   * You must specify either a snapshot ID or a volume size. If you specify a snapshot, the default is the snapshot size. You can specify a volume size that is equal to or larger than the snapshot size.
   *
   * The following are the supported volumes sizes for each volume type:
   *
   * - \`gp2\` and \`gp3\` : 1-16,384
   * - \`io1\` and \`io2\` : 4-16,384
   * - \`st1\` and \`sc1\` : 125-16,384
   * - \`standard\` : 1-1,024
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-size
   */
  readonly size?: number;

  /**
   * The snapshot from which to create the volume.
   *
   * You must specify either a snapshot ID or a volume size.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-snapshotid
   */
  readonly snapshotId?: string;

  /**
   * The tags to apply to the volume during creation.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The throughput to provision for a volume, with a maximum of 1,000 MiB/s.
   *
   * This parameter is valid only for \`gp3\` volumes. The default value is 125.
   *
   * Valid Range: Minimum value of 125. Maximum value of 1000.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-throughput
   */
  readonly throughput?: number;

  /**
   * The volume type. This parameter can be one of the following values:.
   *
   * - General Purpose SSD: \`gp2\` | \`gp3\`
   * - Provisioned IOPS SSD: \`io1\` | \`io2\`
   * - Throughput Optimized HDD: \`st1\`
   * - Cold HDD: \`sc1\`
   * - Magnetic: \`standard\`
   *
   * For more information, see [Amazon EBS volume types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html) in the *Amazon Elastic Compute Cloud User Guide* .
   *
   * Default: \`gp2\`
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-volumetype
   */
  readonly volumeType?: string;
}

/**
 * Determine whether the given properties match those of a \`CfnVolumeProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnVolumeProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVolumePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("autoEnableIo", cdk.validateBoolean)(properties.autoEnableIo));
  errors.collect(cdk.propertyValidator("availabilityZone", cdk.requiredValidator)(properties.availabilityZone));
  errors.collect(cdk.propertyValidator("availabilityZone", cdk.validateString)(properties.availabilityZone));
  errors.collect(cdk.propertyValidator("encrypted", cdk.validateBoolean)(properties.encrypted));
  errors.collect(cdk.propertyValidator("iops", cdk.validateNumber)(properties.iops));
  errors.collect(cdk.propertyValidator("kmsKeyId", cdk.validateString)(properties.kmsKeyId));
  errors.collect(cdk.propertyValidator("multiAttachEnabled", cdk.validateBoolean)(properties.multiAttachEnabled));
  errors.collect(cdk.propertyValidator("outpostArn", cdk.validateString)(properties.outpostArn));
  errors.collect(cdk.propertyValidator("size", cdk.validateNumber)(properties.size));
  errors.collect(cdk.propertyValidator("snapshotId", cdk.validateString)(properties.snapshotId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("throughput", cdk.validateNumber)(properties.throughput));
  errors.collect(cdk.propertyValidator("volumeType", cdk.validateString)(properties.volumeType));
  return errors.wrap("supplied properties not correct for \\"CfnVolumeProps\\"");
}

// @ts-ignore TS6133
function convertCfnVolumePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVolumePropsValidator(properties).assertSuccess();
  return {
    "AutoEnableIO": cdk.booleanToCloudFormation(properties.autoEnableIo),
    "AvailabilityZone": cdk.stringToCloudFormation(properties.availabilityZone),
    "Encrypted": cdk.booleanToCloudFormation(properties.encrypted),
    "Iops": cdk.numberToCloudFormation(properties.iops),
    "KmsKeyId": cdk.stringToCloudFormation(properties.kmsKeyId),
    "MultiAttachEnabled": cdk.booleanToCloudFormation(properties.multiAttachEnabled),
    "OutpostArn": cdk.stringToCloudFormation(properties.outpostArn),
    "Size": cdk.numberToCloudFormation(properties.size),
    "SnapshotId": cdk.stringToCloudFormation(properties.snapshotId),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "Throughput": cdk.numberToCloudFormation(properties.throughput),
    "VolumeType": cdk.stringToCloudFormation(properties.volumeType)
  };
}

// @ts-ignore TS6133
function CfnVolumePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnVolumeProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVolumeProps>();
  ret.addPropertyResult("autoEnableIo", "AutoEnableIO", (properties.AutoEnableIO != null ? cfn_parse.FromCloudFormation.getBoolean(properties.AutoEnableIO) : undefined));
  ret.addPropertyResult("availabilityZone", "AvailabilityZone", (properties.AvailabilityZone != null ? cfn_parse.FromCloudFormation.getString(properties.AvailabilityZone) : undefined));
  ret.addPropertyResult("encrypted", "Encrypted", (properties.Encrypted != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Encrypted) : undefined));
  ret.addPropertyResult("iops", "Iops", (properties.Iops != null ? cfn_parse.FromCloudFormation.getNumber(properties.Iops) : undefined));
  ret.addPropertyResult("kmsKeyId", "KmsKeyId", (properties.KmsKeyId != null ? cfn_parse.FromCloudFormation.getString(properties.KmsKeyId) : undefined));
  ret.addPropertyResult("multiAttachEnabled", "MultiAttachEnabled", (properties.MultiAttachEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.MultiAttachEnabled) : undefined));
  ret.addPropertyResult("outpostArn", "OutpostArn", (properties.OutpostArn != null ? cfn_parse.FromCloudFormation.getString(properties.OutpostArn) : undefined));
  ret.addPropertyResult("size", "Size", (properties.Size != null ? cfn_parse.FromCloudFormation.getNumber(properties.Size) : undefined));
  ret.addPropertyResult("snapshotId", "SnapshotId", (properties.SnapshotId != null ? cfn_parse.FromCloudFormation.getString(properties.SnapshotId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("throughput", "Throughput", (properties.Throughput != null ? cfn_parse.FromCloudFormation.getNumber(properties.Throughput) : undefined));
  ret.addPropertyResult("volumeType", "VolumeType", (properties.VolumeType != null ? cfn_parse.FromCloudFormation.getString(properties.VolumeType) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Attaches an Amazon EBS volume to a running instance and exposes it to the instance with the specified device name.
 *
 * Before this resource can be deleted (and therefore the volume detached), you must first unmount the volume in the instance. Failure to do so results in the volume being stuck in the busy state while it is trying to detach, which could possibly damage the file system or the data it contains.
 *
 * If an Amazon EBS volume is the root device of an instance, it cannot be detached while the instance is in the "running" state. To detach the root volume, stop the instance first.
 *
 * If the root volume is detached from an instance with an AWS Marketplace product code, then the product codes from that volume are no longer associated with the instance.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volumeattachment.html
 */
export class CfnVolumeAttachment extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::VolumeAttachment";

  /**
   * Build a CfnVolumeAttachment from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnVolumeAttachment {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnVolumeAttachmentPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnVolumeAttachment(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The device name (for example, \`/dev/sdh\` or \`xvdh\` ).
   */
  public device?: string;

  /**
   * The ID of the instance to which the volume attaches.
   */
  public instanceId: string;

  /**
   * The ID of the Amazon EBS volume.
   */
  public volumeId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnVolumeAttachmentProps) {
    super(scope, id, {
      "type": CfnVolumeAttachment.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "instanceId", this);
    cdk.requireProperty(props, "volumeId", this);

    this.device = props.device;
    this.instanceId = props.instanceId;
    this.volumeId = props.volumeId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "device": this.device,
      "instanceId": this.instanceId,
      "volumeId": this.volumeId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnVolumeAttachment.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnVolumeAttachmentPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnVolumeAttachment\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volumeattachment.html
 */
export interface CfnVolumeAttachmentProps {
  /**
   * The device name (for example, \`/dev/sdh\` or \`xvdh\` ).
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volumeattachment.html#cfn-ec2-volumeattachment-device
   */
  readonly device?: string;

  /**
   * The ID of the instance to which the volume attaches.
   *
   * This value can be a reference to an [\`AWS::EC2::Instance\`](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html) resource, or it can be the physical ID of an existing EC2 instance.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volumeattachment.html#cfn-ec2-volumeattachment-instanceid
   */
  readonly instanceId: string;

  /**
   * The ID of the Amazon EBS volume.
   *
   * The volume and instance must be within the same Availability Zone. This value can be a reference to an [\`AWS::EC2::Volume\`](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ebs-volume.html) resource, or it can be the volume ID of an existing Amazon EBS volume.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volumeattachment.html#cfn-ec2-volumeattachment-volumeid
   */
  readonly volumeId: string;
}

/**
 * Determine whether the given properties match those of a \`CfnVolumeAttachmentProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnVolumeAttachmentProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVolumeAttachmentPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("device", cdk.validateString)(properties.device));
  errors.collect(cdk.propertyValidator("instanceId", cdk.requiredValidator)(properties.instanceId));
  errors.collect(cdk.propertyValidator("instanceId", cdk.validateString)(properties.instanceId));
  errors.collect(cdk.propertyValidator("volumeId", cdk.requiredValidator)(properties.volumeId));
  errors.collect(cdk.propertyValidator("volumeId", cdk.validateString)(properties.volumeId));
  return errors.wrap("supplied properties not correct for \\"CfnVolumeAttachmentProps\\"");
}

// @ts-ignore TS6133
function convertCfnVolumeAttachmentPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVolumeAttachmentPropsValidator(properties).assertSuccess();
  return {
    "Device": cdk.stringToCloudFormation(properties.device),
    "InstanceId": cdk.stringToCloudFormation(properties.instanceId),
    "VolumeId": cdk.stringToCloudFormation(properties.volumeId)
  };
}

// @ts-ignore TS6133
function CfnVolumeAttachmentPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnVolumeAttachmentProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVolumeAttachmentProps>();
  ret.addPropertyResult("device", "Device", (properties.Device != null ? cfn_parse.FromCloudFormation.getString(properties.Device) : undefined));
  ret.addPropertyResult("instanceId", "InstanceId", (properties.InstanceId != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceId) : undefined));
  ret.addPropertyResult("volumeId", "VolumeId", (properties.VolumeId != null ? cfn_parse.FromCloudFormation.getString(properties.VolumeId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a virtual private cloud (VPC).
 *
 * You can optionally request an IPv6 CIDR block for the VPC. You can request an Amazon-provided IPv6 CIDR block from Amazon's pool of IPv6 addresses, or an IPv6 CIDR block from an IPv6 address pool that you provisioned through bring your own IP addresses (BYOIP).
 *
 * For more information, see [Virtual private clouds (VPC)](https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/configure-your-vpc.html) in the *Amazon VPC User Guide* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html
 */
export class CfnVPC extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::VPC";

  /**
   * Build a CfnVPC from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnVPC {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnVPCPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnVPC(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The primary IPv4 CIDR block for the VPC. For example, 10.0.0.0/16.
   *
   * @cloudformationAttribute CidrBlock
   */
  public readonly attrCidrBlock: string;

  /**
   * The association IDs of the IPv4 CIDR blocks for the VPC. For example, [ vpc-cidr-assoc-0280ab6b ].
   *
   * @cloudformationAttribute CidrBlockAssociations
   */
  public readonly attrCidrBlockAssociations: Array<string>;

  /**
   * The ID of the default network ACL for the VPC. For example, acl-814dafe3.
   *
   * @cloudformationAttribute DefaultNetworkAcl
   */
  public readonly attrDefaultNetworkAcl: string;

  /**
   * The ID of the default security group for the VPC. For example, sg-b178e0d3.
   *
   * @cloudformationAttribute DefaultSecurityGroup
   */
  public readonly attrDefaultSecurityGroup: string;

  /**
   * The IPv6 CIDR blocks for the VPC. For example, [ 2001:db8:1234:1a00::/56 ].
   *
   * @cloudformationAttribute Ipv6CidrBlocks
   */
  public readonly attrIpv6CidrBlocks: Array<string>;

  /**
   * The ID of the VPC.
   *
   * @cloudformationAttribute VpcId
   */
  public readonly attrVpcId: string;

  /**
   * The IPv4 network range for the VPC, in CIDR notation.
   */
  public cidrBlock?: string;

  /**
   * Indicates whether the instances launched in the VPC get DNS hostnames.
   */
  public enableDnsHostnames?: boolean | cdk.IResolvable;

  /**
   * Indicates whether the DNS resolution is supported for the VPC.
   */
  public enableDnsSupport?: boolean | cdk.IResolvable;

  /**
   * The allowed tenancy of instances launched into the VPC.
   */
  public instanceTenancy?: string;

  /**
   * The ID of an IPv4 IPAM pool you want to use for allocating this VPC's CIDR.
   */
  public ipv4IpamPoolId?: string;

  /**
   * The netmask length of the IPv4 CIDR you want to allocate to this VPC from an Amazon VPC IP Address Manager (IPAM) pool.
   */
  public ipv4NetmaskLength?: number;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags for the VPC.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnVPCProps = {}) {
    super(scope, id, {
      "type": CfnVPC.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.attrCidrBlock = cdk.Token.asString(this.getAtt("CidrBlock", cdk.ResolutionTypeHint.STRING));
    this.attrCidrBlockAssociations = cdk.Token.asList(this.getAtt("CidrBlockAssociations", cdk.ResolutionTypeHint.STRING_LIST));
    this.attrDefaultNetworkAcl = cdk.Token.asString(this.getAtt("DefaultNetworkAcl", cdk.ResolutionTypeHint.STRING));
    this.attrDefaultSecurityGroup = cdk.Token.asString(this.getAtt("DefaultSecurityGroup", cdk.ResolutionTypeHint.STRING));
    this.attrIpv6CidrBlocks = cdk.Token.asList(this.getAtt("Ipv6CidrBlocks", cdk.ResolutionTypeHint.STRING_LIST));
    this.attrVpcId = cdk.Token.asString(this.getAtt("VpcId", cdk.ResolutionTypeHint.STRING));
    this.cidrBlock = props.cidrBlock;
    this.enableDnsHostnames = props.enableDnsHostnames;
    this.enableDnsSupport = props.enableDnsSupport;
    this.instanceTenancy = props.instanceTenancy;
    this.ipv4IpamPoolId = props.ipv4IpamPoolId;
    this.ipv4NetmaskLength = props.ipv4NetmaskLength;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::VPC", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "cidrBlock": this.cidrBlock,
      "enableDnsHostnames": this.enableDnsHostnames,
      "enableDnsSupport": this.enableDnsSupport,
      "instanceTenancy": this.instanceTenancy,
      "ipv4IpamPoolId": this.ipv4IpamPoolId,
      "ipv4NetmaskLength": this.ipv4NetmaskLength,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnVPC.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnVPCPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnVPC\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html
 */
export interface CfnVPCProps {
  /**
   * The IPv4 network range for the VPC, in CIDR notation.
   *
   * For example, \`10.0.0.0/16\` . We modify the specified CIDR block to its canonical form; for example, if you specify \`100.68.0.18/18\` , we modify it to \`100.68.0.0/18\` .
   *
   * You must specify either \`CidrBlock\` or \`Ipv4IpamPoolId\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html#cfn-ec2-vpc-cidrblock
   */
  readonly cidrBlock?: string;

  /**
   * Indicates whether the instances launched in the VPC get DNS hostnames.
   *
   * If enabled, instances in the VPC get DNS hostnames; otherwise, they do not. Disabled by default for nondefault VPCs. For more information, see [DNS attributes in your VPC](https://docs.aws.amazon.com/vpc/latest/userguide/vpc-dns.html#vpc-dns-support) .
   *
   * You can only enable DNS hostnames if you've enabled DNS support.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html#cfn-ec2-vpc-enablednshostnames
   */
  readonly enableDnsHostnames?: boolean | cdk.IResolvable;

  /**
   * Indicates whether the DNS resolution is supported for the VPC.
   *
   * If enabled, queries to the Amazon provided DNS server at the 169.254.169.253 IP address, or the reserved IP address at the base of the VPC network range "plus two" succeed. If disabled, the Amazon provided DNS service in the VPC that resolves public DNS hostnames to IP addresses is not enabled. Enabled by default. For more information, see [DNS attributes in your VPC](https://docs.aws.amazon.com/vpc/latest/userguide/vpc-dns.html#vpc-dns-support) .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html#cfn-ec2-vpc-enablednssupport
   */
  readonly enableDnsSupport?: boolean | cdk.IResolvable;

  /**
   * The allowed tenancy of instances launched into the VPC.
   *
   * - \`default\` : An instance launched into the VPC runs on shared hardware by default, unless you explicitly specify a different tenancy during instance launch.
   * - \`dedicated\` : An instance launched into the VPC runs on dedicated hardware by default, unless you explicitly specify a tenancy of \`host\` during instance launch. You cannot specify a tenancy of \`default\` during instance launch.
   *
   * Updating \`InstanceTenancy\` requires no replacement only if you are updating its value from \`dedicated\` to \`default\` . Updating \`InstanceTenancy\` from \`default\` to \`dedicated\` requires replacement.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html#cfn-ec2-vpc-instancetenancy
   */
  readonly instanceTenancy?: string;

  /**
   * The ID of an IPv4 IPAM pool you want to use for allocating this VPC's CIDR.
   *
   * For more information, see [What is IPAM?](https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html) in the *Amazon VPC IPAM User Guide* .
   *
   * You must specify either \`CidrBlock\` or \`Ipv4IpamPoolId\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html#cfn-ec2-vpc-ipv4ipampoolid
   */
  readonly ipv4IpamPoolId?: string;

  /**
   * The netmask length of the IPv4 CIDR you want to allocate to this VPC from an Amazon VPC IP Address Manager (IPAM) pool.
   *
   * For more information about IPAM, see [What is IPAM?](https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html) in the *Amazon VPC IPAM User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html#cfn-ec2-vpc-ipv4netmasklength
   */
  readonly ipv4NetmaskLength?: number;

  /**
   * The tags for the VPC.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html#cfn-ec2-vpc-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a \`CfnVPCProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnVPCProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVPCPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("cidrBlock", cdk.validateString)(properties.cidrBlock));
  errors.collect(cdk.propertyValidator("enableDnsHostnames", cdk.validateBoolean)(properties.enableDnsHostnames));
  errors.collect(cdk.propertyValidator("enableDnsSupport", cdk.validateBoolean)(properties.enableDnsSupport));
  errors.collect(cdk.propertyValidator("instanceTenancy", cdk.validateString)(properties.instanceTenancy));
  errors.collect(cdk.propertyValidator("ipv4IpamPoolId", cdk.validateString)(properties.ipv4IpamPoolId));
  errors.collect(cdk.propertyValidator("ipv4NetmaskLength", cdk.validateNumber)(properties.ipv4NetmaskLength));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnVPCProps\\"");
}

// @ts-ignore TS6133
function convertCfnVPCPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVPCPropsValidator(properties).assertSuccess();
  return {
    "CidrBlock": cdk.stringToCloudFormation(properties.cidrBlock),
    "EnableDnsHostnames": cdk.booleanToCloudFormation(properties.enableDnsHostnames),
    "EnableDnsSupport": cdk.booleanToCloudFormation(properties.enableDnsSupport),
    "InstanceTenancy": cdk.stringToCloudFormation(properties.instanceTenancy),
    "Ipv4IpamPoolId": cdk.stringToCloudFormation(properties.ipv4IpamPoolId),
    "Ipv4NetmaskLength": cdk.numberToCloudFormation(properties.ipv4NetmaskLength),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnVPCPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnVPCProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVPCProps>();
  ret.addPropertyResult("cidrBlock", "CidrBlock", (properties.CidrBlock != null ? cfn_parse.FromCloudFormation.getString(properties.CidrBlock) : undefined));
  ret.addPropertyResult("enableDnsHostnames", "EnableDnsHostnames", (properties.EnableDnsHostnames != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EnableDnsHostnames) : undefined));
  ret.addPropertyResult("enableDnsSupport", "EnableDnsSupport", (properties.EnableDnsSupport != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EnableDnsSupport) : undefined));
  ret.addPropertyResult("instanceTenancy", "InstanceTenancy", (properties.InstanceTenancy != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceTenancy) : undefined));
  ret.addPropertyResult("ipv4IpamPoolId", "Ipv4IpamPoolId", (properties.Ipv4IpamPoolId != null ? cfn_parse.FromCloudFormation.getString(properties.Ipv4IpamPoolId) : undefined));
  ret.addPropertyResult("ipv4NetmaskLength", "Ipv4NetmaskLength", (properties.Ipv4NetmaskLength != null ? cfn_parse.FromCloudFormation.getNumber(properties.Ipv4NetmaskLength) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Associates a CIDR block with your VPC.
 *
 * You can only associate a single IPv6 CIDR block with your VPC. The IPv6 CIDR block size is fixed at /56.
 *
 * For more information about associating CIDR blocks with your VPC and applicable restrictions, see [VPC and Subnet Sizing](https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Subnets.html#VPC_Sizing) in the *Amazon VPC User Guide* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html
 */
export class CfnVPCCidrBlock extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::VPCCidrBlock";

  /**
   * Build a CfnVPCCidrBlock from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnVPCCidrBlock {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnVPCCidrBlockPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnVPCCidrBlock(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * Requests an Amazon-provided IPv6 CIDR block with a /56 prefix length for the VPC.
   */
  public amazonProvidedIpv6CidrBlock?: boolean | cdk.IResolvable;

  /**
   * An IPv4 CIDR block to associate with the VPC.
   */
  public cidrBlock?: string;

  /**
   * Associate a CIDR allocated from an IPv4 IPAM pool to a VPC.
   */
  public ipv4IpamPoolId?: string;

  /**
   * The netmask length of the IPv4 CIDR you would like to associate from an Amazon VPC IP Address Manager (IPAM) pool.
   */
  public ipv4NetmaskLength?: number;

  /**
   * An IPv6 CIDR block from the IPv6 address pool. You must also specify \`Ipv6Pool\` in the request.
   */
  public ipv6CidrBlock?: string;

  /**
   * Associates a CIDR allocated from an IPv6 IPAM pool to a VPC.
   */
  public ipv6IpamPoolId?: string;

  /**
   * The netmask length of the IPv6 CIDR you would like to associate from an Amazon VPC IP Address Manager (IPAM) pool.
   */
  public ipv6NetmaskLength?: number;

  /**
   * The ID of an IPv6 address pool from which to allocate the IPv6 CIDR block.
   */
  public ipv6Pool?: string;

  /**
   * The ID of the VPC.
   */
  public vpcId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnVPCCidrBlockProps) {
    super(scope, id, {
      "type": CfnVPCCidrBlock.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "vpcId", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.amazonProvidedIpv6CidrBlock = props.amazonProvidedIpv6CidrBlock;
    this.cidrBlock = props.cidrBlock;
    this.ipv4IpamPoolId = props.ipv4IpamPoolId;
    this.ipv4NetmaskLength = props.ipv4NetmaskLength;
    this.ipv6CidrBlock = props.ipv6CidrBlock;
    this.ipv6IpamPoolId = props.ipv6IpamPoolId;
    this.ipv6NetmaskLength = props.ipv6NetmaskLength;
    this.ipv6Pool = props.ipv6Pool;
    this.vpcId = props.vpcId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "amazonProvidedIpv6CidrBlock": this.amazonProvidedIpv6CidrBlock,
      "cidrBlock": this.cidrBlock,
      "ipv4IpamPoolId": this.ipv4IpamPoolId,
      "ipv4NetmaskLength": this.ipv4NetmaskLength,
      "ipv6CidrBlock": this.ipv6CidrBlock,
      "ipv6IpamPoolId": this.ipv6IpamPoolId,
      "ipv6NetmaskLength": this.ipv6NetmaskLength,
      "ipv6Pool": this.ipv6Pool,
      "vpcId": this.vpcId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnVPCCidrBlock.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnVPCCidrBlockPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnVPCCidrBlock\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html
 */
export interface CfnVPCCidrBlockProps {
  /**
   * Requests an Amazon-provided IPv6 CIDR block with a /56 prefix length for the VPC.
   *
   * You cannot specify the range of IPv6 addresses, or the size of the CIDR block.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-amazonprovidedipv6cidrblock
   */
  readonly amazonProvidedIpv6CidrBlock?: boolean | cdk.IResolvable;

  /**
   * An IPv4 CIDR block to associate with the VPC.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-cidrblock
   */
  readonly cidrBlock?: string;

  /**
   * Associate a CIDR allocated from an IPv4 IPAM pool to a VPC.
   *
   * For more information about Amazon VPC IP Address Manager (IPAM), see [What is IPAM?](https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html) in the *Amazon VPC IPAM User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-ipv4ipampoolid
   */
  readonly ipv4IpamPoolId?: string;

  /**
   * The netmask length of the IPv4 CIDR you would like to associate from an Amazon VPC IP Address Manager (IPAM) pool.
   *
   * For more information about IPAM, see [What is IPAM?](https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html) in the *Amazon VPC IPAM User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-ipv4netmasklength
   */
  readonly ipv4NetmaskLength?: number;

  /**
   * An IPv6 CIDR block from the IPv6 address pool. You must also specify \`Ipv6Pool\` in the request.
   *
   * To let Amazon choose the IPv6 CIDR block for you, omit this parameter.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-ipv6cidrblock
   */
  readonly ipv6CidrBlock?: string;

  /**
   * Associates a CIDR allocated from an IPv6 IPAM pool to a VPC.
   *
   * For more information about Amazon VPC IP Address Manager (IPAM), see [What is IPAM?](https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html) in the *Amazon VPC IPAM User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-ipv6ipampoolid
   */
  readonly ipv6IpamPoolId?: string;

  /**
   * The netmask length of the IPv6 CIDR you would like to associate from an Amazon VPC IP Address Manager (IPAM) pool.
   *
   * For more information about IPAM, see [What is IPAM?](https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html) in the *Amazon VPC IPAM User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-ipv6netmasklength
   */
  readonly ipv6NetmaskLength?: number;

  /**
   * The ID of an IPv6 address pool from which to allocate the IPv6 CIDR block.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-ipv6pool
   */
  readonly ipv6Pool?: string;

  /**
   * The ID of the VPC.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-vpcid
   */
  readonly vpcId: string;
}

/**
 * Determine whether the given properties match those of a \`CfnVPCCidrBlockProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnVPCCidrBlockProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVPCCidrBlockPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("amazonProvidedIpv6CidrBlock", cdk.validateBoolean)(properties.amazonProvidedIpv6CidrBlock));
  errors.collect(cdk.propertyValidator("cidrBlock", cdk.validateString)(properties.cidrBlock));
  errors.collect(cdk.propertyValidator("ipv4IpamPoolId", cdk.validateString)(properties.ipv4IpamPoolId));
  errors.collect(cdk.propertyValidator("ipv4NetmaskLength", cdk.validateNumber)(properties.ipv4NetmaskLength));
  errors.collect(cdk.propertyValidator("ipv6CidrBlock", cdk.validateString)(properties.ipv6CidrBlock));
  errors.collect(cdk.propertyValidator("ipv6IpamPoolId", cdk.validateString)(properties.ipv6IpamPoolId));
  errors.collect(cdk.propertyValidator("ipv6NetmaskLength", cdk.validateNumber)(properties.ipv6NetmaskLength));
  errors.collect(cdk.propertyValidator("ipv6Pool", cdk.validateString)(properties.ipv6Pool));
  errors.collect(cdk.propertyValidator("vpcId", cdk.requiredValidator)(properties.vpcId));
  errors.collect(cdk.propertyValidator("vpcId", cdk.validateString)(properties.vpcId));
  return errors.wrap("supplied properties not correct for \\"CfnVPCCidrBlockProps\\"");
}

// @ts-ignore TS6133
function convertCfnVPCCidrBlockPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVPCCidrBlockPropsValidator(properties).assertSuccess();
  return {
    "AmazonProvidedIpv6CidrBlock": cdk.booleanToCloudFormation(properties.amazonProvidedIpv6CidrBlock),
    "CidrBlock": cdk.stringToCloudFormation(properties.cidrBlock),
    "Ipv4IpamPoolId": cdk.stringToCloudFormation(properties.ipv4IpamPoolId),
    "Ipv4NetmaskLength": cdk.numberToCloudFormation(properties.ipv4NetmaskLength),
    "Ipv6CidrBlock": cdk.stringToCloudFormation(properties.ipv6CidrBlock),
    "Ipv6IpamPoolId": cdk.stringToCloudFormation(properties.ipv6IpamPoolId),
    "Ipv6NetmaskLength": cdk.numberToCloudFormation(properties.ipv6NetmaskLength),
    "Ipv6Pool": cdk.stringToCloudFormation(properties.ipv6Pool),
    "VpcId": cdk.stringToCloudFormation(properties.vpcId)
  };
}

// @ts-ignore TS6133
function CfnVPCCidrBlockPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnVPCCidrBlockProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVPCCidrBlockProps>();
  ret.addPropertyResult("amazonProvidedIpv6CidrBlock", "AmazonProvidedIpv6CidrBlock", (properties.AmazonProvidedIpv6CidrBlock != null ? cfn_parse.FromCloudFormation.getBoolean(properties.AmazonProvidedIpv6CidrBlock) : undefined));
  ret.addPropertyResult("cidrBlock", "CidrBlock", (properties.CidrBlock != null ? cfn_parse.FromCloudFormation.getString(properties.CidrBlock) : undefined));
  ret.addPropertyResult("ipv4IpamPoolId", "Ipv4IpamPoolId", (properties.Ipv4IpamPoolId != null ? cfn_parse.FromCloudFormation.getString(properties.Ipv4IpamPoolId) : undefined));
  ret.addPropertyResult("ipv4NetmaskLength", "Ipv4NetmaskLength", (properties.Ipv4NetmaskLength != null ? cfn_parse.FromCloudFormation.getNumber(properties.Ipv4NetmaskLength) : undefined));
  ret.addPropertyResult("ipv6CidrBlock", "Ipv6CidrBlock", (properties.Ipv6CidrBlock != null ? cfn_parse.FromCloudFormation.getString(properties.Ipv6CidrBlock) : undefined));
  ret.addPropertyResult("ipv6IpamPoolId", "Ipv6IpamPoolId", (properties.Ipv6IpamPoolId != null ? cfn_parse.FromCloudFormation.getString(properties.Ipv6IpamPoolId) : undefined));
  ret.addPropertyResult("ipv6NetmaskLength", "Ipv6NetmaskLength", (properties.Ipv6NetmaskLength != null ? cfn_parse.FromCloudFormation.getNumber(properties.Ipv6NetmaskLength) : undefined));
  ret.addPropertyResult("ipv6Pool", "Ipv6Pool", (properties.Ipv6Pool != null ? cfn_parse.FromCloudFormation.getString(properties.Ipv6Pool) : undefined));
  ret.addPropertyResult("vpcId", "VpcId", (properties.VpcId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Associates a set of DHCP options with a VPC, or associates no DHCP options with the VPC.
 *
 * After you associate the options with the VPC, any existing instances and all new instances that you launch in that VPC use the options. You don't need to restart or relaunch the instances. They automatically pick up the changes within a few hours, depending on how frequently the instance renews its DHCP lease. You can explicitly renew the lease using the operating system on the instance.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcdhcpoptionsassociation.html
 */
export class CfnVPCDHCPOptionsAssociation extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::VPCDHCPOptionsAssociation";

  /**
   * Build a CfnVPCDHCPOptionsAssociation from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnVPCDHCPOptionsAssociation {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnVPCDHCPOptionsAssociationPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnVPCDHCPOptionsAssociation(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the DHCP options set, or \`default\` to associate no DHCP options with the VPC.
   */
  public dhcpOptionsId: string;

  /**
   * The ID of the VPC.
   */
  public vpcId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnVPCDHCPOptionsAssociationProps) {
    super(scope, id, {
      "type": CfnVPCDHCPOptionsAssociation.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "dhcpOptionsId", this);
    cdk.requireProperty(props, "vpcId", this);

    this.dhcpOptionsId = props.dhcpOptionsId;
    this.vpcId = props.vpcId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "dhcpOptionsId": this.dhcpOptionsId,
      "vpcId": this.vpcId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnVPCDHCPOptionsAssociation.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnVPCDHCPOptionsAssociationPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnVPCDHCPOptionsAssociation\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcdhcpoptionsassociation.html
 */
export interface CfnVPCDHCPOptionsAssociationProps {
  /**
   * The ID of the DHCP options set, or \`default\` to associate no DHCP options with the VPC.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcdhcpoptionsassociation.html#cfn-ec2-vpcdhcpoptionsassociation-dhcpoptionsid
   */
  readonly dhcpOptionsId: string;

  /**
   * The ID of the VPC.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcdhcpoptionsassociation.html#cfn-ec2-vpcdhcpoptionsassociation-vpcid
   */
  readonly vpcId: string;
}

/**
 * Determine whether the given properties match those of a \`CfnVPCDHCPOptionsAssociationProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnVPCDHCPOptionsAssociationProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVPCDHCPOptionsAssociationPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("dhcpOptionsId", cdk.requiredValidator)(properties.dhcpOptionsId));
  errors.collect(cdk.propertyValidator("dhcpOptionsId", cdk.validateString)(properties.dhcpOptionsId));
  errors.collect(cdk.propertyValidator("vpcId", cdk.requiredValidator)(properties.vpcId));
  errors.collect(cdk.propertyValidator("vpcId", cdk.validateString)(properties.vpcId));
  return errors.wrap("supplied properties not correct for \\"CfnVPCDHCPOptionsAssociationProps\\"");
}

// @ts-ignore TS6133
function convertCfnVPCDHCPOptionsAssociationPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVPCDHCPOptionsAssociationPropsValidator(properties).assertSuccess();
  return {
    "DhcpOptionsId": cdk.stringToCloudFormation(properties.dhcpOptionsId),
    "VpcId": cdk.stringToCloudFormation(properties.vpcId)
  };
}

// @ts-ignore TS6133
function CfnVPCDHCPOptionsAssociationPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnVPCDHCPOptionsAssociationProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVPCDHCPOptionsAssociationProps>();
  ret.addPropertyResult("dhcpOptionsId", "DhcpOptionsId", (properties.DhcpOptionsId != null ? cfn_parse.FromCloudFormation.getString(properties.DhcpOptionsId) : undefined));
  ret.addPropertyResult("vpcId", "VpcId", (properties.VpcId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a VPC endpoint.
 *
 * A VPC endpoint provides a private connection between your VPC and an endpoint service. You can use an endpoint service provided by AWS , an AWS Marketplace Partner, or another AWS accounts in your organization. For more information, see the [AWS PrivateLink User Guide](https://docs.aws.amazon.com/vpc/latest/privatelink/) .
 *
 * An endpoint of type \`Interface\` establishes connections between the subnets in your VPC and an AWS service , your own service, or a service hosted by another AWS account . With an interface VPC endpoint, you specify the subnets in which to create the endpoint and the security groups to associate with the endpoint network interfaces.
 *
 * An endpoint of type \`gateway\` serves as a target for a route in your route table for traffic destined for Amazon S3 or DynamoDB . You can specify an endpoint policy for the endpoint, which controls access to the service from your VPC. You can also specify the VPC route tables that use the endpoint. For more information about connectivity to Amazon S3 , see [Why can't I connect to an S3 bucket using a gateway VPC endpoint?](https://docs.aws.amazon.com/premiumsupport/knowledge-center/connect-s3-vpc-endpoint)
 *
 * An endpoint of type \`GatewayLoadBalancer\` provides private connectivity between your VPC and virtual appliances from a service provider.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html
 */
export class CfnVPCEndpoint extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::VPCEndpoint";

  /**
   * Build a CfnVPCEndpoint from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnVPCEndpoint {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnVPCEndpointPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnVPCEndpoint(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The date and time the VPC endpoint was created. For example: \`Fri Sep 28 23:34:36 UTC 2018.\`
   *
   * @cloudformationAttribute CreationTimestamp
   */
  public readonly attrCreationTimestamp: string;

  /**
   * (Interface endpoints) The DNS entries for the endpoint. Each entry is a combination of the hosted zone ID and the DNS name. The entries are ordered as follows: regional public DNS, zonal public DNS, private DNS, and wildcard DNS. This order is not enforced for AWS Marketplace services.
   *
   * The following is an example. In the first entry, the hosted zone ID is Z1HUB23UULQXV and the DNS name is vpce-01abc23456de78f9g-12abccd3.ec2.us-east-1.vpce.amazonaws.com.
   *
   * ["Z1HUB23UULQXV:vpce-01abc23456de78f9g-12abccd3.ec2.us-east-1.vpce.amazonaws.com", "Z1HUB23UULQXV:vpce-01abc23456de78f9g-12abccd3-us-east-1a.ec2.us-east-1.vpce.amazonaws.com", "Z1C12344VYDITB0:ec2.us-east-1.amazonaws.com"]
   *
   * If you update the \`PrivateDnsEnabled\` or \`SubnetIds\` properties, the DNS entries in the list will change.
   *
   * @cloudformationAttribute DnsEntries
   */
  public readonly attrDnsEntries: Array<string>;

  /**
   * The ID of the VPC endpoint.
   *
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * (Interface endpoints) The network interface IDs. If you update the \`PrivateDnsEnabled\` or \`SubnetIds\` properties, the items in this list might change.
   *
   * @cloudformationAttribute NetworkInterfaceIds
   */
  public readonly attrNetworkInterfaceIds: Array<string>;

  /**
   * An endpoint policy, which controls access to the service from the VPC.
   */
  public policyDocument?: any | cdk.IResolvable;

  /**
   * Indicate whether to associate a private hosted zone with the specified VPC.
   */
  public privateDnsEnabled?: boolean | cdk.IResolvable;

  /**
   * The IDs of the route tables.
   */
  public routeTableIds?: Array<string>;

  /**
   * The IDs of the security groups to associate with the endpoint network interfaces.
   */
  public securityGroupIds?: Array<string>;

  /**
   * The name of the endpoint service.
   */
  public serviceName: string;

  /**
   * The IDs of the subnets in which to create endpoint network interfaces.
   */
  public subnetIds?: Array<string>;

  /**
   * The type of endpoint.
   */
  public vpcEndpointType?: string;

  /**
   * The ID of the VPC.
   */
  public vpcId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnVPCEndpointProps) {
    super(scope, id, {
      "type": CfnVPCEndpoint.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "serviceName", this);
    cdk.requireProperty(props, "vpcId", this);

    this.attrCreationTimestamp = cdk.Token.asString(this.getAtt("CreationTimestamp", cdk.ResolutionTypeHint.STRING));
    this.attrDnsEntries = cdk.Token.asList(this.getAtt("DnsEntries", cdk.ResolutionTypeHint.STRING_LIST));
    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.attrNetworkInterfaceIds = cdk.Token.asList(this.getAtt("NetworkInterfaceIds", cdk.ResolutionTypeHint.STRING_LIST));
    this.policyDocument = props.policyDocument;
    this.privateDnsEnabled = props.privateDnsEnabled;
    this.routeTableIds = props.routeTableIds;
    this.securityGroupIds = props.securityGroupIds;
    this.serviceName = props.serviceName;
    this.subnetIds = props.subnetIds;
    this.vpcEndpointType = props.vpcEndpointType;
    this.vpcId = props.vpcId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "policyDocument": this.policyDocument,
      "privateDnsEnabled": this.privateDnsEnabled,
      "routeTableIds": this.routeTableIds,
      "securityGroupIds": this.securityGroupIds,
      "serviceName": this.serviceName,
      "subnetIds": this.subnetIds,
      "vpcEndpointType": this.vpcEndpointType,
      "vpcId": this.vpcId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnVPCEndpoint.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnVPCEndpointPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnVPCEndpoint\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html
 */
export interface CfnVPCEndpointProps {
  /**
   * An endpoint policy, which controls access to the service from the VPC.
   *
   * The default endpoint policy allows full access to the service. Endpoint policies are supported only for gateway and interface endpoints.
   *
   * For CloudFormation templates in YAML, you can provide the policy in JSON or YAML format. AWS CloudFormation converts YAML policies to JSON format before calling the API to create or modify the VPC endpoint.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-policydocument
   */
  readonly policyDocument?: any | cdk.IResolvable;

  /**
   * Indicate whether to associate a private hosted zone with the specified VPC.
   *
   * The private hosted zone contains a record set for the default public DNS name for the service for the Region (for example, \`kinesis.us-east-1.amazonaws.com\` ), which resolves to the private IP addresses of the endpoint network interfaces in the VPC. This enables you to make requests to the default public DNS name for the service instead of the public DNS names that are automatically generated by the VPC endpoint service.
   *
   * To use a private hosted zone, you must set the following VPC attributes to \`true\` : \`enableDnsHostnames\` and \`enableDnsSupport\` .
   *
   * This property is supported only for interface endpoints.
   *
   * Default: \`false\`
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-privatednsenabled
   */
  readonly privateDnsEnabled?: boolean | cdk.IResolvable;

  /**
   * The IDs of the route tables.
   *
   * Routing is supported only for gateway endpoints.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-routetableids
   */
  readonly routeTableIds?: Array<string>;

  /**
   * The IDs of the security groups to associate with the endpoint network interfaces.
   *
   * If this parameter is not specified, we use the default security group for the VPC. Security groups are supported only for interface endpoints.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-securitygroupids
   */
  readonly securityGroupIds?: Array<string>;

  /**
   * The name of the endpoint service.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-servicename
   */
  readonly serviceName: string;

  /**
   * The IDs of the subnets in which to create endpoint network interfaces.
   *
   * You must specify this property for an interface endpoint or a Gateway Load Balancer endpoint. You can't specify this property for a gateway endpoint. For a Gateway Load Balancer endpoint, you can specify only one subnet.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-subnetids
   */
  readonly subnetIds?: Array<string>;

  /**
   * The type of endpoint.
   *
   * Default: Gateway
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-vpcendpointtype
   */
  readonly vpcEndpointType?: string;

  /**
   * The ID of the VPC.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-vpcid
   */
  readonly vpcId: string;
}

/**
 * Determine whether the given properties match those of a \`CfnVPCEndpointProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnVPCEndpointProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVPCEndpointPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("policyDocument", cdk.validateObject)(properties.policyDocument));
  errors.collect(cdk.propertyValidator("privateDnsEnabled", cdk.validateBoolean)(properties.privateDnsEnabled));
  errors.collect(cdk.propertyValidator("routeTableIds", cdk.listValidator(cdk.validateString))(properties.routeTableIds));
  errors.collect(cdk.propertyValidator("securityGroupIds", cdk.listValidator(cdk.validateString))(properties.securityGroupIds));
  errors.collect(cdk.propertyValidator("serviceName", cdk.requiredValidator)(properties.serviceName));
  errors.collect(cdk.propertyValidator("serviceName", cdk.validateString)(properties.serviceName));
  errors.collect(cdk.propertyValidator("subnetIds", cdk.listValidator(cdk.validateString))(properties.subnetIds));
  errors.collect(cdk.propertyValidator("vpcEndpointType", cdk.validateString)(properties.vpcEndpointType));
  errors.collect(cdk.propertyValidator("vpcId", cdk.requiredValidator)(properties.vpcId));
  errors.collect(cdk.propertyValidator("vpcId", cdk.validateString)(properties.vpcId));
  return errors.wrap("supplied properties not correct for \\"CfnVPCEndpointProps\\"");
}

// @ts-ignore TS6133
function convertCfnVPCEndpointPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVPCEndpointPropsValidator(properties).assertSuccess();
  return {
    "PolicyDocument": cdk.objectToCloudFormation(properties.policyDocument),
    "PrivateDnsEnabled": cdk.booleanToCloudFormation(properties.privateDnsEnabled),
    "RouteTableIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.routeTableIds),
    "SecurityGroupIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.securityGroupIds),
    "ServiceName": cdk.stringToCloudFormation(properties.serviceName),
    "SubnetIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.subnetIds),
    "VpcEndpointType": cdk.stringToCloudFormation(properties.vpcEndpointType),
    "VpcId": cdk.stringToCloudFormation(properties.vpcId)
  };
}

// @ts-ignore TS6133
function CfnVPCEndpointPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnVPCEndpointProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVPCEndpointProps>();
  ret.addPropertyResult("policyDocument", "PolicyDocument", (properties.PolicyDocument != null ? cfn_parse.FromCloudFormation.getAny(properties.PolicyDocument) : undefined));
  ret.addPropertyResult("privateDnsEnabled", "PrivateDnsEnabled", (properties.PrivateDnsEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.PrivateDnsEnabled) : undefined));
  ret.addPropertyResult("routeTableIds", "RouteTableIds", (properties.RouteTableIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.RouteTableIds) : undefined));
  ret.addPropertyResult("securityGroupIds", "SecurityGroupIds", (properties.SecurityGroupIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecurityGroupIds) : undefined));
  ret.addPropertyResult("serviceName", "ServiceName", (properties.ServiceName != null ? cfn_parse.FromCloudFormation.getString(properties.ServiceName) : undefined));
  ret.addPropertyResult("subnetIds", "SubnetIds", (properties.SubnetIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SubnetIds) : undefined));
  ret.addPropertyResult("vpcEndpointType", "VpcEndpointType", (properties.VpcEndpointType != null ? cfn_parse.FromCloudFormation.getString(properties.VpcEndpointType) : undefined));
  ret.addPropertyResult("vpcId", "VpcId", (properties.VpcId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a connection notification for a VPC endpoint or VPC endpoint service.
 *
 * A connection notification notifies you of specific endpoint events. You must create an SNS topic to receive notifications. For more information, see [Create a Topic](https://docs.aws.amazon.com/sns/latest/dg/CreateTopic.html) in the *Amazon Simple Notification Service Developer Guide* .
 *
 * You can create a connection notification for interface endpoints only.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointconnectionnotification.html
 */
export class CfnVPCEndpointConnectionNotification extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::VPCEndpointConnectionNotification";

  /**
   * Build a CfnVPCEndpointConnectionNotification from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnVPCEndpointConnectionNotification {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnVPCEndpointConnectionNotificationPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnVPCEndpointConnectionNotification(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The endpoint events for which to receive notifications.
   */
  public connectionEvents: Array<string>;

  /**
   * The ARN of the SNS topic for the notifications.
   */
  public connectionNotificationArn: string;

  /**
   * The ID of the endpoint service.
   */
  public serviceId?: string;

  /**
   * The ID of the endpoint.
   */
  public vpcEndpointId?: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnVPCEndpointConnectionNotificationProps) {
    super(scope, id, {
      "type": CfnVPCEndpointConnectionNotification.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "connectionEvents", this);
    cdk.requireProperty(props, "connectionNotificationArn", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.connectionEvents = props.connectionEvents;
    this.connectionNotificationArn = props.connectionNotificationArn;
    this.serviceId = props.serviceId;
    this.vpcEndpointId = props.vpcEndpointId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "connectionEvents": this.connectionEvents,
      "connectionNotificationArn": this.connectionNotificationArn,
      "serviceId": this.serviceId,
      "vpcEndpointId": this.vpcEndpointId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnVPCEndpointConnectionNotification.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnVPCEndpointConnectionNotificationPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnVPCEndpointConnectionNotification\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointconnectionnotification.html
 */
export interface CfnVPCEndpointConnectionNotificationProps {
  /**
   * The endpoint events for which to receive notifications.
   *
   * Valid values are \`Accept\` , \`Connect\` , \`Delete\` , and \`Reject\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointconnectionnotification.html#cfn-ec2-vpcendpointconnectionnotification-connectionevents
   */
  readonly connectionEvents: Array<string>;

  /**
   * The ARN of the SNS topic for the notifications.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointconnectionnotification.html#cfn-ec2-vpcendpointconnectionnotification-connectionnotificationarn
   */
  readonly connectionNotificationArn: string;

  /**
   * The ID of the endpoint service.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointconnectionnotification.html#cfn-ec2-vpcendpointconnectionnotification-serviceid
   */
  readonly serviceId?: string;

  /**
   * The ID of the endpoint.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointconnectionnotification.html#cfn-ec2-vpcendpointconnectionnotification-vpcendpointid
   */
  readonly vpcEndpointId?: string;
}

/**
 * Determine whether the given properties match those of a \`CfnVPCEndpointConnectionNotificationProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnVPCEndpointConnectionNotificationProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVPCEndpointConnectionNotificationPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("connectionEvents", cdk.requiredValidator)(properties.connectionEvents));
  errors.collect(cdk.propertyValidator("connectionEvents", cdk.listValidator(cdk.validateString))(properties.connectionEvents));
  errors.collect(cdk.propertyValidator("connectionNotificationArn", cdk.requiredValidator)(properties.connectionNotificationArn));
  errors.collect(cdk.propertyValidator("connectionNotificationArn", cdk.validateString)(properties.connectionNotificationArn));
  errors.collect(cdk.propertyValidator("serviceId", cdk.validateString)(properties.serviceId));
  errors.collect(cdk.propertyValidator("vpcEndpointId", cdk.validateString)(properties.vpcEndpointId));
  return errors.wrap("supplied properties not correct for \\"CfnVPCEndpointConnectionNotificationProps\\"");
}

// @ts-ignore TS6133
function convertCfnVPCEndpointConnectionNotificationPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVPCEndpointConnectionNotificationPropsValidator(properties).assertSuccess();
  return {
    "ConnectionEvents": cdk.listMapper(cdk.stringToCloudFormation)(properties.connectionEvents),
    "ConnectionNotificationArn": cdk.stringToCloudFormation(properties.connectionNotificationArn),
    "ServiceId": cdk.stringToCloudFormation(properties.serviceId),
    "VPCEndpointId": cdk.stringToCloudFormation(properties.vpcEndpointId)
  };
}

// @ts-ignore TS6133
function CfnVPCEndpointConnectionNotificationPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnVPCEndpointConnectionNotificationProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVPCEndpointConnectionNotificationProps>();
  ret.addPropertyResult("connectionEvents", "ConnectionEvents", (properties.ConnectionEvents != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.ConnectionEvents) : undefined));
  ret.addPropertyResult("connectionNotificationArn", "ConnectionNotificationArn", (properties.ConnectionNotificationArn != null ? cfn_parse.FromCloudFormation.getString(properties.ConnectionNotificationArn) : undefined));
  ret.addPropertyResult("serviceId", "ServiceId", (properties.ServiceId != null ? cfn_parse.FromCloudFormation.getString(properties.ServiceId) : undefined));
  ret.addPropertyResult("vpcEndpointId", "VPCEndpointId", (properties.VPCEndpointId != null ? cfn_parse.FromCloudFormation.getString(properties.VPCEndpointId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Creates a VPC endpoint service configuration to which service consumers ( AWS accounts, users, and IAM roles) can connect.
 *
 * To create an endpoint service configuration, you must first create one of the following for your service:
 *
 * - A [Network Load Balancer](https://docs.aws.amazon.com/elasticloadbalancing/latest/network/introduction.html) . Service consumers connect to your service using an interface endpoint.
 * - A [Gateway Load Balancer](https://docs.aws.amazon.com/elasticloadbalancing/latest/gateway/introduction.html) . Service consumers connect to your service using a Gateway Load Balancer endpoint.
 *
 * For more information, see the [AWS PrivateLink User Guide](https://docs.aws.amazon.com/vpc/latest/privatelink/) .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservice.html
 */
export class CfnVPCEndpointService extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::VPCEndpointService";

  /**
   * Build a CfnVPCEndpointService from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnVPCEndpointService {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnVPCEndpointServicePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnVPCEndpointService(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the endpoint service.
   *
   * @cloudformationAttribute ServiceId
   */
  public readonly attrServiceId: string;

  /**
   * Indicates whether requests from service consumers to create an endpoint to your service must be accepted.
   */
  public acceptanceRequired?: boolean | cdk.IResolvable;

  /**
   * Indicates whether to enable the built-in Contributor Insights rules provided by AWS PrivateLink .
   */
  public contributorInsightsEnabled?: boolean | cdk.IResolvable;

  /**
   * The Amazon Resource Names (ARNs) of the Gateway Load Balancers.
   */
  public gatewayLoadBalancerArns?: Array<string>;

  /**
   * The Amazon Resource Names (ARNs) of the Network Load Balancers.
   */
  public networkLoadBalancerArns?: Array<string>;

  /**
   * The entity that is responsible for the endpoint costs.
   */
  public payerResponsibility?: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnVPCEndpointServiceProps = {}) {
    super(scope, id, {
      "type": CfnVPCEndpointService.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.attrServiceId = cdk.Token.asString(this.getAtt("ServiceId", cdk.ResolutionTypeHint.STRING));
    this.acceptanceRequired = props.acceptanceRequired;
    this.contributorInsightsEnabled = props.contributorInsightsEnabled;
    this.gatewayLoadBalancerArns = props.gatewayLoadBalancerArns;
    this.networkLoadBalancerArns = props.networkLoadBalancerArns;
    this.payerResponsibility = props.payerResponsibility;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "acceptanceRequired": this.acceptanceRequired,
      "contributorInsightsEnabled": this.contributorInsightsEnabled,
      "gatewayLoadBalancerArns": this.gatewayLoadBalancerArns,
      "networkLoadBalancerArns": this.networkLoadBalancerArns,
      "payerResponsibility": this.payerResponsibility
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnVPCEndpointService.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnVPCEndpointServicePropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnVPCEndpointService\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservice.html
 */
export interface CfnVPCEndpointServiceProps {
  /**
   * Indicates whether requests from service consumers to create an endpoint to your service must be accepted.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservice.html#cfn-ec2-vpcendpointservice-acceptancerequired
   */
  readonly acceptanceRequired?: boolean | cdk.IResolvable;

  /**
   * Indicates whether to enable the built-in Contributor Insights rules provided by AWS PrivateLink .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservice.html#cfn-ec2-vpcendpointservice-contributorinsightsenabled
   */
  readonly contributorInsightsEnabled?: boolean | cdk.IResolvable;

  /**
   * The Amazon Resource Names (ARNs) of the Gateway Load Balancers.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservice.html#cfn-ec2-vpcendpointservice-gatewayloadbalancerarns
   */
  readonly gatewayLoadBalancerArns?: Array<string>;

  /**
   * The Amazon Resource Names (ARNs) of the Network Load Balancers.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservice.html#cfn-ec2-vpcendpointservice-networkloadbalancerarns
   */
  readonly networkLoadBalancerArns?: Array<string>;

  /**
   * The entity that is responsible for the endpoint costs.
   *
   * The default is the endpoint owner. If you set the payer responsibility to the service owner, you cannot set it back to the endpoint owner.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservice.html#cfn-ec2-vpcendpointservice-payerresponsibility
   */
  readonly payerResponsibility?: string;
}

/**
 * Determine whether the given properties match those of a \`CfnVPCEndpointServiceProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnVPCEndpointServiceProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVPCEndpointServicePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("acceptanceRequired", cdk.validateBoolean)(properties.acceptanceRequired));
  errors.collect(cdk.propertyValidator("contributorInsightsEnabled", cdk.validateBoolean)(properties.contributorInsightsEnabled));
  errors.collect(cdk.propertyValidator("gatewayLoadBalancerArns", cdk.listValidator(cdk.validateString))(properties.gatewayLoadBalancerArns));
  errors.collect(cdk.propertyValidator("networkLoadBalancerArns", cdk.listValidator(cdk.validateString))(properties.networkLoadBalancerArns));
  errors.collect(cdk.propertyValidator("payerResponsibility", cdk.validateString)(properties.payerResponsibility));
  return errors.wrap("supplied properties not correct for \\"CfnVPCEndpointServiceProps\\"");
}

// @ts-ignore TS6133
function convertCfnVPCEndpointServicePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVPCEndpointServicePropsValidator(properties).assertSuccess();
  return {
    "AcceptanceRequired": cdk.booleanToCloudFormation(properties.acceptanceRequired),
    "ContributorInsightsEnabled": cdk.booleanToCloudFormation(properties.contributorInsightsEnabled),
    "GatewayLoadBalancerArns": cdk.listMapper(cdk.stringToCloudFormation)(properties.gatewayLoadBalancerArns),
    "NetworkLoadBalancerArns": cdk.listMapper(cdk.stringToCloudFormation)(properties.networkLoadBalancerArns),
    "PayerResponsibility": cdk.stringToCloudFormation(properties.payerResponsibility)
  };
}

// @ts-ignore TS6133
function CfnVPCEndpointServicePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnVPCEndpointServiceProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVPCEndpointServiceProps>();
  ret.addPropertyResult("acceptanceRequired", "AcceptanceRequired", (properties.AcceptanceRequired != null ? cfn_parse.FromCloudFormation.getBoolean(properties.AcceptanceRequired) : undefined));
  ret.addPropertyResult("contributorInsightsEnabled", "ContributorInsightsEnabled", (properties.ContributorInsightsEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.ContributorInsightsEnabled) : undefined));
  ret.addPropertyResult("gatewayLoadBalancerArns", "GatewayLoadBalancerArns", (properties.GatewayLoadBalancerArns != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.GatewayLoadBalancerArns) : undefined));
  ret.addPropertyResult("networkLoadBalancerArns", "NetworkLoadBalancerArns", (properties.NetworkLoadBalancerArns != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.NetworkLoadBalancerArns) : undefined));
  ret.addPropertyResult("payerResponsibility", "PayerResponsibility", (properties.PayerResponsibility != null ? cfn_parse.FromCloudFormation.getString(properties.PayerResponsibility) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Grant or revoke permissions for service consumers (users, IAM roles, and AWS accounts) to connect to a VPC endpoint service.
 *
 * If you grant permissions to all principals, the service is public. Any users who know the name of a public service can send a request to attach an endpoint. If the service does not require manual approval, attachments are automatically approved.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservicepermissions.html
 */
export class CfnVPCEndpointServicePermissions extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::VPCEndpointServicePermissions";

  /**
   * Build a CfnVPCEndpointServicePermissions from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnVPCEndpointServicePermissions {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnVPCEndpointServicePermissionsPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnVPCEndpointServicePermissions(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The Amazon Resource Names (ARN) of one or more principals (for example, users, IAM roles, and AWS accounts ).
   */
  public allowedPrincipals?: Array<string>;

  /**
   * The ID of the service.
   */
  public serviceId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnVPCEndpointServicePermissionsProps) {
    super(scope, id, {
      "type": CfnVPCEndpointServicePermissions.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "serviceId", this);

    this.allowedPrincipals = props.allowedPrincipals;
    this.serviceId = props.serviceId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "allowedPrincipals": this.allowedPrincipals,
      "serviceId": this.serviceId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnVPCEndpointServicePermissions.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnVPCEndpointServicePermissionsPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnVPCEndpointServicePermissions\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservicepermissions.html
 */
export interface CfnVPCEndpointServicePermissionsProps {
  /**
   * The Amazon Resource Names (ARN) of one or more principals (for example, users, IAM roles, and AWS accounts ).
   *
   * Permissions are granted to the principals in this list. To grant permissions to all principals, specify an asterisk (*). Permissions are revoked for principals not in this list. If the list is empty, then all permissions are revoked.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservicepermissions.html#cfn-ec2-vpcendpointservicepermissions-allowedprincipals
   */
  readonly allowedPrincipals?: Array<string>;

  /**
   * The ID of the service.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservicepermissions.html#cfn-ec2-vpcendpointservicepermissions-serviceid
   */
  readonly serviceId: string;
}

/**
 * Determine whether the given properties match those of a \`CfnVPCEndpointServicePermissionsProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnVPCEndpointServicePermissionsProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVPCEndpointServicePermissionsPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("allowedPrincipals", cdk.listValidator(cdk.validateString))(properties.allowedPrincipals));
  errors.collect(cdk.propertyValidator("serviceId", cdk.requiredValidator)(properties.serviceId));
  errors.collect(cdk.propertyValidator("serviceId", cdk.validateString)(properties.serviceId));
  return errors.wrap("supplied properties not correct for \\"CfnVPCEndpointServicePermissionsProps\\"");
}

// @ts-ignore TS6133
function convertCfnVPCEndpointServicePermissionsPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVPCEndpointServicePermissionsPropsValidator(properties).assertSuccess();
  return {
    "AllowedPrincipals": cdk.listMapper(cdk.stringToCloudFormation)(properties.allowedPrincipals),
    "ServiceId": cdk.stringToCloudFormation(properties.serviceId)
  };
}

// @ts-ignore TS6133
function CfnVPCEndpointServicePermissionsPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnVPCEndpointServicePermissionsProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVPCEndpointServicePermissionsProps>();
  ret.addPropertyResult("allowedPrincipals", "AllowedPrincipals", (properties.AllowedPrincipals != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.AllowedPrincipals) : undefined));
  ret.addPropertyResult("serviceId", "ServiceId", (properties.ServiceId != null ? cfn_parse.FromCloudFormation.getString(properties.ServiceId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Attaches an internet gateway, or a virtual private gateway to a VPC, enabling connectivity between the internet and the VPC.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcgatewayattachment.html
 */
export class CfnVPCGatewayAttachment extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::VPCGatewayAttachment";

  /**
   * Build a CfnVPCGatewayAttachment from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnVPCGatewayAttachment {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnVPCGatewayAttachmentPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnVPCGatewayAttachment(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The ID of the internet gateway.
   */
  public internetGatewayId?: string;

  /**
   * The ID of the VPC.
   */
  public vpcId: string;

  /**
   * The ID of the virtual private gateway.
   */
  public vpnGatewayId?: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnVPCGatewayAttachmentProps) {
    super(scope, id, {
      "type": CfnVPCGatewayAttachment.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "vpcId", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.internetGatewayId = props.internetGatewayId;
    this.vpcId = props.vpcId;
    this.vpnGatewayId = props.vpnGatewayId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "internetGatewayId": this.internetGatewayId,
      "vpcId": this.vpcId,
      "vpnGatewayId": this.vpnGatewayId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnVPCGatewayAttachment.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnVPCGatewayAttachmentPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnVPCGatewayAttachment\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcgatewayattachment.html
 */
export interface CfnVPCGatewayAttachmentProps {
  /**
   * The ID of the internet gateway.
   *
   * You must specify either \`InternetGatewayId\` or \`VpnGatewayId\` , but not both.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcgatewayattachment.html#cfn-ec2-vpcgatewayattachment-internetgatewayid
   */
  readonly internetGatewayId?: string;

  /**
   * The ID of the VPC.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcgatewayattachment.html#cfn-ec2-vpcgatewayattachment-vpcid
   */
  readonly vpcId: string;

  /**
   * The ID of the virtual private gateway.
   *
   * You must specify either \`InternetGatewayId\` or \`VpnGatewayId\` , but not both.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcgatewayattachment.html#cfn-ec2-vpcgatewayattachment-vpngatewayid
   */
  readonly vpnGatewayId?: string;
}

/**
 * Determine whether the given properties match those of a \`CfnVPCGatewayAttachmentProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnVPCGatewayAttachmentProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVPCGatewayAttachmentPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("internetGatewayId", cdk.validateString)(properties.internetGatewayId));
  errors.collect(cdk.propertyValidator("vpcId", cdk.requiredValidator)(properties.vpcId));
  errors.collect(cdk.propertyValidator("vpcId", cdk.validateString)(properties.vpcId));
  errors.collect(cdk.propertyValidator("vpnGatewayId", cdk.validateString)(properties.vpnGatewayId));
  return errors.wrap("supplied properties not correct for \\"CfnVPCGatewayAttachmentProps\\"");
}

// @ts-ignore TS6133
function convertCfnVPCGatewayAttachmentPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVPCGatewayAttachmentPropsValidator(properties).assertSuccess();
  return {
    "InternetGatewayId": cdk.stringToCloudFormation(properties.internetGatewayId),
    "VpcId": cdk.stringToCloudFormation(properties.vpcId),
    "VpnGatewayId": cdk.stringToCloudFormation(properties.vpnGatewayId)
  };
}

// @ts-ignore TS6133
function CfnVPCGatewayAttachmentPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnVPCGatewayAttachmentProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVPCGatewayAttachmentProps>();
  ret.addPropertyResult("internetGatewayId", "InternetGatewayId", (properties.InternetGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.InternetGatewayId) : undefined));
  ret.addPropertyResult("vpcId", "VpcId", (properties.VpcId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcId) : undefined));
  ret.addPropertyResult("vpnGatewayId", "VpnGatewayId", (properties.VpnGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.VpnGatewayId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Requests a VPC peering connection between two VPCs: a requester VPC that you own and an accepter VPC with which to create the connection.
 *
 * The accepter VPC can belong to a different AWS account and can be in a different Region than the requester VPC.
 *
 * The requester VPC and accepter VPC cannot have overlapping CIDR blocks. If you create a VPC peering connection request between VPCs with overlapping CIDR blocks, the VPC peering connection has a status of \`failed\` .
 *
 * If the VPCs belong to different accounts, the acceptor account must have a role that allows the requester account to accept the VPC peering connection. For more information, see [Walkthough: Peer with a VPC in another AWS account](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/peer-with-vpc-in-another-account.html) .
 *
 * If the requester and acceptor VPCs are in the same account, the peering request is accepted without a peering role.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcpeeringconnection.html
 */
export class CfnVPCPeeringConnection extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::VPCPeeringConnection";

  /**
   * Build a CfnVPCPeeringConnection from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnVPCPeeringConnection {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnVPCPeeringConnectionPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnVPCPeeringConnection(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the peering connection.
   *
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The AWS account ID of the owner of the accepter VPC.
   */
  public peerOwnerId?: string;

  /**
   * The Region code for the accepter VPC, if the accepter VPC is located in a Region other than the Region in which you make the request.
   */
  public peerRegion?: string;

  /**
   * The Amazon Resource Name (ARN) of the VPC peer role for the peering connection in another AWS account.
   */
  public peerRoleArn?: string;

  /**
   * The ID of the VPC with which you are creating the VPC peering connection.
   */
  public peerVpcId: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * Any tags assigned to the resource.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The ID of the VPC.
   */
  public vpcId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnVPCPeeringConnectionProps) {
    super(scope, id, {
      "type": CfnVPCPeeringConnection.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "peerVpcId", this);
    cdk.requireProperty(props, "vpcId", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.peerOwnerId = props.peerOwnerId;
    this.peerRegion = props.peerRegion;
    this.peerRoleArn = props.peerRoleArn;
    this.peerVpcId = props.peerVpcId;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::VPCPeeringConnection", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.vpcId = props.vpcId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "peerOwnerId": this.peerOwnerId,
      "peerRegion": this.peerRegion,
      "peerRoleArn": this.peerRoleArn,
      "peerVpcId": this.peerVpcId,
      "tags": this.tags.renderTags(),
      "vpcId": this.vpcId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnVPCPeeringConnection.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnVPCPeeringConnectionPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnVPCPeeringConnection\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcpeeringconnection.html
 */
export interface CfnVPCPeeringConnectionProps {
  /**
   * The AWS account ID of the owner of the accepter VPC.
   *
   * Default: Your AWS account ID
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcpeeringconnection.html#cfn-ec2-vpcpeeringconnection-peerownerid
   */
  readonly peerOwnerId?: string;

  /**
   * The Region code for the accepter VPC, if the accepter VPC is located in a Region other than the Region in which you make the request.
   *
   * Default: The Region in which you make the request.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcpeeringconnection.html#cfn-ec2-vpcpeeringconnection-peerregion
   */
  readonly peerRegion?: string;

  /**
   * The Amazon Resource Name (ARN) of the VPC peer role for the peering connection in another AWS account.
   *
   * This is required when you are peering a VPC in a different AWS account.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcpeeringconnection.html#cfn-ec2-vpcpeeringconnection-peerrolearn
   */
  readonly peerRoleArn?: string;

  /**
   * The ID of the VPC with which you are creating the VPC peering connection.
   *
   * You must specify this parameter in the request.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcpeeringconnection.html#cfn-ec2-vpcpeeringconnection-peervpcid
   */
  readonly peerVpcId: string;

  /**
   * Any tags assigned to the resource.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcpeeringconnection.html#cfn-ec2-vpcpeeringconnection-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The ID of the VPC.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcpeeringconnection.html#cfn-ec2-vpcpeeringconnection-vpcid
   */
  readonly vpcId: string;
}

/**
 * Determine whether the given properties match those of a \`CfnVPCPeeringConnectionProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnVPCPeeringConnectionProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVPCPeeringConnectionPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("peerOwnerId", cdk.validateString)(properties.peerOwnerId));
  errors.collect(cdk.propertyValidator("peerRegion", cdk.validateString)(properties.peerRegion));
  errors.collect(cdk.propertyValidator("peerRoleArn", cdk.validateString)(properties.peerRoleArn));
  errors.collect(cdk.propertyValidator("peerVpcId", cdk.requiredValidator)(properties.peerVpcId));
  errors.collect(cdk.propertyValidator("peerVpcId", cdk.validateString)(properties.peerVpcId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("vpcId", cdk.requiredValidator)(properties.vpcId));
  errors.collect(cdk.propertyValidator("vpcId", cdk.validateString)(properties.vpcId));
  return errors.wrap("supplied properties not correct for \\"CfnVPCPeeringConnectionProps\\"");
}

// @ts-ignore TS6133
function convertCfnVPCPeeringConnectionPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVPCPeeringConnectionPropsValidator(properties).assertSuccess();
  return {
    "PeerOwnerId": cdk.stringToCloudFormation(properties.peerOwnerId),
    "PeerRegion": cdk.stringToCloudFormation(properties.peerRegion),
    "PeerRoleArn": cdk.stringToCloudFormation(properties.peerRoleArn),
    "PeerVpcId": cdk.stringToCloudFormation(properties.peerVpcId),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "VpcId": cdk.stringToCloudFormation(properties.vpcId)
  };
}

// @ts-ignore TS6133
function CfnVPCPeeringConnectionPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnVPCPeeringConnectionProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVPCPeeringConnectionProps>();
  ret.addPropertyResult("peerOwnerId", "PeerOwnerId", (properties.PeerOwnerId != null ? cfn_parse.FromCloudFormation.getString(properties.PeerOwnerId) : undefined));
  ret.addPropertyResult("peerRegion", "PeerRegion", (properties.PeerRegion != null ? cfn_parse.FromCloudFormation.getString(properties.PeerRegion) : undefined));
  ret.addPropertyResult("peerRoleArn", "PeerRoleArn", (properties.PeerRoleArn != null ? cfn_parse.FromCloudFormation.getString(properties.PeerRoleArn) : undefined));
  ret.addPropertyResult("peerVpcId", "PeerVpcId", (properties.PeerVpcId != null ? cfn_parse.FromCloudFormation.getString(properties.PeerVpcId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("vpcId", "VpcId", (properties.VpcId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a VPN connection between a virtual private gateway and a VPN customer gateway or a transit gateway and a VPN customer gateway.
 *
 * To specify a VPN connection between a transit gateway and customer gateway, use the \`TransitGatewayId\` and \`CustomerGatewayId\` properties.
 *
 * To specify a VPN connection between a virtual private gateway and customer gateway, use the \`VpnGatewayId\` and \`CustomerGatewayId\` properties.
 *
 * For more information, see [AWS Site-to-Site VPN](https://docs.aws.amazon.com/vpn/latest/s2svpn/VPC_VPN.html) in the *AWS Site-to-Site VPN User Guide* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnection.html
 */
export class CfnVPNConnection extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::VPNConnection";

  /**
   * Build a CfnVPNConnection from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnVPNConnection {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnVPNConnectionPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnVPNConnection(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the VPN connection.
   *
   * @cloudformationAttribute VpnConnectionId
   */
  public readonly attrVpnConnectionId: string;

  /**
   * The ID of the customer gateway at your end of the VPN connection.
   */
  public customerGatewayId: string;

  /**
   * Indicates whether the VPN connection uses static routes only.
   */
  public staticRoutesOnly?: boolean | cdk.IResolvable;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * Any tags assigned to the VPN connection.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The ID of the transit gateway associated with the VPN connection.
   */
  public transitGatewayId?: string;

  /**
   * The type of VPN connection.
   */
  public type: string;

  /**
   * The ID of the virtual private gateway at the AWS side of the VPN connection.
   */
  public vpnGatewayId?: string;

  /**
   * The tunnel options for the VPN connection.
   */
  public vpnTunnelOptionsSpecifications?: Array<cdk.IResolvable | CfnVPNConnection.VpnTunnelOptionsSpecificationProperty> | cdk.IResolvable;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnVPNConnectionProps) {
    super(scope, id, {
      "type": CfnVPNConnection.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "customerGatewayId", this);
    cdk.requireProperty(props, "type", this);

    this.attrVpnConnectionId = cdk.Token.asString(this.getAtt("VpnConnectionId", cdk.ResolutionTypeHint.STRING));
    this.customerGatewayId = props.customerGatewayId;
    this.staticRoutesOnly = props.staticRoutesOnly;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::VPNConnection", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.transitGatewayId = props.transitGatewayId;
    this.type = props.type;
    this.vpnGatewayId = props.vpnGatewayId;
    this.vpnTunnelOptionsSpecifications = props.vpnTunnelOptionsSpecifications;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "customerGatewayId": this.customerGatewayId,
      "staticRoutesOnly": this.staticRoutesOnly,
      "tags": this.tags.renderTags(),
      "transitGatewayId": this.transitGatewayId,
      "type": this.type,
      "vpnGatewayId": this.vpnGatewayId,
      "vpnTunnelOptionsSpecifications": this.vpnTunnelOptionsSpecifications
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnVPNConnection.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnVPNConnectionPropsToCloudFormation(props);
  }
}

export namespace CfnVPNConnection {
  /**
   * The tunnel options for a single VPN tunnel.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-vpntunneloptionsspecification.html
   */
  export interface VpnTunnelOptionsSpecificationProperty {
    /**
     * The pre-shared key (PSK) to establish initial authentication between the virtual private gateway and customer gateway.
     *
     * Constraints: Allowed characters are alphanumeric characters, periods (.), and underscores (_). Must be between 8 and 64 characters in length and cannot start with zero (0).
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-vpntunneloptionsspecification.html#cfn-ec2-vpnconnection-vpntunneloptionsspecification-presharedkey
     */
    readonly preSharedKey?: string;

    /**
     * The range of inside IP addresses for the tunnel.
     *
     * Any specified CIDR blocks must be unique across all VPN connections that use the same virtual private gateway.
     *
     * Constraints: A size /30 CIDR block from the \`169.254.0.0/16\` range. The following CIDR blocks are reserved and cannot be used:
     *
     * - \`169.254.0.0/30\`
     * - \`169.254.1.0/30\`
     * - \`169.254.2.0/30\`
     * - \`169.254.3.0/30\`
     * - \`169.254.4.0/30\`
     * - \`169.254.5.0/30\`
     * - \`169.254.169.252/30\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-vpntunneloptionsspecification.html#cfn-ec2-vpnconnection-vpntunneloptionsspecification-tunnelinsidecidr
     */
    readonly tunnelInsideCidr?: string;
  }
}

/**
 * Properties for defining a \`CfnVPNConnection\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnection.html
 */
export interface CfnVPNConnectionProps {
  /**
   * The ID of the customer gateway at your end of the VPN connection.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnection.html#cfn-ec2-vpnconnection-customergatewayid
   */
  readonly customerGatewayId: string;

  /**
   * Indicates whether the VPN connection uses static routes only.
   *
   * Static routes must be used for devices that don't support BGP.
   *
   * If you are creating a VPN connection for a device that does not support Border Gateway Protocol (BGP), you must specify \`true\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnection.html#cfn-ec2-vpnconnection-staticroutesonly
   */
  readonly staticRoutesOnly?: boolean | cdk.IResolvable;

  /**
   * Any tags assigned to the VPN connection.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnection.html#cfn-ec2-vpnconnection-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The ID of the transit gateway associated with the VPN connection.
   *
   * You must specify either \`TransitGatewayId\` or \`VpnGatewayId\` , but not both.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnection.html#cfn-ec2-vpnconnection-transitgatewayid
   */
  readonly transitGatewayId?: string;

  /**
   * The type of VPN connection.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnection.html#cfn-ec2-vpnconnection-type
   */
  readonly type: string;

  /**
   * The ID of the virtual private gateway at the AWS side of the VPN connection.
   *
   * You must specify either \`TransitGatewayId\` or \`VpnGatewayId\` , but not both.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnection.html#cfn-ec2-vpnconnection-vpngatewayid
   */
  readonly vpnGatewayId?: string;

  /**
   * The tunnel options for the VPN connection.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnection.html#cfn-ec2-vpnconnection-vpntunneloptionsspecifications
   */
  readonly vpnTunnelOptionsSpecifications?: Array<cdk.IResolvable | CfnVPNConnection.VpnTunnelOptionsSpecificationProperty> | cdk.IResolvable;
}

/**
 * Determine whether the given properties match those of a \`VpnTunnelOptionsSpecificationProperty\`
 *
 * @param properties - the TypeScript properties of a \`VpnTunnelOptionsSpecificationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVPNConnectionVpnTunnelOptionsSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("preSharedKey", cdk.validateString)(properties.preSharedKey));
  errors.collect(cdk.propertyValidator("tunnelInsideCidr", cdk.validateString)(properties.tunnelInsideCidr));
  return errors.wrap("supplied properties not correct for \\"VpnTunnelOptionsSpecificationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnVPNConnectionVpnTunnelOptionsSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVPNConnectionVpnTunnelOptionsSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "PreSharedKey": cdk.stringToCloudFormation(properties.preSharedKey),
    "TunnelInsideCidr": cdk.stringToCloudFormation(properties.tunnelInsideCidr)
  };
}

// @ts-ignore TS6133
function CfnVPNConnectionVpnTunnelOptionsSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnVPNConnection.VpnTunnelOptionsSpecificationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVPNConnection.VpnTunnelOptionsSpecificationProperty>();
  ret.addPropertyResult("preSharedKey", "PreSharedKey", (properties.PreSharedKey != null ? cfn_parse.FromCloudFormation.getString(properties.PreSharedKey) : undefined));
  ret.addPropertyResult("tunnelInsideCidr", "TunnelInsideCidr", (properties.TunnelInsideCidr != null ? cfn_parse.FromCloudFormation.getString(properties.TunnelInsideCidr) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnVPNConnectionProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnVPNConnectionProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVPNConnectionPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("customerGatewayId", cdk.requiredValidator)(properties.customerGatewayId));
  errors.collect(cdk.propertyValidator("customerGatewayId", cdk.validateString)(properties.customerGatewayId));
  errors.collect(cdk.propertyValidator("staticRoutesOnly", cdk.validateBoolean)(properties.staticRoutesOnly));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("transitGatewayId", cdk.validateString)(properties.transitGatewayId));
  errors.collect(cdk.propertyValidator("type", cdk.requiredValidator)(properties.type));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  errors.collect(cdk.propertyValidator("vpnGatewayId", cdk.validateString)(properties.vpnGatewayId));
  errors.collect(cdk.propertyValidator("vpnTunnelOptionsSpecifications", cdk.listValidator(CfnVPNConnectionVpnTunnelOptionsSpecificationPropertyValidator))(properties.vpnTunnelOptionsSpecifications));
  return errors.wrap("supplied properties not correct for \\"CfnVPNConnectionProps\\"");
}

// @ts-ignore TS6133
function convertCfnVPNConnectionPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVPNConnectionPropsValidator(properties).assertSuccess();
  return {
    "CustomerGatewayId": cdk.stringToCloudFormation(properties.customerGatewayId),
    "StaticRoutesOnly": cdk.booleanToCloudFormation(properties.staticRoutesOnly),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "TransitGatewayId": cdk.stringToCloudFormation(properties.transitGatewayId),
    "Type": cdk.stringToCloudFormation(properties.type),
    "VpnGatewayId": cdk.stringToCloudFormation(properties.vpnGatewayId),
    "VpnTunnelOptionsSpecifications": cdk.listMapper(convertCfnVPNConnectionVpnTunnelOptionsSpecificationPropertyToCloudFormation)(properties.vpnTunnelOptionsSpecifications)
  };
}

// @ts-ignore TS6133
function CfnVPNConnectionPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnVPNConnectionProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVPNConnectionProps>();
  ret.addPropertyResult("customerGatewayId", "CustomerGatewayId", (properties.CustomerGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.CustomerGatewayId) : undefined));
  ret.addPropertyResult("staticRoutesOnly", "StaticRoutesOnly", (properties.StaticRoutesOnly != null ? cfn_parse.FromCloudFormation.getBoolean(properties.StaticRoutesOnly) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("transitGatewayId", "TransitGatewayId", (properties.TransitGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.TransitGatewayId) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addPropertyResult("vpnGatewayId", "VpnGatewayId", (properties.VpnGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.VpnGatewayId) : undefined));
  ret.addPropertyResult("vpnTunnelOptionsSpecifications", "VpnTunnelOptionsSpecifications", (properties.VpnTunnelOptionsSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnVPNConnectionVpnTunnelOptionsSpecificationPropertyFromCloudFormation)(properties.VpnTunnelOptionsSpecifications) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a static route for a VPN connection between an existing virtual private gateway and a VPN customer gateway.
 *
 * The static route allows traffic to be routed from the virtual private gateway to the VPN customer gateway.
 *
 * For more information, see [AWS Site-to-Site VPN](https://docs.aws.amazon.com/vpn/latest/s2svpn/VPC_VPN.html) in the *AWS Site-to-Site VPN User Guide* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnectionroute.html
 */
export class CfnVPNConnectionRoute extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::VPNConnectionRoute";

  /**
   * Build a CfnVPNConnectionRoute from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnVPNConnectionRoute {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnVPNConnectionRoutePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnVPNConnectionRoute(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The CIDR block associated with the local subnet of the customer network.
   */
  public destinationCidrBlock: string;

  /**
   * The ID of the VPN connection.
   */
  public vpnConnectionId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnVPNConnectionRouteProps) {
    super(scope, id, {
      "type": CfnVPNConnectionRoute.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "destinationCidrBlock", this);
    cdk.requireProperty(props, "vpnConnectionId", this);

    this.destinationCidrBlock = props.destinationCidrBlock;
    this.vpnConnectionId = props.vpnConnectionId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "destinationCidrBlock": this.destinationCidrBlock,
      "vpnConnectionId": this.vpnConnectionId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnVPNConnectionRoute.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnVPNConnectionRoutePropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnVPNConnectionRoute\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnectionroute.html
 */
export interface CfnVPNConnectionRouteProps {
  /**
   * The CIDR block associated with the local subnet of the customer network.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnectionroute.html#cfn-ec2-vpnconnectionroute-destinationcidrblock
   */
  readonly destinationCidrBlock: string;

  /**
   * The ID of the VPN connection.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnectionroute.html#cfn-ec2-vpnconnectionroute-vpnconnectionid
   */
  readonly vpnConnectionId: string;
}

/**
 * Determine whether the given properties match those of a \`CfnVPNConnectionRouteProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnVPNConnectionRouteProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVPNConnectionRoutePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("destinationCidrBlock", cdk.requiredValidator)(properties.destinationCidrBlock));
  errors.collect(cdk.propertyValidator("destinationCidrBlock", cdk.validateString)(properties.destinationCidrBlock));
  errors.collect(cdk.propertyValidator("vpnConnectionId", cdk.requiredValidator)(properties.vpnConnectionId));
  errors.collect(cdk.propertyValidator("vpnConnectionId", cdk.validateString)(properties.vpnConnectionId));
  return errors.wrap("supplied properties not correct for \\"CfnVPNConnectionRouteProps\\"");
}

// @ts-ignore TS6133
function convertCfnVPNConnectionRoutePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVPNConnectionRoutePropsValidator(properties).assertSuccess();
  return {
    "DestinationCidrBlock": cdk.stringToCloudFormation(properties.destinationCidrBlock),
    "VpnConnectionId": cdk.stringToCloudFormation(properties.vpnConnectionId)
  };
}

// @ts-ignore TS6133
function CfnVPNConnectionRoutePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnVPNConnectionRouteProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVPNConnectionRouteProps>();
  ret.addPropertyResult("destinationCidrBlock", "DestinationCidrBlock", (properties.DestinationCidrBlock != null ? cfn_parse.FromCloudFormation.getString(properties.DestinationCidrBlock) : undefined));
  ret.addPropertyResult("vpnConnectionId", "VpnConnectionId", (properties.VpnConnectionId != null ? cfn_parse.FromCloudFormation.getString(properties.VpnConnectionId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a virtual private gateway.
 *
 * A virtual private gateway is the endpoint on the VPC side of your VPN connection. You can create a virtual private gateway before creating the VPC itself.
 *
 * For more information, see [AWS Site-to-Site VPN](https://docs.aws.amazon.com/vpn/latest/s2svpn/VPC_VPN.html) in the *AWS Site-to-Site VPN User Guide* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpngateway.html
 */
export class CfnVPNGateway extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::VPNGateway";

  /**
   * Build a CfnVPNGateway from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnVPNGateway {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnVPNGatewayPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnVPNGateway(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the VPN gateway.
   *
   * @cloudformationAttribute VPNGatewayId
   */
  public readonly attrVpnGatewayId: string;

  /**
   * The private Autonomous System Number (ASN) for the Amazon side of a BGP session.
   */
  public amazonSideAsn?: number;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * Any tags assigned to the virtual private gateway.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The type of VPN connection the virtual private gateway supports.
   */
  public type: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnVPNGatewayProps) {
    super(scope, id, {
      "type": CfnVPNGateway.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "type", this);

    this.attrVpnGatewayId = cdk.Token.asString(this.getAtt("VPNGatewayId", cdk.ResolutionTypeHint.STRING));
    this.amazonSideAsn = props.amazonSideAsn;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::VPNGateway", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.type = props.type;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "amazonSideAsn": this.amazonSideAsn,
      "tags": this.tags.renderTags(),
      "type": this.type
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnVPNGateway.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnVPNGatewayPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnVPNGateway\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpngateway.html
 */
export interface CfnVPNGatewayProps {
  /**
   * The private Autonomous System Number (ASN) for the Amazon side of a BGP session.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpngateway.html#cfn-ec2-vpngateway-amazonsideasn
   */
  readonly amazonSideAsn?: number;

  /**
   * Any tags assigned to the virtual private gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpngateway.html#cfn-ec2-vpngateway-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The type of VPN connection the virtual private gateway supports.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpngateway.html#cfn-ec2-vpngateway-type
   */
  readonly type: string;
}

/**
 * Determine whether the given properties match those of a \`CfnVPNGatewayProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnVPNGatewayProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVPNGatewayPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("amazonSideAsn", cdk.validateNumber)(properties.amazonSideAsn));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("type", cdk.requiredValidator)(properties.type));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  return errors.wrap("supplied properties not correct for \\"CfnVPNGatewayProps\\"");
}

// @ts-ignore TS6133
function convertCfnVPNGatewayPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVPNGatewayPropsValidator(properties).assertSuccess();
  return {
    "AmazonSideAsn": cdk.numberToCloudFormation(properties.amazonSideAsn),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "Type": cdk.stringToCloudFormation(properties.type)
  };
}

// @ts-ignore TS6133
function CfnVPNGatewayPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnVPNGatewayProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVPNGatewayProps>();
  ret.addPropertyResult("amazonSideAsn", "AmazonSideAsn", (properties.AmazonSideAsn != null ? cfn_parse.FromCloudFormation.getNumber(properties.AmazonSideAsn) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Enables a virtual private gateway (VGW) to propagate routes to the specified route table of a VPC.
 *
 * If you reference a VPN gateway that is in the same template as your VPN gateway route propagation, you must explicitly declare a dependency on the VPN gateway attachment. The \`AWS::EC2::VPNGatewayRoutePropagation\` resource cannot use the VPN gateway until it has successfully attached to the VPC. Add a [DependsOn Attribute](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-dependson.html) in the \`AWS::EC2::VPNGatewayRoutePropagation\` resource to explicitly declare a dependency on the VPN gateway attachment.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpngatewayroutepropagation.html
 */
export class CfnVPNGatewayRoutePropagation extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::VPNGatewayRoutePropagation";

  /**
   * Build a CfnVPNGatewayRoutePropagation from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnVPNGatewayRoutePropagation {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnVPNGatewayRoutePropagationPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnVPNGatewayRoutePropagation(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The ID of the route table.
   */
  public routeTableIds: Array<string>;

  /**
   * The ID of the virtual private gateway that is attached to a VPC.
   */
  public vpnGatewayId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnVPNGatewayRoutePropagationProps) {
    super(scope, id, {
      "type": CfnVPNGatewayRoutePropagation.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "routeTableIds", this);
    cdk.requireProperty(props, "vpnGatewayId", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.routeTableIds = props.routeTableIds;
    this.vpnGatewayId = props.vpnGatewayId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "routeTableIds": this.routeTableIds,
      "vpnGatewayId": this.vpnGatewayId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnVPNGatewayRoutePropagation.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnVPNGatewayRoutePropagationPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnVPNGatewayRoutePropagation\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpngatewayroutepropagation.html
 */
export interface CfnVPNGatewayRoutePropagationProps {
  /**
   * The ID of the route table.
   *
   * The routing table must be associated with the same VPC that the virtual private gateway is attached to.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpngatewayroutepropagation.html#cfn-ec2-vpngatewayroutepropagation-routetableids
   */
  readonly routeTableIds: Array<string>;

  /**
   * The ID of the virtual private gateway that is attached to a VPC.
   *
   * The virtual private gateway must be attached to the same VPC that the routing tables are associated with.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpngatewayroutepropagation.html#cfn-ec2-vpngatewayroutepropagation-vpngatewayid
   */
  readonly vpnGatewayId: string;
}

/**
 * Determine whether the given properties match those of a \`CfnVPNGatewayRoutePropagationProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnVPNGatewayRoutePropagationProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVPNGatewayRoutePropagationPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("routeTableIds", cdk.requiredValidator)(properties.routeTableIds));
  errors.collect(cdk.propertyValidator("routeTableIds", cdk.listValidator(cdk.validateString))(properties.routeTableIds));
  errors.collect(cdk.propertyValidator("vpnGatewayId", cdk.requiredValidator)(properties.vpnGatewayId));
  errors.collect(cdk.propertyValidator("vpnGatewayId", cdk.validateString)(properties.vpnGatewayId));
  return errors.wrap("supplied properties not correct for \\"CfnVPNGatewayRoutePropagationProps\\"");
}

// @ts-ignore TS6133
function convertCfnVPNGatewayRoutePropagationPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVPNGatewayRoutePropagationPropsValidator(properties).assertSuccess();
  return {
    "RouteTableIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.routeTableIds),
    "VpnGatewayId": cdk.stringToCloudFormation(properties.vpnGatewayId)
  };
}

// @ts-ignore TS6133
function CfnVPNGatewayRoutePropagationPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnVPNGatewayRoutePropagationProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVPNGatewayRoutePropagationProps>();
  ret.addPropertyResult("routeTableIds", "RouteTableIds", (properties.RouteTableIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.RouteTableIds) : undefined));
  ret.addPropertyResult("vpnGatewayId", "VpnGatewayId", (properties.VpnGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.VpnGatewayId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}",
}
`;

exports[`aws-omics 1`] = `
{
  "augmentations": undefined,
  "metrics": undefined,
  "module": "/* eslint-disable prettier/prettier,max-len */
import * as cdk from "aws-cdk-lib";
import * as constructs from "constructs";
import * as cfn_parse from "aws-cdk-lib/core/lib/helpers-internal";

/**
 * Creates an annotation store.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-annotationstore.html
 */
export class CfnAnnotationStore extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::Omics::AnnotationStore";

  /**
   * Build a CfnAnnotationStore from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnAnnotationStore {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnAnnotationStorePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnAnnotationStore(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * When the store was created.
   *
   * @cloudformationAttribute CreationTime
   */
  public readonly attrCreationTime: string;

  /**
   * The store's ID.
   *
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The store's status.
   *
   * @cloudformationAttribute Status
   */
  public readonly attrStatus: string;

  /**
   * The store's status message.
   *
   * @cloudformationAttribute StatusMessage
   */
  public readonly attrStatusMessage: string;

  /**
   * The store's ARN.
   *
   * @cloudformationAttribute StoreArn
   */
  public readonly attrStoreArn: string;

  /**
   * The store's size in bytes.
   *
   * @cloudformationAttribute StoreSizeBytes
   */
  public readonly attrStoreSizeBytes: cdk.IResolvable;

  /**
   * When the store was updated.
   *
   * @cloudformationAttribute UpdateTime
   */
  public readonly attrUpdateTime: string;

  /**
   * A description for the store.
   */
  public description?: string;

  /**
   * The name of the Annotation Store.
   */
  public name: string;

  /**
   * The genome reference for the store's annotations.
   */
  public reference?: cdk.IResolvable | CfnAnnotationStore.ReferenceItemProperty;

  /**
   * The store's server-side encryption (SSE) settings.
   */
  public sseConfig?: cdk.IResolvable | CfnAnnotationStore.SseConfigProperty;

  /**
   * The annotation file format of the store.
   */
  public storeFormat: string;

  /**
   * File parsing options for the annotation store.
   */
  public storeOptions?: cdk.IResolvable | CfnAnnotationStore.StoreOptionsProperty;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * Tags for the store.
   */
  public tagsRaw?: Record<string, string>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnAnnotationStoreProps) {
    super(scope, id, {
      "type": CfnAnnotationStore.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "name", this);
    cdk.requireProperty(props, "storeFormat", this);

    this.attrCreationTime = cdk.Token.asString(this.getAtt("CreationTime", cdk.ResolutionTypeHint.STRING));
    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.attrStatus = cdk.Token.asString(this.getAtt("Status", cdk.ResolutionTypeHint.STRING));
    this.attrStatusMessage = cdk.Token.asString(this.getAtt("StatusMessage", cdk.ResolutionTypeHint.STRING));
    this.attrStoreArn = cdk.Token.asString(this.getAtt("StoreArn", cdk.ResolutionTypeHint.STRING));
    this.attrStoreSizeBytes = this.getAtt("StoreSizeBytes", cdk.ResolutionTypeHint.NUMBER);
    this.attrUpdateTime = cdk.Token.asString(this.getAtt("UpdateTime", cdk.ResolutionTypeHint.STRING));
    this.description = props.description;
    this.name = props.name;
    this.reference = props.reference;
    this.sseConfig = props.sseConfig;
    this.storeFormat = props.storeFormat;
    this.storeOptions = props.storeOptions;
    this.tags = new cdk.TagManager(cdk.TagType.MAP, "AWS::Omics::AnnotationStore", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "description": this.description,
      "name": this.name,
      "reference": this.reference,
      "sseConfig": this.sseConfig,
      "storeFormat": this.storeFormat,
      "storeOptions": this.storeOptions,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnAnnotationStore.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnAnnotationStorePropsToCloudFormation(props);
  }
}

export namespace CfnAnnotationStore {
  /**
   * A genome reference.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-annotationstore-referenceitem.html
   */
  export interface ReferenceItemProperty {
    /**
     * The reference's ARN.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-annotationstore-referenceitem.html#cfn-omics-annotationstore-referenceitem-referencearn
     */
    readonly referenceArn: string;
  }

  /**
   * Server-side encryption (SSE) settings for a store.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-annotationstore-sseconfig.html
   */
  export interface SseConfigProperty {
    /**
     * An encryption key ARN.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-annotationstore-sseconfig.html#cfn-omics-annotationstore-sseconfig-keyarn
     */
    readonly keyArn?: string;

    /**
     * The encryption type.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-annotationstore-sseconfig.html#cfn-omics-annotationstore-sseconfig-type
     */
    readonly type: string;
  }

  /**
   * The store's file parsing options.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-annotationstore-storeoptions.html
   */
  export interface StoreOptionsProperty {
    /**
     * Formatting options for a TSV file.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-annotationstore-storeoptions.html#cfn-omics-annotationstore-storeoptions-tsvstoreoptions
     */
    readonly tsvStoreOptions: cdk.IResolvable | CfnAnnotationStore.TsvStoreOptionsProperty;
  }

  /**
   * The store's parsing options.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-annotationstore-tsvstoreoptions.html
   */
  export interface TsvStoreOptionsProperty {
    /**
     * The store's annotation type.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-annotationstore-tsvstoreoptions.html#cfn-omics-annotationstore-tsvstoreoptions-annotationtype
     */
    readonly annotationType?: string;

    /**
     * The store's header key to column name mapping.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-annotationstore-tsvstoreoptions.html#cfn-omics-annotationstore-tsvstoreoptions-formattoheader
     */
    readonly formatToHeader?: cdk.IResolvable | Record<string, string>;

    /**
     * The schema of an annotation store.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-annotationstore-tsvstoreoptions.html#cfn-omics-annotationstore-tsvstoreoptions-schema
     */
    readonly schema?: any | cdk.IResolvable;
  }
}

/**
 * Properties for defining a \`CfnAnnotationStore\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-annotationstore.html
 */
export interface CfnAnnotationStoreProps {
  /**
   * A description for the store.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-annotationstore.html#cfn-omics-annotationstore-description
   */
  readonly description?: string;

  /**
   * The name of the Annotation Store.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-annotationstore.html#cfn-omics-annotationstore-name
   */
  readonly name: string;

  /**
   * The genome reference for the store's annotations.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-annotationstore.html#cfn-omics-annotationstore-reference
   */
  readonly reference?: cdk.IResolvable | CfnAnnotationStore.ReferenceItemProperty;

  /**
   * The store's server-side encryption (SSE) settings.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-annotationstore.html#cfn-omics-annotationstore-sseconfig
   */
  readonly sseConfig?: cdk.IResolvable | CfnAnnotationStore.SseConfigProperty;

  /**
   * The annotation file format of the store.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-annotationstore.html#cfn-omics-annotationstore-storeformat
   */
  readonly storeFormat: string;

  /**
   * File parsing options for the annotation store.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-annotationstore.html#cfn-omics-annotationstore-storeoptions
   */
  readonly storeOptions?: cdk.IResolvable | CfnAnnotationStore.StoreOptionsProperty;

  /**
   * Tags for the store.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-annotationstore.html#cfn-omics-annotationstore-tags
   */
  readonly tags?: Record<string, string>;
}

/**
 * Determine whether the given properties match those of a \`ReferenceItemProperty\`
 *
 * @param properties - the TypeScript properties of a \`ReferenceItemProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnAnnotationStoreReferenceItemPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("referenceArn", cdk.requiredValidator)(properties.referenceArn));
  errors.collect(cdk.propertyValidator("referenceArn", cdk.validateString)(properties.referenceArn));
  return errors.wrap("supplied properties not correct for \\"ReferenceItemProperty\\"");
}

// @ts-ignore TS6133
function convertCfnAnnotationStoreReferenceItemPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnAnnotationStoreReferenceItemPropertyValidator(properties).assertSuccess();
  return {
    "ReferenceArn": cdk.stringToCloudFormation(properties.referenceArn)
  };
}

// @ts-ignore TS6133
function CfnAnnotationStoreReferenceItemPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnAnnotationStore.ReferenceItemProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnAnnotationStore.ReferenceItemProperty>();
  ret.addPropertyResult("referenceArn", "ReferenceArn", (properties.ReferenceArn != null ? cfn_parse.FromCloudFormation.getString(properties.ReferenceArn) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`SseConfigProperty\`
 *
 * @param properties - the TypeScript properties of a \`SseConfigProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnAnnotationStoreSseConfigPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("keyArn", cdk.validateString)(properties.keyArn));
  errors.collect(cdk.propertyValidator("type", cdk.requiredValidator)(properties.type));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  return errors.wrap("supplied properties not correct for \\"SseConfigProperty\\"");
}

// @ts-ignore TS6133
function convertCfnAnnotationStoreSseConfigPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnAnnotationStoreSseConfigPropertyValidator(properties).assertSuccess();
  return {
    "KeyArn": cdk.stringToCloudFormation(properties.keyArn),
    "Type": cdk.stringToCloudFormation(properties.type)
  };
}

// @ts-ignore TS6133
function CfnAnnotationStoreSseConfigPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnAnnotationStore.SseConfigProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnAnnotationStore.SseConfigProperty>();
  ret.addPropertyResult("keyArn", "KeyArn", (properties.KeyArn != null ? cfn_parse.FromCloudFormation.getString(properties.KeyArn) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`TsvStoreOptionsProperty\`
 *
 * @param properties - the TypeScript properties of a \`TsvStoreOptionsProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnAnnotationStoreTsvStoreOptionsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("annotationType", cdk.validateString)(properties.annotationType));
  errors.collect(cdk.propertyValidator("formatToHeader", cdk.hashValidator(cdk.validateString))(properties.formatToHeader));
  errors.collect(cdk.propertyValidator("schema", cdk.validateObject)(properties.schema));
  return errors.wrap("supplied properties not correct for \\"TsvStoreOptionsProperty\\"");
}

// @ts-ignore TS6133
function convertCfnAnnotationStoreTsvStoreOptionsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnAnnotationStoreTsvStoreOptionsPropertyValidator(properties).assertSuccess();
  return {
    "AnnotationType": cdk.stringToCloudFormation(properties.annotationType),
    "FormatToHeader": cdk.hashMapper(cdk.stringToCloudFormation)(properties.formatToHeader),
    "Schema": cdk.objectToCloudFormation(properties.schema)
  };
}

// @ts-ignore TS6133
function CfnAnnotationStoreTsvStoreOptionsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnAnnotationStore.TsvStoreOptionsProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnAnnotationStore.TsvStoreOptionsProperty>();
  ret.addPropertyResult("annotationType", "AnnotationType", (properties.AnnotationType != null ? cfn_parse.FromCloudFormation.getString(properties.AnnotationType) : undefined));
  ret.addPropertyResult("formatToHeader", "FormatToHeader", (properties.FormatToHeader != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getString)(properties.FormatToHeader) : undefined));
  ret.addPropertyResult("schema", "Schema", (properties.Schema != null ? cfn_parse.FromCloudFormation.getAny(properties.Schema) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`StoreOptionsProperty\`
 *
 * @param properties - the TypeScript properties of a \`StoreOptionsProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnAnnotationStoreStoreOptionsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("tsvStoreOptions", cdk.requiredValidator)(properties.tsvStoreOptions));
  errors.collect(cdk.propertyValidator("tsvStoreOptions", CfnAnnotationStoreTsvStoreOptionsPropertyValidator)(properties.tsvStoreOptions));
  return errors.wrap("supplied properties not correct for \\"StoreOptionsProperty\\"");
}

// @ts-ignore TS6133
function convertCfnAnnotationStoreStoreOptionsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnAnnotationStoreStoreOptionsPropertyValidator(properties).assertSuccess();
  return {
    "TsvStoreOptions": convertCfnAnnotationStoreTsvStoreOptionsPropertyToCloudFormation(properties.tsvStoreOptions)
  };
}

// @ts-ignore TS6133
function CfnAnnotationStoreStoreOptionsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnAnnotationStore.StoreOptionsProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnAnnotationStore.StoreOptionsProperty>();
  ret.addPropertyResult("tsvStoreOptions", "TsvStoreOptions", (properties.TsvStoreOptions != null ? CfnAnnotationStoreTsvStoreOptionsPropertyFromCloudFormation(properties.TsvStoreOptions) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnAnnotationStoreProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnAnnotationStoreProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnAnnotationStorePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("name", cdk.requiredValidator)(properties.name));
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  errors.collect(cdk.propertyValidator("reference", CfnAnnotationStoreReferenceItemPropertyValidator)(properties.reference));
  errors.collect(cdk.propertyValidator("sseConfig", CfnAnnotationStoreSseConfigPropertyValidator)(properties.sseConfig));
  errors.collect(cdk.propertyValidator("storeFormat", cdk.requiredValidator)(properties.storeFormat));
  errors.collect(cdk.propertyValidator("storeFormat", cdk.validateString)(properties.storeFormat));
  errors.collect(cdk.propertyValidator("storeOptions", CfnAnnotationStoreStoreOptionsPropertyValidator)(properties.storeOptions));
  errors.collect(cdk.propertyValidator("tags", cdk.hashValidator(cdk.validateString))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnAnnotationStoreProps\\"");
}

// @ts-ignore TS6133
function convertCfnAnnotationStorePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnAnnotationStorePropsValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "Name": cdk.stringToCloudFormation(properties.name),
    "Reference": convertCfnAnnotationStoreReferenceItemPropertyToCloudFormation(properties.reference),
    "SseConfig": convertCfnAnnotationStoreSseConfigPropertyToCloudFormation(properties.sseConfig),
    "StoreFormat": cdk.stringToCloudFormation(properties.storeFormat),
    "StoreOptions": convertCfnAnnotationStoreStoreOptionsPropertyToCloudFormation(properties.storeOptions),
    "Tags": cdk.hashMapper(cdk.stringToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnAnnotationStorePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnAnnotationStoreProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnAnnotationStoreProps>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addPropertyResult("reference", "Reference", (properties.Reference != null ? CfnAnnotationStoreReferenceItemPropertyFromCloudFormation(properties.Reference) : undefined));
  ret.addPropertyResult("sseConfig", "SseConfig", (properties.SseConfig != null ? CfnAnnotationStoreSseConfigPropertyFromCloudFormation(properties.SseConfig) : undefined));
  ret.addPropertyResult("storeFormat", "StoreFormat", (properties.StoreFormat != null ? cfn_parse.FromCloudFormation.getString(properties.StoreFormat) : undefined));
  ret.addPropertyResult("storeOptions", "StoreOptions", (properties.StoreOptions != null ? CfnAnnotationStoreStoreOptionsPropertyFromCloudFormation(properties.StoreOptions) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getString)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Creates a reference store.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-referencestore.html
 */
export class CfnReferenceStore extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::Omics::ReferenceStore";

  /**
   * Build a CfnReferenceStore from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnReferenceStore {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnReferenceStorePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnReferenceStore(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The store's ARN.
   *
   * @cloudformationAttribute Arn
   */
  public readonly attrArn: string;

  /**
   * When the store was created.
   *
   * @cloudformationAttribute CreationTime
   */
  public readonly attrCreationTime: string;

  /**
   * The store's ID.
   *
   * @cloudformationAttribute ReferenceStoreId
   */
  public readonly attrReferenceStoreId: string;

  /**
   * A description for the store.
   */
  public description?: string;

  /**
   * A name for the store.
   */
  public name: string;

  /**
   * Server-side encryption (SSE) settings for the store.
   */
  public sseConfig?: cdk.IResolvable | CfnReferenceStore.SseConfigProperty;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * Tags for the store.
   */
  public tagsRaw?: Record<string, string>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnReferenceStoreProps) {
    super(scope, id, {
      "type": CfnReferenceStore.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "name", this);

    this.attrArn = cdk.Token.asString(this.getAtt("Arn", cdk.ResolutionTypeHint.STRING));
    this.attrCreationTime = cdk.Token.asString(this.getAtt("CreationTime", cdk.ResolutionTypeHint.STRING));
    this.attrReferenceStoreId = cdk.Token.asString(this.getAtt("ReferenceStoreId", cdk.ResolutionTypeHint.STRING));
    this.description = props.description;
    this.name = props.name;
    this.sseConfig = props.sseConfig;
    this.tags = new cdk.TagManager(cdk.TagType.MAP, "AWS::Omics::ReferenceStore", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "description": this.description,
      "name": this.name,
      "sseConfig": this.sseConfig,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnReferenceStore.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnReferenceStorePropsToCloudFormation(props);
  }
}

export namespace CfnReferenceStore {
  /**
   * Server-side encryption (SSE) settings for a store.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-referencestore-sseconfig.html
   */
  export interface SseConfigProperty {
    /**
     * An encryption key ARN.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-referencestore-sseconfig.html#cfn-omics-referencestore-sseconfig-keyarn
     */
    readonly keyArn?: string;

    /**
     * The encryption type.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-referencestore-sseconfig.html#cfn-omics-referencestore-sseconfig-type
     */
    readonly type: string;
  }
}

/**
 * Properties for defining a \`CfnReferenceStore\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-referencestore.html
 */
export interface CfnReferenceStoreProps {
  /**
   * A description for the store.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-referencestore.html#cfn-omics-referencestore-description
   */
  readonly description?: string;

  /**
   * A name for the store.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-referencestore.html#cfn-omics-referencestore-name
   */
  readonly name: string;

  /**
   * Server-side encryption (SSE) settings for the store.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-referencestore.html#cfn-omics-referencestore-sseconfig
   */
  readonly sseConfig?: cdk.IResolvable | CfnReferenceStore.SseConfigProperty;

  /**
   * Tags for the store.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-referencestore.html#cfn-omics-referencestore-tags
   */
  readonly tags?: Record<string, string>;
}

/**
 * Determine whether the given properties match those of a \`SseConfigProperty\`
 *
 * @param properties - the TypeScript properties of a \`SseConfigProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnReferenceStoreSseConfigPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("keyArn", cdk.validateString)(properties.keyArn));
  errors.collect(cdk.propertyValidator("type", cdk.requiredValidator)(properties.type));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  return errors.wrap("supplied properties not correct for \\"SseConfigProperty\\"");
}

// @ts-ignore TS6133
function convertCfnReferenceStoreSseConfigPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnReferenceStoreSseConfigPropertyValidator(properties).assertSuccess();
  return {
    "KeyArn": cdk.stringToCloudFormation(properties.keyArn),
    "Type": cdk.stringToCloudFormation(properties.type)
  };
}

// @ts-ignore TS6133
function CfnReferenceStoreSseConfigPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnReferenceStore.SseConfigProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnReferenceStore.SseConfigProperty>();
  ret.addPropertyResult("keyArn", "KeyArn", (properties.KeyArn != null ? cfn_parse.FromCloudFormation.getString(properties.KeyArn) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnReferenceStoreProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnReferenceStoreProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnReferenceStorePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("name", cdk.requiredValidator)(properties.name));
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  errors.collect(cdk.propertyValidator("sseConfig", CfnReferenceStoreSseConfigPropertyValidator)(properties.sseConfig));
  errors.collect(cdk.propertyValidator("tags", cdk.hashValidator(cdk.validateString))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnReferenceStoreProps\\"");
}

// @ts-ignore TS6133
function convertCfnReferenceStorePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnReferenceStorePropsValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "Name": cdk.stringToCloudFormation(properties.name),
    "SseConfig": convertCfnReferenceStoreSseConfigPropertyToCloudFormation(properties.sseConfig),
    "Tags": cdk.hashMapper(cdk.stringToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnReferenceStorePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnReferenceStoreProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnReferenceStoreProps>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addPropertyResult("sseConfig", "SseConfig", (properties.SseConfig != null ? CfnReferenceStoreSseConfigPropertyFromCloudFormation(properties.SseConfig) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getString)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Creates a run group.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-rungroup.html
 */
export class CfnRunGroup extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::Omics::RunGroup";

  /**
   * Build a CfnRunGroup from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnRunGroup {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnRunGroupPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnRunGroup(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The run group's ARN.
   *
   * @cloudformationAttribute Arn
   */
  public readonly attrArn: string;

  /**
   * When the run group was created.
   *
   * @cloudformationAttribute CreationTime
   */
  public readonly attrCreationTime: string;

  /**
   * The run group's ID.
   *
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The group's maximum CPU count setting.
   */
  public maxCpus?: number;

  /**
   * The group's maximum duration setting in minutes.
   */
  public maxDuration?: number;

  /**
   * The group's maximum concurrent run setting.
   */
  public maxRuns?: number;

  /**
   * The group's name.
   */
  public name?: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * Tags for the group.
   */
  public tagsRaw?: Record<string, string>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnRunGroupProps = {}) {
    super(scope, id, {
      "type": CfnRunGroup.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.attrArn = cdk.Token.asString(this.getAtt("Arn", cdk.ResolutionTypeHint.STRING));
    this.attrCreationTime = cdk.Token.asString(this.getAtt("CreationTime", cdk.ResolutionTypeHint.STRING));
    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.maxCpus = props.maxCpus;
    this.maxDuration = props.maxDuration;
    this.maxRuns = props.maxRuns;
    this.name = props.name;
    this.tags = new cdk.TagManager(cdk.TagType.MAP, "AWS::Omics::RunGroup", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "maxCpus": this.maxCpus,
      "maxDuration": this.maxDuration,
      "maxRuns": this.maxRuns,
      "name": this.name,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnRunGroup.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnRunGroupPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnRunGroup\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-rungroup.html
 */
export interface CfnRunGroupProps {
  /**
   * The group's maximum CPU count setting.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-rungroup.html#cfn-omics-rungroup-maxcpus
   */
  readonly maxCpus?: number;

  /**
   * The group's maximum duration setting in minutes.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-rungroup.html#cfn-omics-rungroup-maxduration
   */
  readonly maxDuration?: number;

  /**
   * The group's maximum concurrent run setting.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-rungroup.html#cfn-omics-rungroup-maxruns
   */
  readonly maxRuns?: number;

  /**
   * The group's name.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-rungroup.html#cfn-omics-rungroup-name
   */
  readonly name?: string;

  /**
   * Tags for the group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-rungroup.html#cfn-omics-rungroup-tags
   */
  readonly tags?: Record<string, string>;
}

/**
 * Determine whether the given properties match those of a \`CfnRunGroupProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnRunGroupProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnRunGroupPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("maxCpus", cdk.validateNumber)(properties.maxCpus));
  errors.collect(cdk.propertyValidator("maxDuration", cdk.validateNumber)(properties.maxDuration));
  errors.collect(cdk.propertyValidator("maxRuns", cdk.validateNumber)(properties.maxRuns));
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  errors.collect(cdk.propertyValidator("tags", cdk.hashValidator(cdk.validateString))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnRunGroupProps\\"");
}

// @ts-ignore TS6133
function convertCfnRunGroupPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnRunGroupPropsValidator(properties).assertSuccess();
  return {
    "MaxCpus": cdk.numberToCloudFormation(properties.maxCpus),
    "MaxDuration": cdk.numberToCloudFormation(properties.maxDuration),
    "MaxRuns": cdk.numberToCloudFormation(properties.maxRuns),
    "Name": cdk.stringToCloudFormation(properties.name),
    "Tags": cdk.hashMapper(cdk.stringToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnRunGroupPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnRunGroupProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnRunGroupProps>();
  ret.addPropertyResult("maxCpus", "MaxCpus", (properties.MaxCpus != null ? cfn_parse.FromCloudFormation.getNumber(properties.MaxCpus) : undefined));
  ret.addPropertyResult("maxDuration", "MaxDuration", (properties.MaxDuration != null ? cfn_parse.FromCloudFormation.getNumber(properties.MaxDuration) : undefined));
  ret.addPropertyResult("maxRuns", "MaxRuns", (properties.MaxRuns != null ? cfn_parse.FromCloudFormation.getNumber(properties.MaxRuns) : undefined));
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getString)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Creates a sequence store.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-sequencestore.html
 */
export class CfnSequenceStore extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::Omics::SequenceStore";

  /**
   * Build a CfnSequenceStore from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnSequenceStore {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnSequenceStorePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnSequenceStore(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The store's ARN.
   *
   * @cloudformationAttribute Arn
   */
  public readonly attrArn: string;

  /**
   * When the store was created.
   *
   * @cloudformationAttribute CreationTime
   */
  public readonly attrCreationTime: string;

  /**
   * The store's ID.
   *
   * @cloudformationAttribute SequenceStoreId
   */
  public readonly attrSequenceStoreId: string;

  /**
   * A description for the store.
   */
  public description?: string;

  /**
   * An S3 URI representing the bucket and folder to store failed read set uploads.
   */
  public fallbackLocation?: string;

  /**
   * A name for the store.
   */
  public name: string;

  /**
   * Server-side encryption (SSE) settings for the store.
   */
  public sseConfig?: cdk.IResolvable | CfnSequenceStore.SseConfigProperty;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * Tags for the store.
   */
  public tagsRaw?: Record<string, string>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnSequenceStoreProps) {
    super(scope, id, {
      "type": CfnSequenceStore.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "name", this);

    this.attrArn = cdk.Token.asString(this.getAtt("Arn", cdk.ResolutionTypeHint.STRING));
    this.attrCreationTime = cdk.Token.asString(this.getAtt("CreationTime", cdk.ResolutionTypeHint.STRING));
    this.attrSequenceStoreId = cdk.Token.asString(this.getAtt("SequenceStoreId", cdk.ResolutionTypeHint.STRING));
    this.description = props.description;
    this.fallbackLocation = props.fallbackLocation;
    this.name = props.name;
    this.sseConfig = props.sseConfig;
    this.tags = new cdk.TagManager(cdk.TagType.MAP, "AWS::Omics::SequenceStore", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "description": this.description,
      "fallbackLocation": this.fallbackLocation,
      "name": this.name,
      "sseConfig": this.sseConfig,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnSequenceStore.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnSequenceStorePropsToCloudFormation(props);
  }
}

export namespace CfnSequenceStore {
  /**
   * Server-side encryption (SSE) settings for a store.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-sequencestore-sseconfig.html
   */
  export interface SseConfigProperty {
    /**
     * An encryption key ARN.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-sequencestore-sseconfig.html#cfn-omics-sequencestore-sseconfig-keyarn
     */
    readonly keyArn?: string;

    /**
     * The encryption type.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-sequencestore-sseconfig.html#cfn-omics-sequencestore-sseconfig-type
     */
    readonly type: string;
  }
}

/**
 * Properties for defining a \`CfnSequenceStore\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-sequencestore.html
 */
export interface CfnSequenceStoreProps {
  /**
   * A description for the store.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-sequencestore.html#cfn-omics-sequencestore-description
   */
  readonly description?: string;

  /**
   * An S3 URI representing the bucket and folder to store failed read set uploads.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-sequencestore.html#cfn-omics-sequencestore-fallbacklocation
   */
  readonly fallbackLocation?: string;

  /**
   * A name for the store.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-sequencestore.html#cfn-omics-sequencestore-name
   */
  readonly name: string;

  /**
   * Server-side encryption (SSE) settings for the store.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-sequencestore.html#cfn-omics-sequencestore-sseconfig
   */
  readonly sseConfig?: cdk.IResolvable | CfnSequenceStore.SseConfigProperty;

  /**
   * Tags for the store.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-sequencestore.html#cfn-omics-sequencestore-tags
   */
  readonly tags?: Record<string, string>;
}

/**
 * Determine whether the given properties match those of a \`SseConfigProperty\`
 *
 * @param properties - the TypeScript properties of a \`SseConfigProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSequenceStoreSseConfigPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("keyArn", cdk.validateString)(properties.keyArn));
  errors.collect(cdk.propertyValidator("type", cdk.requiredValidator)(properties.type));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  return errors.wrap("supplied properties not correct for \\"SseConfigProperty\\"");
}

// @ts-ignore TS6133
function convertCfnSequenceStoreSseConfigPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSequenceStoreSseConfigPropertyValidator(properties).assertSuccess();
  return {
    "KeyArn": cdk.stringToCloudFormation(properties.keyArn),
    "Type": cdk.stringToCloudFormation(properties.type)
  };
}

// @ts-ignore TS6133
function CfnSequenceStoreSseConfigPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSequenceStore.SseConfigProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSequenceStore.SseConfigProperty>();
  ret.addPropertyResult("keyArn", "KeyArn", (properties.KeyArn != null ? cfn_parse.FromCloudFormation.getString(properties.KeyArn) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnSequenceStoreProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnSequenceStoreProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSequenceStorePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("fallbackLocation", cdk.validateString)(properties.fallbackLocation));
  errors.collect(cdk.propertyValidator("name", cdk.requiredValidator)(properties.name));
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  errors.collect(cdk.propertyValidator("sseConfig", CfnSequenceStoreSseConfigPropertyValidator)(properties.sseConfig));
  errors.collect(cdk.propertyValidator("tags", cdk.hashValidator(cdk.validateString))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnSequenceStoreProps\\"");
}

// @ts-ignore TS6133
function convertCfnSequenceStorePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSequenceStorePropsValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "FallbackLocation": cdk.stringToCloudFormation(properties.fallbackLocation),
    "Name": cdk.stringToCloudFormation(properties.name),
    "SseConfig": convertCfnSequenceStoreSseConfigPropertyToCloudFormation(properties.sseConfig),
    "Tags": cdk.hashMapper(cdk.stringToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnSequenceStorePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSequenceStoreProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSequenceStoreProps>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("fallbackLocation", "FallbackLocation", (properties.FallbackLocation != null ? cfn_parse.FromCloudFormation.getString(properties.FallbackLocation) : undefined));
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addPropertyResult("sseConfig", "SseConfig", (properties.SseConfig != null ? CfnSequenceStoreSseConfigPropertyFromCloudFormation(properties.SseConfig) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getString)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Create a store for variant data.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-variantstore.html
 */
export class CfnVariantStore extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::Omics::VariantStore";

  /**
   * Build a CfnVariantStore from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnVariantStore {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnVariantStorePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnVariantStore(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * When the store was created.
   *
   * @cloudformationAttribute CreationTime
   */
  public readonly attrCreationTime: string;

  /**
   * The store's ID.
   *
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The store's status.
   *
   * @cloudformationAttribute Status
   */
  public readonly attrStatus: string;

  /**
   * The store's status message.
   *
   * @cloudformationAttribute StatusMessage
   */
  public readonly attrStatusMessage: string;

  /**
   * The store's ARN.
   *
   * @cloudformationAttribute StoreArn
   */
  public readonly attrStoreArn: string;

  /**
   * The store's size in bytes.
   *
   * @cloudformationAttribute StoreSizeBytes
   */
  public readonly attrStoreSizeBytes: cdk.IResolvable;

  /**
   * When the store was updated.
   *
   * @cloudformationAttribute UpdateTime
   */
  public readonly attrUpdateTime: string;

  /**
   * A description for the store.
   */
  public description?: string;

  /**
   * A name for the store.
   */
  public name: string;

  /**
   * The genome reference for the store's variants.
   */
  public reference: cdk.IResolvable | CfnVariantStore.ReferenceItemProperty;

  /**
   * Server-side encryption (SSE) settings for the store.
   */
  public sseConfig?: cdk.IResolvable | CfnVariantStore.SseConfigProperty;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * Tags for the store.
   */
  public tagsRaw?: Record<string, string>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnVariantStoreProps) {
    super(scope, id, {
      "type": CfnVariantStore.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "name", this);
    cdk.requireProperty(props, "reference", this);

    this.attrCreationTime = cdk.Token.asString(this.getAtt("CreationTime", cdk.ResolutionTypeHint.STRING));
    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.attrStatus = cdk.Token.asString(this.getAtt("Status", cdk.ResolutionTypeHint.STRING));
    this.attrStatusMessage = cdk.Token.asString(this.getAtt("StatusMessage", cdk.ResolutionTypeHint.STRING));
    this.attrStoreArn = cdk.Token.asString(this.getAtt("StoreArn", cdk.ResolutionTypeHint.STRING));
    this.attrStoreSizeBytes = this.getAtt("StoreSizeBytes", cdk.ResolutionTypeHint.NUMBER);
    this.attrUpdateTime = cdk.Token.asString(this.getAtt("UpdateTime", cdk.ResolutionTypeHint.STRING));
    this.description = props.description;
    this.name = props.name;
    this.reference = props.reference;
    this.sseConfig = props.sseConfig;
    this.tags = new cdk.TagManager(cdk.TagType.MAP, "AWS::Omics::VariantStore", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "description": this.description,
      "name": this.name,
      "reference": this.reference,
      "sseConfig": this.sseConfig,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnVariantStore.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnVariantStorePropsToCloudFormation(props);
  }
}

export namespace CfnVariantStore {
  /**
   * The read set's genome reference ARN.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-variantstore-referenceitem.html
   */
  export interface ReferenceItemProperty {
    /**
     * The reference's ARN.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-variantstore-referenceitem.html#cfn-omics-variantstore-referenceitem-referencearn
     */
    readonly referenceArn: string;
  }

  /**
   * Server-side encryption (SSE) settings for a store.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-variantstore-sseconfig.html
   */
  export interface SseConfigProperty {
    /**
     * An encryption key ARN.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-variantstore-sseconfig.html#cfn-omics-variantstore-sseconfig-keyarn
     */
    readonly keyArn?: string;

    /**
     * The encryption type.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-variantstore-sseconfig.html#cfn-omics-variantstore-sseconfig-type
     */
    readonly type: string;
  }
}

/**
 * Properties for defining a \`CfnVariantStore\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-variantstore.html
 */
export interface CfnVariantStoreProps {
  /**
   * A description for the store.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-variantstore.html#cfn-omics-variantstore-description
   */
  readonly description?: string;

  /**
   * A name for the store.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-variantstore.html#cfn-omics-variantstore-name
   */
  readonly name: string;

  /**
   * The genome reference for the store's variants.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-variantstore.html#cfn-omics-variantstore-reference
   */
  readonly reference: cdk.IResolvable | CfnVariantStore.ReferenceItemProperty;

  /**
   * Server-side encryption (SSE) settings for the store.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-variantstore.html#cfn-omics-variantstore-sseconfig
   */
  readonly sseConfig?: cdk.IResolvable | CfnVariantStore.SseConfigProperty;

  /**
   * Tags for the store.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-variantstore.html#cfn-omics-variantstore-tags
   */
  readonly tags?: Record<string, string>;
}

/**
 * Determine whether the given properties match those of a \`ReferenceItemProperty\`
 *
 * @param properties - the TypeScript properties of a \`ReferenceItemProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVariantStoreReferenceItemPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("referenceArn", cdk.requiredValidator)(properties.referenceArn));
  errors.collect(cdk.propertyValidator("referenceArn", cdk.validateString)(properties.referenceArn));
  return errors.wrap("supplied properties not correct for \\"ReferenceItemProperty\\"");
}

// @ts-ignore TS6133
function convertCfnVariantStoreReferenceItemPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVariantStoreReferenceItemPropertyValidator(properties).assertSuccess();
  return {
    "ReferenceArn": cdk.stringToCloudFormation(properties.referenceArn)
  };
}

// @ts-ignore TS6133
function CfnVariantStoreReferenceItemPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnVariantStore.ReferenceItemProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVariantStore.ReferenceItemProperty>();
  ret.addPropertyResult("referenceArn", "ReferenceArn", (properties.ReferenceArn != null ? cfn_parse.FromCloudFormation.getString(properties.ReferenceArn) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`SseConfigProperty\`
 *
 * @param properties - the TypeScript properties of a \`SseConfigProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVariantStoreSseConfigPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("keyArn", cdk.validateString)(properties.keyArn));
  errors.collect(cdk.propertyValidator("type", cdk.requiredValidator)(properties.type));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  return errors.wrap("supplied properties not correct for \\"SseConfigProperty\\"");
}

// @ts-ignore TS6133
function convertCfnVariantStoreSseConfigPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVariantStoreSseConfigPropertyValidator(properties).assertSuccess();
  return {
    "KeyArn": cdk.stringToCloudFormation(properties.keyArn),
    "Type": cdk.stringToCloudFormation(properties.type)
  };
}

// @ts-ignore TS6133
function CfnVariantStoreSseConfigPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnVariantStore.SseConfigProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVariantStore.SseConfigProperty>();
  ret.addPropertyResult("keyArn", "KeyArn", (properties.KeyArn != null ? cfn_parse.FromCloudFormation.getString(properties.KeyArn) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnVariantStoreProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnVariantStoreProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVariantStorePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("name", cdk.requiredValidator)(properties.name));
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  errors.collect(cdk.propertyValidator("reference", cdk.requiredValidator)(properties.reference));
  errors.collect(cdk.propertyValidator("reference", CfnVariantStoreReferenceItemPropertyValidator)(properties.reference));
  errors.collect(cdk.propertyValidator("sseConfig", CfnVariantStoreSseConfigPropertyValidator)(properties.sseConfig));
  errors.collect(cdk.propertyValidator("tags", cdk.hashValidator(cdk.validateString))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnVariantStoreProps\\"");
}

// @ts-ignore TS6133
function convertCfnVariantStorePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVariantStorePropsValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "Name": cdk.stringToCloudFormation(properties.name),
    "Reference": convertCfnVariantStoreReferenceItemPropertyToCloudFormation(properties.reference),
    "SseConfig": convertCfnVariantStoreSseConfigPropertyToCloudFormation(properties.sseConfig),
    "Tags": cdk.hashMapper(cdk.stringToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnVariantStorePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnVariantStoreProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVariantStoreProps>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addPropertyResult("reference", "Reference", (properties.Reference != null ? CfnVariantStoreReferenceItemPropertyFromCloudFormation(properties.Reference) : undefined));
  ret.addPropertyResult("sseConfig", "SseConfig", (properties.SseConfig != null ? CfnVariantStoreSseConfigPropertyFromCloudFormation(properties.SseConfig) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getString)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Creates a workflow.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-workflow.html
 */
export class CfnWorkflow extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::Omics::Workflow";

  /**
   * Build a CfnWorkflow from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnWorkflow {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnWorkflowPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnWorkflow(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ARN for the workflow.
   *
   * @cloudformationAttribute Arn
   */
  public readonly attrArn: string;

  /**
   * When the workflow was created.
   *
   * @cloudformationAttribute CreationTime
   */
  public readonly attrCreationTime: string;

  /**
   * The workflow's ID.
   *
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The workflow's status.
   *
   * @cloudformationAttribute Status
   */
  public readonly attrStatus: string;

  /**
   * The workflow's type.
   *
   * @cloudformationAttribute Type
   */
  public readonly attrType: string;

  /**
   * The URI of a definition for the workflow.
   */
  public definitionUri?: string;

  /**
   * The parameter's description.
   */
  public description?: string;

  /**
   * An engine for the workflow.
   */
  public engine?: string;

  /**
   * The path of the main definition file for the workflow.
   */
  public main?: string;

  /**
   * The workflow's name.
   */
  public name?: string;

  /**
   * The workflow's parameter template.
   */
  public parameterTemplate?: cdk.IResolvable | Record<string, cdk.IResolvable | CfnWorkflow.WorkflowParameterProperty>;

  /**
   * A storage capacity for the workflow in gigabytes.
   */
  public storageCapacity?: number;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * Tags for the workflow.
   */
  public tagsRaw?: Record<string, string>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnWorkflowProps = {}) {
    super(scope, id, {
      "type": CfnWorkflow.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.attrArn = cdk.Token.asString(this.getAtt("Arn", cdk.ResolutionTypeHint.STRING));
    this.attrCreationTime = cdk.Token.asString(this.getAtt("CreationTime", cdk.ResolutionTypeHint.STRING));
    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.attrStatus = cdk.Token.asString(this.getAtt("Status", cdk.ResolutionTypeHint.STRING));
    this.attrType = cdk.Token.asString(this.getAtt("Type", cdk.ResolutionTypeHint.STRING));
    this.definitionUri = props.definitionUri;
    this.description = props.description;
    this.engine = props.engine;
    this.main = props.main;
    this.name = props.name;
    this.parameterTemplate = props.parameterTemplate;
    this.storageCapacity = props.storageCapacity;
    this.tags = new cdk.TagManager(cdk.TagType.MAP, "AWS::Omics::Workflow", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "definitionUri": this.definitionUri,
      "description": this.description,
      "engine": this.engine,
      "main": this.main,
      "name": this.name,
      "parameterTemplate": this.parameterTemplate,
      "storageCapacity": this.storageCapacity,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnWorkflow.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnWorkflowPropsToCloudFormation(props);
  }
}

export namespace CfnWorkflow {
  /**
   * A workflow parameter.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-workflow-workflowparameter.html
   */
  export interface WorkflowParameterProperty {
    /**
     * The parameter's description.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-workflow-workflowparameter.html#cfn-omics-workflow-workflowparameter-description
     */
    readonly description?: string;

    /**
     * Whether the parameter is optional.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-workflow-workflowparameter.html#cfn-omics-workflow-workflowparameter-optional
     */
    readonly optional?: boolean | cdk.IResolvable;
  }
}

/**
 * Properties for defining a \`CfnWorkflow\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-workflow.html
 */
export interface CfnWorkflowProps {
  /**
   * The URI of a definition for the workflow.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-workflow.html#cfn-omics-workflow-definitionuri
   */
  readonly definitionUri?: string;

  /**
   * The parameter's description.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-workflow.html#cfn-omics-workflow-description
   */
  readonly description?: string;

  /**
   * An engine for the workflow.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-workflow.html#cfn-omics-workflow-engine
   */
  readonly engine?: string;

  /**
   * The path of the main definition file for the workflow.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-workflow.html#cfn-omics-workflow-main
   */
  readonly main?: string;

  /**
   * The workflow's name.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-workflow.html#cfn-omics-workflow-name
   */
  readonly name?: string;

  /**
   * The workflow's parameter template.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-workflow.html#cfn-omics-workflow-parametertemplate
   */
  readonly parameterTemplate?: cdk.IResolvable | Record<string, cdk.IResolvable | CfnWorkflow.WorkflowParameterProperty>;

  /**
   * A storage capacity for the workflow in gigabytes.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-workflow.html#cfn-omics-workflow-storagecapacity
   */
  readonly storageCapacity?: number;

  /**
   * Tags for the workflow.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-workflow.html#cfn-omics-workflow-tags
   */
  readonly tags?: Record<string, string>;
}

/**
 * Determine whether the given properties match those of a \`WorkflowParameterProperty\`
 *
 * @param properties - the TypeScript properties of a \`WorkflowParameterProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnWorkflowWorkflowParameterPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("optional", cdk.validateBoolean)(properties.optional));
  return errors.wrap("supplied properties not correct for \\"WorkflowParameterProperty\\"");
}

// @ts-ignore TS6133
function convertCfnWorkflowWorkflowParameterPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnWorkflowWorkflowParameterPropertyValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "Optional": cdk.booleanToCloudFormation(properties.optional)
  };
}

// @ts-ignore TS6133
function CfnWorkflowWorkflowParameterPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnWorkflow.WorkflowParameterProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnWorkflow.WorkflowParameterProperty>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("optional", "Optional", (properties.Optional != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Optional) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnWorkflowProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnWorkflowProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnWorkflowPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("definitionUri", cdk.validateString)(properties.definitionUri));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("engine", cdk.validateString)(properties.engine));
  errors.collect(cdk.propertyValidator("main", cdk.validateString)(properties.main));
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  errors.collect(cdk.propertyValidator("parameterTemplate", cdk.hashValidator(CfnWorkflowWorkflowParameterPropertyValidator))(properties.parameterTemplate));
  errors.collect(cdk.propertyValidator("storageCapacity", cdk.validateNumber)(properties.storageCapacity));
  errors.collect(cdk.propertyValidator("tags", cdk.hashValidator(cdk.validateString))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnWorkflowProps\\"");
}

// @ts-ignore TS6133
function convertCfnWorkflowPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnWorkflowPropsValidator(properties).assertSuccess();
  return {
    "DefinitionUri": cdk.stringToCloudFormation(properties.definitionUri),
    "Description": cdk.stringToCloudFormation(properties.description),
    "Engine": cdk.stringToCloudFormation(properties.engine),
    "Main": cdk.stringToCloudFormation(properties.main),
    "Name": cdk.stringToCloudFormation(properties.name),
    "ParameterTemplate": cdk.hashMapper(convertCfnWorkflowWorkflowParameterPropertyToCloudFormation)(properties.parameterTemplate),
    "StorageCapacity": cdk.numberToCloudFormation(properties.storageCapacity),
    "Tags": cdk.hashMapper(cdk.stringToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnWorkflowPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnWorkflowProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnWorkflowProps>();
  ret.addPropertyResult("definitionUri", "DefinitionUri", (properties.DefinitionUri != null ? cfn_parse.FromCloudFormation.getString(properties.DefinitionUri) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("engine", "Engine", (properties.Engine != null ? cfn_parse.FromCloudFormation.getString(properties.Engine) : undefined));
  ret.addPropertyResult("main", "Main", (properties.Main != null ? cfn_parse.FromCloudFormation.getString(properties.Main) : undefined));
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addPropertyResult("parameterTemplate", "ParameterTemplate", (properties.ParameterTemplate != null ? cfn_parse.FromCloudFormation.getMap(CfnWorkflowWorkflowParameterPropertyFromCloudFormation)(properties.ParameterTemplate) : undefined));
  ret.addPropertyResult("storageCapacity", "StorageCapacity", (properties.StorageCapacity != null ? cfn_parse.FromCloudFormation.getNumber(properties.StorageCapacity) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getString)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}",
}
`;

exports[`aws-sam 1`] = `
{
  "augmentations": undefined,
  "metrics": undefined,
  "module": "/* eslint-disable prettier/prettier,max-len */
import * as cdk from "aws-cdk-lib";
import * as constructs from "constructs";
import * as cfn_parse from "aws-cdk-lib/core/lib/helpers-internal";

/**
 * Definition of AWS::Serverless::Api.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html
 */
export class CfnApi extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::Serverless::Api";

  /**
   * The \`Transform\` a template must use in order to use this resource
   */
  public static readonly REQUIRED_TRANSFORM: string = "AWS::Serverless-2016-10-31";

  /**
   * Build a CfnApi from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnApi {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnApiPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnApi(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  public accessLogSetting?: CfnApi.AccessLogSettingProperty | cdk.IResolvable;

  public auth?: CfnApi.AuthProperty | cdk.IResolvable;

  public binaryMediaTypes?: Array<string>;

  public cacheClusterEnabled?: boolean | cdk.IResolvable;

  public cacheClusterSize?: string;

  public canarySetting?: CfnApi.CanarySettingProperty | cdk.IResolvable;

  public cors?: CfnApi.CorsConfigurationProperty | cdk.IResolvable | string;

  public definitionBody?: any | cdk.IResolvable;

  public definitionUri?: cdk.IResolvable | CfnApi.S3LocationProperty | string;

  public description?: string;

  public disableExecuteApiEndpoint?: boolean | cdk.IResolvable;

  public domain?: CfnApi.DomainConfigurationProperty | cdk.IResolvable;

  public endpointConfiguration?: CfnApi.EndpointConfigurationProperty | cdk.IResolvable | string;

  public gatewayResponses?: any | cdk.IResolvable;

  public methodSettings?: Array<any | cdk.IResolvable> | cdk.IResolvable;

  public minimumCompressionSize?: number;

  public models?: any | cdk.IResolvable;

  public name?: string;

  public openApiVersion?: string;

  public stageName: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  public tagsRaw?: Record<string, string>;

  public tracingEnabled?: boolean | cdk.IResolvable;

  public variables?: cdk.IResolvable | Record<string, string>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnApiProps) {
    super(scope, id, {
      "type": CfnApi.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "stageName", this);

    // Automatically add the required transform
    this.stack.addTransform(CfnApi.REQUIRED_TRANSFORM);

    this.accessLogSetting = props.accessLogSetting;
    this.auth = props.auth;
    this.binaryMediaTypes = props.binaryMediaTypes;
    this.cacheClusterEnabled = props.cacheClusterEnabled;
    this.cacheClusterSize = props.cacheClusterSize;
    this.canarySetting = props.canarySetting;
    this.cors = props.cors;
    this.definitionBody = props.definitionBody;
    this.definitionUri = props.definitionUri;
    this.description = props.description;
    this.disableExecuteApiEndpoint = props.disableExecuteApiEndpoint;
    this.domain = props.domain;
    this.endpointConfiguration = props.endpointConfiguration;
    this.gatewayResponses = props.gatewayResponses;
    this.methodSettings = props.methodSettings;
    this.minimumCompressionSize = props.minimumCompressionSize;
    this.models = props.models;
    this.name = props.name;
    this.openApiVersion = props.openApiVersion;
    this.stageName = props.stageName;
    this.tags = new cdk.TagManager(cdk.TagType.MAP, "AWS::Serverless::Api", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.tracingEnabled = props.tracingEnabled;
    this.variables = props.variables;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "accessLogSetting": this.accessLogSetting,
      "auth": this.auth,
      "binaryMediaTypes": this.binaryMediaTypes,
      "cacheClusterEnabled": this.cacheClusterEnabled,
      "cacheClusterSize": this.cacheClusterSize,
      "canarySetting": this.canarySetting,
      "cors": this.cors,
      "definitionBody": this.definitionBody,
      "definitionUri": this.definitionUri,
      "description": this.description,
      "disableExecuteApiEndpoint": this.disableExecuteApiEndpoint,
      "domain": this.domain,
      "endpointConfiguration": this.endpointConfiguration,
      "gatewayResponses": this.gatewayResponses,
      "methodSettings": this.methodSettings,
      "minimumCompressionSize": this.minimumCompressionSize,
      "models": this.models,
      "name": this.name,
      "openApiVersion": this.openApiVersion,
      "stageName": this.stageName,
      "tags": this.tags.renderTags(),
      "tracingEnabled": this.tracingEnabled,
      "variables": this.variables
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnApi.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnApiPropsToCloudFormation(props);
  }
}

export namespace CfnApi {
  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-accesslogsetting.html
   */
  export interface AccessLogSettingProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-accesslogsetting.html#cfn-serverless-api-accesslogsetting-destinationarn
     */
    readonly destinationArn?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-accesslogsetting.html#cfn-serverless-api-accesslogsetting-format
     */
    readonly format?: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-auth.html
   */
  export interface AuthProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-auth.html#cfn-serverless-api-auth-adddefaultauthorizertocorspreflight
     */
    readonly addDefaultAuthorizerToCorsPreflight?: boolean | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-auth.html#cfn-serverless-api-auth-authorizers
     */
    readonly authorizers?: any | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-auth.html#cfn-serverless-api-auth-defaultauthorizer
     */
    readonly defaultAuthorizer?: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-canarysetting.html
   */
  export interface CanarySettingProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-canarysetting.html#cfn-serverless-api-canarysetting-deploymentid
     */
    readonly deploymentId?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-canarysetting.html#cfn-serverless-api-canarysetting-percenttraffic
     */
    readonly percentTraffic?: number;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-canarysetting.html#cfn-serverless-api-canarysetting-stagevariableoverrides
     */
    readonly stageVariableOverrides?: cdk.IResolvable | Record<string, string>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-canarysetting.html#cfn-serverless-api-canarysetting-usestagecache
     */
    readonly useStageCache?: boolean | cdk.IResolvable;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-corsconfiguration.html
   */
  export interface CorsConfigurationProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-corsconfiguration.html#cfn-serverless-api-corsconfiguration-allowcredentials
     */
    readonly allowCredentials?: boolean | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-corsconfiguration.html#cfn-serverless-api-corsconfiguration-allowheaders
     */
    readonly allowHeaders?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-corsconfiguration.html#cfn-serverless-api-corsconfiguration-allowmethods
     */
    readonly allowMethods?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-corsconfiguration.html#cfn-serverless-api-corsconfiguration-alloworigin
     */
    readonly allowOrigin: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-corsconfiguration.html#cfn-serverless-api-corsconfiguration-maxage
     */
    readonly maxAge?: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-s3location.html
   */
  export interface S3LocationProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-s3location.html#cfn-serverless-api-s3location-bucket
     */
    readonly bucket: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-s3location.html#cfn-serverless-api-s3location-key
     */
    readonly key: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-s3location.html#cfn-serverless-api-s3location-version
     */
    readonly version: number;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-domainconfiguration.html
   */
  export interface DomainConfigurationProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-domainconfiguration.html#cfn-serverless-api-domainconfiguration-basepath
     */
    readonly basePath?: Array<string>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-domainconfiguration.html#cfn-serverless-api-domainconfiguration-certificatearn
     */
    readonly certificateArn: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-domainconfiguration.html#cfn-serverless-api-domainconfiguration-domainname
     */
    readonly domainName: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-domainconfiguration.html#cfn-serverless-api-domainconfiguration-endpointconfiguration
     */
    readonly endpointConfiguration?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-domainconfiguration.html#cfn-serverless-api-domainconfiguration-mutualtlsauthentication
     */
    readonly mutualTlsAuthentication?: cdk.IResolvable | CfnApi.MutualTlsAuthenticationProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-domainconfiguration.html#cfn-serverless-api-domainconfiguration-ownershipverificationcertificatearn
     */
    readonly ownershipVerificationCertificateArn?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-domainconfiguration.html#cfn-serverless-api-domainconfiguration-route53
     */
    readonly route53?: cdk.IResolvable | CfnApi.Route53ConfigurationProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-domainconfiguration.html#cfn-serverless-api-domainconfiguration-securitypolicy
     */
    readonly securityPolicy?: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-mutualtlsauthentication.html
   */
  export interface MutualTlsAuthenticationProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-mutualtlsauthentication.html#cfn-serverless-api-mutualtlsauthentication-truststoreuri
     */
    readonly truststoreUri?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-mutualtlsauthentication.html#cfn-serverless-api-mutualtlsauthentication-truststoreversion
     */
    readonly truststoreVersion?: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-route53configuration.html
   */
  export interface Route53ConfigurationProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-route53configuration.html#cfn-serverless-api-route53configuration-distributeddomainname
     */
    readonly distributedDomainName?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-route53configuration.html#cfn-serverless-api-route53configuration-evaluatetargethealth
     */
    readonly evaluateTargetHealth?: boolean | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-route53configuration.html#cfn-serverless-api-route53configuration-hostedzoneid
     */
    readonly hostedZoneId?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-route53configuration.html#cfn-serverless-api-route53configuration-hostedzonename
     */
    readonly hostedZoneName?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-route53configuration.html#cfn-serverless-api-route53configuration-ipv6
     */
    readonly ipV6?: boolean | cdk.IResolvable;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-endpointconfiguration.html
   */
  export interface EndpointConfigurationProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-endpointconfiguration.html#cfn-serverless-api-endpointconfiguration-type
     */
    readonly type?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-endpointconfiguration.html#cfn-serverless-api-endpointconfiguration-vpcendpointids
     */
    readonly vpcEndpointIds?: Array<string>;
  }
}

/**
 * Properties for defining a \`CfnApi\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html
 */
export interface CfnApiProps {
  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-accesslogsetting
   */
  readonly accessLogSetting?: CfnApi.AccessLogSettingProperty | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-auth
   */
  readonly auth?: CfnApi.AuthProperty | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-binarymediatypes
   */
  readonly binaryMediaTypes?: Array<string>;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-cacheclusterenabled
   */
  readonly cacheClusterEnabled?: boolean | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-cacheclustersize
   */
  readonly cacheClusterSize?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-canarysetting
   */
  readonly canarySetting?: CfnApi.CanarySettingProperty | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-cors
   */
  readonly cors?: CfnApi.CorsConfigurationProperty | cdk.IResolvable | string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-definitionbody
   */
  readonly definitionBody?: any | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-definitionuri
   */
  readonly definitionUri?: cdk.IResolvable | CfnApi.S3LocationProperty | string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-description
   */
  readonly description?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-disableexecuteapiendpoint
   */
  readonly disableExecuteApiEndpoint?: boolean | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-domain
   */
  readonly domain?: CfnApi.DomainConfigurationProperty | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-endpointconfiguration
   */
  readonly endpointConfiguration?: CfnApi.EndpointConfigurationProperty | cdk.IResolvable | string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-gatewayresponses
   */
  readonly gatewayResponses?: any | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-methodsettings
   */
  readonly methodSettings?: Array<any | cdk.IResolvable> | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-minimumcompressionsize
   */
  readonly minimumCompressionSize?: number;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-models
   */
  readonly models?: any | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-name
   */
  readonly name?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-openapiversion
   */
  readonly openApiVersion?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-stagename
   */
  readonly stageName: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-tags
   */
  readonly tags?: Record<string, string>;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-tracingenabled
   */
  readonly tracingEnabled?: boolean | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-variables
   */
  readonly variables?: cdk.IResolvable | Record<string, string>;
}

/**
 * Determine whether the given properties match those of a \`AccessLogSettingProperty\`
 *
 * @param properties - the TypeScript properties of a \`AccessLogSettingProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApiAccessLogSettingPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("destinationArn", cdk.validateString)(properties.destinationArn));
  errors.collect(cdk.propertyValidator("format", cdk.validateString)(properties.format));
  return errors.wrap("supplied properties not correct for \\"AccessLogSettingProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApiAccessLogSettingPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApiAccessLogSettingPropertyValidator(properties).assertSuccess();
  return {
    "DestinationArn": cdk.stringToCloudFormation(properties.destinationArn),
    "Format": cdk.stringToCloudFormation(properties.format)
  };
}

// @ts-ignore TS6133
function CfnApiAccessLogSettingPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApi.AccessLogSettingProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApi.AccessLogSettingProperty>();
  ret.addPropertyResult("destinationArn", "DestinationArn", (properties.DestinationArn != null ? cfn_parse.FromCloudFormation.getString(properties.DestinationArn) : undefined));
  ret.addPropertyResult("format", "Format", (properties.Format != null ? cfn_parse.FromCloudFormation.getString(properties.Format) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`AuthProperty\`
 *
 * @param properties - the TypeScript properties of a \`AuthProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApiAuthPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("addDefaultAuthorizerToCorsPreflight", cdk.validateBoolean)(properties.addDefaultAuthorizerToCorsPreflight));
  errors.collect(cdk.propertyValidator("authorizers", cdk.validateObject)(properties.authorizers));
  errors.collect(cdk.propertyValidator("defaultAuthorizer", cdk.validateString)(properties.defaultAuthorizer));
  return errors.wrap("supplied properties not correct for \\"AuthProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApiAuthPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApiAuthPropertyValidator(properties).assertSuccess();
  return {
    "AddDefaultAuthorizerToCorsPreflight": cdk.booleanToCloudFormation(properties.addDefaultAuthorizerToCorsPreflight),
    "Authorizers": cdk.objectToCloudFormation(properties.authorizers),
    "DefaultAuthorizer": cdk.stringToCloudFormation(properties.defaultAuthorizer)
  };
}

// @ts-ignore TS6133
function CfnApiAuthPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApi.AuthProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApi.AuthProperty>();
  ret.addPropertyResult("addDefaultAuthorizerToCorsPreflight", "AddDefaultAuthorizerToCorsPreflight", (properties.AddDefaultAuthorizerToCorsPreflight != null ? cfn_parse.FromCloudFormation.getBoolean(properties.AddDefaultAuthorizerToCorsPreflight) : undefined));
  ret.addPropertyResult("authorizers", "Authorizers", (properties.Authorizers != null ? cfn_parse.FromCloudFormation.getAny(properties.Authorizers) : undefined));
  ret.addPropertyResult("defaultAuthorizer", "DefaultAuthorizer", (properties.DefaultAuthorizer != null ? cfn_parse.FromCloudFormation.getString(properties.DefaultAuthorizer) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CanarySettingProperty\`
 *
 * @param properties - the TypeScript properties of a \`CanarySettingProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApiCanarySettingPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("deploymentId", cdk.validateString)(properties.deploymentId));
  errors.collect(cdk.propertyValidator("percentTraffic", cdk.validateNumber)(properties.percentTraffic));
  errors.collect(cdk.propertyValidator("stageVariableOverrides", cdk.hashValidator(cdk.validateString))(properties.stageVariableOverrides));
  errors.collect(cdk.propertyValidator("useStageCache", cdk.validateBoolean)(properties.useStageCache));
  return errors.wrap("supplied properties not correct for \\"CanarySettingProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApiCanarySettingPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApiCanarySettingPropertyValidator(properties).assertSuccess();
  return {
    "DeploymentId": cdk.stringToCloudFormation(properties.deploymentId),
    "PercentTraffic": cdk.numberToCloudFormation(properties.percentTraffic),
    "StageVariableOverrides": cdk.hashMapper(cdk.stringToCloudFormation)(properties.stageVariableOverrides),
    "UseStageCache": cdk.booleanToCloudFormation(properties.useStageCache)
  };
}

// @ts-ignore TS6133
function CfnApiCanarySettingPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApi.CanarySettingProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApi.CanarySettingProperty>();
  ret.addPropertyResult("deploymentId", "DeploymentId", (properties.DeploymentId != null ? cfn_parse.FromCloudFormation.getString(properties.DeploymentId) : undefined));
  ret.addPropertyResult("percentTraffic", "PercentTraffic", (properties.PercentTraffic != null ? cfn_parse.FromCloudFormation.getNumber(properties.PercentTraffic) : undefined));
  ret.addPropertyResult("stageVariableOverrides", "StageVariableOverrides", (properties.StageVariableOverrides != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getString)(properties.StageVariableOverrides) : undefined));
  ret.addPropertyResult("useStageCache", "UseStageCache", (properties.UseStageCache != null ? cfn_parse.FromCloudFormation.getBoolean(properties.UseStageCache) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CorsConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`CorsConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApiCorsConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("allowCredentials", cdk.validateBoolean)(properties.allowCredentials));
  errors.collect(cdk.propertyValidator("allowHeaders", cdk.validateString)(properties.allowHeaders));
  errors.collect(cdk.propertyValidator("allowMethods", cdk.validateString)(properties.allowMethods));
  errors.collect(cdk.propertyValidator("allowOrigin", cdk.requiredValidator)(properties.allowOrigin));
  errors.collect(cdk.propertyValidator("allowOrigin", cdk.validateString)(properties.allowOrigin));
  errors.collect(cdk.propertyValidator("maxAge", cdk.validateString)(properties.maxAge));
  return errors.wrap("supplied properties not correct for \\"CorsConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApiCorsConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApiCorsConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "AllowCredentials": cdk.booleanToCloudFormation(properties.allowCredentials),
    "AllowHeaders": cdk.stringToCloudFormation(properties.allowHeaders),
    "AllowMethods": cdk.stringToCloudFormation(properties.allowMethods),
    "AllowOrigin": cdk.stringToCloudFormation(properties.allowOrigin),
    "MaxAge": cdk.stringToCloudFormation(properties.maxAge)
  };
}

// @ts-ignore TS6133
function CfnApiCorsConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApi.CorsConfigurationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApi.CorsConfigurationProperty>();
  ret.addPropertyResult("allowCredentials", "AllowCredentials", (properties.AllowCredentials != null ? cfn_parse.FromCloudFormation.getBoolean(properties.AllowCredentials) : undefined));
  ret.addPropertyResult("allowHeaders", "AllowHeaders", (properties.AllowHeaders != null ? cfn_parse.FromCloudFormation.getString(properties.AllowHeaders) : undefined));
  ret.addPropertyResult("allowMethods", "AllowMethods", (properties.AllowMethods != null ? cfn_parse.FromCloudFormation.getString(properties.AllowMethods) : undefined));
  ret.addPropertyResult("allowOrigin", "AllowOrigin", (properties.AllowOrigin != null ? cfn_parse.FromCloudFormation.getString(properties.AllowOrigin) : undefined));
  ret.addPropertyResult("maxAge", "MaxAge", (properties.MaxAge != null ? cfn_parse.FromCloudFormation.getString(properties.MaxAge) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`S3LocationProperty\`
 *
 * @param properties - the TypeScript properties of a \`S3LocationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApiS3LocationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("bucket", cdk.requiredValidator)(properties.bucket));
  errors.collect(cdk.propertyValidator("bucket", cdk.validateString)(properties.bucket));
  errors.collect(cdk.propertyValidator("key", cdk.requiredValidator)(properties.key));
  errors.collect(cdk.propertyValidator("key", cdk.validateString)(properties.key));
  errors.collect(cdk.propertyValidator("version", cdk.requiredValidator)(properties.version));
  errors.collect(cdk.propertyValidator("version", cdk.validateNumber)(properties.version));
  return errors.wrap("supplied properties not correct for \\"S3LocationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApiS3LocationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApiS3LocationPropertyValidator(properties).assertSuccess();
  return {
    "Bucket": cdk.stringToCloudFormation(properties.bucket),
    "Key": cdk.stringToCloudFormation(properties.key),
    "Version": cdk.numberToCloudFormation(properties.version)
  };
}

// @ts-ignore TS6133
function CfnApiS3LocationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApi.S3LocationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApi.S3LocationProperty>();
  ret.addPropertyResult("bucket", "Bucket", (properties.Bucket != null ? cfn_parse.FromCloudFormation.getString(properties.Bucket) : undefined));
  ret.addPropertyResult("key", "Key", (properties.Key != null ? cfn_parse.FromCloudFormation.getString(properties.Key) : undefined));
  ret.addPropertyResult("version", "Version", (properties.Version != null ? cfn_parse.FromCloudFormation.getNumber(properties.Version) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`MutualTlsAuthenticationProperty\`
 *
 * @param properties - the TypeScript properties of a \`MutualTlsAuthenticationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApiMutualTlsAuthenticationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("truststoreUri", cdk.validateString)(properties.truststoreUri));
  errors.collect(cdk.propertyValidator("truststoreVersion", cdk.validateString)(properties.truststoreVersion));
  return errors.wrap("supplied properties not correct for \\"MutualTlsAuthenticationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApiMutualTlsAuthenticationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApiMutualTlsAuthenticationPropertyValidator(properties).assertSuccess();
  return {
    "TruststoreUri": cdk.stringToCloudFormation(properties.truststoreUri),
    "TruststoreVersion": cdk.stringToCloudFormation(properties.truststoreVersion)
  };
}

// @ts-ignore TS6133
function CfnApiMutualTlsAuthenticationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApi.MutualTlsAuthenticationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApi.MutualTlsAuthenticationProperty>();
  ret.addPropertyResult("truststoreUri", "TruststoreUri", (properties.TruststoreUri != null ? cfn_parse.FromCloudFormation.getString(properties.TruststoreUri) : undefined));
  ret.addPropertyResult("truststoreVersion", "TruststoreVersion", (properties.TruststoreVersion != null ? cfn_parse.FromCloudFormation.getString(properties.TruststoreVersion) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`Route53ConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`Route53ConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApiRoute53ConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("distributedDomainName", cdk.validateString)(properties.distributedDomainName));
  errors.collect(cdk.propertyValidator("evaluateTargetHealth", cdk.validateBoolean)(properties.evaluateTargetHealth));
  errors.collect(cdk.propertyValidator("hostedZoneId", cdk.validateString)(properties.hostedZoneId));
  errors.collect(cdk.propertyValidator("hostedZoneName", cdk.validateString)(properties.hostedZoneName));
  errors.collect(cdk.propertyValidator("ipV6", cdk.validateBoolean)(properties.ipV6));
  return errors.wrap("supplied properties not correct for \\"Route53ConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApiRoute53ConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApiRoute53ConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "DistributedDomainName": cdk.stringToCloudFormation(properties.distributedDomainName),
    "EvaluateTargetHealth": cdk.booleanToCloudFormation(properties.evaluateTargetHealth),
    "HostedZoneId": cdk.stringToCloudFormation(properties.hostedZoneId),
    "HostedZoneName": cdk.stringToCloudFormation(properties.hostedZoneName),
    "IpV6": cdk.booleanToCloudFormation(properties.ipV6)
  };
}

// @ts-ignore TS6133
function CfnApiRoute53ConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApi.Route53ConfigurationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApi.Route53ConfigurationProperty>();
  ret.addPropertyResult("distributedDomainName", "DistributedDomainName", (properties.DistributedDomainName != null ? cfn_parse.FromCloudFormation.getString(properties.DistributedDomainName) : undefined));
  ret.addPropertyResult("evaluateTargetHealth", "EvaluateTargetHealth", (properties.EvaluateTargetHealth != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EvaluateTargetHealth) : undefined));
  ret.addPropertyResult("hostedZoneId", "HostedZoneId", (properties.HostedZoneId != null ? cfn_parse.FromCloudFormation.getString(properties.HostedZoneId) : undefined));
  ret.addPropertyResult("hostedZoneName", "HostedZoneName", (properties.HostedZoneName != null ? cfn_parse.FromCloudFormation.getString(properties.HostedZoneName) : undefined));
  ret.addPropertyResult("ipV6", "IpV6", (properties.IpV6 != null ? cfn_parse.FromCloudFormation.getBoolean(properties.IpV6) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`DomainConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`DomainConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApiDomainConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("basePath", cdk.listValidator(cdk.validateString))(properties.basePath));
  errors.collect(cdk.propertyValidator("certificateArn", cdk.requiredValidator)(properties.certificateArn));
  errors.collect(cdk.propertyValidator("certificateArn", cdk.validateString)(properties.certificateArn));
  errors.collect(cdk.propertyValidator("domainName", cdk.requiredValidator)(properties.domainName));
  errors.collect(cdk.propertyValidator("domainName", cdk.validateString)(properties.domainName));
  errors.collect(cdk.propertyValidator("endpointConfiguration", cdk.validateString)(properties.endpointConfiguration));
  errors.collect(cdk.propertyValidator("mutualTlsAuthentication", CfnApiMutualTlsAuthenticationPropertyValidator)(properties.mutualTlsAuthentication));
  errors.collect(cdk.propertyValidator("ownershipVerificationCertificateArn", cdk.validateString)(properties.ownershipVerificationCertificateArn));
  errors.collect(cdk.propertyValidator("route53", CfnApiRoute53ConfigurationPropertyValidator)(properties.route53));
  errors.collect(cdk.propertyValidator("securityPolicy", cdk.validateString)(properties.securityPolicy));
  return errors.wrap("supplied properties not correct for \\"DomainConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApiDomainConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApiDomainConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "BasePath": cdk.listMapper(cdk.stringToCloudFormation)(properties.basePath),
    "CertificateArn": cdk.stringToCloudFormation(properties.certificateArn),
    "DomainName": cdk.stringToCloudFormation(properties.domainName),
    "EndpointConfiguration": cdk.stringToCloudFormation(properties.endpointConfiguration),
    "MutualTlsAuthentication": convertCfnApiMutualTlsAuthenticationPropertyToCloudFormation(properties.mutualTlsAuthentication),
    "OwnershipVerificationCertificateArn": cdk.stringToCloudFormation(properties.ownershipVerificationCertificateArn),
    "Route53": convertCfnApiRoute53ConfigurationPropertyToCloudFormation(properties.route53),
    "SecurityPolicy": cdk.stringToCloudFormation(properties.securityPolicy)
  };
}

// @ts-ignore TS6133
function CfnApiDomainConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApi.DomainConfigurationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApi.DomainConfigurationProperty>();
  ret.addPropertyResult("basePath", "BasePath", (properties.BasePath != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.BasePath) : undefined));
  ret.addPropertyResult("certificateArn", "CertificateArn", (properties.CertificateArn != null ? cfn_parse.FromCloudFormation.getString(properties.CertificateArn) : undefined));
  ret.addPropertyResult("domainName", "DomainName", (properties.DomainName != null ? cfn_parse.FromCloudFormation.getString(properties.DomainName) : undefined));
  ret.addPropertyResult("endpointConfiguration", "EndpointConfiguration", (properties.EndpointConfiguration != null ? cfn_parse.FromCloudFormation.getString(properties.EndpointConfiguration) : undefined));
  ret.addPropertyResult("mutualTlsAuthentication", "MutualTlsAuthentication", (properties.MutualTlsAuthentication != null ? CfnApiMutualTlsAuthenticationPropertyFromCloudFormation(properties.MutualTlsAuthentication) : undefined));
  ret.addPropertyResult("ownershipVerificationCertificateArn", "OwnershipVerificationCertificateArn", (properties.OwnershipVerificationCertificateArn != null ? cfn_parse.FromCloudFormation.getString(properties.OwnershipVerificationCertificateArn) : undefined));
  ret.addPropertyResult("route53", "Route53", (properties.Route53 != null ? CfnApiRoute53ConfigurationPropertyFromCloudFormation(properties.Route53) : undefined));
  ret.addPropertyResult("securityPolicy", "SecurityPolicy", (properties.SecurityPolicy != null ? cfn_parse.FromCloudFormation.getString(properties.SecurityPolicy) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`EndpointConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`EndpointConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApiEndpointConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  errors.collect(cdk.propertyValidator("vpcEndpointIds", cdk.listValidator(cdk.validateString))(properties.vpcEndpointIds));
  return errors.wrap("supplied properties not correct for \\"EndpointConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApiEndpointConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApiEndpointConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "Type": cdk.stringToCloudFormation(properties.type),
    "VpcEndpointIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.vpcEndpointIds)
  };
}

// @ts-ignore TS6133
function CfnApiEndpointConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApi.EndpointConfigurationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApi.EndpointConfigurationProperty>();
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addPropertyResult("vpcEndpointIds", "VpcEndpointIds", (properties.VpcEndpointIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.VpcEndpointIds) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnApiProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnApiProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApiPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("accessLogSetting", CfnApiAccessLogSettingPropertyValidator)(properties.accessLogSetting));
  errors.collect(cdk.propertyValidator("auth", CfnApiAuthPropertyValidator)(properties.auth));
  errors.collect(cdk.propertyValidator("binaryMediaTypes", cdk.listValidator(cdk.validateString))(properties.binaryMediaTypes));
  errors.collect(cdk.propertyValidator("cacheClusterEnabled", cdk.validateBoolean)(properties.cacheClusterEnabled));
  errors.collect(cdk.propertyValidator("cacheClusterSize", cdk.validateString)(properties.cacheClusterSize));
  errors.collect(cdk.propertyValidator("canarySetting", CfnApiCanarySettingPropertyValidator)(properties.canarySetting));
  errors.collect(cdk.propertyValidator("cors", cdk.unionValidator(CfnApiCorsConfigurationPropertyValidator, cdk.validateString))(properties.cors));
  errors.collect(cdk.propertyValidator("definitionBody", cdk.validateObject)(properties.definitionBody));
  errors.collect(cdk.propertyValidator("definitionUri", cdk.unionValidator(CfnApiS3LocationPropertyValidator, cdk.validateString))(properties.definitionUri));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("disableExecuteApiEndpoint", cdk.validateBoolean)(properties.disableExecuteApiEndpoint));
  errors.collect(cdk.propertyValidator("domain", CfnApiDomainConfigurationPropertyValidator)(properties.domain));
  errors.collect(cdk.propertyValidator("endpointConfiguration", cdk.unionValidator(CfnApiEndpointConfigurationPropertyValidator, cdk.validateString))(properties.endpointConfiguration));
  errors.collect(cdk.propertyValidator("gatewayResponses", cdk.validateObject)(properties.gatewayResponses));
  errors.collect(cdk.propertyValidator("methodSettings", cdk.listValidator(cdk.validateObject))(properties.methodSettings));
  errors.collect(cdk.propertyValidator("minimumCompressionSize", cdk.validateNumber)(properties.minimumCompressionSize));
  errors.collect(cdk.propertyValidator("models", cdk.validateObject)(properties.models));
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  errors.collect(cdk.propertyValidator("openApiVersion", cdk.validateString)(properties.openApiVersion));
  errors.collect(cdk.propertyValidator("stageName", cdk.requiredValidator)(properties.stageName));
  errors.collect(cdk.propertyValidator("stageName", cdk.validateString)(properties.stageName));
  errors.collect(cdk.propertyValidator("tags", cdk.hashValidator(cdk.validateString))(properties.tags));
  errors.collect(cdk.propertyValidator("tracingEnabled", cdk.validateBoolean)(properties.tracingEnabled));
  errors.collect(cdk.propertyValidator("variables", cdk.hashValidator(cdk.validateString))(properties.variables));
  return errors.wrap("supplied properties not correct for \\"CfnApiProps\\"");
}

// @ts-ignore TS6133
function convertCfnApiPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApiPropsValidator(properties).assertSuccess();
  return {
    "AccessLogSetting": convertCfnApiAccessLogSettingPropertyToCloudFormation(properties.accessLogSetting),
    "Auth": convertCfnApiAuthPropertyToCloudFormation(properties.auth),
    "BinaryMediaTypes": cdk.listMapper(cdk.stringToCloudFormation)(properties.binaryMediaTypes),
    "CacheClusterEnabled": cdk.booleanToCloudFormation(properties.cacheClusterEnabled),
    "CacheClusterSize": cdk.stringToCloudFormation(properties.cacheClusterSize),
    "CanarySetting": convertCfnApiCanarySettingPropertyToCloudFormation(properties.canarySetting),
    "Cors": cdk.unionMapper([CfnApiCorsConfigurationPropertyValidator, cdk.validateString], [convertCfnApiCorsConfigurationPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.cors),
    "DefinitionBody": cdk.objectToCloudFormation(properties.definitionBody),
    "DefinitionUri": cdk.unionMapper([CfnApiS3LocationPropertyValidator, cdk.validateString], [convertCfnApiS3LocationPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.definitionUri),
    "Description": cdk.stringToCloudFormation(properties.description),
    "DisableExecuteApiEndpoint": cdk.booleanToCloudFormation(properties.disableExecuteApiEndpoint),
    "Domain": convertCfnApiDomainConfigurationPropertyToCloudFormation(properties.domain),
    "EndpointConfiguration": cdk.unionMapper([CfnApiEndpointConfigurationPropertyValidator, cdk.validateString], [convertCfnApiEndpointConfigurationPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.endpointConfiguration),
    "GatewayResponses": cdk.objectToCloudFormation(properties.gatewayResponses),
    "MethodSettings": cdk.listMapper(cdk.objectToCloudFormation)(properties.methodSettings),
    "MinimumCompressionSize": cdk.numberToCloudFormation(properties.minimumCompressionSize),
    "Models": cdk.objectToCloudFormation(properties.models),
    "Name": cdk.stringToCloudFormation(properties.name),
    "OpenApiVersion": cdk.stringToCloudFormation(properties.openApiVersion),
    "StageName": cdk.stringToCloudFormation(properties.stageName),
    "Tags": cdk.hashMapper(cdk.stringToCloudFormation)(properties.tags),
    "TracingEnabled": cdk.booleanToCloudFormation(properties.tracingEnabled),
    "Variables": cdk.hashMapper(cdk.stringToCloudFormation)(properties.variables)
  };
}

// @ts-ignore TS6133
function CfnApiPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApiProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApiProps>();
  ret.addPropertyResult("accessLogSetting", "AccessLogSetting", (properties.AccessLogSetting != null ? CfnApiAccessLogSettingPropertyFromCloudFormation(properties.AccessLogSetting) : undefined));
  ret.addPropertyResult("auth", "Auth", (properties.Auth != null ? CfnApiAuthPropertyFromCloudFormation(properties.Auth) : undefined));
  ret.addPropertyResult("binaryMediaTypes", "BinaryMediaTypes", (properties.BinaryMediaTypes != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.BinaryMediaTypes) : undefined));
  ret.addPropertyResult("cacheClusterEnabled", "CacheClusterEnabled", (properties.CacheClusterEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.CacheClusterEnabled) : undefined));
  ret.addPropertyResult("cacheClusterSize", "CacheClusterSize", (properties.CacheClusterSize != null ? cfn_parse.FromCloudFormation.getString(properties.CacheClusterSize) : undefined));
  ret.addPropertyResult("canarySetting", "CanarySetting", (properties.CanarySetting != null ? CfnApiCanarySettingPropertyFromCloudFormation(properties.CanarySetting) : undefined));
  ret.addPropertyResult("cors", "Cors", (properties.Cors != null ? cfn_parse.FromCloudFormation.getTypeUnion([CfnApiCorsConfigurationPropertyValidator, cdk.validateString], [CfnApiCorsConfigurationPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.Cors) : undefined));
  ret.addPropertyResult("definitionBody", "DefinitionBody", (properties.DefinitionBody != null ? cfn_parse.FromCloudFormation.getAny(properties.DefinitionBody) : undefined));
  ret.addPropertyResult("definitionUri", "DefinitionUri", (properties.DefinitionUri != null ? cfn_parse.FromCloudFormation.getTypeUnion([CfnApiS3LocationPropertyValidator, cdk.validateString], [CfnApiS3LocationPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.DefinitionUri) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("disableExecuteApiEndpoint", "DisableExecuteApiEndpoint", (properties.DisableExecuteApiEndpoint != null ? cfn_parse.FromCloudFormation.getBoolean(properties.DisableExecuteApiEndpoint) : undefined));
  ret.addPropertyResult("domain", "Domain", (properties.Domain != null ? CfnApiDomainConfigurationPropertyFromCloudFormation(properties.Domain) : undefined));
  ret.addPropertyResult("endpointConfiguration", "EndpointConfiguration", (properties.EndpointConfiguration != null ? cfn_parse.FromCloudFormation.getTypeUnion([CfnApiEndpointConfigurationPropertyValidator, cdk.validateString], [CfnApiEndpointConfigurationPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.EndpointConfiguration) : undefined));
  ret.addPropertyResult("gatewayResponses", "GatewayResponses", (properties.GatewayResponses != null ? cfn_parse.FromCloudFormation.getAny(properties.GatewayResponses) : undefined));
  ret.addPropertyResult("methodSettings", "MethodSettings", (properties.MethodSettings != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getAny)(properties.MethodSettings) : undefined));
  ret.addPropertyResult("minimumCompressionSize", "MinimumCompressionSize", (properties.MinimumCompressionSize != null ? cfn_parse.FromCloudFormation.getNumber(properties.MinimumCompressionSize) : undefined));
  ret.addPropertyResult("models", "Models", (properties.Models != null ? cfn_parse.FromCloudFormation.getAny(properties.Models) : undefined));
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addPropertyResult("openApiVersion", "OpenApiVersion", (properties.OpenApiVersion != null ? cfn_parse.FromCloudFormation.getString(properties.OpenApiVersion) : undefined));
  ret.addPropertyResult("stageName", "StageName", (properties.StageName != null ? cfn_parse.FromCloudFormation.getString(properties.StageName) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getString)(properties.Tags) : undefined));
  ret.addPropertyResult("tracingEnabled", "TracingEnabled", (properties.TracingEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.TracingEnabled) : undefined));
  ret.addPropertyResult("variables", "Variables", (properties.Variables != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getString)(properties.Variables) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Definition of AWS::Serverless::Application.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-application.html
 */
export class CfnApplication extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::Serverless::Application";

  /**
   * The \`Transform\` a template must use in order to use this resource
   */
  public static readonly REQUIRED_TRANSFORM: string = "AWS::Serverless-2016-10-31";

  /**
   * Build a CfnApplication from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnApplication {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnApplicationPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnApplication(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  public location: CfnApplication.ApplicationLocationProperty | cdk.IResolvable | string;

  public notificationArns?: Array<string>;

  public parameters?: cdk.IResolvable | Record<string, string>;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  public tagsRaw?: Record<string, string>;

  public timeoutInMinutes?: number;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnApplicationProps) {
    super(scope, id, {
      "type": CfnApplication.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "location", this);

    // Automatically add the required transform
    this.stack.addTransform(CfnApplication.REQUIRED_TRANSFORM);

    this.location = props.location;
    this.notificationArns = props.notificationArns;
    this.parameters = props.parameters;
    this.tags = new cdk.TagManager(cdk.TagType.MAP, "AWS::Serverless::Application", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.timeoutInMinutes = props.timeoutInMinutes;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "location": this.location,
      "notificationArns": this.notificationArns,
      "parameters": this.parameters,
      "tags": this.tags.renderTags(),
      "timeoutInMinutes": this.timeoutInMinutes
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnApplication.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnApplicationPropsToCloudFormation(props);
  }
}

export namespace CfnApplication {
  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-application-applicationlocation.html
   */
  export interface ApplicationLocationProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-application-applicationlocation.html#cfn-serverless-application-applicationlocation-applicationid
     */
    readonly applicationId: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-application-applicationlocation.html#cfn-serverless-application-applicationlocation-semanticversion
     */
    readonly semanticVersion: string;
  }
}

/**
 * Properties for defining a \`CfnApplication\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-application.html
 */
export interface CfnApplicationProps {
  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-application.html#cfn-serverless-application-location
   */
  readonly location: CfnApplication.ApplicationLocationProperty | cdk.IResolvable | string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-application.html#cfn-serverless-application-notificationarns
   */
  readonly notificationArns?: Array<string>;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-application.html#cfn-serverless-application-parameters
   */
  readonly parameters?: cdk.IResolvable | Record<string, string>;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-application.html#cfn-serverless-application-tags
   */
  readonly tags?: Record<string, string>;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-application.html#cfn-serverless-application-timeoutinminutes
   */
  readonly timeoutInMinutes?: number;
}

/**
 * Determine whether the given properties match those of a \`ApplicationLocationProperty\`
 *
 * @param properties - the TypeScript properties of a \`ApplicationLocationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationApplicationLocationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("applicationId", cdk.requiredValidator)(properties.applicationId));
  errors.collect(cdk.propertyValidator("applicationId", cdk.validateString)(properties.applicationId));
  errors.collect(cdk.propertyValidator("semanticVersion", cdk.requiredValidator)(properties.semanticVersion));
  errors.collect(cdk.propertyValidator("semanticVersion", cdk.validateString)(properties.semanticVersion));
  return errors.wrap("supplied properties not correct for \\"ApplicationLocationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationApplicationLocationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationApplicationLocationPropertyValidator(properties).assertSuccess();
  return {
    "ApplicationId": cdk.stringToCloudFormation(properties.applicationId),
    "SemanticVersion": cdk.stringToCloudFormation(properties.semanticVersion)
  };
}

// @ts-ignore TS6133
function CfnApplicationApplicationLocationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApplication.ApplicationLocationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplication.ApplicationLocationProperty>();
  ret.addPropertyResult("applicationId", "ApplicationId", (properties.ApplicationId != null ? cfn_parse.FromCloudFormation.getString(properties.ApplicationId) : undefined));
  ret.addPropertyResult("semanticVersion", "SemanticVersion", (properties.SemanticVersion != null ? cfn_parse.FromCloudFormation.getString(properties.SemanticVersion) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnApplicationProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnApplicationProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("location", cdk.requiredValidator)(properties.location));
  errors.collect(cdk.propertyValidator("location", cdk.unionValidator(CfnApplicationApplicationLocationPropertyValidator, cdk.validateString))(properties.location));
  errors.collect(cdk.propertyValidator("notificationArns", cdk.listValidator(cdk.validateString))(properties.notificationArns));
  errors.collect(cdk.propertyValidator("parameters", cdk.hashValidator(cdk.validateString))(properties.parameters));
  errors.collect(cdk.propertyValidator("tags", cdk.hashValidator(cdk.validateString))(properties.tags));
  errors.collect(cdk.propertyValidator("timeoutInMinutes", cdk.validateNumber)(properties.timeoutInMinutes));
  return errors.wrap("supplied properties not correct for \\"CfnApplicationProps\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationPropsValidator(properties).assertSuccess();
  return {
    "Location": cdk.unionMapper([CfnApplicationApplicationLocationPropertyValidator, cdk.validateString], [convertCfnApplicationApplicationLocationPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.location),
    "NotificationArns": cdk.listMapper(cdk.stringToCloudFormation)(properties.notificationArns),
    "Parameters": cdk.hashMapper(cdk.stringToCloudFormation)(properties.parameters),
    "Tags": cdk.hashMapper(cdk.stringToCloudFormation)(properties.tags),
    "TimeoutInMinutes": cdk.numberToCloudFormation(properties.timeoutInMinutes)
  };
}

// @ts-ignore TS6133
function CfnApplicationPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApplicationProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationProps>();
  ret.addPropertyResult("location", "Location", (properties.Location != null ? cfn_parse.FromCloudFormation.getTypeUnion([CfnApplicationApplicationLocationPropertyValidator, cdk.validateString], [CfnApplicationApplicationLocationPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.Location) : undefined));
  ret.addPropertyResult("notificationArns", "NotificationArns", (properties.NotificationArns != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.NotificationArns) : undefined));
  ret.addPropertyResult("parameters", "Parameters", (properties.Parameters != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getString)(properties.Parameters) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getString)(properties.Tags) : undefined));
  ret.addPropertyResult("timeoutInMinutes", "TimeoutInMinutes", (properties.TimeoutInMinutes != null ? cfn_parse.FromCloudFormation.getNumber(properties.TimeoutInMinutes) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Definition of AWS::Serverless::Function.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html
 */
export class CfnFunction extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::Serverless::Function";

  /**
   * The \`Transform\` a template must use in order to use this resource
   */
  public static readonly REQUIRED_TRANSFORM: string = "AWS::Serverless-2016-10-31";

  /**
   * Build a CfnFunction from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnFunction {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnFunctionPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnFunction(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  public architectures?: Array<string>;

  public assumeRolePolicyDocument?: any | cdk.IResolvable;

  public autoPublishAlias?: string;

  public autoPublishCodeSha256?: string;

  public codeSigningConfigArn?: string;

  public codeUri?: cdk.IResolvable | CfnFunction.S3LocationProperty | string;

  public deadLetterQueue?: CfnFunction.DeadLetterQueueProperty | cdk.IResolvable;

  public deploymentPreference?: CfnFunction.DeploymentPreferenceProperty | cdk.IResolvable;

  public description?: string;

  public environment?: CfnFunction.FunctionEnvironmentProperty | cdk.IResolvable;

  public eventInvokeConfig?: CfnFunction.EventInvokeConfigProperty | cdk.IResolvable;

  public events?: cdk.IResolvable | Record<string, CfnFunction.EventSourceProperty | cdk.IResolvable>;

  public fileSystemConfigs?: Array<CfnFunction.FileSystemConfigProperty | cdk.IResolvable> | cdk.IResolvable;

  public functionName?: string;

  public handler?: string;

  public imageConfig?: CfnFunction.ImageConfigProperty | cdk.IResolvable;

  public imageUri?: string;

  public inlineCode?: string;

  public kmsKeyArn?: string;

  public layers?: Array<string>;

  public memorySize?: number;

  public packageType?: string;

  public permissionsBoundary?: string;

  public policies?: Array<CfnFunction.IAMPolicyDocumentProperty | cdk.IResolvable | CfnFunction.SAMPolicyTemplateProperty | string> | CfnFunction.IAMPolicyDocumentProperty | cdk.IResolvable | string;

  public provisionedConcurrencyConfig?: cdk.IResolvable | CfnFunction.ProvisionedConcurrencyConfigProperty;

  public reservedConcurrentExecutions?: number;

  public role?: string;

  public runtime?: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  public tagsRaw?: Record<string, string>;

  public timeout?: number;

  public tracing?: string;

  public versionDescription?: string;

  public vpcConfig?: cdk.IResolvable | CfnFunction.VpcConfigProperty;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnFunctionProps = {}) {
    super(scope, id, {
      "type": CfnFunction.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    // Automatically add the required transform
    this.stack.addTransform(CfnFunction.REQUIRED_TRANSFORM);

    this.architectures = props.architectures;
    this.assumeRolePolicyDocument = props.assumeRolePolicyDocument;
    this.autoPublishAlias = props.autoPublishAlias;
    this.autoPublishCodeSha256 = props.autoPublishCodeSha256;
    this.codeSigningConfigArn = props.codeSigningConfigArn;
    this.codeUri = props.codeUri;
    this.deadLetterQueue = props.deadLetterQueue;
    this.deploymentPreference = props.deploymentPreference;
    this.description = props.description;
    this.environment = props.environment;
    this.eventInvokeConfig = props.eventInvokeConfig;
    this.events = props.events;
    this.fileSystemConfigs = props.fileSystemConfigs;
    this.functionName = props.functionName;
    this.handler = props.handler;
    this.imageConfig = props.imageConfig;
    this.imageUri = props.imageUri;
    this.inlineCode = props.inlineCode;
    this.kmsKeyArn = props.kmsKeyArn;
    this.layers = props.layers;
    this.memorySize = props.memorySize;
    this.packageType = props.packageType;
    this.permissionsBoundary = props.permissionsBoundary;
    this.policies = props.policies;
    this.provisionedConcurrencyConfig = props.provisionedConcurrencyConfig;
    this.reservedConcurrentExecutions = props.reservedConcurrentExecutions;
    this.role = props.role;
    this.runtime = props.runtime;
    this.tags = new cdk.TagManager(cdk.TagType.MAP, "AWS::Serverless::Function", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.timeout = props.timeout;
    this.tracing = props.tracing;
    this.versionDescription = props.versionDescription;
    this.vpcConfig = props.vpcConfig;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "architectures": this.architectures,
      "assumeRolePolicyDocument": this.assumeRolePolicyDocument,
      "autoPublishAlias": this.autoPublishAlias,
      "autoPublishCodeSha256": this.autoPublishCodeSha256,
      "codeSigningConfigArn": this.codeSigningConfigArn,
      "codeUri": this.codeUri,
      "deadLetterQueue": this.deadLetterQueue,
      "deploymentPreference": this.deploymentPreference,
      "description": this.description,
      "environment": this.environment,
      "eventInvokeConfig": this.eventInvokeConfig,
      "events": this.events,
      "fileSystemConfigs": this.fileSystemConfigs,
      "functionName": this.functionName,
      "handler": this.handler,
      "imageConfig": this.imageConfig,
      "imageUri": this.imageUri,
      "inlineCode": this.inlineCode,
      "kmsKeyArn": this.kmsKeyArn,
      "layers": this.layers,
      "memorySize": this.memorySize,
      "packageType": this.packageType,
      "permissionsBoundary": this.permissionsBoundary,
      "policies": this.policies,
      "provisionedConcurrencyConfig": this.provisionedConcurrencyConfig,
      "reservedConcurrentExecutions": this.reservedConcurrentExecutions,
      "role": this.role,
      "runtime": this.runtime,
      "tags": this.tags.renderTags(),
      "timeout": this.timeout,
      "tracing": this.tracing,
      "versionDescription": this.versionDescription,
      "vpcConfig": this.vpcConfig
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnFunction.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnFunctionPropsToCloudFormation(props);
  }
}

export namespace CfnFunction {
  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-s3location.html
   */
  export interface S3LocationProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-s3location.html#cfn-serverless-function-s3location-bucket
     */
    readonly bucket: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-s3location.html#cfn-serverless-function-s3location-key
     */
    readonly key: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-s3location.html#cfn-serverless-function-s3location-version
     */
    readonly version?: number;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deadletterqueue.html
   */
  export interface DeadLetterQueueProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deadletterqueue.html#cfn-serverless-function-deadletterqueue-targetarn
     */
    readonly targetArn: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deadletterqueue.html#cfn-serverless-function-deadletterqueue-type
     */
    readonly type: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deploymentpreference.html
   */
  export interface DeploymentPreferenceProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deploymentpreference.html#cfn-serverless-function-deploymentpreference-alarms
     */
    readonly alarms?: Array<string>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deploymentpreference.html#cfn-serverless-function-deploymentpreference-enabled
     */
    readonly enabled?: boolean | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deploymentpreference.html#cfn-serverless-function-deploymentpreference-hooks
     */
    readonly hooks?: CfnFunction.HooksProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deploymentpreference.html#cfn-serverless-function-deploymentpreference-role
     */
    readonly role?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deploymentpreference.html#cfn-serverless-function-deploymentpreference-type
     */
    readonly type?: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-hooks.html
   */
  export interface HooksProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-hooks.html#cfn-serverless-function-hooks-posttraffic
     */
    readonly postTraffic?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-hooks.html#cfn-serverless-function-hooks-pretraffic
     */
    readonly preTraffic?: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-functionenvironment.html
   */
  export interface FunctionEnvironmentProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-functionenvironment.html#cfn-serverless-function-functionenvironment-variables
     */
    readonly variables: cdk.IResolvable | Record<string, string>;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventinvokeconfig.html
   */
  export interface EventInvokeConfigProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventinvokeconfig.html#cfn-serverless-function-eventinvokeconfig-destinationconfig
     */
    readonly destinationConfig?: CfnFunction.EventInvokeDestinationConfigProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventinvokeconfig.html#cfn-serverless-function-eventinvokeconfig-maximumeventageinseconds
     */
    readonly maximumEventAgeInSeconds?: number;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventinvokeconfig.html#cfn-serverless-function-eventinvokeconfig-maximumretryattempts
     */
    readonly maximumRetryAttempts?: number;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventinvokedestinationconfig.html
   */
  export interface EventInvokeDestinationConfigProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventinvokedestinationconfig.html#cfn-serverless-function-eventinvokedestinationconfig-onfailure
     */
    readonly onFailure: CfnFunction.DestinationProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventinvokedestinationconfig.html#cfn-serverless-function-eventinvokedestinationconfig-onsuccess
     */
    readonly onSuccess: CfnFunction.DestinationProperty | cdk.IResolvable;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-destination.html
   */
  export interface DestinationProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-destination.html#cfn-serverless-function-destination-destination
     */
    readonly destination: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-destination.html#cfn-serverless-function-destination-type
     */
    readonly type?: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventsource.html
   */
  export interface EventSourceProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventsource.html#cfn-serverless-function-eventsource-properties
     */
    readonly properties: CfnFunction.AlexaSkillEventProperty | CfnFunction.ApiEventProperty | CfnFunction.CloudWatchEventEventProperty | CfnFunction.CloudWatchLogsEventProperty | CfnFunction.CognitoEventProperty | CfnFunction.DynamoDBEventProperty | CfnFunction.EventBridgeRuleEventProperty | CfnFunction.HttpApiEventProperty | CfnFunction.IoTRuleEventProperty | cdk.IResolvable | CfnFunction.KinesisEventProperty | CfnFunction.S3EventProperty | CfnFunction.ScheduleEventProperty | CfnFunction.SNSEventProperty | CfnFunction.SQSEventProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventsource.html#cfn-serverless-function-eventsource-type
     */
    readonly type: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-s3event.html
   */
  export interface S3EventProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-s3event.html#cfn-serverless-function-s3event-bucket
     */
    readonly bucket: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-s3event.html#cfn-serverless-function-s3event-events
     */
    readonly events: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-s3event.html#cfn-serverless-function-s3event-filter
     */
    readonly filter?: cdk.IResolvable | CfnFunction.S3NotificationFilterProperty;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-s3notificationfilter.html
   */
  export interface S3NotificationFilterProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-s3notificationfilter.html#cfn-serverless-function-s3notificationfilter-s3key
     */
    readonly s3Key: cdk.IResolvable | CfnFunction.S3KeyFilterProperty;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-s3keyfilter.html
   */
  export interface S3KeyFilterProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-s3keyfilter.html#cfn-serverless-function-s3keyfilter-rules
     */
    readonly rules: Array<cdk.IResolvable | CfnFunction.S3KeyFilterRuleProperty> | cdk.IResolvable;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-s3keyfilterrule.html
   */
  export interface S3KeyFilterRuleProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-s3keyfilterrule.html#cfn-serverless-function-s3keyfilterrule-name
     */
    readonly name: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-s3keyfilterrule.html#cfn-serverless-function-s3keyfilterrule-value
     */
    readonly value: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-snsevent.html
   */
  export interface SNSEventProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-snsevent.html#cfn-serverless-function-snsevent-topic
     */
    readonly topic: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-sqsevent.html
   */
  export interface SQSEventProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-sqsevent.html#cfn-serverless-function-sqsevent-batchsize
     */
    readonly batchSize?: number;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-sqsevent.html#cfn-serverless-function-sqsevent-enabled
     */
    readonly enabled?: boolean | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-sqsevent.html#cfn-serverless-function-sqsevent-queue
     */
    readonly queue: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-kinesisevent.html
   */
  export interface KinesisEventProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-kinesisevent.html#cfn-serverless-function-kinesisevent-batchsize
     */
    readonly batchSize?: number;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-kinesisevent.html#cfn-serverless-function-kinesisevent-enabled
     */
    readonly enabled?: boolean | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-kinesisevent.html#cfn-serverless-function-kinesisevent-functionresponsetypes
     */
    readonly functionResponseTypes?: Array<string>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-kinesisevent.html#cfn-serverless-function-kinesisevent-startingposition
     */
    readonly startingPosition: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-kinesisevent.html#cfn-serverless-function-kinesisevent-stream
     */
    readonly stream: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-dynamodbevent.html
   */
  export interface DynamoDBEventProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-dynamodbevent.html#cfn-serverless-function-dynamodbevent-batchsize
     */
    readonly batchSize?: number;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-dynamodbevent.html#cfn-serverless-function-dynamodbevent-bisectbatchonfunctionerror
     */
    readonly bisectBatchOnFunctionError?: boolean | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-dynamodbevent.html#cfn-serverless-function-dynamodbevent-destinationconfig
     */
    readonly destinationConfig?: CfnFunction.DestinationConfigProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-dynamodbevent.html#cfn-serverless-function-dynamodbevent-enabled
     */
    readonly enabled?: boolean | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-dynamodbevent.html#cfn-serverless-function-dynamodbevent-maximumbatchingwindowinseconds
     */
    readonly maximumBatchingWindowInSeconds?: number;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-dynamodbevent.html#cfn-serverless-function-dynamodbevent-maximumrecordageinseconds
     */
    readonly maximumRecordAgeInSeconds?: number;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-dynamodbevent.html#cfn-serverless-function-dynamodbevent-maximumretryattempts
     */
    readonly maximumRetryAttempts?: number;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-dynamodbevent.html#cfn-serverless-function-dynamodbevent-parallelizationfactor
     */
    readonly parallelizationFactor?: number;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-dynamodbevent.html#cfn-serverless-function-dynamodbevent-startingposition
     */
    readonly startingPosition: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-dynamodbevent.html#cfn-serverless-function-dynamodbevent-stream
     */
    readonly stream: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-destinationconfig.html
   */
  export interface DestinationConfigProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-destinationconfig.html#cfn-serverless-function-destinationconfig-onfailure
     */
    readonly onFailure: CfnFunction.DestinationProperty | cdk.IResolvable;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-apievent.html
   */
  export interface ApiEventProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-apievent.html#cfn-serverless-function-apievent-auth
     */
    readonly auth?: CfnFunction.AuthProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-apievent.html#cfn-serverless-function-apievent-method
     */
    readonly method: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-apievent.html#cfn-serverless-function-apievent-path
     */
    readonly path: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-apievent.html#cfn-serverless-function-apievent-requestmodel
     */
    readonly requestModel?: cdk.IResolvable | CfnFunction.RequestModelProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-apievent.html#cfn-serverless-function-apievent-requestparameters
     */
    readonly requestParameters?: Array<cdk.IResolvable | CfnFunction.RequestParameterProperty | string> | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-apievent.html#cfn-serverless-function-apievent-restapiid
     */
    readonly restApiId?: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-auth.html
   */
  export interface AuthProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-auth.html#cfn-serverless-function-auth-apikeyrequired
     */
    readonly apiKeyRequired?: boolean | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-auth.html#cfn-serverless-function-auth-authorizationscopes
     */
    readonly authorizationScopes?: Array<string>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-auth.html#cfn-serverless-function-auth-authorizer
     */
    readonly authorizer?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-auth.html#cfn-serverless-function-auth-resourcepolicy
     */
    readonly resourcePolicy?: CfnFunction.AuthResourcePolicyProperty | cdk.IResolvable;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-authresourcepolicy.html
   */
  export interface AuthResourcePolicyProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-authresourcepolicy.html#cfn-serverless-function-authresourcepolicy-awsaccountblacklist
     */
    readonly awsAccountBlacklist?: Array<string>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-authresourcepolicy.html#cfn-serverless-function-authresourcepolicy-awsaccountwhitelist
     */
    readonly awsAccountWhitelist?: Array<string>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-authresourcepolicy.html#cfn-serverless-function-authresourcepolicy-customstatements
     */
    readonly customStatements?: Array<any | cdk.IResolvable> | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-authresourcepolicy.html#cfn-serverless-function-authresourcepolicy-intrinsicvpcblacklist
     */
    readonly intrinsicVpcBlacklist?: Array<string>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-authresourcepolicy.html#cfn-serverless-function-authresourcepolicy-intrinsicvpceblacklist
     */
    readonly intrinsicVpceBlacklist?: Array<string>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-authresourcepolicy.html#cfn-serverless-function-authresourcepolicy-intrinsicvpcewhitelist
     */
    readonly intrinsicVpceWhitelist?: Array<string>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-authresourcepolicy.html#cfn-serverless-function-authresourcepolicy-intrinsicvpcwhitelist
     */
    readonly intrinsicVpcWhitelist?: Array<string>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-authresourcepolicy.html#cfn-serverless-function-authresourcepolicy-iprangeblacklist
     */
    readonly ipRangeBlacklist?: Array<string>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-authresourcepolicy.html#cfn-serverless-function-authresourcepolicy-iprangewhitelist
     */
    readonly ipRangeWhitelist?: Array<string>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-authresourcepolicy.html#cfn-serverless-function-authresourcepolicy-sourcevpcblacklist
     */
    readonly sourceVpcBlacklist?: Array<string>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-authresourcepolicy.html#cfn-serverless-function-authresourcepolicy-sourcevpcwhitelist
     */
    readonly sourceVpcWhitelist?: Array<string>;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-requestmodel.html
   */
  export interface RequestModelProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-requestmodel.html#cfn-serverless-function-requestmodel-model
     */
    readonly model: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-requestmodel.html#cfn-serverless-function-requestmodel-required
     */
    readonly required?: boolean | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-requestmodel.html#cfn-serverless-function-requestmodel-validatebody
     */
    readonly validateBody?: boolean | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-requestmodel.html#cfn-serverless-function-requestmodel-validateparameters
     */
    readonly validateParameters?: boolean | cdk.IResolvable;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-requestparameter.html
   */
  export interface RequestParameterProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-requestparameter.html#cfn-serverless-function-requestparameter-caching
     */
    readonly caching?: boolean | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-requestparameter.html#cfn-serverless-function-requestparameter-required
     */
    readonly required?: boolean | cdk.IResolvable;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-scheduleevent.html
   */
  export interface ScheduleEventProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-scheduleevent.html#cfn-serverless-function-scheduleevent-description
     */
    readonly description?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-scheduleevent.html#cfn-serverless-function-scheduleevent-enabled
     */
    readonly enabled?: boolean | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-scheduleevent.html#cfn-serverless-function-scheduleevent-input
     */
    readonly input?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-scheduleevent.html#cfn-serverless-function-scheduleevent-name
     */
    readonly name?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-scheduleevent.html#cfn-serverless-function-scheduleevent-schedule
     */
    readonly schedule: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-cloudwatcheventevent.html
   */
  export interface CloudWatchEventEventProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-cloudwatcheventevent.html#cfn-serverless-function-cloudwatcheventevent-input
     */
    readonly input?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-cloudwatcheventevent.html#cfn-serverless-function-cloudwatcheventevent-inputpath
     */
    readonly inputPath?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-cloudwatcheventevent.html#cfn-serverless-function-cloudwatcheventevent-pattern
     */
    readonly pattern: any | cdk.IResolvable;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-cloudwatchlogsevent.html
   */
  export interface CloudWatchLogsEventProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-cloudwatchlogsevent.html#cfn-serverless-function-cloudwatchlogsevent-filterpattern
     */
    readonly filterPattern: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-cloudwatchlogsevent.html#cfn-serverless-function-cloudwatchlogsevent-loggroupname
     */
    readonly logGroupName: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-iotruleevent.html
   */
  export interface IoTRuleEventProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-iotruleevent.html#cfn-serverless-function-iotruleevent-awsiotsqlversion
     */
    readonly awsIotSqlVersion?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-iotruleevent.html#cfn-serverless-function-iotruleevent-sql
     */
    readonly sql: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-alexaskillevent.html
   */
  export interface AlexaSkillEventProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-alexaskillevent.html#cfn-serverless-function-alexaskillevent-variables
     */
    readonly variables?: cdk.IResolvable | Record<string, string>;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventbridgeruleevent.html
   */
  export interface EventBridgeRuleEventProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventbridgeruleevent.html#cfn-serverless-function-eventbridgeruleevent-eventbusname
     */
    readonly eventBusName?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventbridgeruleevent.html#cfn-serverless-function-eventbridgeruleevent-input
     */
    readonly input?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventbridgeruleevent.html#cfn-serverless-function-eventbridgeruleevent-inputpath
     */
    readonly inputPath?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventbridgeruleevent.html#cfn-serverless-function-eventbridgeruleevent-pattern
     */
    readonly pattern: any | cdk.IResolvable;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-httpapievent.html
   */
  export interface HttpApiEventProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-httpapievent.html#cfn-serverless-function-httpapievent-apiid
     */
    readonly apiId?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-httpapievent.html#cfn-serverless-function-httpapievent-auth
     */
    readonly auth?: CfnFunction.HttpApiFunctionAuthProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-httpapievent.html#cfn-serverless-function-httpapievent-method
     */
    readonly method?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-httpapievent.html#cfn-serverless-function-httpapievent-path
     */
    readonly path?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-httpapievent.html#cfn-serverless-function-httpapievent-payloadformatversion
     */
    readonly payloadFormatVersion?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-httpapievent.html#cfn-serverless-function-httpapievent-routesettings
     */
    readonly routeSettings?: cdk.IResolvable | CfnFunction.RouteSettingsProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-httpapievent.html#cfn-serverless-function-httpapievent-timeoutinmillis
     */
    readonly timeoutInMillis?: number;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-httpapifunctionauth.html
   */
  export interface HttpApiFunctionAuthProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-httpapifunctionauth.html#cfn-serverless-function-httpapifunctionauth-authorizationscopes
     */
    readonly authorizationScopes?: Array<string>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-httpapifunctionauth.html#cfn-serverless-function-httpapifunctionauth-authorizer
     */
    readonly authorizer?: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-routesettings.html
   */
  export interface RouteSettingsProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-routesettings.html#cfn-serverless-function-routesettings-datatraceenabled
     */
    readonly dataTraceEnabled?: boolean | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-routesettings.html#cfn-serverless-function-routesettings-detailedmetricsenabled
     */
    readonly detailedMetricsEnabled?: boolean | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-routesettings.html#cfn-serverless-function-routesettings-logginglevel
     */
    readonly loggingLevel?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-routesettings.html#cfn-serverless-function-routesettings-throttlingburstlimit
     */
    readonly throttlingBurstLimit?: number;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-routesettings.html#cfn-serverless-function-routesettings-throttlingratelimit
     */
    readonly throttlingRateLimit?: number;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-cognitoevent.html
   */
  export interface CognitoEventProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-cognitoevent.html#cfn-serverless-function-cognitoevent-trigger
     */
    readonly trigger: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-cognitoevent.html#cfn-serverless-function-cognitoevent-userpool
     */
    readonly userPool: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-filesystemconfig.html
   */
  export interface FileSystemConfigProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-filesystemconfig.html#cfn-serverless-function-filesystemconfig-arn
     */
    readonly arn?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-filesystemconfig.html#cfn-serverless-function-filesystemconfig-localmountpath
     */
    readonly localMountPath?: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-imageconfig.html
   */
  export interface ImageConfigProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-imageconfig.html#cfn-serverless-function-imageconfig-command
     */
    readonly command?: Array<string>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-imageconfig.html#cfn-serverless-function-imageconfig-entrypoint
     */
    readonly entryPoint?: Array<string>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-imageconfig.html#cfn-serverless-function-imageconfig-workingdirectory
     */
    readonly workingDirectory?: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-iampolicydocument.html
   */
  export interface IAMPolicyDocumentProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-iampolicydocument.html#cfn-serverless-function-iampolicydocument-statement
     */
    readonly statement: any | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-iampolicydocument.html#cfn-serverless-function-iampolicydocument-version
     */
    readonly version?: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-sampolicytemplate.html
   */
  export interface SAMPolicyTemplateProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-sampolicytemplate.html#cfn-serverless-function-sampolicytemplate-amidescribepolicy
     */
    readonly amiDescribePolicy?: CfnFunction.EmptySAMPTProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-sampolicytemplate.html#cfn-serverless-function-sampolicytemplate-awssecretsmanagergetsecretvaluepolicy
     */
    readonly awsSecretsManagerGetSecretValuePolicy?: cdk.IResolvable | CfnFunction.SecretArnSAMPTProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-sampolicytemplate.html#cfn-serverless-function-sampolicytemplate-cloudformationdescribestackspolicy
     */
    readonly cloudFormationDescribeStacksPolicy?: CfnFunction.EmptySAMPTProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-sampolicytemplate.html#cfn-serverless-function-sampolicytemplate-cloudwatchputmetricpolicy
     */
    readonly cloudWatchPutMetricPolicy?: CfnFunction.EmptySAMPTProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-sampolicytemplate.html#cfn-serverless-function-sampolicytemplate-dynamodbcrudpolicy
     */
    readonly dynamoDbCrudPolicy?: cdk.IResolvable | CfnFunction.TableSAMPTProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-sampolicytemplate.html#cfn-serverless-function-sampolicytemplate-dynamodbreadpolicy
     */
    readonly dynamoDbReadPolicy?: cdk.IResolvable | CfnFunction.TableSAMPTProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-sampolicytemplate.html#cfn-serverless-function-sampolicytemplate-dynamodbstreamreadpolicy
     */
    readonly dynamoDbStreamReadPolicy?: cdk.IResolvable | CfnFunction.TableStreamSAMPTProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-sampolicytemplate.html#cfn-serverless-function-sampolicytemplate-dynamodbwritepolicy
     */
    readonly dynamoDbWritePolicy?: cdk.IResolvable | CfnFunction.TableSAMPTProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-sampolicytemplate.html#cfn-serverless-function-sampolicytemplate-ec2describepolicy
     */
    readonly ec2DescribePolicy?: CfnFunction.EmptySAMPTProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-sampolicytemplate.html#cfn-serverless-function-sampolicytemplate-elasticsearchhttppostpolicy
     */
    readonly elasticsearchHttpPostPolicy?: CfnFunction.DomainSAMPTProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-sampolicytemplate.html#cfn-serverless-function-sampolicytemplate-filterlogeventspolicy
     */
    readonly filterLogEventsPolicy?: cdk.IResolvable | CfnFunction.LogGroupSAMPTProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-sampolicytemplate.html#cfn-serverless-function-sampolicytemplate-kinesiscrudpolicy
     */
    readonly kinesisCrudPolicy?: cdk.IResolvable | CfnFunction.StreamSAMPTProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-sampolicytemplate.html#cfn-serverless-function-sampolicytemplate-kinesisstreamreadpolicy
     */
    readonly kinesisStreamReadPolicy?: cdk.IResolvable | CfnFunction.StreamSAMPTProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-sampolicytemplate.html#cfn-serverless-function-sampolicytemplate-kmsdecryptpolicy
     */
    readonly kmsDecryptPolicy?: cdk.IResolvable | CfnFunction.KeySAMPTProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-sampolicytemplate.html#cfn-serverless-function-sampolicytemplate-lambdainvokepolicy
     */
    readonly lambdaInvokePolicy?: CfnFunction.FunctionSAMPTProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-sampolicytemplate.html#cfn-serverless-function-sampolicytemplate-rekognitiondetectonlypolicy
     */
    readonly rekognitionDetectOnlyPolicy?: CfnFunction.EmptySAMPTProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-sampolicytemplate.html#cfn-serverless-function-sampolicytemplate-rekognitionlabelspolicy
     */
    readonly rekognitionLabelsPolicy?: CfnFunction.EmptySAMPTProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-sampolicytemplate.html#cfn-serverless-function-sampolicytemplate-rekognitionnodataaccesspolicy
     */
    readonly rekognitionNoDataAccessPolicy?: CfnFunction.CollectionSAMPTProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-sampolicytemplate.html#cfn-serverless-function-sampolicytemplate-rekognitionreadpolicy
     */
    readonly rekognitionReadPolicy?: CfnFunction.CollectionSAMPTProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-sampolicytemplate.html#cfn-serverless-function-sampolicytemplate-rekognitionwriteonlyaccesspolicy
     */
    readonly rekognitionWriteOnlyAccessPolicy?: CfnFunction.CollectionSAMPTProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-sampolicytemplate.html#cfn-serverless-function-sampolicytemplate-s3crudpolicy
     */
    readonly s3CrudPolicy?: CfnFunction.BucketSAMPTProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-sampolicytemplate.html#cfn-serverless-function-sampolicytemplate-s3readpolicy
     */
    readonly s3ReadPolicy?: CfnFunction.BucketSAMPTProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-sampolicytemplate.html#cfn-serverless-function-sampolicytemplate-s3writepolicy
     */
    readonly s3WritePolicy?: CfnFunction.BucketSAMPTProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-sampolicytemplate.html#cfn-serverless-function-sampolicytemplate-sesbulktemplatedcrudpolicy
     */
    readonly sesBulkTemplatedCrudPolicy?: CfnFunction.IdentitySAMPTProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-sampolicytemplate.html#cfn-serverless-function-sampolicytemplate-sescrudpolicy
     */
    readonly sesCrudPolicy?: CfnFunction.IdentitySAMPTProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-sampolicytemplate.html#cfn-serverless-function-sampolicytemplate-sesemailtemplatecrudpolicy
     */
    readonly sesEmailTemplateCrudPolicy?: CfnFunction.EmptySAMPTProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-sampolicytemplate.html#cfn-serverless-function-sampolicytemplate-sessendbouncepolicy
     */
    readonly sesSendBouncePolicy?: CfnFunction.IdentitySAMPTProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-sampolicytemplate.html#cfn-serverless-function-sampolicytemplate-snscrudpolicy
     */
    readonly snsCrudPolicy?: cdk.IResolvable | CfnFunction.TopicSAMPTProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-sampolicytemplate.html#cfn-serverless-function-sampolicytemplate-snspublishmessagepolicy
     */
    readonly snsPublishMessagePolicy?: cdk.IResolvable | CfnFunction.TopicSAMPTProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-sampolicytemplate.html#cfn-serverless-function-sampolicytemplate-sqspollerpolicy
     */
    readonly sqsPollerPolicy?: cdk.IResolvable | CfnFunction.QueueSAMPTProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-sampolicytemplate.html#cfn-serverless-function-sampolicytemplate-sqssendmessagepolicy
     */
    readonly sqsSendMessagePolicy?: cdk.IResolvable | CfnFunction.QueueSAMPTProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-sampolicytemplate.html#cfn-serverless-function-sampolicytemplate-ssmparameterreadpolicy
     */
    readonly ssmParameterReadPolicy?: cdk.IResolvable | CfnFunction.ParameterNameSAMPTProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-sampolicytemplate.html#cfn-serverless-function-sampolicytemplate-stepfunctionsexecutionpolicy
     */
    readonly stepFunctionsExecutionPolicy?: cdk.IResolvable | CfnFunction.StateMachineSAMPTProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-sampolicytemplate.html#cfn-serverless-function-sampolicytemplate-vpcaccesspolicy
     */
    readonly vpcAccessPolicy?: CfnFunction.EmptySAMPTProperty | cdk.IResolvable;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-emptysampt.html
   */
  export interface EmptySAMPTProperty {

  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-secretarnsampt.html
   */
  export interface SecretArnSAMPTProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-secretarnsampt.html#cfn-serverless-function-secretarnsampt-secretarn
     */
    readonly secretArn: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-tablesampt.html
   */
  export interface TableSAMPTProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-tablesampt.html#cfn-serverless-function-tablesampt-tablename
     */
    readonly tableName: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-tablestreamsampt.html
   */
  export interface TableStreamSAMPTProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-tablestreamsampt.html#cfn-serverless-function-tablestreamsampt-streamname
     */
    readonly streamName: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-tablestreamsampt.html#cfn-serverless-function-tablestreamsampt-tablename
     */
    readonly tableName: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-domainsampt.html
   */
  export interface DomainSAMPTProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-domainsampt.html#cfn-serverless-function-domainsampt-domainname
     */
    readonly domainName: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-loggroupsampt.html
   */
  export interface LogGroupSAMPTProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-loggroupsampt.html#cfn-serverless-function-loggroupsampt-loggroupname
     */
    readonly logGroupName: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-keysampt.html
   */
  export interface KeySAMPTProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-keysampt.html#cfn-serverless-function-keysampt-keyid
     */
    readonly keyId: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-streamsampt.html
   */
  export interface StreamSAMPTProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-streamsampt.html#cfn-serverless-function-streamsampt-streamname
     */
    readonly streamName: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-functionsampt.html
   */
  export interface FunctionSAMPTProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-functionsampt.html#cfn-serverless-function-functionsampt-functionname
     */
    readonly functionName: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-collectionsampt.html
   */
  export interface CollectionSAMPTProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-collectionsampt.html#cfn-serverless-function-collectionsampt-collectionid
     */
    readonly collectionId: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-bucketsampt.html
   */
  export interface BucketSAMPTProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-bucketsampt.html#cfn-serverless-function-bucketsampt-bucketname
     */
    readonly bucketName: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-identitysampt.html
   */
  export interface IdentitySAMPTProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-identitysampt.html#cfn-serverless-function-identitysampt-identityname
     */
    readonly identityName: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-topicsampt.html
   */
  export interface TopicSAMPTProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-topicsampt.html#cfn-serverless-function-topicsampt-topicname
     */
    readonly topicName: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-queuesampt.html
   */
  export interface QueueSAMPTProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-queuesampt.html#cfn-serverless-function-queuesampt-queuename
     */
    readonly queueName: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-parameternamesampt.html
   */
  export interface ParameterNameSAMPTProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-parameternamesampt.html#cfn-serverless-function-parameternamesampt-parametername
     */
    readonly parameterName: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-statemachinesampt.html
   */
  export interface StateMachineSAMPTProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-statemachinesampt.html#cfn-serverless-function-statemachinesampt-statemachinename
     */
    readonly stateMachineName: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-provisionedconcurrencyconfig.html
   */
  export interface ProvisionedConcurrencyConfigProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-provisionedconcurrencyconfig.html#cfn-serverless-function-provisionedconcurrencyconfig-provisionedconcurrentexecutions
     */
    readonly provisionedConcurrentExecutions: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-vpcconfig.html
   */
  export interface VpcConfigProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-vpcconfig.html#cfn-serverless-function-vpcconfig-securitygroupids
     */
    readonly securityGroupIds: Array<string>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-vpcconfig.html#cfn-serverless-function-vpcconfig-subnetids
     */
    readonly subnetIds: Array<string>;
  }
}

/**
 * Properties for defining a \`CfnFunction\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html
 */
export interface CfnFunctionProps {
  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-architectures
   */
  readonly architectures?: Array<string>;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-assumerolepolicydocument
   */
  readonly assumeRolePolicyDocument?: any | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-autopublishalias
   */
  readonly autoPublishAlias?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-autopublishcodesha256
   */
  readonly autoPublishCodeSha256?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-codesigningconfigarn
   */
  readonly codeSigningConfigArn?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-codeuri
   */
  readonly codeUri?: cdk.IResolvable | CfnFunction.S3LocationProperty | string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-deadletterqueue
   */
  readonly deadLetterQueue?: CfnFunction.DeadLetterQueueProperty | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-deploymentpreference
   */
  readonly deploymentPreference?: CfnFunction.DeploymentPreferenceProperty | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-description
   */
  readonly description?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-environment
   */
  readonly environment?: CfnFunction.FunctionEnvironmentProperty | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-eventinvokeconfig
   */
  readonly eventInvokeConfig?: CfnFunction.EventInvokeConfigProperty | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-events
   */
  readonly events?: cdk.IResolvable | Record<string, CfnFunction.EventSourceProperty | cdk.IResolvable>;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-filesystemconfigs
   */
  readonly fileSystemConfigs?: Array<CfnFunction.FileSystemConfigProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-functionname
   */
  readonly functionName?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-handler
   */
  readonly handler?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-imageconfig
   */
  readonly imageConfig?: CfnFunction.ImageConfigProperty | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-imageuri
   */
  readonly imageUri?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-inlinecode
   */
  readonly inlineCode?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-kmskeyarn
   */
  readonly kmsKeyArn?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-layers
   */
  readonly layers?: Array<string>;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-memorysize
   */
  readonly memorySize?: number;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-packagetype
   */
  readonly packageType?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-permissionsboundary
   */
  readonly permissionsBoundary?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-policies
   */
  readonly policies?: Array<CfnFunction.IAMPolicyDocumentProperty | cdk.IResolvable | CfnFunction.SAMPolicyTemplateProperty | string> | CfnFunction.IAMPolicyDocumentProperty | cdk.IResolvable | string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-provisionedconcurrencyconfig
   */
  readonly provisionedConcurrencyConfig?: cdk.IResolvable | CfnFunction.ProvisionedConcurrencyConfigProperty;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-reservedconcurrentexecutions
   */
  readonly reservedConcurrentExecutions?: number;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-role
   */
  readonly role?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-runtime
   */
  readonly runtime?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-tags
   */
  readonly tags?: Record<string, string>;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-timeout
   */
  readonly timeout?: number;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-tracing
   */
  readonly tracing?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-versiondescription
   */
  readonly versionDescription?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-vpcconfig
   */
  readonly vpcConfig?: cdk.IResolvable | CfnFunction.VpcConfigProperty;
}

/**
 * Determine whether the given properties match those of a \`S3LocationProperty\`
 *
 * @param properties - the TypeScript properties of a \`S3LocationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionS3LocationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("bucket", cdk.requiredValidator)(properties.bucket));
  errors.collect(cdk.propertyValidator("bucket", cdk.validateString)(properties.bucket));
  errors.collect(cdk.propertyValidator("key", cdk.requiredValidator)(properties.key));
  errors.collect(cdk.propertyValidator("key", cdk.validateString)(properties.key));
  errors.collect(cdk.propertyValidator("version", cdk.validateNumber)(properties.version));
  return errors.wrap("supplied properties not correct for \\"S3LocationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionS3LocationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionS3LocationPropertyValidator(properties).assertSuccess();
  return {
    "Bucket": cdk.stringToCloudFormation(properties.bucket),
    "Key": cdk.stringToCloudFormation(properties.key),
    "Version": cdk.numberToCloudFormation(properties.version)
  };
}

// @ts-ignore TS6133
function CfnFunctionS3LocationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnFunction.S3LocationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.S3LocationProperty>();
  ret.addPropertyResult("bucket", "Bucket", (properties.Bucket != null ? cfn_parse.FromCloudFormation.getString(properties.Bucket) : undefined));
  ret.addPropertyResult("key", "Key", (properties.Key != null ? cfn_parse.FromCloudFormation.getString(properties.Key) : undefined));
  ret.addPropertyResult("version", "Version", (properties.Version != null ? cfn_parse.FromCloudFormation.getNumber(properties.Version) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`DeadLetterQueueProperty\`
 *
 * @param properties - the TypeScript properties of a \`DeadLetterQueueProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionDeadLetterQueuePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("targetArn", cdk.requiredValidator)(properties.targetArn));
  errors.collect(cdk.propertyValidator("targetArn", cdk.validateString)(properties.targetArn));
  errors.collect(cdk.propertyValidator("type", cdk.requiredValidator)(properties.type));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  return errors.wrap("supplied properties not correct for \\"DeadLetterQueueProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionDeadLetterQueuePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionDeadLetterQueuePropertyValidator(properties).assertSuccess();
  return {
    "TargetArn": cdk.stringToCloudFormation(properties.targetArn),
    "Type": cdk.stringToCloudFormation(properties.type)
  };
}

// @ts-ignore TS6133
function CfnFunctionDeadLetterQueuePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnFunction.DeadLetterQueueProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.DeadLetterQueueProperty>();
  ret.addPropertyResult("targetArn", "TargetArn", (properties.TargetArn != null ? cfn_parse.FromCloudFormation.getString(properties.TargetArn) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`HooksProperty\`
 *
 * @param properties - the TypeScript properties of a \`HooksProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionHooksPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("postTraffic", cdk.validateString)(properties.postTraffic));
  errors.collect(cdk.propertyValidator("preTraffic", cdk.validateString)(properties.preTraffic));
  return errors.wrap("supplied properties not correct for \\"HooksProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionHooksPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionHooksPropertyValidator(properties).assertSuccess();
  return {
    "PostTraffic": cdk.stringToCloudFormation(properties.postTraffic),
    "PreTraffic": cdk.stringToCloudFormation(properties.preTraffic)
  };
}

// @ts-ignore TS6133
function CfnFunctionHooksPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnFunction.HooksProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.HooksProperty>();
  ret.addPropertyResult("postTraffic", "PostTraffic", (properties.PostTraffic != null ? cfn_parse.FromCloudFormation.getString(properties.PostTraffic) : undefined));
  ret.addPropertyResult("preTraffic", "PreTraffic", (properties.PreTraffic != null ? cfn_parse.FromCloudFormation.getString(properties.PreTraffic) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`DeploymentPreferenceProperty\`
 *
 * @param properties - the TypeScript properties of a \`DeploymentPreferenceProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionDeploymentPreferencePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("alarms", cdk.listValidator(cdk.validateString))(properties.alarms));
  errors.collect(cdk.propertyValidator("enabled", cdk.validateBoolean)(properties.enabled));
  errors.collect(cdk.propertyValidator("hooks", CfnFunctionHooksPropertyValidator)(properties.hooks));
  errors.collect(cdk.propertyValidator("role", cdk.validateString)(properties.role));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  return errors.wrap("supplied properties not correct for \\"DeploymentPreferenceProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionDeploymentPreferencePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionDeploymentPreferencePropertyValidator(properties).assertSuccess();
  return {
    "Alarms": cdk.listMapper(cdk.stringToCloudFormation)(properties.alarms),
    "Enabled": cdk.booleanToCloudFormation(properties.enabled),
    "Hooks": convertCfnFunctionHooksPropertyToCloudFormation(properties.hooks),
    "Role": cdk.stringToCloudFormation(properties.role),
    "Type": cdk.stringToCloudFormation(properties.type)
  };
}

// @ts-ignore TS6133
function CfnFunctionDeploymentPreferencePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnFunction.DeploymentPreferenceProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.DeploymentPreferenceProperty>();
  ret.addPropertyResult("alarms", "Alarms", (properties.Alarms != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.Alarms) : undefined));
  ret.addPropertyResult("enabled", "Enabled", (properties.Enabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Enabled) : undefined));
  ret.addPropertyResult("hooks", "Hooks", (properties.Hooks != null ? CfnFunctionHooksPropertyFromCloudFormation(properties.Hooks) : undefined));
  ret.addPropertyResult("role", "Role", (properties.Role != null ? cfn_parse.FromCloudFormation.getString(properties.Role) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`FunctionEnvironmentProperty\`
 *
 * @param properties - the TypeScript properties of a \`FunctionEnvironmentProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionFunctionEnvironmentPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("variables", cdk.requiredValidator)(properties.variables));
  errors.collect(cdk.propertyValidator("variables", cdk.hashValidator(cdk.validateString))(properties.variables));
  return errors.wrap("supplied properties not correct for \\"FunctionEnvironmentProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionFunctionEnvironmentPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionFunctionEnvironmentPropertyValidator(properties).assertSuccess();
  return {
    "Variables": cdk.hashMapper(cdk.stringToCloudFormation)(properties.variables)
  };
}

// @ts-ignore TS6133
function CfnFunctionFunctionEnvironmentPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnFunction.FunctionEnvironmentProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.FunctionEnvironmentProperty>();
  ret.addPropertyResult("variables", "Variables", (properties.Variables != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getString)(properties.Variables) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`DestinationProperty\`
 *
 * @param properties - the TypeScript properties of a \`DestinationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionDestinationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("destination", cdk.requiredValidator)(properties.destination));
  errors.collect(cdk.propertyValidator("destination", cdk.validateString)(properties.destination));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  return errors.wrap("supplied properties not correct for \\"DestinationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionDestinationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionDestinationPropertyValidator(properties).assertSuccess();
  return {
    "Destination": cdk.stringToCloudFormation(properties.destination),
    "Type": cdk.stringToCloudFormation(properties.type)
  };
}

// @ts-ignore TS6133
function CfnFunctionDestinationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnFunction.DestinationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.DestinationProperty>();
  ret.addPropertyResult("destination", "Destination", (properties.Destination != null ? cfn_parse.FromCloudFormation.getString(properties.Destination) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`EventInvokeDestinationConfigProperty\`
 *
 * @param properties - the TypeScript properties of a \`EventInvokeDestinationConfigProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionEventInvokeDestinationConfigPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("onFailure", cdk.requiredValidator)(properties.onFailure));
  errors.collect(cdk.propertyValidator("onFailure", CfnFunctionDestinationPropertyValidator)(properties.onFailure));
  errors.collect(cdk.propertyValidator("onSuccess", cdk.requiredValidator)(properties.onSuccess));
  errors.collect(cdk.propertyValidator("onSuccess", CfnFunctionDestinationPropertyValidator)(properties.onSuccess));
  return errors.wrap("supplied properties not correct for \\"EventInvokeDestinationConfigProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionEventInvokeDestinationConfigPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionEventInvokeDestinationConfigPropertyValidator(properties).assertSuccess();
  return {
    "OnFailure": convertCfnFunctionDestinationPropertyToCloudFormation(properties.onFailure),
    "OnSuccess": convertCfnFunctionDestinationPropertyToCloudFormation(properties.onSuccess)
  };
}

// @ts-ignore TS6133
function CfnFunctionEventInvokeDestinationConfigPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnFunction.EventInvokeDestinationConfigProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.EventInvokeDestinationConfigProperty>();
  ret.addPropertyResult("onFailure", "OnFailure", (properties.OnFailure != null ? CfnFunctionDestinationPropertyFromCloudFormation(properties.OnFailure) : undefined));
  ret.addPropertyResult("onSuccess", "OnSuccess", (properties.OnSuccess != null ? CfnFunctionDestinationPropertyFromCloudFormation(properties.OnSuccess) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`EventInvokeConfigProperty\`
 *
 * @param properties - the TypeScript properties of a \`EventInvokeConfigProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionEventInvokeConfigPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("destinationConfig", CfnFunctionEventInvokeDestinationConfigPropertyValidator)(properties.destinationConfig));
  errors.collect(cdk.propertyValidator("maximumEventAgeInSeconds", cdk.validateNumber)(properties.maximumEventAgeInSeconds));
  errors.collect(cdk.propertyValidator("maximumRetryAttempts", cdk.validateNumber)(properties.maximumRetryAttempts));
  return errors.wrap("supplied properties not correct for \\"EventInvokeConfigProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionEventInvokeConfigPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionEventInvokeConfigPropertyValidator(properties).assertSuccess();
  return {
    "DestinationConfig": convertCfnFunctionEventInvokeDestinationConfigPropertyToCloudFormation(properties.destinationConfig),
    "MaximumEventAgeInSeconds": cdk.numberToCloudFormation(properties.maximumEventAgeInSeconds),
    "MaximumRetryAttempts": cdk.numberToCloudFormation(properties.maximumRetryAttempts)
  };
}

// @ts-ignore TS6133
function CfnFunctionEventInvokeConfigPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnFunction.EventInvokeConfigProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.EventInvokeConfigProperty>();
  ret.addPropertyResult("destinationConfig", "DestinationConfig", (properties.DestinationConfig != null ? CfnFunctionEventInvokeDestinationConfigPropertyFromCloudFormation(properties.DestinationConfig) : undefined));
  ret.addPropertyResult("maximumEventAgeInSeconds", "MaximumEventAgeInSeconds", (properties.MaximumEventAgeInSeconds != null ? cfn_parse.FromCloudFormation.getNumber(properties.MaximumEventAgeInSeconds) : undefined));
  ret.addPropertyResult("maximumRetryAttempts", "MaximumRetryAttempts", (properties.MaximumRetryAttempts != null ? cfn_parse.FromCloudFormation.getNumber(properties.MaximumRetryAttempts) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`S3KeyFilterRuleProperty\`
 *
 * @param properties - the TypeScript properties of a \`S3KeyFilterRuleProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionS3KeyFilterRulePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("name", cdk.requiredValidator)(properties.name));
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  errors.collect(cdk.propertyValidator("value", cdk.requiredValidator)(properties.value));
  errors.collect(cdk.propertyValidator("value", cdk.validateString)(properties.value));
  return errors.wrap("supplied properties not correct for \\"S3KeyFilterRuleProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionS3KeyFilterRulePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionS3KeyFilterRulePropertyValidator(properties).assertSuccess();
  return {
    "Name": cdk.stringToCloudFormation(properties.name),
    "Value": cdk.stringToCloudFormation(properties.value)
  };
}

// @ts-ignore TS6133
function CfnFunctionS3KeyFilterRulePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnFunction.S3KeyFilterRuleProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.S3KeyFilterRuleProperty>();
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addPropertyResult("value", "Value", (properties.Value != null ? cfn_parse.FromCloudFormation.getString(properties.Value) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`S3KeyFilterProperty\`
 *
 * @param properties - the TypeScript properties of a \`S3KeyFilterProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionS3KeyFilterPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("rules", cdk.requiredValidator)(properties.rules));
  errors.collect(cdk.propertyValidator("rules", cdk.listValidator(CfnFunctionS3KeyFilterRulePropertyValidator))(properties.rules));
  return errors.wrap("supplied properties not correct for \\"S3KeyFilterProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionS3KeyFilterPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionS3KeyFilterPropertyValidator(properties).assertSuccess();
  return {
    "Rules": cdk.listMapper(convertCfnFunctionS3KeyFilterRulePropertyToCloudFormation)(properties.rules)
  };
}

// @ts-ignore TS6133
function CfnFunctionS3KeyFilterPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnFunction.S3KeyFilterProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.S3KeyFilterProperty>();
  ret.addPropertyResult("rules", "Rules", (properties.Rules != null ? cfn_parse.FromCloudFormation.getArray(CfnFunctionS3KeyFilterRulePropertyFromCloudFormation)(properties.Rules) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`S3NotificationFilterProperty\`
 *
 * @param properties - the TypeScript properties of a \`S3NotificationFilterProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionS3NotificationFilterPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("s3Key", cdk.requiredValidator)(properties.s3Key));
  errors.collect(cdk.propertyValidator("s3Key", CfnFunctionS3KeyFilterPropertyValidator)(properties.s3Key));
  return errors.wrap("supplied properties not correct for \\"S3NotificationFilterProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionS3NotificationFilterPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionS3NotificationFilterPropertyValidator(properties).assertSuccess();
  return {
    "S3Key": convertCfnFunctionS3KeyFilterPropertyToCloudFormation(properties.s3Key)
  };
}

// @ts-ignore TS6133
function CfnFunctionS3NotificationFilterPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnFunction.S3NotificationFilterProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.S3NotificationFilterProperty>();
  ret.addPropertyResult("s3Key", "S3Key", (properties.S3Key != null ? CfnFunctionS3KeyFilterPropertyFromCloudFormation(properties.S3Key) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`S3EventProperty\`
 *
 * @param properties - the TypeScript properties of a \`S3EventProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionS3EventPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("bucket", cdk.requiredValidator)(properties.bucket));
  errors.collect(cdk.propertyValidator("bucket", cdk.validateString)(properties.bucket));
  errors.collect(cdk.propertyValidator("events", cdk.requiredValidator)(properties.events));
  errors.collect(cdk.propertyValidator("events", cdk.validateString)(properties.events));
  errors.collect(cdk.propertyValidator("filter", CfnFunctionS3NotificationFilterPropertyValidator)(properties.filter));
  return errors.wrap("supplied properties not correct for \\"S3EventProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionS3EventPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionS3EventPropertyValidator(properties).assertSuccess();
  return {
    "Bucket": cdk.stringToCloudFormation(properties.bucket),
    "Events": cdk.stringToCloudFormation(properties.events),
    "Filter": convertCfnFunctionS3NotificationFilterPropertyToCloudFormation(properties.filter)
  };
}

// @ts-ignore TS6133
function CfnFunctionS3EventPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnFunction.S3EventProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.S3EventProperty>();
  ret.addPropertyResult("bucket", "Bucket", (properties.Bucket != null ? cfn_parse.FromCloudFormation.getString(properties.Bucket) : undefined));
  ret.addPropertyResult("events", "Events", (properties.Events != null ? cfn_parse.FromCloudFormation.getString(properties.Events) : undefined));
  ret.addPropertyResult("filter", "Filter", (properties.Filter != null ? CfnFunctionS3NotificationFilterPropertyFromCloudFormation(properties.Filter) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`SNSEventProperty\`
 *
 * @param properties - the TypeScript properties of a \`SNSEventProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionSNSEventPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("topic", cdk.requiredValidator)(properties.topic));
  errors.collect(cdk.propertyValidator("topic", cdk.validateString)(properties.topic));
  return errors.wrap("supplied properties not correct for \\"SNSEventProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionSNSEventPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionSNSEventPropertyValidator(properties).assertSuccess();
  return {
    "Topic": cdk.stringToCloudFormation(properties.topic)
  };
}

// @ts-ignore TS6133
function CfnFunctionSNSEventPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnFunction.SNSEventProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.SNSEventProperty>();
  ret.addPropertyResult("topic", "Topic", (properties.Topic != null ? cfn_parse.FromCloudFormation.getString(properties.Topic) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`SQSEventProperty\`
 *
 * @param properties - the TypeScript properties of a \`SQSEventProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionSQSEventPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("batchSize", cdk.validateNumber)(properties.batchSize));
  errors.collect(cdk.propertyValidator("enabled", cdk.validateBoolean)(properties.enabled));
  errors.collect(cdk.propertyValidator("queue", cdk.requiredValidator)(properties.queue));
  errors.collect(cdk.propertyValidator("queue", cdk.validateString)(properties.queue));
  return errors.wrap("supplied properties not correct for \\"SQSEventProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionSQSEventPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionSQSEventPropertyValidator(properties).assertSuccess();
  return {
    "BatchSize": cdk.numberToCloudFormation(properties.batchSize),
    "Enabled": cdk.booleanToCloudFormation(properties.enabled),
    "Queue": cdk.stringToCloudFormation(properties.queue)
  };
}

// @ts-ignore TS6133
function CfnFunctionSQSEventPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnFunction.SQSEventProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.SQSEventProperty>();
  ret.addPropertyResult("batchSize", "BatchSize", (properties.BatchSize != null ? cfn_parse.FromCloudFormation.getNumber(properties.BatchSize) : undefined));
  ret.addPropertyResult("enabled", "Enabled", (properties.Enabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Enabled) : undefined));
  ret.addPropertyResult("queue", "Queue", (properties.Queue != null ? cfn_parse.FromCloudFormation.getString(properties.Queue) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`KinesisEventProperty\`
 *
 * @param properties - the TypeScript properties of a \`KinesisEventProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionKinesisEventPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("batchSize", cdk.validateNumber)(properties.batchSize));
  errors.collect(cdk.propertyValidator("enabled", cdk.validateBoolean)(properties.enabled));
  errors.collect(cdk.propertyValidator("functionResponseTypes", cdk.listValidator(cdk.validateString))(properties.functionResponseTypes));
  errors.collect(cdk.propertyValidator("startingPosition", cdk.requiredValidator)(properties.startingPosition));
  errors.collect(cdk.propertyValidator("startingPosition", cdk.validateString)(properties.startingPosition));
  errors.collect(cdk.propertyValidator("stream", cdk.requiredValidator)(properties.stream));
  errors.collect(cdk.propertyValidator("stream", cdk.validateString)(properties.stream));
  return errors.wrap("supplied properties not correct for \\"KinesisEventProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionKinesisEventPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionKinesisEventPropertyValidator(properties).assertSuccess();
  return {
    "BatchSize": cdk.numberToCloudFormation(properties.batchSize),
    "Enabled": cdk.booleanToCloudFormation(properties.enabled),
    "FunctionResponseTypes": cdk.listMapper(cdk.stringToCloudFormation)(properties.functionResponseTypes),
    "StartingPosition": cdk.stringToCloudFormation(properties.startingPosition),
    "Stream": cdk.stringToCloudFormation(properties.stream)
  };
}

// @ts-ignore TS6133
function CfnFunctionKinesisEventPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnFunction.KinesisEventProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.KinesisEventProperty>();
  ret.addPropertyResult("batchSize", "BatchSize", (properties.BatchSize != null ? cfn_parse.FromCloudFormation.getNumber(properties.BatchSize) : undefined));
  ret.addPropertyResult("enabled", "Enabled", (properties.Enabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Enabled) : undefined));
  ret.addPropertyResult("functionResponseTypes", "FunctionResponseTypes", (properties.FunctionResponseTypes != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.FunctionResponseTypes) : undefined));
  ret.addPropertyResult("startingPosition", "StartingPosition", (properties.StartingPosition != null ? cfn_parse.FromCloudFormation.getString(properties.StartingPosition) : undefined));
  ret.addPropertyResult("stream", "Stream", (properties.Stream != null ? cfn_parse.FromCloudFormation.getString(properties.Stream) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`DestinationConfigProperty\`
 *
 * @param properties - the TypeScript properties of a \`DestinationConfigProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionDestinationConfigPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("onFailure", cdk.requiredValidator)(properties.onFailure));
  errors.collect(cdk.propertyValidator("onFailure", CfnFunctionDestinationPropertyValidator)(properties.onFailure));
  return errors.wrap("supplied properties not correct for \\"DestinationConfigProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionDestinationConfigPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionDestinationConfigPropertyValidator(properties).assertSuccess();
  return {
    "OnFailure": convertCfnFunctionDestinationPropertyToCloudFormation(properties.onFailure)
  };
}

// @ts-ignore TS6133
function CfnFunctionDestinationConfigPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnFunction.DestinationConfigProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.DestinationConfigProperty>();
  ret.addPropertyResult("onFailure", "OnFailure", (properties.OnFailure != null ? CfnFunctionDestinationPropertyFromCloudFormation(properties.OnFailure) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`DynamoDBEventProperty\`
 *
 * @param properties - the TypeScript properties of a \`DynamoDBEventProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionDynamoDBEventPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("batchSize", cdk.validateNumber)(properties.batchSize));
  errors.collect(cdk.propertyValidator("bisectBatchOnFunctionError", cdk.validateBoolean)(properties.bisectBatchOnFunctionError));
  errors.collect(cdk.propertyValidator("destinationConfig", CfnFunctionDestinationConfigPropertyValidator)(properties.destinationConfig));
  errors.collect(cdk.propertyValidator("enabled", cdk.validateBoolean)(properties.enabled));
  errors.collect(cdk.propertyValidator("maximumBatchingWindowInSeconds", cdk.validateNumber)(properties.maximumBatchingWindowInSeconds));
  errors.collect(cdk.propertyValidator("maximumRecordAgeInSeconds", cdk.validateNumber)(properties.maximumRecordAgeInSeconds));
  errors.collect(cdk.propertyValidator("maximumRetryAttempts", cdk.validateNumber)(properties.maximumRetryAttempts));
  errors.collect(cdk.propertyValidator("parallelizationFactor", cdk.validateNumber)(properties.parallelizationFactor));
  errors.collect(cdk.propertyValidator("startingPosition", cdk.requiredValidator)(properties.startingPosition));
  errors.collect(cdk.propertyValidator("startingPosition", cdk.validateString)(properties.startingPosition));
  errors.collect(cdk.propertyValidator("stream", cdk.requiredValidator)(properties.stream));
  errors.collect(cdk.propertyValidator("stream", cdk.validateString)(properties.stream));
  return errors.wrap("supplied properties not correct for \\"DynamoDBEventProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionDynamoDBEventPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionDynamoDBEventPropertyValidator(properties).assertSuccess();
  return {
    "BatchSize": cdk.numberToCloudFormation(properties.batchSize),
    "BisectBatchOnFunctionError": cdk.booleanToCloudFormation(properties.bisectBatchOnFunctionError),
    "DestinationConfig": convertCfnFunctionDestinationConfigPropertyToCloudFormation(properties.destinationConfig),
    "Enabled": cdk.booleanToCloudFormation(properties.enabled),
    "MaximumBatchingWindowInSeconds": cdk.numberToCloudFormation(properties.maximumBatchingWindowInSeconds),
    "MaximumRecordAgeInSeconds": cdk.numberToCloudFormation(properties.maximumRecordAgeInSeconds),
    "MaximumRetryAttempts": cdk.numberToCloudFormation(properties.maximumRetryAttempts),
    "ParallelizationFactor": cdk.numberToCloudFormation(properties.parallelizationFactor),
    "StartingPosition": cdk.stringToCloudFormation(properties.startingPosition),
    "Stream": cdk.stringToCloudFormation(properties.stream)
  };
}

// @ts-ignore TS6133
function CfnFunctionDynamoDBEventPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnFunction.DynamoDBEventProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.DynamoDBEventProperty>();
  ret.addPropertyResult("batchSize", "BatchSize", (properties.BatchSize != null ? cfn_parse.FromCloudFormation.getNumber(properties.BatchSize) : undefined));
  ret.addPropertyResult("bisectBatchOnFunctionError", "BisectBatchOnFunctionError", (properties.BisectBatchOnFunctionError != null ? cfn_parse.FromCloudFormation.getBoolean(properties.BisectBatchOnFunctionError) : undefined));
  ret.addPropertyResult("destinationConfig", "DestinationConfig", (properties.DestinationConfig != null ? CfnFunctionDestinationConfigPropertyFromCloudFormation(properties.DestinationConfig) : undefined));
  ret.addPropertyResult("enabled", "Enabled", (properties.Enabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Enabled) : undefined));
  ret.addPropertyResult("maximumBatchingWindowInSeconds", "MaximumBatchingWindowInSeconds", (properties.MaximumBatchingWindowInSeconds != null ? cfn_parse.FromCloudFormation.getNumber(properties.MaximumBatchingWindowInSeconds) : undefined));
  ret.addPropertyResult("maximumRecordAgeInSeconds", "MaximumRecordAgeInSeconds", (properties.MaximumRecordAgeInSeconds != null ? cfn_parse.FromCloudFormation.getNumber(properties.MaximumRecordAgeInSeconds) : undefined));
  ret.addPropertyResult("maximumRetryAttempts", "MaximumRetryAttempts", (properties.MaximumRetryAttempts != null ? cfn_parse.FromCloudFormation.getNumber(properties.MaximumRetryAttempts) : undefined));
  ret.addPropertyResult("parallelizationFactor", "ParallelizationFactor", (properties.ParallelizationFactor != null ? cfn_parse.FromCloudFormation.getNumber(properties.ParallelizationFactor) : undefined));
  ret.addPropertyResult("startingPosition", "StartingPosition", (properties.StartingPosition != null ? cfn_parse.FromCloudFormation.getString(properties.StartingPosition) : undefined));
  ret.addPropertyResult("stream", "Stream", (properties.Stream != null ? cfn_parse.FromCloudFormation.getString(properties.Stream) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`AuthResourcePolicyProperty\`
 *
 * @param properties - the TypeScript properties of a \`AuthResourcePolicyProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionAuthResourcePolicyPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("awsAccountBlacklist", cdk.listValidator(cdk.validateString))(properties.awsAccountBlacklist));
  errors.collect(cdk.propertyValidator("awsAccountWhitelist", cdk.listValidator(cdk.validateString))(properties.awsAccountWhitelist));
  errors.collect(cdk.propertyValidator("customStatements", cdk.listValidator(cdk.validateObject))(properties.customStatements));
  errors.collect(cdk.propertyValidator("intrinsicVpcBlacklist", cdk.listValidator(cdk.validateString))(properties.intrinsicVpcBlacklist));
  errors.collect(cdk.propertyValidator("intrinsicVpcWhitelist", cdk.listValidator(cdk.validateString))(properties.intrinsicVpcWhitelist));
  errors.collect(cdk.propertyValidator("intrinsicVpceBlacklist", cdk.listValidator(cdk.validateString))(properties.intrinsicVpceBlacklist));
  errors.collect(cdk.propertyValidator("intrinsicVpceWhitelist", cdk.listValidator(cdk.validateString))(properties.intrinsicVpceWhitelist));
  errors.collect(cdk.propertyValidator("ipRangeBlacklist", cdk.listValidator(cdk.validateString))(properties.ipRangeBlacklist));
  errors.collect(cdk.propertyValidator("ipRangeWhitelist", cdk.listValidator(cdk.validateString))(properties.ipRangeWhitelist));
  errors.collect(cdk.propertyValidator("sourceVpcBlacklist", cdk.listValidator(cdk.validateString))(properties.sourceVpcBlacklist));
  errors.collect(cdk.propertyValidator("sourceVpcWhitelist", cdk.listValidator(cdk.validateString))(properties.sourceVpcWhitelist));
  return errors.wrap("supplied properties not correct for \\"AuthResourcePolicyProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionAuthResourcePolicyPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionAuthResourcePolicyPropertyValidator(properties).assertSuccess();
  return {
    "AwsAccountBlacklist": cdk.listMapper(cdk.stringToCloudFormation)(properties.awsAccountBlacklist),
    "AwsAccountWhitelist": cdk.listMapper(cdk.stringToCloudFormation)(properties.awsAccountWhitelist),
    "CustomStatements": cdk.listMapper(cdk.objectToCloudFormation)(properties.customStatements),
    "IntrinsicVpcBlacklist": cdk.listMapper(cdk.stringToCloudFormation)(properties.intrinsicVpcBlacklist),
    "IntrinsicVpcWhitelist": cdk.listMapper(cdk.stringToCloudFormation)(properties.intrinsicVpcWhitelist),
    "IntrinsicVpceBlacklist": cdk.listMapper(cdk.stringToCloudFormation)(properties.intrinsicVpceBlacklist),
    "IntrinsicVpceWhitelist": cdk.listMapper(cdk.stringToCloudFormation)(properties.intrinsicVpceWhitelist),
    "IpRangeBlacklist": cdk.listMapper(cdk.stringToCloudFormation)(properties.ipRangeBlacklist),
    "IpRangeWhitelist": cdk.listMapper(cdk.stringToCloudFormation)(properties.ipRangeWhitelist),
    "SourceVpcBlacklist": cdk.listMapper(cdk.stringToCloudFormation)(properties.sourceVpcBlacklist),
    "SourceVpcWhitelist": cdk.listMapper(cdk.stringToCloudFormation)(properties.sourceVpcWhitelist)
  };
}

// @ts-ignore TS6133
function CfnFunctionAuthResourcePolicyPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnFunction.AuthResourcePolicyProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.AuthResourcePolicyProperty>();
  ret.addPropertyResult("awsAccountBlacklist", "AwsAccountBlacklist", (properties.AwsAccountBlacklist != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.AwsAccountBlacklist) : undefined));
  ret.addPropertyResult("awsAccountWhitelist", "AwsAccountWhitelist", (properties.AwsAccountWhitelist != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.AwsAccountWhitelist) : undefined));
  ret.addPropertyResult("customStatements", "CustomStatements", (properties.CustomStatements != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getAny)(properties.CustomStatements) : undefined));
  ret.addPropertyResult("intrinsicVpcBlacklist", "IntrinsicVpcBlacklist", (properties.IntrinsicVpcBlacklist != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.IntrinsicVpcBlacklist) : undefined));
  ret.addPropertyResult("intrinsicVpceBlacklist", "IntrinsicVpceBlacklist", (properties.IntrinsicVpceBlacklist != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.IntrinsicVpceBlacklist) : undefined));
  ret.addPropertyResult("intrinsicVpceWhitelist", "IntrinsicVpceWhitelist", (properties.IntrinsicVpceWhitelist != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.IntrinsicVpceWhitelist) : undefined));
  ret.addPropertyResult("intrinsicVpcWhitelist", "IntrinsicVpcWhitelist", (properties.IntrinsicVpcWhitelist != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.IntrinsicVpcWhitelist) : undefined));
  ret.addPropertyResult("ipRangeBlacklist", "IpRangeBlacklist", (properties.IpRangeBlacklist != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.IpRangeBlacklist) : undefined));
  ret.addPropertyResult("ipRangeWhitelist", "IpRangeWhitelist", (properties.IpRangeWhitelist != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.IpRangeWhitelist) : undefined));
  ret.addPropertyResult("sourceVpcBlacklist", "SourceVpcBlacklist", (properties.SourceVpcBlacklist != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SourceVpcBlacklist) : undefined));
  ret.addPropertyResult("sourceVpcWhitelist", "SourceVpcWhitelist", (properties.SourceVpcWhitelist != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SourceVpcWhitelist) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`AuthProperty\`
 *
 * @param properties - the TypeScript properties of a \`AuthProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionAuthPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("apiKeyRequired", cdk.validateBoolean)(properties.apiKeyRequired));
  errors.collect(cdk.propertyValidator("authorizationScopes", cdk.listValidator(cdk.validateString))(properties.authorizationScopes));
  errors.collect(cdk.propertyValidator("authorizer", cdk.validateString)(properties.authorizer));
  errors.collect(cdk.propertyValidator("resourcePolicy", CfnFunctionAuthResourcePolicyPropertyValidator)(properties.resourcePolicy));
  return errors.wrap("supplied properties not correct for \\"AuthProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionAuthPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionAuthPropertyValidator(properties).assertSuccess();
  return {
    "ApiKeyRequired": cdk.booleanToCloudFormation(properties.apiKeyRequired),
    "AuthorizationScopes": cdk.listMapper(cdk.stringToCloudFormation)(properties.authorizationScopes),
    "Authorizer": cdk.stringToCloudFormation(properties.authorizer),
    "ResourcePolicy": convertCfnFunctionAuthResourcePolicyPropertyToCloudFormation(properties.resourcePolicy)
  };
}

// @ts-ignore TS6133
function CfnFunctionAuthPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnFunction.AuthProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.AuthProperty>();
  ret.addPropertyResult("apiKeyRequired", "ApiKeyRequired", (properties.ApiKeyRequired != null ? cfn_parse.FromCloudFormation.getBoolean(properties.ApiKeyRequired) : undefined));
  ret.addPropertyResult("authorizationScopes", "AuthorizationScopes", (properties.AuthorizationScopes != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.AuthorizationScopes) : undefined));
  ret.addPropertyResult("authorizer", "Authorizer", (properties.Authorizer != null ? cfn_parse.FromCloudFormation.getString(properties.Authorizer) : undefined));
  ret.addPropertyResult("resourcePolicy", "ResourcePolicy", (properties.ResourcePolicy != null ? CfnFunctionAuthResourcePolicyPropertyFromCloudFormation(properties.ResourcePolicy) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`RequestModelProperty\`
 *
 * @param properties - the TypeScript properties of a \`RequestModelProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionRequestModelPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("model", cdk.requiredValidator)(properties.model));
  errors.collect(cdk.propertyValidator("model", cdk.validateString)(properties.model));
  errors.collect(cdk.propertyValidator("required", cdk.validateBoolean)(properties.required));
  errors.collect(cdk.propertyValidator("validateBody", cdk.validateBoolean)(properties.validateBody));
  errors.collect(cdk.propertyValidator("validateParameters", cdk.validateBoolean)(properties.validateParameters));
  return errors.wrap("supplied properties not correct for \\"RequestModelProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionRequestModelPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionRequestModelPropertyValidator(properties).assertSuccess();
  return {
    "Model": cdk.stringToCloudFormation(properties.model),
    "Required": cdk.booleanToCloudFormation(properties.required),
    "ValidateBody": cdk.booleanToCloudFormation(properties.validateBody),
    "ValidateParameters": cdk.booleanToCloudFormation(properties.validateParameters)
  };
}

// @ts-ignore TS6133
function CfnFunctionRequestModelPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnFunction.RequestModelProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.RequestModelProperty>();
  ret.addPropertyResult("model", "Model", (properties.Model != null ? cfn_parse.FromCloudFormation.getString(properties.Model) : undefined));
  ret.addPropertyResult("required", "Required", (properties.Required != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Required) : undefined));
  ret.addPropertyResult("validateBody", "ValidateBody", (properties.ValidateBody != null ? cfn_parse.FromCloudFormation.getBoolean(properties.ValidateBody) : undefined));
  ret.addPropertyResult("validateParameters", "ValidateParameters", (properties.ValidateParameters != null ? cfn_parse.FromCloudFormation.getBoolean(properties.ValidateParameters) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`RequestParameterProperty\`
 *
 * @param properties - the TypeScript properties of a \`RequestParameterProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionRequestParameterPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("caching", cdk.validateBoolean)(properties.caching));
  errors.collect(cdk.propertyValidator("required", cdk.validateBoolean)(properties.required));
  return errors.wrap("supplied properties not correct for \\"RequestParameterProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionRequestParameterPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionRequestParameterPropertyValidator(properties).assertSuccess();
  return {
    "Caching": cdk.booleanToCloudFormation(properties.caching),
    "Required": cdk.booleanToCloudFormation(properties.required)
  };
}

// @ts-ignore TS6133
function CfnFunctionRequestParameterPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnFunction.RequestParameterProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.RequestParameterProperty>();
  ret.addPropertyResult("caching", "Caching", (properties.Caching != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Caching) : undefined));
  ret.addPropertyResult("required", "Required", (properties.Required != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Required) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ApiEventProperty\`
 *
 * @param properties - the TypeScript properties of a \`ApiEventProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionApiEventPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("auth", CfnFunctionAuthPropertyValidator)(properties.auth));
  errors.collect(cdk.propertyValidator("method", cdk.requiredValidator)(properties.method));
  errors.collect(cdk.propertyValidator("method", cdk.validateString)(properties.method));
  errors.collect(cdk.propertyValidator("path", cdk.requiredValidator)(properties.path));
  errors.collect(cdk.propertyValidator("path", cdk.validateString)(properties.path));
  errors.collect(cdk.propertyValidator("requestModel", CfnFunctionRequestModelPropertyValidator)(properties.requestModel));
  errors.collect(cdk.propertyValidator("requestParameters", cdk.listValidator(cdk.unionValidator(CfnFunctionRequestParameterPropertyValidator, cdk.validateString)))(properties.requestParameters));
  errors.collect(cdk.propertyValidator("restApiId", cdk.validateString)(properties.restApiId));
  return errors.wrap("supplied properties not correct for \\"ApiEventProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionApiEventPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionApiEventPropertyValidator(properties).assertSuccess();
  return {
    "Auth": convertCfnFunctionAuthPropertyToCloudFormation(properties.auth),
    "Method": cdk.stringToCloudFormation(properties.method),
    "Path": cdk.stringToCloudFormation(properties.path),
    "RequestModel": convertCfnFunctionRequestModelPropertyToCloudFormation(properties.requestModel),
    "RequestParameters": cdk.listMapper(cdk.unionMapper([CfnFunctionRequestParameterPropertyValidator, cdk.validateString], [convertCfnFunctionRequestParameterPropertyToCloudFormation, cdk.stringToCloudFormation]))(properties.requestParameters),
    "RestApiId": cdk.stringToCloudFormation(properties.restApiId)
  };
}

// @ts-ignore TS6133
function CfnFunctionApiEventPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnFunction.ApiEventProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.ApiEventProperty>();
  ret.addPropertyResult("auth", "Auth", (properties.Auth != null ? CfnFunctionAuthPropertyFromCloudFormation(properties.Auth) : undefined));
  ret.addPropertyResult("method", "Method", (properties.Method != null ? cfn_parse.FromCloudFormation.getString(properties.Method) : undefined));
  ret.addPropertyResult("path", "Path", (properties.Path != null ? cfn_parse.FromCloudFormation.getString(properties.Path) : undefined));
  ret.addPropertyResult("requestModel", "RequestModel", (properties.RequestModel != null ? CfnFunctionRequestModelPropertyFromCloudFormation(properties.RequestModel) : undefined));
  ret.addPropertyResult("requestParameters", "RequestParameters", (properties.RequestParameters != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getTypeUnion([CfnFunctionRequestParameterPropertyValidator, cdk.validateString], [CfnFunctionRequestParameterPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString]))(properties.RequestParameters) : undefined));
  ret.addPropertyResult("restApiId", "RestApiId", (properties.RestApiId != null ? cfn_parse.FromCloudFormation.getString(properties.RestApiId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ScheduleEventProperty\`
 *
 * @param properties - the TypeScript properties of a \`ScheduleEventProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionScheduleEventPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("enabled", cdk.validateBoolean)(properties.enabled));
  errors.collect(cdk.propertyValidator("input", cdk.validateString)(properties.input));
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  errors.collect(cdk.propertyValidator("schedule", cdk.requiredValidator)(properties.schedule));
  errors.collect(cdk.propertyValidator("schedule", cdk.validateString)(properties.schedule));
  return errors.wrap("supplied properties not correct for \\"ScheduleEventProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionScheduleEventPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionScheduleEventPropertyValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "Enabled": cdk.booleanToCloudFormation(properties.enabled),
    "Input": cdk.stringToCloudFormation(properties.input),
    "Name": cdk.stringToCloudFormation(properties.name),
    "Schedule": cdk.stringToCloudFormation(properties.schedule)
  };
}

// @ts-ignore TS6133
function CfnFunctionScheduleEventPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnFunction.ScheduleEventProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.ScheduleEventProperty>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("enabled", "Enabled", (properties.Enabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Enabled) : undefined));
  ret.addPropertyResult("input", "Input", (properties.Input != null ? cfn_parse.FromCloudFormation.getString(properties.Input) : undefined));
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addPropertyResult("schedule", "Schedule", (properties.Schedule != null ? cfn_parse.FromCloudFormation.getString(properties.Schedule) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CloudWatchEventEventProperty\`
 *
 * @param properties - the TypeScript properties of a \`CloudWatchEventEventProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionCloudWatchEventEventPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("input", cdk.validateString)(properties.input));
  errors.collect(cdk.propertyValidator("inputPath", cdk.validateString)(properties.inputPath));
  errors.collect(cdk.propertyValidator("pattern", cdk.requiredValidator)(properties.pattern));
  errors.collect(cdk.propertyValidator("pattern", cdk.validateObject)(properties.pattern));
  return errors.wrap("supplied properties not correct for \\"CloudWatchEventEventProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionCloudWatchEventEventPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionCloudWatchEventEventPropertyValidator(properties).assertSuccess();
  return {
    "Input": cdk.stringToCloudFormation(properties.input),
    "InputPath": cdk.stringToCloudFormation(properties.inputPath),
    "Pattern": cdk.objectToCloudFormation(properties.pattern)
  };
}

// @ts-ignore TS6133
function CfnFunctionCloudWatchEventEventPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnFunction.CloudWatchEventEventProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.CloudWatchEventEventProperty>();
  ret.addPropertyResult("input", "Input", (properties.Input != null ? cfn_parse.FromCloudFormation.getString(properties.Input) : undefined));
  ret.addPropertyResult("inputPath", "InputPath", (properties.InputPath != null ? cfn_parse.FromCloudFormation.getString(properties.InputPath) : undefined));
  ret.addPropertyResult("pattern", "Pattern", (properties.Pattern != null ? cfn_parse.FromCloudFormation.getAny(properties.Pattern) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CloudWatchLogsEventProperty\`
 *
 * @param properties - the TypeScript properties of a \`CloudWatchLogsEventProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionCloudWatchLogsEventPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("filterPattern", cdk.requiredValidator)(properties.filterPattern));
  errors.collect(cdk.propertyValidator("filterPattern", cdk.validateString)(properties.filterPattern));
  errors.collect(cdk.propertyValidator("logGroupName", cdk.requiredValidator)(properties.logGroupName));
  errors.collect(cdk.propertyValidator("logGroupName", cdk.validateString)(properties.logGroupName));
  return errors.wrap("supplied properties not correct for \\"CloudWatchLogsEventProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionCloudWatchLogsEventPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionCloudWatchLogsEventPropertyValidator(properties).assertSuccess();
  return {
    "FilterPattern": cdk.stringToCloudFormation(properties.filterPattern),
    "LogGroupName": cdk.stringToCloudFormation(properties.logGroupName)
  };
}

// @ts-ignore TS6133
function CfnFunctionCloudWatchLogsEventPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnFunction.CloudWatchLogsEventProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.CloudWatchLogsEventProperty>();
  ret.addPropertyResult("filterPattern", "FilterPattern", (properties.FilterPattern != null ? cfn_parse.FromCloudFormation.getString(properties.FilterPattern) : undefined));
  ret.addPropertyResult("logGroupName", "LogGroupName", (properties.LogGroupName != null ? cfn_parse.FromCloudFormation.getString(properties.LogGroupName) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`IoTRuleEventProperty\`
 *
 * @param properties - the TypeScript properties of a \`IoTRuleEventProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionIoTRuleEventPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("awsIotSqlVersion", cdk.validateString)(properties.awsIotSqlVersion));
  errors.collect(cdk.propertyValidator("sql", cdk.requiredValidator)(properties.sql));
  errors.collect(cdk.propertyValidator("sql", cdk.validateString)(properties.sql));
  return errors.wrap("supplied properties not correct for \\"IoTRuleEventProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionIoTRuleEventPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionIoTRuleEventPropertyValidator(properties).assertSuccess();
  return {
    "AwsIotSqlVersion": cdk.stringToCloudFormation(properties.awsIotSqlVersion),
    "Sql": cdk.stringToCloudFormation(properties.sql)
  };
}

// @ts-ignore TS6133
function CfnFunctionIoTRuleEventPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnFunction.IoTRuleEventProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.IoTRuleEventProperty>();
  ret.addPropertyResult("awsIotSqlVersion", "AwsIotSqlVersion", (properties.AwsIotSqlVersion != null ? cfn_parse.FromCloudFormation.getString(properties.AwsIotSqlVersion) : undefined));
  ret.addPropertyResult("sql", "Sql", (properties.Sql != null ? cfn_parse.FromCloudFormation.getString(properties.Sql) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`AlexaSkillEventProperty\`
 *
 * @param properties - the TypeScript properties of a \`AlexaSkillEventProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionAlexaSkillEventPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("variables", cdk.hashValidator(cdk.validateString))(properties.variables));
  return errors.wrap("supplied properties not correct for \\"AlexaSkillEventProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionAlexaSkillEventPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionAlexaSkillEventPropertyValidator(properties).assertSuccess();
  return {
    "Variables": cdk.hashMapper(cdk.stringToCloudFormation)(properties.variables)
  };
}

// @ts-ignore TS6133
function CfnFunctionAlexaSkillEventPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnFunction.AlexaSkillEventProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.AlexaSkillEventProperty>();
  ret.addPropertyResult("variables", "Variables", (properties.Variables != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getString)(properties.Variables) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`EventBridgeRuleEventProperty\`
 *
 * @param properties - the TypeScript properties of a \`EventBridgeRuleEventProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionEventBridgeRuleEventPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("eventBusName", cdk.validateString)(properties.eventBusName));
  errors.collect(cdk.propertyValidator("input", cdk.validateString)(properties.input));
  errors.collect(cdk.propertyValidator("inputPath", cdk.validateString)(properties.inputPath));
  errors.collect(cdk.propertyValidator("pattern", cdk.requiredValidator)(properties.pattern));
  errors.collect(cdk.propertyValidator("pattern", cdk.validateObject)(properties.pattern));
  return errors.wrap("supplied properties not correct for \\"EventBridgeRuleEventProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionEventBridgeRuleEventPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionEventBridgeRuleEventPropertyValidator(properties).assertSuccess();
  return {
    "EventBusName": cdk.stringToCloudFormation(properties.eventBusName),
    "Input": cdk.stringToCloudFormation(properties.input),
    "InputPath": cdk.stringToCloudFormation(properties.inputPath),
    "Pattern": cdk.objectToCloudFormation(properties.pattern)
  };
}

// @ts-ignore TS6133
function CfnFunctionEventBridgeRuleEventPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnFunction.EventBridgeRuleEventProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.EventBridgeRuleEventProperty>();
  ret.addPropertyResult("eventBusName", "EventBusName", (properties.EventBusName != null ? cfn_parse.FromCloudFormation.getString(properties.EventBusName) : undefined));
  ret.addPropertyResult("input", "Input", (properties.Input != null ? cfn_parse.FromCloudFormation.getString(properties.Input) : undefined));
  ret.addPropertyResult("inputPath", "InputPath", (properties.InputPath != null ? cfn_parse.FromCloudFormation.getString(properties.InputPath) : undefined));
  ret.addPropertyResult("pattern", "Pattern", (properties.Pattern != null ? cfn_parse.FromCloudFormation.getAny(properties.Pattern) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`HttpApiFunctionAuthProperty\`
 *
 * @param properties - the TypeScript properties of a \`HttpApiFunctionAuthProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionHttpApiFunctionAuthPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("authorizationScopes", cdk.listValidator(cdk.validateString))(properties.authorizationScopes));
  errors.collect(cdk.propertyValidator("authorizer", cdk.validateString)(properties.authorizer));
  return errors.wrap("supplied properties not correct for \\"HttpApiFunctionAuthProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionHttpApiFunctionAuthPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionHttpApiFunctionAuthPropertyValidator(properties).assertSuccess();
  return {
    "AuthorizationScopes": cdk.listMapper(cdk.stringToCloudFormation)(properties.authorizationScopes),
    "Authorizer": cdk.stringToCloudFormation(properties.authorizer)
  };
}

// @ts-ignore TS6133
function CfnFunctionHttpApiFunctionAuthPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnFunction.HttpApiFunctionAuthProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.HttpApiFunctionAuthProperty>();
  ret.addPropertyResult("authorizationScopes", "AuthorizationScopes", (properties.AuthorizationScopes != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.AuthorizationScopes) : undefined));
  ret.addPropertyResult("authorizer", "Authorizer", (properties.Authorizer != null ? cfn_parse.FromCloudFormation.getString(properties.Authorizer) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`RouteSettingsProperty\`
 *
 * @param properties - the TypeScript properties of a \`RouteSettingsProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionRouteSettingsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("dataTraceEnabled", cdk.validateBoolean)(properties.dataTraceEnabled));
  errors.collect(cdk.propertyValidator("detailedMetricsEnabled", cdk.validateBoolean)(properties.detailedMetricsEnabled));
  errors.collect(cdk.propertyValidator("loggingLevel", cdk.validateString)(properties.loggingLevel));
  errors.collect(cdk.propertyValidator("throttlingBurstLimit", cdk.validateNumber)(properties.throttlingBurstLimit));
  errors.collect(cdk.propertyValidator("throttlingRateLimit", cdk.validateNumber)(properties.throttlingRateLimit));
  return errors.wrap("supplied properties not correct for \\"RouteSettingsProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionRouteSettingsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionRouteSettingsPropertyValidator(properties).assertSuccess();
  return {
    "DataTraceEnabled": cdk.booleanToCloudFormation(properties.dataTraceEnabled),
    "DetailedMetricsEnabled": cdk.booleanToCloudFormation(properties.detailedMetricsEnabled),
    "LoggingLevel": cdk.stringToCloudFormation(properties.loggingLevel),
    "ThrottlingBurstLimit": cdk.numberToCloudFormation(properties.throttlingBurstLimit),
    "ThrottlingRateLimit": cdk.numberToCloudFormation(properties.throttlingRateLimit)
  };
}

// @ts-ignore TS6133
function CfnFunctionRouteSettingsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnFunction.RouteSettingsProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.RouteSettingsProperty>();
  ret.addPropertyResult("dataTraceEnabled", "DataTraceEnabled", (properties.DataTraceEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.DataTraceEnabled) : undefined));
  ret.addPropertyResult("detailedMetricsEnabled", "DetailedMetricsEnabled", (properties.DetailedMetricsEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.DetailedMetricsEnabled) : undefined));
  ret.addPropertyResult("loggingLevel", "LoggingLevel", (properties.LoggingLevel != null ? cfn_parse.FromCloudFormation.getString(properties.LoggingLevel) : undefined));
  ret.addPropertyResult("throttlingBurstLimit", "ThrottlingBurstLimit", (properties.ThrottlingBurstLimit != null ? cfn_parse.FromCloudFormation.getNumber(properties.ThrottlingBurstLimit) : undefined));
  ret.addPropertyResult("throttlingRateLimit", "ThrottlingRateLimit", (properties.ThrottlingRateLimit != null ? cfn_parse.FromCloudFormation.getNumber(properties.ThrottlingRateLimit) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`HttpApiEventProperty\`
 *
 * @param properties - the TypeScript properties of a \`HttpApiEventProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionHttpApiEventPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("apiId", cdk.validateString)(properties.apiId));
  errors.collect(cdk.propertyValidator("auth", CfnFunctionHttpApiFunctionAuthPropertyValidator)(properties.auth));
  errors.collect(cdk.propertyValidator("method", cdk.validateString)(properties.method));
  errors.collect(cdk.propertyValidator("path", cdk.validateString)(properties.path));
  errors.collect(cdk.propertyValidator("payloadFormatVersion", cdk.validateString)(properties.payloadFormatVersion));
  errors.collect(cdk.propertyValidator("routeSettings", CfnFunctionRouteSettingsPropertyValidator)(properties.routeSettings));
  errors.collect(cdk.propertyValidator("timeoutInMillis", cdk.validateNumber)(properties.timeoutInMillis));
  return errors.wrap("supplied properties not correct for \\"HttpApiEventProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionHttpApiEventPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionHttpApiEventPropertyValidator(properties).assertSuccess();
  return {
    "ApiId": cdk.stringToCloudFormation(properties.apiId),
    "Auth": convertCfnFunctionHttpApiFunctionAuthPropertyToCloudFormation(properties.auth),
    "Method": cdk.stringToCloudFormation(properties.method),
    "Path": cdk.stringToCloudFormation(properties.path),
    "PayloadFormatVersion": cdk.stringToCloudFormation(properties.payloadFormatVersion),
    "RouteSettings": convertCfnFunctionRouteSettingsPropertyToCloudFormation(properties.routeSettings),
    "TimeoutInMillis": cdk.numberToCloudFormation(properties.timeoutInMillis)
  };
}

// @ts-ignore TS6133
function CfnFunctionHttpApiEventPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnFunction.HttpApiEventProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.HttpApiEventProperty>();
  ret.addPropertyResult("apiId", "ApiId", (properties.ApiId != null ? cfn_parse.FromCloudFormation.getString(properties.ApiId) : undefined));
  ret.addPropertyResult("auth", "Auth", (properties.Auth != null ? CfnFunctionHttpApiFunctionAuthPropertyFromCloudFormation(properties.Auth) : undefined));
  ret.addPropertyResult("method", "Method", (properties.Method != null ? cfn_parse.FromCloudFormation.getString(properties.Method) : undefined));
  ret.addPropertyResult("path", "Path", (properties.Path != null ? cfn_parse.FromCloudFormation.getString(properties.Path) : undefined));
  ret.addPropertyResult("payloadFormatVersion", "PayloadFormatVersion", (properties.PayloadFormatVersion != null ? cfn_parse.FromCloudFormation.getString(properties.PayloadFormatVersion) : undefined));
  ret.addPropertyResult("routeSettings", "RouteSettings", (properties.RouteSettings != null ? CfnFunctionRouteSettingsPropertyFromCloudFormation(properties.RouteSettings) : undefined));
  ret.addPropertyResult("timeoutInMillis", "TimeoutInMillis", (properties.TimeoutInMillis != null ? cfn_parse.FromCloudFormation.getNumber(properties.TimeoutInMillis) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CognitoEventProperty\`
 *
 * @param properties - the TypeScript properties of a \`CognitoEventProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionCognitoEventPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("trigger", cdk.requiredValidator)(properties.trigger));
  errors.collect(cdk.propertyValidator("trigger", cdk.validateString)(properties.trigger));
  errors.collect(cdk.propertyValidator("userPool", cdk.requiredValidator)(properties.userPool));
  errors.collect(cdk.propertyValidator("userPool", cdk.validateString)(properties.userPool));
  return errors.wrap("supplied properties not correct for \\"CognitoEventProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionCognitoEventPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionCognitoEventPropertyValidator(properties).assertSuccess();
  return {
    "Trigger": cdk.stringToCloudFormation(properties.trigger),
    "UserPool": cdk.stringToCloudFormation(properties.userPool)
  };
}

// @ts-ignore TS6133
function CfnFunctionCognitoEventPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnFunction.CognitoEventProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.CognitoEventProperty>();
  ret.addPropertyResult("trigger", "Trigger", (properties.Trigger != null ? cfn_parse.FromCloudFormation.getString(properties.Trigger) : undefined));
  ret.addPropertyResult("userPool", "UserPool", (properties.UserPool != null ? cfn_parse.FromCloudFormation.getString(properties.UserPool) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`EventSourceProperty\`
 *
 * @param properties - the TypeScript properties of a \`EventSourceProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionEventSourcePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("properties", cdk.requiredValidator)(properties.properties));
  errors.collect(cdk.propertyValidator("properties", cdk.unionValidator(CfnFunctionAlexaSkillEventPropertyValidator, CfnFunctionApiEventPropertyValidator, CfnFunctionCloudWatchEventEventPropertyValidator, CfnFunctionCloudWatchLogsEventPropertyValidator, CfnFunctionCognitoEventPropertyValidator, CfnFunctionDynamoDBEventPropertyValidator, CfnFunctionEventBridgeRuleEventPropertyValidator, CfnFunctionHttpApiEventPropertyValidator, CfnFunctionIoTRuleEventPropertyValidator, CfnFunctionKinesisEventPropertyValidator, CfnFunctionS3EventPropertyValidator, CfnFunctionScheduleEventPropertyValidator, CfnFunctionSNSEventPropertyValidator, CfnFunctionSQSEventPropertyValidator))(properties.properties));
  errors.collect(cdk.propertyValidator("type", cdk.requiredValidator)(properties.type));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  return errors.wrap("supplied properties not correct for \\"EventSourceProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionEventSourcePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionEventSourcePropertyValidator(properties).assertSuccess();
  return {
    "Properties": cdk.unionMapper([CfnFunctionAlexaSkillEventPropertyValidator, CfnFunctionApiEventPropertyValidator, CfnFunctionCloudWatchEventEventPropertyValidator, CfnFunctionCloudWatchLogsEventPropertyValidator, CfnFunctionCognitoEventPropertyValidator, CfnFunctionDynamoDBEventPropertyValidator, CfnFunctionEventBridgeRuleEventPropertyValidator, CfnFunctionHttpApiEventPropertyValidator, CfnFunctionIoTRuleEventPropertyValidator, CfnFunctionKinesisEventPropertyValidator, CfnFunctionS3EventPropertyValidator, CfnFunctionScheduleEventPropertyValidator, CfnFunctionSNSEventPropertyValidator, CfnFunctionSQSEventPropertyValidator], [convertCfnFunctionAlexaSkillEventPropertyToCloudFormation, convertCfnFunctionApiEventPropertyToCloudFormation, convertCfnFunctionCloudWatchEventEventPropertyToCloudFormation, convertCfnFunctionCloudWatchLogsEventPropertyToCloudFormation, convertCfnFunctionCognitoEventPropertyToCloudFormation, convertCfnFunctionDynamoDBEventPropertyToCloudFormation, convertCfnFunctionEventBridgeRuleEventPropertyToCloudFormation, convertCfnFunctionHttpApiEventPropertyToCloudFormation, convertCfnFunctionIoTRuleEventPropertyToCloudFormation, convertCfnFunctionKinesisEventPropertyToCloudFormation, convertCfnFunctionS3EventPropertyToCloudFormation, convertCfnFunctionScheduleEventPropertyToCloudFormation, convertCfnFunctionSNSEventPropertyToCloudFormation, convertCfnFunctionSQSEventPropertyToCloudFormation])(properties.properties),
    "Type": cdk.stringToCloudFormation(properties.type)
  };
}

// @ts-ignore TS6133
function CfnFunctionEventSourcePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnFunction.EventSourceProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.EventSourceProperty>();
  ret.addPropertyResult("properties", "Properties", (properties.Properties != null ? cfn_parse.FromCloudFormation.getTypeUnion([CfnFunctionAlexaSkillEventPropertyValidator, CfnFunctionApiEventPropertyValidator, CfnFunctionCloudWatchEventEventPropertyValidator, CfnFunctionCloudWatchLogsEventPropertyValidator, CfnFunctionCognitoEventPropertyValidator, CfnFunctionDynamoDBEventPropertyValidator, CfnFunctionEventBridgeRuleEventPropertyValidator, CfnFunctionHttpApiEventPropertyValidator, CfnFunctionIoTRuleEventPropertyValidator, CfnFunctionKinesisEventPropertyValidator, CfnFunctionS3EventPropertyValidator, CfnFunctionScheduleEventPropertyValidator, CfnFunctionSNSEventPropertyValidator, CfnFunctionSQSEventPropertyValidator], [CfnFunctionAlexaSkillEventPropertyFromCloudFormation, CfnFunctionApiEventPropertyFromCloudFormation, CfnFunctionCloudWatchEventEventPropertyFromCloudFormation, CfnFunctionCloudWatchLogsEventPropertyFromCloudFormation, CfnFunctionCognitoEventPropertyFromCloudFormation, CfnFunctionDynamoDBEventPropertyFromCloudFormation, CfnFunctionEventBridgeRuleEventPropertyFromCloudFormation, CfnFunctionHttpApiEventPropertyFromCloudFormation, CfnFunctionIoTRuleEventPropertyFromCloudFormation, CfnFunctionKinesisEventPropertyFromCloudFormation, CfnFunctionS3EventPropertyFromCloudFormation, CfnFunctionScheduleEventPropertyFromCloudFormation, CfnFunctionSNSEventPropertyFromCloudFormation, CfnFunctionSQSEventPropertyFromCloudFormation])(properties.Properties) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`FileSystemConfigProperty\`
 *
 * @param properties - the TypeScript properties of a \`FileSystemConfigProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionFileSystemConfigPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("arn", cdk.validateString)(properties.arn));
  errors.collect(cdk.propertyValidator("localMountPath", cdk.validateString)(properties.localMountPath));
  return errors.wrap("supplied properties not correct for \\"FileSystemConfigProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionFileSystemConfigPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionFileSystemConfigPropertyValidator(properties).assertSuccess();
  return {
    "Arn": cdk.stringToCloudFormation(properties.arn),
    "LocalMountPath": cdk.stringToCloudFormation(properties.localMountPath)
  };
}

// @ts-ignore TS6133
function CfnFunctionFileSystemConfigPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnFunction.FileSystemConfigProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.FileSystemConfigProperty>();
  ret.addPropertyResult("arn", "Arn", (properties.Arn != null ? cfn_parse.FromCloudFormation.getString(properties.Arn) : undefined));
  ret.addPropertyResult("localMountPath", "LocalMountPath", (properties.LocalMountPath != null ? cfn_parse.FromCloudFormation.getString(properties.LocalMountPath) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ImageConfigProperty\`
 *
 * @param properties - the TypeScript properties of a \`ImageConfigProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionImageConfigPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("command", cdk.listValidator(cdk.validateString))(properties.command));
  errors.collect(cdk.propertyValidator("entryPoint", cdk.listValidator(cdk.validateString))(properties.entryPoint));
  errors.collect(cdk.propertyValidator("workingDirectory", cdk.validateString)(properties.workingDirectory));
  return errors.wrap("supplied properties not correct for \\"ImageConfigProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionImageConfigPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionImageConfigPropertyValidator(properties).assertSuccess();
  return {
    "Command": cdk.listMapper(cdk.stringToCloudFormation)(properties.command),
    "EntryPoint": cdk.listMapper(cdk.stringToCloudFormation)(properties.entryPoint),
    "WorkingDirectory": cdk.stringToCloudFormation(properties.workingDirectory)
  };
}

// @ts-ignore TS6133
function CfnFunctionImageConfigPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnFunction.ImageConfigProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.ImageConfigProperty>();
  ret.addPropertyResult("command", "Command", (properties.Command != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.Command) : undefined));
  ret.addPropertyResult("entryPoint", "EntryPoint", (properties.EntryPoint != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.EntryPoint) : undefined));
  ret.addPropertyResult("workingDirectory", "WorkingDirectory", (properties.WorkingDirectory != null ? cfn_parse.FromCloudFormation.getString(properties.WorkingDirectory) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`IAMPolicyDocumentProperty\`
 *
 * @param properties - the TypeScript properties of a \`IAMPolicyDocumentProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionIAMPolicyDocumentPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("statement", cdk.requiredValidator)(properties.statement));
  errors.collect(cdk.propertyValidator("statement", cdk.validateObject)(properties.statement));
  errors.collect(cdk.propertyValidator("version", cdk.validateString)(properties.version));
  return errors.wrap("supplied properties not correct for \\"IAMPolicyDocumentProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionIAMPolicyDocumentPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionIAMPolicyDocumentPropertyValidator(properties).assertSuccess();
  return {
    "Statement": cdk.objectToCloudFormation(properties.statement),
    "Version": cdk.stringToCloudFormation(properties.version)
  };
}

// @ts-ignore TS6133
function CfnFunctionIAMPolicyDocumentPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnFunction.IAMPolicyDocumentProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.IAMPolicyDocumentProperty>();
  ret.addPropertyResult("statement", "Statement", (properties.Statement != null ? cfn_parse.FromCloudFormation.getAny(properties.Statement) : undefined));
  ret.addPropertyResult("version", "Version", (properties.Version != null ? cfn_parse.FromCloudFormation.getString(properties.Version) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`EmptySAMPTProperty\`
 *
 * @param properties - the TypeScript properties of a \`EmptySAMPTProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionEmptySAMPTPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  return errors.wrap("supplied properties not correct for \\"EmptySAMPTProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionEmptySAMPTPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionEmptySAMPTPropertyValidator(properties).assertSuccess();
  return {};
}

// @ts-ignore TS6133
function CfnFunctionEmptySAMPTPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnFunction.EmptySAMPTProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.EmptySAMPTProperty>();
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`SecretArnSAMPTProperty\`
 *
 * @param properties - the TypeScript properties of a \`SecretArnSAMPTProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionSecretArnSAMPTPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("secretArn", cdk.requiredValidator)(properties.secretArn));
  errors.collect(cdk.propertyValidator("secretArn", cdk.validateString)(properties.secretArn));
  return errors.wrap("supplied properties not correct for \\"SecretArnSAMPTProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionSecretArnSAMPTPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionSecretArnSAMPTPropertyValidator(properties).assertSuccess();
  return {
    "SecretArn": cdk.stringToCloudFormation(properties.secretArn)
  };
}

// @ts-ignore TS6133
function CfnFunctionSecretArnSAMPTPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnFunction.SecretArnSAMPTProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.SecretArnSAMPTProperty>();
  ret.addPropertyResult("secretArn", "SecretArn", (properties.SecretArn != null ? cfn_parse.FromCloudFormation.getString(properties.SecretArn) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`TableSAMPTProperty\`
 *
 * @param properties - the TypeScript properties of a \`TableSAMPTProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionTableSAMPTPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("tableName", cdk.requiredValidator)(properties.tableName));
  errors.collect(cdk.propertyValidator("tableName", cdk.validateString)(properties.tableName));
  return errors.wrap("supplied properties not correct for \\"TableSAMPTProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionTableSAMPTPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionTableSAMPTPropertyValidator(properties).assertSuccess();
  return {
    "TableName": cdk.stringToCloudFormation(properties.tableName)
  };
}

// @ts-ignore TS6133
function CfnFunctionTableSAMPTPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnFunction.TableSAMPTProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.TableSAMPTProperty>();
  ret.addPropertyResult("tableName", "TableName", (properties.TableName != null ? cfn_parse.FromCloudFormation.getString(properties.TableName) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`TableStreamSAMPTProperty\`
 *
 * @param properties - the TypeScript properties of a \`TableStreamSAMPTProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionTableStreamSAMPTPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("streamName", cdk.requiredValidator)(properties.streamName));
  errors.collect(cdk.propertyValidator("streamName", cdk.validateString)(properties.streamName));
  errors.collect(cdk.propertyValidator("tableName", cdk.requiredValidator)(properties.tableName));
  errors.collect(cdk.propertyValidator("tableName", cdk.validateString)(properties.tableName));
  return errors.wrap("supplied properties not correct for \\"TableStreamSAMPTProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionTableStreamSAMPTPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionTableStreamSAMPTPropertyValidator(properties).assertSuccess();
  return {
    "StreamName": cdk.stringToCloudFormation(properties.streamName),
    "TableName": cdk.stringToCloudFormation(properties.tableName)
  };
}

// @ts-ignore TS6133
function CfnFunctionTableStreamSAMPTPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnFunction.TableStreamSAMPTProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.TableStreamSAMPTProperty>();
  ret.addPropertyResult("streamName", "StreamName", (properties.StreamName != null ? cfn_parse.FromCloudFormation.getString(properties.StreamName) : undefined));
  ret.addPropertyResult("tableName", "TableName", (properties.TableName != null ? cfn_parse.FromCloudFormation.getString(properties.TableName) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`DomainSAMPTProperty\`
 *
 * @param properties - the TypeScript properties of a \`DomainSAMPTProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionDomainSAMPTPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("domainName", cdk.requiredValidator)(properties.domainName));
  errors.collect(cdk.propertyValidator("domainName", cdk.validateString)(properties.domainName));
  return errors.wrap("supplied properties not correct for \\"DomainSAMPTProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionDomainSAMPTPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionDomainSAMPTPropertyValidator(properties).assertSuccess();
  return {
    "DomainName": cdk.stringToCloudFormation(properties.domainName)
  };
}

// @ts-ignore TS6133
function CfnFunctionDomainSAMPTPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnFunction.DomainSAMPTProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.DomainSAMPTProperty>();
  ret.addPropertyResult("domainName", "DomainName", (properties.DomainName != null ? cfn_parse.FromCloudFormation.getString(properties.DomainName) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`LogGroupSAMPTProperty\`
 *
 * @param properties - the TypeScript properties of a \`LogGroupSAMPTProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionLogGroupSAMPTPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("logGroupName", cdk.requiredValidator)(properties.logGroupName));
  errors.collect(cdk.propertyValidator("logGroupName", cdk.validateString)(properties.logGroupName));
  return errors.wrap("supplied properties not correct for \\"LogGroupSAMPTProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionLogGroupSAMPTPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionLogGroupSAMPTPropertyValidator(properties).assertSuccess();
  return {
    "LogGroupName": cdk.stringToCloudFormation(properties.logGroupName)
  };
}

// @ts-ignore TS6133
function CfnFunctionLogGroupSAMPTPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnFunction.LogGroupSAMPTProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.LogGroupSAMPTProperty>();
  ret.addPropertyResult("logGroupName", "LogGroupName", (properties.LogGroupName != null ? cfn_parse.FromCloudFormation.getString(properties.LogGroupName) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`KeySAMPTProperty\`
 *
 * @param properties - the TypeScript properties of a \`KeySAMPTProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionKeySAMPTPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("keyId", cdk.requiredValidator)(properties.keyId));
  errors.collect(cdk.propertyValidator("keyId", cdk.validateString)(properties.keyId));
  return errors.wrap("supplied properties not correct for \\"KeySAMPTProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionKeySAMPTPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionKeySAMPTPropertyValidator(properties).assertSuccess();
  return {
    "KeyId": cdk.stringToCloudFormation(properties.keyId)
  };
}

// @ts-ignore TS6133
function CfnFunctionKeySAMPTPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnFunction.KeySAMPTProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.KeySAMPTProperty>();
  ret.addPropertyResult("keyId", "KeyId", (properties.KeyId != null ? cfn_parse.FromCloudFormation.getString(properties.KeyId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`StreamSAMPTProperty\`
 *
 * @param properties - the TypeScript properties of a \`StreamSAMPTProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionStreamSAMPTPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("streamName", cdk.requiredValidator)(properties.streamName));
  errors.collect(cdk.propertyValidator("streamName", cdk.validateString)(properties.streamName));
  return errors.wrap("supplied properties not correct for \\"StreamSAMPTProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionStreamSAMPTPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionStreamSAMPTPropertyValidator(properties).assertSuccess();
  return {
    "StreamName": cdk.stringToCloudFormation(properties.streamName)
  };
}

// @ts-ignore TS6133
function CfnFunctionStreamSAMPTPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnFunction.StreamSAMPTProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.StreamSAMPTProperty>();
  ret.addPropertyResult("streamName", "StreamName", (properties.StreamName != null ? cfn_parse.FromCloudFormation.getString(properties.StreamName) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`FunctionSAMPTProperty\`
 *
 * @param properties - the TypeScript properties of a \`FunctionSAMPTProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionFunctionSAMPTPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("functionName", cdk.requiredValidator)(properties.functionName));
  errors.collect(cdk.propertyValidator("functionName", cdk.validateString)(properties.functionName));
  return errors.wrap("supplied properties not correct for \\"FunctionSAMPTProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionFunctionSAMPTPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionFunctionSAMPTPropertyValidator(properties).assertSuccess();
  return {
    "FunctionName": cdk.stringToCloudFormation(properties.functionName)
  };
}

// @ts-ignore TS6133
function CfnFunctionFunctionSAMPTPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnFunction.FunctionSAMPTProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.FunctionSAMPTProperty>();
  ret.addPropertyResult("functionName", "FunctionName", (properties.FunctionName != null ? cfn_parse.FromCloudFormation.getString(properties.FunctionName) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CollectionSAMPTProperty\`
 *
 * @param properties - the TypeScript properties of a \`CollectionSAMPTProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionCollectionSAMPTPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("collectionId", cdk.requiredValidator)(properties.collectionId));
  errors.collect(cdk.propertyValidator("collectionId", cdk.validateString)(properties.collectionId));
  return errors.wrap("supplied properties not correct for \\"CollectionSAMPTProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionCollectionSAMPTPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionCollectionSAMPTPropertyValidator(properties).assertSuccess();
  return {
    "CollectionId": cdk.stringToCloudFormation(properties.collectionId)
  };
}

// @ts-ignore TS6133
function CfnFunctionCollectionSAMPTPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnFunction.CollectionSAMPTProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.CollectionSAMPTProperty>();
  ret.addPropertyResult("collectionId", "CollectionId", (properties.CollectionId != null ? cfn_parse.FromCloudFormation.getString(properties.CollectionId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`BucketSAMPTProperty\`
 *
 * @param properties - the TypeScript properties of a \`BucketSAMPTProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionBucketSAMPTPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("bucketName", cdk.requiredValidator)(properties.bucketName));
  errors.collect(cdk.propertyValidator("bucketName", cdk.validateString)(properties.bucketName));
  return errors.wrap("supplied properties not correct for \\"BucketSAMPTProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionBucketSAMPTPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionBucketSAMPTPropertyValidator(properties).assertSuccess();
  return {
    "BucketName": cdk.stringToCloudFormation(properties.bucketName)
  };
}

// @ts-ignore TS6133
function CfnFunctionBucketSAMPTPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnFunction.BucketSAMPTProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.BucketSAMPTProperty>();
  ret.addPropertyResult("bucketName", "BucketName", (properties.BucketName != null ? cfn_parse.FromCloudFormation.getString(properties.BucketName) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`IdentitySAMPTProperty\`
 *
 * @param properties - the TypeScript properties of a \`IdentitySAMPTProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionIdentitySAMPTPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("identityName", cdk.requiredValidator)(properties.identityName));
  errors.collect(cdk.propertyValidator("identityName", cdk.validateString)(properties.identityName));
  return errors.wrap("supplied properties not correct for \\"IdentitySAMPTProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionIdentitySAMPTPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionIdentitySAMPTPropertyValidator(properties).assertSuccess();
  return {
    "IdentityName": cdk.stringToCloudFormation(properties.identityName)
  };
}

// @ts-ignore TS6133
function CfnFunctionIdentitySAMPTPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnFunction.IdentitySAMPTProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.IdentitySAMPTProperty>();
  ret.addPropertyResult("identityName", "IdentityName", (properties.IdentityName != null ? cfn_parse.FromCloudFormation.getString(properties.IdentityName) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`TopicSAMPTProperty\`
 *
 * @param properties - the TypeScript properties of a \`TopicSAMPTProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionTopicSAMPTPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("topicName", cdk.requiredValidator)(properties.topicName));
  errors.collect(cdk.propertyValidator("topicName", cdk.validateString)(properties.topicName));
  return errors.wrap("supplied properties not correct for \\"TopicSAMPTProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionTopicSAMPTPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionTopicSAMPTPropertyValidator(properties).assertSuccess();
  return {
    "TopicName": cdk.stringToCloudFormation(properties.topicName)
  };
}

// @ts-ignore TS6133
function CfnFunctionTopicSAMPTPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnFunction.TopicSAMPTProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.TopicSAMPTProperty>();
  ret.addPropertyResult("topicName", "TopicName", (properties.TopicName != null ? cfn_parse.FromCloudFormation.getString(properties.TopicName) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`QueueSAMPTProperty\`
 *
 * @param properties - the TypeScript properties of a \`QueueSAMPTProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionQueueSAMPTPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("queueName", cdk.requiredValidator)(properties.queueName));
  errors.collect(cdk.propertyValidator("queueName", cdk.validateString)(properties.queueName));
  return errors.wrap("supplied properties not correct for \\"QueueSAMPTProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionQueueSAMPTPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionQueueSAMPTPropertyValidator(properties).assertSuccess();
  return {
    "QueueName": cdk.stringToCloudFormation(properties.queueName)
  };
}

// @ts-ignore TS6133
function CfnFunctionQueueSAMPTPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnFunction.QueueSAMPTProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.QueueSAMPTProperty>();
  ret.addPropertyResult("queueName", "QueueName", (properties.QueueName != null ? cfn_parse.FromCloudFormation.getString(properties.QueueName) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ParameterNameSAMPTProperty\`
 *
 * @param properties - the TypeScript properties of a \`ParameterNameSAMPTProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionParameterNameSAMPTPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("parameterName", cdk.requiredValidator)(properties.parameterName));
  errors.collect(cdk.propertyValidator("parameterName", cdk.validateString)(properties.parameterName));
  return errors.wrap("supplied properties not correct for \\"ParameterNameSAMPTProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionParameterNameSAMPTPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionParameterNameSAMPTPropertyValidator(properties).assertSuccess();
  return {
    "ParameterName": cdk.stringToCloudFormation(properties.parameterName)
  };
}

// @ts-ignore TS6133
function CfnFunctionParameterNameSAMPTPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnFunction.ParameterNameSAMPTProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.ParameterNameSAMPTProperty>();
  ret.addPropertyResult("parameterName", "ParameterName", (properties.ParameterName != null ? cfn_parse.FromCloudFormation.getString(properties.ParameterName) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`StateMachineSAMPTProperty\`
 *
 * @param properties - the TypeScript properties of a \`StateMachineSAMPTProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionStateMachineSAMPTPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("stateMachineName", cdk.requiredValidator)(properties.stateMachineName));
  errors.collect(cdk.propertyValidator("stateMachineName", cdk.validateString)(properties.stateMachineName));
  return errors.wrap("supplied properties not correct for \\"StateMachineSAMPTProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionStateMachineSAMPTPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionStateMachineSAMPTPropertyValidator(properties).assertSuccess();
  return {
    "StateMachineName": cdk.stringToCloudFormation(properties.stateMachineName)
  };
}

// @ts-ignore TS6133
function CfnFunctionStateMachineSAMPTPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnFunction.StateMachineSAMPTProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.StateMachineSAMPTProperty>();
  ret.addPropertyResult("stateMachineName", "StateMachineName", (properties.StateMachineName != null ? cfn_parse.FromCloudFormation.getString(properties.StateMachineName) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`SAMPolicyTemplateProperty\`
 *
 * @param properties - the TypeScript properties of a \`SAMPolicyTemplateProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionSAMPolicyTemplatePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("amiDescribePolicy", CfnFunctionEmptySAMPTPropertyValidator)(properties.amiDescribePolicy));
  errors.collect(cdk.propertyValidator("awsSecretsManagerGetSecretValuePolicy", CfnFunctionSecretArnSAMPTPropertyValidator)(properties.awsSecretsManagerGetSecretValuePolicy));
  errors.collect(cdk.propertyValidator("cloudFormationDescribeStacksPolicy", CfnFunctionEmptySAMPTPropertyValidator)(properties.cloudFormationDescribeStacksPolicy));
  errors.collect(cdk.propertyValidator("cloudWatchPutMetricPolicy", CfnFunctionEmptySAMPTPropertyValidator)(properties.cloudWatchPutMetricPolicy));
  errors.collect(cdk.propertyValidator("dynamoDbCrudPolicy", CfnFunctionTableSAMPTPropertyValidator)(properties.dynamoDbCrudPolicy));
  errors.collect(cdk.propertyValidator("dynamoDbReadPolicy", CfnFunctionTableSAMPTPropertyValidator)(properties.dynamoDbReadPolicy));
  errors.collect(cdk.propertyValidator("dynamoDbStreamReadPolicy", CfnFunctionTableStreamSAMPTPropertyValidator)(properties.dynamoDbStreamReadPolicy));
  errors.collect(cdk.propertyValidator("dynamoDbWritePolicy", CfnFunctionTableSAMPTPropertyValidator)(properties.dynamoDbWritePolicy));
  errors.collect(cdk.propertyValidator("ec2DescribePolicy", CfnFunctionEmptySAMPTPropertyValidator)(properties.ec2DescribePolicy));
  errors.collect(cdk.propertyValidator("elasticsearchHttpPostPolicy", CfnFunctionDomainSAMPTPropertyValidator)(properties.elasticsearchHttpPostPolicy));
  errors.collect(cdk.propertyValidator("filterLogEventsPolicy", CfnFunctionLogGroupSAMPTPropertyValidator)(properties.filterLogEventsPolicy));
  errors.collect(cdk.propertyValidator("kmsDecryptPolicy", CfnFunctionKeySAMPTPropertyValidator)(properties.kmsDecryptPolicy));
  errors.collect(cdk.propertyValidator("kinesisCrudPolicy", CfnFunctionStreamSAMPTPropertyValidator)(properties.kinesisCrudPolicy));
  errors.collect(cdk.propertyValidator("kinesisStreamReadPolicy", CfnFunctionStreamSAMPTPropertyValidator)(properties.kinesisStreamReadPolicy));
  errors.collect(cdk.propertyValidator("lambdaInvokePolicy", CfnFunctionFunctionSAMPTPropertyValidator)(properties.lambdaInvokePolicy));
  errors.collect(cdk.propertyValidator("rekognitionDetectOnlyPolicy", CfnFunctionEmptySAMPTPropertyValidator)(properties.rekognitionDetectOnlyPolicy));
  errors.collect(cdk.propertyValidator("rekognitionLabelsPolicy", CfnFunctionEmptySAMPTPropertyValidator)(properties.rekognitionLabelsPolicy));
  errors.collect(cdk.propertyValidator("rekognitionNoDataAccessPolicy", CfnFunctionCollectionSAMPTPropertyValidator)(properties.rekognitionNoDataAccessPolicy));
  errors.collect(cdk.propertyValidator("rekognitionReadPolicy", CfnFunctionCollectionSAMPTPropertyValidator)(properties.rekognitionReadPolicy));
  errors.collect(cdk.propertyValidator("rekognitionWriteOnlyAccessPolicy", CfnFunctionCollectionSAMPTPropertyValidator)(properties.rekognitionWriteOnlyAccessPolicy));
  errors.collect(cdk.propertyValidator("s3CrudPolicy", CfnFunctionBucketSAMPTPropertyValidator)(properties.s3CrudPolicy));
  errors.collect(cdk.propertyValidator("s3ReadPolicy", CfnFunctionBucketSAMPTPropertyValidator)(properties.s3ReadPolicy));
  errors.collect(cdk.propertyValidator("s3WritePolicy", CfnFunctionBucketSAMPTPropertyValidator)(properties.s3WritePolicy));
  errors.collect(cdk.propertyValidator("sesBulkTemplatedCrudPolicy", CfnFunctionIdentitySAMPTPropertyValidator)(properties.sesBulkTemplatedCrudPolicy));
  errors.collect(cdk.propertyValidator("sesCrudPolicy", CfnFunctionIdentitySAMPTPropertyValidator)(properties.sesCrudPolicy));
  errors.collect(cdk.propertyValidator("sesEmailTemplateCrudPolicy", CfnFunctionEmptySAMPTPropertyValidator)(properties.sesEmailTemplateCrudPolicy));
  errors.collect(cdk.propertyValidator("sesSendBouncePolicy", CfnFunctionIdentitySAMPTPropertyValidator)(properties.sesSendBouncePolicy));
  errors.collect(cdk.propertyValidator("snsCrudPolicy", CfnFunctionTopicSAMPTPropertyValidator)(properties.snsCrudPolicy));
  errors.collect(cdk.propertyValidator("snsPublishMessagePolicy", CfnFunctionTopicSAMPTPropertyValidator)(properties.snsPublishMessagePolicy));
  errors.collect(cdk.propertyValidator("sqsPollerPolicy", CfnFunctionQueueSAMPTPropertyValidator)(properties.sqsPollerPolicy));
  errors.collect(cdk.propertyValidator("sqsSendMessagePolicy", CfnFunctionQueueSAMPTPropertyValidator)(properties.sqsSendMessagePolicy));
  errors.collect(cdk.propertyValidator("ssmParameterReadPolicy", CfnFunctionParameterNameSAMPTPropertyValidator)(properties.ssmParameterReadPolicy));
  errors.collect(cdk.propertyValidator("stepFunctionsExecutionPolicy", CfnFunctionStateMachineSAMPTPropertyValidator)(properties.stepFunctionsExecutionPolicy));
  errors.collect(cdk.propertyValidator("vpcAccessPolicy", CfnFunctionEmptySAMPTPropertyValidator)(properties.vpcAccessPolicy));
  return errors.wrap("supplied properties not correct for \\"SAMPolicyTemplateProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionSAMPolicyTemplatePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionSAMPolicyTemplatePropertyValidator(properties).assertSuccess();
  return {
    "AMIDescribePolicy": convertCfnFunctionEmptySAMPTPropertyToCloudFormation(properties.amiDescribePolicy),
    "AWSSecretsManagerGetSecretValuePolicy": convertCfnFunctionSecretArnSAMPTPropertyToCloudFormation(properties.awsSecretsManagerGetSecretValuePolicy),
    "CloudFormationDescribeStacksPolicy": convertCfnFunctionEmptySAMPTPropertyToCloudFormation(properties.cloudFormationDescribeStacksPolicy),
    "CloudWatchPutMetricPolicy": convertCfnFunctionEmptySAMPTPropertyToCloudFormation(properties.cloudWatchPutMetricPolicy),
    "DynamoDBCrudPolicy": convertCfnFunctionTableSAMPTPropertyToCloudFormation(properties.dynamoDbCrudPolicy),
    "DynamoDBReadPolicy": convertCfnFunctionTableSAMPTPropertyToCloudFormation(properties.dynamoDbReadPolicy),
    "DynamoDBStreamReadPolicy": convertCfnFunctionTableStreamSAMPTPropertyToCloudFormation(properties.dynamoDbStreamReadPolicy),
    "DynamoDBWritePolicy": convertCfnFunctionTableSAMPTPropertyToCloudFormation(properties.dynamoDbWritePolicy),
    "EC2DescribePolicy": convertCfnFunctionEmptySAMPTPropertyToCloudFormation(properties.ec2DescribePolicy),
    "ElasticsearchHttpPostPolicy": convertCfnFunctionDomainSAMPTPropertyToCloudFormation(properties.elasticsearchHttpPostPolicy),
    "FilterLogEventsPolicy": convertCfnFunctionLogGroupSAMPTPropertyToCloudFormation(properties.filterLogEventsPolicy),
    "KMSDecryptPolicy": convertCfnFunctionKeySAMPTPropertyToCloudFormation(properties.kmsDecryptPolicy),
    "KinesisCrudPolicy": convertCfnFunctionStreamSAMPTPropertyToCloudFormation(properties.kinesisCrudPolicy),
    "KinesisStreamReadPolicy": convertCfnFunctionStreamSAMPTPropertyToCloudFormation(properties.kinesisStreamReadPolicy),
    "LambdaInvokePolicy": convertCfnFunctionFunctionSAMPTPropertyToCloudFormation(properties.lambdaInvokePolicy),
    "RekognitionDetectOnlyPolicy": convertCfnFunctionEmptySAMPTPropertyToCloudFormation(properties.rekognitionDetectOnlyPolicy),
    "RekognitionLabelsPolicy": convertCfnFunctionEmptySAMPTPropertyToCloudFormation(properties.rekognitionLabelsPolicy),
    "RekognitionNoDataAccessPolicy": convertCfnFunctionCollectionSAMPTPropertyToCloudFormation(properties.rekognitionNoDataAccessPolicy),
    "RekognitionReadPolicy": convertCfnFunctionCollectionSAMPTPropertyToCloudFormation(properties.rekognitionReadPolicy),
    "RekognitionWriteOnlyAccessPolicy": convertCfnFunctionCollectionSAMPTPropertyToCloudFormation(properties.rekognitionWriteOnlyAccessPolicy),
    "S3CrudPolicy": convertCfnFunctionBucketSAMPTPropertyToCloudFormation(properties.s3CrudPolicy),
    "S3ReadPolicy": convertCfnFunctionBucketSAMPTPropertyToCloudFormation(properties.s3ReadPolicy),
    "S3WritePolicy": convertCfnFunctionBucketSAMPTPropertyToCloudFormation(properties.s3WritePolicy),
    "SESBulkTemplatedCrudPolicy": convertCfnFunctionIdentitySAMPTPropertyToCloudFormation(properties.sesBulkTemplatedCrudPolicy),
    "SESCrudPolicy": convertCfnFunctionIdentitySAMPTPropertyToCloudFormation(properties.sesCrudPolicy),
    "SESEmailTemplateCrudPolicy": convertCfnFunctionEmptySAMPTPropertyToCloudFormation(properties.sesEmailTemplateCrudPolicy),
    "SESSendBouncePolicy": convertCfnFunctionIdentitySAMPTPropertyToCloudFormation(properties.sesSendBouncePolicy),
    "SNSCrudPolicy": convertCfnFunctionTopicSAMPTPropertyToCloudFormation(properties.snsCrudPolicy),
    "SNSPublishMessagePolicy": convertCfnFunctionTopicSAMPTPropertyToCloudFormation(properties.snsPublishMessagePolicy),
    "SQSPollerPolicy": convertCfnFunctionQueueSAMPTPropertyToCloudFormation(properties.sqsPollerPolicy),
    "SQSSendMessagePolicy": convertCfnFunctionQueueSAMPTPropertyToCloudFormation(properties.sqsSendMessagePolicy),
    "SSMParameterReadPolicy": convertCfnFunctionParameterNameSAMPTPropertyToCloudFormation(properties.ssmParameterReadPolicy),
    "StepFunctionsExecutionPolicy": convertCfnFunctionStateMachineSAMPTPropertyToCloudFormation(properties.stepFunctionsExecutionPolicy),
    "VPCAccessPolicy": convertCfnFunctionEmptySAMPTPropertyToCloudFormation(properties.vpcAccessPolicy)
  };
}

// @ts-ignore TS6133
function CfnFunctionSAMPolicyTemplatePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnFunction.SAMPolicyTemplateProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.SAMPolicyTemplateProperty>();
  ret.addPropertyResult("amiDescribePolicy", "AMIDescribePolicy", (properties.AMIDescribePolicy != null ? CfnFunctionEmptySAMPTPropertyFromCloudFormation(properties.AMIDescribePolicy) : undefined));
  ret.addPropertyResult("awsSecretsManagerGetSecretValuePolicy", "AWSSecretsManagerGetSecretValuePolicy", (properties.AWSSecretsManagerGetSecretValuePolicy != null ? CfnFunctionSecretArnSAMPTPropertyFromCloudFormation(properties.AWSSecretsManagerGetSecretValuePolicy) : undefined));
  ret.addPropertyResult("cloudFormationDescribeStacksPolicy", "CloudFormationDescribeStacksPolicy", (properties.CloudFormationDescribeStacksPolicy != null ? CfnFunctionEmptySAMPTPropertyFromCloudFormation(properties.CloudFormationDescribeStacksPolicy) : undefined));
  ret.addPropertyResult("cloudWatchPutMetricPolicy", "CloudWatchPutMetricPolicy", (properties.CloudWatchPutMetricPolicy != null ? CfnFunctionEmptySAMPTPropertyFromCloudFormation(properties.CloudWatchPutMetricPolicy) : undefined));
  ret.addPropertyResult("dynamoDbCrudPolicy", "DynamoDBCrudPolicy", (properties.DynamoDBCrudPolicy != null ? CfnFunctionTableSAMPTPropertyFromCloudFormation(properties.DynamoDBCrudPolicy) : undefined));
  ret.addPropertyResult("dynamoDbReadPolicy", "DynamoDBReadPolicy", (properties.DynamoDBReadPolicy != null ? CfnFunctionTableSAMPTPropertyFromCloudFormation(properties.DynamoDBReadPolicy) : undefined));
  ret.addPropertyResult("dynamoDbStreamReadPolicy", "DynamoDBStreamReadPolicy", (properties.DynamoDBStreamReadPolicy != null ? CfnFunctionTableStreamSAMPTPropertyFromCloudFormation(properties.DynamoDBStreamReadPolicy) : undefined));
  ret.addPropertyResult("dynamoDbWritePolicy", "DynamoDBWritePolicy", (properties.DynamoDBWritePolicy != null ? CfnFunctionTableSAMPTPropertyFromCloudFormation(properties.DynamoDBWritePolicy) : undefined));
  ret.addPropertyResult("ec2DescribePolicy", "EC2DescribePolicy", (properties.EC2DescribePolicy != null ? CfnFunctionEmptySAMPTPropertyFromCloudFormation(properties.EC2DescribePolicy) : undefined));
  ret.addPropertyResult("elasticsearchHttpPostPolicy", "ElasticsearchHttpPostPolicy", (properties.ElasticsearchHttpPostPolicy != null ? CfnFunctionDomainSAMPTPropertyFromCloudFormation(properties.ElasticsearchHttpPostPolicy) : undefined));
  ret.addPropertyResult("filterLogEventsPolicy", "FilterLogEventsPolicy", (properties.FilterLogEventsPolicy != null ? CfnFunctionLogGroupSAMPTPropertyFromCloudFormation(properties.FilterLogEventsPolicy) : undefined));
  ret.addPropertyResult("kinesisCrudPolicy", "KinesisCrudPolicy", (properties.KinesisCrudPolicy != null ? CfnFunctionStreamSAMPTPropertyFromCloudFormation(properties.KinesisCrudPolicy) : undefined));
  ret.addPropertyResult("kinesisStreamReadPolicy", "KinesisStreamReadPolicy", (properties.KinesisStreamReadPolicy != null ? CfnFunctionStreamSAMPTPropertyFromCloudFormation(properties.KinesisStreamReadPolicy) : undefined));
  ret.addPropertyResult("kmsDecryptPolicy", "KMSDecryptPolicy", (properties.KMSDecryptPolicy != null ? CfnFunctionKeySAMPTPropertyFromCloudFormation(properties.KMSDecryptPolicy) : undefined));
  ret.addPropertyResult("lambdaInvokePolicy", "LambdaInvokePolicy", (properties.LambdaInvokePolicy != null ? CfnFunctionFunctionSAMPTPropertyFromCloudFormation(properties.LambdaInvokePolicy) : undefined));
  ret.addPropertyResult("rekognitionDetectOnlyPolicy", "RekognitionDetectOnlyPolicy", (properties.RekognitionDetectOnlyPolicy != null ? CfnFunctionEmptySAMPTPropertyFromCloudFormation(properties.RekognitionDetectOnlyPolicy) : undefined));
  ret.addPropertyResult("rekognitionLabelsPolicy", "RekognitionLabelsPolicy", (properties.RekognitionLabelsPolicy != null ? CfnFunctionEmptySAMPTPropertyFromCloudFormation(properties.RekognitionLabelsPolicy) : undefined));
  ret.addPropertyResult("rekognitionNoDataAccessPolicy", "RekognitionNoDataAccessPolicy", (properties.RekognitionNoDataAccessPolicy != null ? CfnFunctionCollectionSAMPTPropertyFromCloudFormation(properties.RekognitionNoDataAccessPolicy) : undefined));
  ret.addPropertyResult("rekognitionReadPolicy", "RekognitionReadPolicy", (properties.RekognitionReadPolicy != null ? CfnFunctionCollectionSAMPTPropertyFromCloudFormation(properties.RekognitionReadPolicy) : undefined));
  ret.addPropertyResult("rekognitionWriteOnlyAccessPolicy", "RekognitionWriteOnlyAccessPolicy", (properties.RekognitionWriteOnlyAccessPolicy != null ? CfnFunctionCollectionSAMPTPropertyFromCloudFormation(properties.RekognitionWriteOnlyAccessPolicy) : undefined));
  ret.addPropertyResult("s3CrudPolicy", "S3CrudPolicy", (properties.S3CrudPolicy != null ? CfnFunctionBucketSAMPTPropertyFromCloudFormation(properties.S3CrudPolicy) : undefined));
  ret.addPropertyResult("s3ReadPolicy", "S3ReadPolicy", (properties.S3ReadPolicy != null ? CfnFunctionBucketSAMPTPropertyFromCloudFormation(properties.S3ReadPolicy) : undefined));
  ret.addPropertyResult("s3WritePolicy", "S3WritePolicy", (properties.S3WritePolicy != null ? CfnFunctionBucketSAMPTPropertyFromCloudFormation(properties.S3WritePolicy) : undefined));
  ret.addPropertyResult("sesBulkTemplatedCrudPolicy", "SESBulkTemplatedCrudPolicy", (properties.SESBulkTemplatedCrudPolicy != null ? CfnFunctionIdentitySAMPTPropertyFromCloudFormation(properties.SESBulkTemplatedCrudPolicy) : undefined));
  ret.addPropertyResult("sesCrudPolicy", "SESCrudPolicy", (properties.SESCrudPolicy != null ? CfnFunctionIdentitySAMPTPropertyFromCloudFormation(properties.SESCrudPolicy) : undefined));
  ret.addPropertyResult("sesEmailTemplateCrudPolicy", "SESEmailTemplateCrudPolicy", (properties.SESEmailTemplateCrudPolicy != null ? CfnFunctionEmptySAMPTPropertyFromCloudFormation(properties.SESEmailTemplateCrudPolicy) : undefined));
  ret.addPropertyResult("sesSendBouncePolicy", "SESSendBouncePolicy", (properties.SESSendBouncePolicy != null ? CfnFunctionIdentitySAMPTPropertyFromCloudFormation(properties.SESSendBouncePolicy) : undefined));
  ret.addPropertyResult("snsCrudPolicy", "SNSCrudPolicy", (properties.SNSCrudPolicy != null ? CfnFunctionTopicSAMPTPropertyFromCloudFormation(properties.SNSCrudPolicy) : undefined));
  ret.addPropertyResult("snsPublishMessagePolicy", "SNSPublishMessagePolicy", (properties.SNSPublishMessagePolicy != null ? CfnFunctionTopicSAMPTPropertyFromCloudFormation(properties.SNSPublishMessagePolicy) : undefined));
  ret.addPropertyResult("sqsPollerPolicy", "SQSPollerPolicy", (properties.SQSPollerPolicy != null ? CfnFunctionQueueSAMPTPropertyFromCloudFormation(properties.SQSPollerPolicy) : undefined));
  ret.addPropertyResult("sqsSendMessagePolicy", "SQSSendMessagePolicy", (properties.SQSSendMessagePolicy != null ? CfnFunctionQueueSAMPTPropertyFromCloudFormation(properties.SQSSendMessagePolicy) : undefined));
  ret.addPropertyResult("ssmParameterReadPolicy", "SSMParameterReadPolicy", (properties.SSMParameterReadPolicy != null ? CfnFunctionParameterNameSAMPTPropertyFromCloudFormation(properties.SSMParameterReadPolicy) : undefined));
  ret.addPropertyResult("stepFunctionsExecutionPolicy", "StepFunctionsExecutionPolicy", (properties.StepFunctionsExecutionPolicy != null ? CfnFunctionStateMachineSAMPTPropertyFromCloudFormation(properties.StepFunctionsExecutionPolicy) : undefined));
  ret.addPropertyResult("vpcAccessPolicy", "VPCAccessPolicy", (properties.VPCAccessPolicy != null ? CfnFunctionEmptySAMPTPropertyFromCloudFormation(properties.VPCAccessPolicy) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ProvisionedConcurrencyConfigProperty\`
 *
 * @param properties - the TypeScript properties of a \`ProvisionedConcurrencyConfigProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionProvisionedConcurrencyConfigPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("provisionedConcurrentExecutions", cdk.requiredValidator)(properties.provisionedConcurrentExecutions));
  errors.collect(cdk.propertyValidator("provisionedConcurrentExecutions", cdk.validateString)(properties.provisionedConcurrentExecutions));
  return errors.wrap("supplied properties not correct for \\"ProvisionedConcurrencyConfigProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionProvisionedConcurrencyConfigPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionProvisionedConcurrencyConfigPropertyValidator(properties).assertSuccess();
  return {
    "ProvisionedConcurrentExecutions": cdk.stringToCloudFormation(properties.provisionedConcurrentExecutions)
  };
}

// @ts-ignore TS6133
function CfnFunctionProvisionedConcurrencyConfigPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnFunction.ProvisionedConcurrencyConfigProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.ProvisionedConcurrencyConfigProperty>();
  ret.addPropertyResult("provisionedConcurrentExecutions", "ProvisionedConcurrentExecutions", (properties.ProvisionedConcurrentExecutions != null ? cfn_parse.FromCloudFormation.getString(properties.ProvisionedConcurrentExecutions) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`VpcConfigProperty\`
 *
 * @param properties - the TypeScript properties of a \`VpcConfigProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionVpcConfigPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("securityGroupIds", cdk.requiredValidator)(properties.securityGroupIds));
  errors.collect(cdk.propertyValidator("securityGroupIds", cdk.listValidator(cdk.validateString))(properties.securityGroupIds));
  errors.collect(cdk.propertyValidator("subnetIds", cdk.requiredValidator)(properties.subnetIds));
  errors.collect(cdk.propertyValidator("subnetIds", cdk.listValidator(cdk.validateString))(properties.subnetIds));
  return errors.wrap("supplied properties not correct for \\"VpcConfigProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionVpcConfigPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionVpcConfigPropertyValidator(properties).assertSuccess();
  return {
    "SecurityGroupIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.securityGroupIds),
    "SubnetIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.subnetIds)
  };
}

// @ts-ignore TS6133
function CfnFunctionVpcConfigPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnFunction.VpcConfigProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.VpcConfigProperty>();
  ret.addPropertyResult("securityGroupIds", "SecurityGroupIds", (properties.SecurityGroupIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecurityGroupIds) : undefined));
  ret.addPropertyResult("subnetIds", "SubnetIds", (properties.SubnetIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SubnetIds) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnFunctionProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnFunctionProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("architectures", cdk.listValidator(cdk.validateString))(properties.architectures));
  errors.collect(cdk.propertyValidator("assumeRolePolicyDocument", cdk.validateObject)(properties.assumeRolePolicyDocument));
  errors.collect(cdk.propertyValidator("autoPublishAlias", cdk.validateString)(properties.autoPublishAlias));
  errors.collect(cdk.propertyValidator("autoPublishCodeSha256", cdk.validateString)(properties.autoPublishCodeSha256));
  errors.collect(cdk.propertyValidator("codeSigningConfigArn", cdk.validateString)(properties.codeSigningConfigArn));
  errors.collect(cdk.propertyValidator("codeUri", cdk.unionValidator(CfnFunctionS3LocationPropertyValidator, cdk.validateString))(properties.codeUri));
  errors.collect(cdk.propertyValidator("deadLetterQueue", CfnFunctionDeadLetterQueuePropertyValidator)(properties.deadLetterQueue));
  errors.collect(cdk.propertyValidator("deploymentPreference", CfnFunctionDeploymentPreferencePropertyValidator)(properties.deploymentPreference));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("environment", CfnFunctionFunctionEnvironmentPropertyValidator)(properties.environment));
  errors.collect(cdk.propertyValidator("eventInvokeConfig", CfnFunctionEventInvokeConfigPropertyValidator)(properties.eventInvokeConfig));
  errors.collect(cdk.propertyValidator("events", cdk.hashValidator(CfnFunctionEventSourcePropertyValidator))(properties.events));
  errors.collect(cdk.propertyValidator("fileSystemConfigs", cdk.listValidator(CfnFunctionFileSystemConfigPropertyValidator))(properties.fileSystemConfigs));
  errors.collect(cdk.propertyValidator("functionName", cdk.validateString)(properties.functionName));
  errors.collect(cdk.propertyValidator("handler", cdk.validateString)(properties.handler));
  errors.collect(cdk.propertyValidator("imageConfig", CfnFunctionImageConfigPropertyValidator)(properties.imageConfig));
  errors.collect(cdk.propertyValidator("imageUri", cdk.validateString)(properties.imageUri));
  errors.collect(cdk.propertyValidator("inlineCode", cdk.validateString)(properties.inlineCode));
  errors.collect(cdk.propertyValidator("kmsKeyArn", cdk.validateString)(properties.kmsKeyArn));
  errors.collect(cdk.propertyValidator("layers", cdk.listValidator(cdk.validateString))(properties.layers));
  errors.collect(cdk.propertyValidator("memorySize", cdk.validateNumber)(properties.memorySize));
  errors.collect(cdk.propertyValidator("packageType", cdk.validateString)(properties.packageType));
  errors.collect(cdk.propertyValidator("permissionsBoundary", cdk.validateString)(properties.permissionsBoundary));
  errors.collect(cdk.propertyValidator("policies", cdk.unionValidator(cdk.listValidator(cdk.unionValidator(CfnFunctionIAMPolicyDocumentPropertyValidator, CfnFunctionSAMPolicyTemplatePropertyValidator, cdk.validateString)), CfnFunctionIAMPolicyDocumentPropertyValidator, cdk.validateString))(properties.policies));
  errors.collect(cdk.propertyValidator("provisionedConcurrencyConfig", CfnFunctionProvisionedConcurrencyConfigPropertyValidator)(properties.provisionedConcurrencyConfig));
  errors.collect(cdk.propertyValidator("reservedConcurrentExecutions", cdk.validateNumber)(properties.reservedConcurrentExecutions));
  errors.collect(cdk.propertyValidator("role", cdk.validateString)(properties.role));
  errors.collect(cdk.propertyValidator("runtime", cdk.validateString)(properties.runtime));
  errors.collect(cdk.propertyValidator("tags", cdk.hashValidator(cdk.validateString))(properties.tags));
  errors.collect(cdk.propertyValidator("timeout", cdk.validateNumber)(properties.timeout));
  errors.collect(cdk.propertyValidator("tracing", cdk.validateString)(properties.tracing));
  errors.collect(cdk.propertyValidator("versionDescription", cdk.validateString)(properties.versionDescription));
  errors.collect(cdk.propertyValidator("vpcConfig", CfnFunctionVpcConfigPropertyValidator)(properties.vpcConfig));
  return errors.wrap("supplied properties not correct for \\"CfnFunctionProps\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionPropsValidator(properties).assertSuccess();
  return {
    "Architectures": cdk.listMapper(cdk.stringToCloudFormation)(properties.architectures),
    "AssumeRolePolicyDocument": cdk.objectToCloudFormation(properties.assumeRolePolicyDocument),
    "AutoPublishAlias": cdk.stringToCloudFormation(properties.autoPublishAlias),
    "AutoPublishCodeSha256": cdk.stringToCloudFormation(properties.autoPublishCodeSha256),
    "CodeSigningConfigArn": cdk.stringToCloudFormation(properties.codeSigningConfigArn),
    "CodeUri": cdk.unionMapper([CfnFunctionS3LocationPropertyValidator, cdk.validateString], [convertCfnFunctionS3LocationPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.codeUri),
    "DeadLetterQueue": convertCfnFunctionDeadLetterQueuePropertyToCloudFormation(properties.deadLetterQueue),
    "DeploymentPreference": convertCfnFunctionDeploymentPreferencePropertyToCloudFormation(properties.deploymentPreference),
    "Description": cdk.stringToCloudFormation(properties.description),
    "Environment": convertCfnFunctionFunctionEnvironmentPropertyToCloudFormation(properties.environment),
    "EventInvokeConfig": convertCfnFunctionEventInvokeConfigPropertyToCloudFormation(properties.eventInvokeConfig),
    "Events": cdk.hashMapper(convertCfnFunctionEventSourcePropertyToCloudFormation)(properties.events),
    "FileSystemConfigs": cdk.listMapper(convertCfnFunctionFileSystemConfigPropertyToCloudFormation)(properties.fileSystemConfigs),
    "FunctionName": cdk.stringToCloudFormation(properties.functionName),
    "Handler": cdk.stringToCloudFormation(properties.handler),
    "ImageConfig": convertCfnFunctionImageConfigPropertyToCloudFormation(properties.imageConfig),
    "ImageUri": cdk.stringToCloudFormation(properties.imageUri),
    "InlineCode": cdk.stringToCloudFormation(properties.inlineCode),
    "KmsKeyArn": cdk.stringToCloudFormation(properties.kmsKeyArn),
    "Layers": cdk.listMapper(cdk.stringToCloudFormation)(properties.layers),
    "MemorySize": cdk.numberToCloudFormation(properties.memorySize),
    "PackageType": cdk.stringToCloudFormation(properties.packageType),
    "PermissionsBoundary": cdk.stringToCloudFormation(properties.permissionsBoundary),
    "Policies": cdk.unionMapper([cdk.listValidator(cdk.unionValidator(CfnFunctionIAMPolicyDocumentPropertyValidator, CfnFunctionSAMPolicyTemplatePropertyValidator, cdk.validateString)), CfnFunctionIAMPolicyDocumentPropertyValidator, cdk.validateString], [cdk.listMapper(cdk.unionMapper([CfnFunctionIAMPolicyDocumentPropertyValidator, CfnFunctionSAMPolicyTemplatePropertyValidator, cdk.validateString], [convertCfnFunctionIAMPolicyDocumentPropertyToCloudFormation, convertCfnFunctionSAMPolicyTemplatePropertyToCloudFormation, cdk.stringToCloudFormation])), convertCfnFunctionIAMPolicyDocumentPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.policies),
    "ProvisionedConcurrencyConfig": convertCfnFunctionProvisionedConcurrencyConfigPropertyToCloudFormation(properties.provisionedConcurrencyConfig),
    "ReservedConcurrentExecutions": cdk.numberToCloudFormation(properties.reservedConcurrentExecutions),
    "Role": cdk.stringToCloudFormation(properties.role),
    "Runtime": cdk.stringToCloudFormation(properties.runtime),
    "Tags": cdk.hashMapper(cdk.stringToCloudFormation)(properties.tags),
    "Timeout": cdk.numberToCloudFormation(properties.timeout),
    "Tracing": cdk.stringToCloudFormation(properties.tracing),
    "VersionDescription": cdk.stringToCloudFormation(properties.versionDescription),
    "VpcConfig": convertCfnFunctionVpcConfigPropertyToCloudFormation(properties.vpcConfig)
  };
}

// @ts-ignore TS6133
function CfnFunctionPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnFunctionProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunctionProps>();
  ret.addPropertyResult("architectures", "Architectures", (properties.Architectures != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.Architectures) : undefined));
  ret.addPropertyResult("assumeRolePolicyDocument", "AssumeRolePolicyDocument", (properties.AssumeRolePolicyDocument != null ? cfn_parse.FromCloudFormation.getAny(properties.AssumeRolePolicyDocument) : undefined));
  ret.addPropertyResult("autoPublishAlias", "AutoPublishAlias", (properties.AutoPublishAlias != null ? cfn_parse.FromCloudFormation.getString(properties.AutoPublishAlias) : undefined));
  ret.addPropertyResult("autoPublishCodeSha256", "AutoPublishCodeSha256", (properties.AutoPublishCodeSha256 != null ? cfn_parse.FromCloudFormation.getString(properties.AutoPublishCodeSha256) : undefined));
  ret.addPropertyResult("codeSigningConfigArn", "CodeSigningConfigArn", (properties.CodeSigningConfigArn != null ? cfn_parse.FromCloudFormation.getString(properties.CodeSigningConfigArn) : undefined));
  ret.addPropertyResult("codeUri", "CodeUri", (properties.CodeUri != null ? cfn_parse.FromCloudFormation.getTypeUnion([CfnFunctionS3LocationPropertyValidator, cdk.validateString], [CfnFunctionS3LocationPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.CodeUri) : undefined));
  ret.addPropertyResult("deadLetterQueue", "DeadLetterQueue", (properties.DeadLetterQueue != null ? CfnFunctionDeadLetterQueuePropertyFromCloudFormation(properties.DeadLetterQueue) : undefined));
  ret.addPropertyResult("deploymentPreference", "DeploymentPreference", (properties.DeploymentPreference != null ? CfnFunctionDeploymentPreferencePropertyFromCloudFormation(properties.DeploymentPreference) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("environment", "Environment", (properties.Environment != null ? CfnFunctionFunctionEnvironmentPropertyFromCloudFormation(properties.Environment) : undefined));
  ret.addPropertyResult("eventInvokeConfig", "EventInvokeConfig", (properties.EventInvokeConfig != null ? CfnFunctionEventInvokeConfigPropertyFromCloudFormation(properties.EventInvokeConfig) : undefined));
  ret.addPropertyResult("events", "Events", (properties.Events != null ? cfn_parse.FromCloudFormation.getMap(CfnFunctionEventSourcePropertyFromCloudFormation)(properties.Events) : undefined));
  ret.addPropertyResult("fileSystemConfigs", "FileSystemConfigs", (properties.FileSystemConfigs != null ? cfn_parse.FromCloudFormation.getArray(CfnFunctionFileSystemConfigPropertyFromCloudFormation)(properties.FileSystemConfigs) : undefined));
  ret.addPropertyResult("functionName", "FunctionName", (properties.FunctionName != null ? cfn_parse.FromCloudFormation.getString(properties.FunctionName) : undefined));
  ret.addPropertyResult("handler", "Handler", (properties.Handler != null ? cfn_parse.FromCloudFormation.getString(properties.Handler) : undefined));
  ret.addPropertyResult("imageConfig", "ImageConfig", (properties.ImageConfig != null ? CfnFunctionImageConfigPropertyFromCloudFormation(properties.ImageConfig) : undefined));
  ret.addPropertyResult("imageUri", "ImageUri", (properties.ImageUri != null ? cfn_parse.FromCloudFormation.getString(properties.ImageUri) : undefined));
  ret.addPropertyResult("inlineCode", "InlineCode", (properties.InlineCode != null ? cfn_parse.FromCloudFormation.getString(properties.InlineCode) : undefined));
  ret.addPropertyResult("kmsKeyArn", "KmsKeyArn", (properties.KmsKeyArn != null ? cfn_parse.FromCloudFormation.getString(properties.KmsKeyArn) : undefined));
  ret.addPropertyResult("layers", "Layers", (properties.Layers != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.Layers) : undefined));
  ret.addPropertyResult("memorySize", "MemorySize", (properties.MemorySize != null ? cfn_parse.FromCloudFormation.getNumber(properties.MemorySize) : undefined));
  ret.addPropertyResult("packageType", "PackageType", (properties.PackageType != null ? cfn_parse.FromCloudFormation.getString(properties.PackageType) : undefined));
  ret.addPropertyResult("permissionsBoundary", "PermissionsBoundary", (properties.PermissionsBoundary != null ? cfn_parse.FromCloudFormation.getString(properties.PermissionsBoundary) : undefined));
  ret.addPropertyResult("policies", "Policies", (properties.Policies != null ? cfn_parse.FromCloudFormation.getTypeUnion([cdk.listValidator(cdk.unionValidator(CfnFunctionIAMPolicyDocumentPropertyValidator, CfnFunctionSAMPolicyTemplatePropertyValidator, cdk.validateString)), CfnFunctionIAMPolicyDocumentPropertyValidator, cdk.validateString], [cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getTypeUnion([CfnFunctionIAMPolicyDocumentPropertyValidator, CfnFunctionSAMPolicyTemplatePropertyValidator, cdk.validateString], [CfnFunctionIAMPolicyDocumentPropertyFromCloudFormation, CfnFunctionSAMPolicyTemplatePropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])), CfnFunctionIAMPolicyDocumentPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.Policies) : undefined));
  ret.addPropertyResult("provisionedConcurrencyConfig", "ProvisionedConcurrencyConfig", (properties.ProvisionedConcurrencyConfig != null ? CfnFunctionProvisionedConcurrencyConfigPropertyFromCloudFormation(properties.ProvisionedConcurrencyConfig) : undefined));
  ret.addPropertyResult("reservedConcurrentExecutions", "ReservedConcurrentExecutions", (properties.ReservedConcurrentExecutions != null ? cfn_parse.FromCloudFormation.getNumber(properties.ReservedConcurrentExecutions) : undefined));
  ret.addPropertyResult("role", "Role", (properties.Role != null ? cfn_parse.FromCloudFormation.getString(properties.Role) : undefined));
  ret.addPropertyResult("runtime", "Runtime", (properties.Runtime != null ? cfn_parse.FromCloudFormation.getString(properties.Runtime) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getString)(properties.Tags) : undefined));
  ret.addPropertyResult("timeout", "Timeout", (properties.Timeout != null ? cfn_parse.FromCloudFormation.getNumber(properties.Timeout) : undefined));
  ret.addPropertyResult("tracing", "Tracing", (properties.Tracing != null ? cfn_parse.FromCloudFormation.getString(properties.Tracing) : undefined));
  ret.addPropertyResult("versionDescription", "VersionDescription", (properties.VersionDescription != null ? cfn_parse.FromCloudFormation.getString(properties.VersionDescription) : undefined));
  ret.addPropertyResult("vpcConfig", "VpcConfig", (properties.VpcConfig != null ? CfnFunctionVpcConfigPropertyFromCloudFormation(properties.VpcConfig) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Definition of AWS::Serverless::HttpApi.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-httpapi.html
 */
export class CfnHttpApi extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::Serverless::HttpApi";

  /**
   * The \`Transform\` a template must use in order to use this resource
   */
  public static readonly REQUIRED_TRANSFORM: string = "AWS::Serverless-2016-10-31";

  /**
   * Build a CfnHttpApi from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnHttpApi {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnHttpApiPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnHttpApi(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  public accessLogSetting?: CfnHttpApi.AccessLogSettingProperty | cdk.IResolvable;

  public auth?: CfnHttpApi.HttpApiAuthProperty | cdk.IResolvable;

  public corsConfiguration?: boolean | CfnHttpApi.CorsConfigurationObjectProperty | cdk.IResolvable;

  public defaultRouteSettings?: cdk.IResolvable | CfnHttpApi.RouteSettingsProperty;

  public definitionBody?: any | cdk.IResolvable;

  public definitionUri?: cdk.IResolvable | CfnHttpApi.S3LocationProperty | string;

  public description?: string;

  public disableExecuteApiEndpoint?: boolean | cdk.IResolvable;

  public domain?: CfnHttpApi.HttpApiDomainConfigurationProperty | cdk.IResolvable;

  public failOnWarnings?: boolean | cdk.IResolvable;

  public routeSettings?: cdk.IResolvable | CfnHttpApi.RouteSettingsProperty;

  public stageName?: string;

  public stageVariables?: cdk.IResolvable | Record<string, string>;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  public tagsRaw?: Record<string, string>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnHttpApiProps = {}) {
    super(scope, id, {
      "type": CfnHttpApi.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    // Automatically add the required transform
    this.stack.addTransform(CfnHttpApi.REQUIRED_TRANSFORM);

    this.accessLogSetting = props.accessLogSetting;
    this.auth = props.auth;
    this.corsConfiguration = props.corsConfiguration;
    this.defaultRouteSettings = props.defaultRouteSettings;
    this.definitionBody = props.definitionBody;
    this.definitionUri = props.definitionUri;
    this.description = props.description;
    this.disableExecuteApiEndpoint = props.disableExecuteApiEndpoint;
    this.domain = props.domain;
    this.failOnWarnings = props.failOnWarnings;
    this.routeSettings = props.routeSettings;
    this.stageName = props.stageName;
    this.stageVariables = props.stageVariables;
    this.tags = new cdk.TagManager(cdk.TagType.MAP, "AWS::Serverless::HttpApi", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "accessLogSetting": this.accessLogSetting,
      "auth": this.auth,
      "corsConfiguration": this.corsConfiguration,
      "defaultRouteSettings": this.defaultRouteSettings,
      "definitionBody": this.definitionBody,
      "definitionUri": this.definitionUri,
      "description": this.description,
      "disableExecuteApiEndpoint": this.disableExecuteApiEndpoint,
      "domain": this.domain,
      "failOnWarnings": this.failOnWarnings,
      "routeSettings": this.routeSettings,
      "stageName": this.stageName,
      "stageVariables": this.stageVariables,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnHttpApi.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnHttpApiPropsToCloudFormation(props);
  }
}

export namespace CfnHttpApi {
  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-accesslogsetting.html
   */
  export interface AccessLogSettingProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-accesslogsetting.html#cfn-serverless-httpapi-accesslogsetting-destinationarn
     */
    readonly destinationArn?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-accesslogsetting.html#cfn-serverless-httpapi-accesslogsetting-format
     */
    readonly format?: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-httpapiauth.html
   */
  export interface HttpApiAuthProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-httpapiauth.html#cfn-serverless-httpapi-httpapiauth-authorizers
     */
    readonly authorizers?: any | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-httpapiauth.html#cfn-serverless-httpapi-httpapiauth-defaultauthorizer
     */
    readonly defaultAuthorizer?: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-corsconfigurationobject.html
   */
  export interface CorsConfigurationObjectProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-corsconfigurationobject.html#cfn-serverless-httpapi-corsconfigurationobject-allowcredentials
     */
    readonly allowCredentials?: boolean | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-corsconfigurationobject.html#cfn-serverless-httpapi-corsconfigurationobject-allowheaders
     */
    readonly allowHeaders?: Array<string>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-corsconfigurationobject.html#cfn-serverless-httpapi-corsconfigurationobject-allowmethods
     */
    readonly allowMethods?: Array<string>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-corsconfigurationobject.html#cfn-serverless-httpapi-corsconfigurationobject-alloworigins
     */
    readonly allowOrigins?: Array<string>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-corsconfigurationobject.html#cfn-serverless-httpapi-corsconfigurationobject-exposeheaders
     */
    readonly exposeHeaders?: Array<string>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-corsconfigurationobject.html#cfn-serverless-httpapi-corsconfigurationobject-maxage
     */
    readonly maxAge?: number;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-routesettings.html
   */
  export interface RouteSettingsProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-routesettings.html#cfn-serverless-httpapi-routesettings-datatraceenabled
     */
    readonly dataTraceEnabled?: boolean | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-routesettings.html#cfn-serverless-httpapi-routesettings-detailedmetricsenabled
     */
    readonly detailedMetricsEnabled?: boolean | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-routesettings.html#cfn-serverless-httpapi-routesettings-logginglevel
     */
    readonly loggingLevel?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-routesettings.html#cfn-serverless-httpapi-routesettings-throttlingburstlimit
     */
    readonly throttlingBurstLimit?: number;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-routesettings.html#cfn-serverless-httpapi-routesettings-throttlingratelimit
     */
    readonly throttlingRateLimit?: number;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-s3location.html
   */
  export interface S3LocationProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-s3location.html#cfn-serverless-httpapi-s3location-bucket
     */
    readonly bucket: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-s3location.html#cfn-serverless-httpapi-s3location-key
     */
    readonly key: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-s3location.html#cfn-serverless-httpapi-s3location-version
     */
    readonly version: number;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-httpapidomainconfiguration.html
   */
  export interface HttpApiDomainConfigurationProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-httpapidomainconfiguration.html#cfn-serverless-httpapi-httpapidomainconfiguration-basepath
     */
    readonly basePath?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-httpapidomainconfiguration.html#cfn-serverless-httpapi-httpapidomainconfiguration-certificatearn
     */
    readonly certificateArn: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-httpapidomainconfiguration.html#cfn-serverless-httpapi-httpapidomainconfiguration-domainname
     */
    readonly domainName: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-httpapidomainconfiguration.html#cfn-serverless-httpapi-httpapidomainconfiguration-endpointconfiguration
     */
    readonly endpointConfiguration?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-httpapidomainconfiguration.html#cfn-serverless-httpapi-httpapidomainconfiguration-mutualtlsauthentication
     */
    readonly mutualTlsAuthentication?: cdk.IResolvable | CfnHttpApi.MutualTlsAuthenticationProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-httpapidomainconfiguration.html#cfn-serverless-httpapi-httpapidomainconfiguration-route53
     */
    readonly route53?: cdk.IResolvable | CfnHttpApi.Route53ConfigurationProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-httpapidomainconfiguration.html#cfn-serverless-httpapi-httpapidomainconfiguration-securitypolicy
     */
    readonly securityPolicy?: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-mutualtlsauthentication.html
   */
  export interface MutualTlsAuthenticationProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-mutualtlsauthentication.html#cfn-serverless-httpapi-mutualtlsauthentication-truststoreuri
     */
    readonly truststoreUri?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-mutualtlsauthentication.html#cfn-serverless-httpapi-mutualtlsauthentication-truststoreversion
     */
    readonly truststoreVersion?: boolean | cdk.IResolvable;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-route53configuration.html
   */
  export interface Route53ConfigurationProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-route53configuration.html#cfn-serverless-httpapi-route53configuration-distributeddomainname
     */
    readonly distributedDomainName?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-route53configuration.html#cfn-serverless-httpapi-route53configuration-evaluatetargethealth
     */
    readonly evaluateTargetHealth?: boolean | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-route53configuration.html#cfn-serverless-httpapi-route53configuration-hostedzoneid
     */
    readonly hostedZoneId?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-route53configuration.html#cfn-serverless-httpapi-route53configuration-hostedzonename
     */
    readonly hostedZoneName?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-route53configuration.html#cfn-serverless-httpapi-route53configuration-ipv6
     */
    readonly ipV6?: boolean | cdk.IResolvable;
  }
}

/**
 * Properties for defining a \`CfnHttpApi\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-httpapi.html
 */
export interface CfnHttpApiProps {
  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-httpapi.html#cfn-serverless-httpapi-accesslogsetting
   */
  readonly accessLogSetting?: CfnHttpApi.AccessLogSettingProperty | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-httpapi.html#cfn-serverless-httpapi-auth
   */
  readonly auth?: CfnHttpApi.HttpApiAuthProperty | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-httpapi.html#cfn-serverless-httpapi-corsconfiguration
   */
  readonly corsConfiguration?: boolean | CfnHttpApi.CorsConfigurationObjectProperty | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-httpapi.html#cfn-serverless-httpapi-defaultroutesettings
   */
  readonly defaultRouteSettings?: cdk.IResolvable | CfnHttpApi.RouteSettingsProperty;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-httpapi.html#cfn-serverless-httpapi-definitionbody
   */
  readonly definitionBody?: any | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-httpapi.html#cfn-serverless-httpapi-definitionuri
   */
  readonly definitionUri?: cdk.IResolvable | CfnHttpApi.S3LocationProperty | string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-httpapi.html#cfn-serverless-httpapi-description
   */
  readonly description?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-httpapi.html#cfn-serverless-httpapi-disableexecuteapiendpoint
   */
  readonly disableExecuteApiEndpoint?: boolean | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-httpapi.html#cfn-serverless-httpapi-domain
   */
  readonly domain?: CfnHttpApi.HttpApiDomainConfigurationProperty | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-httpapi.html#cfn-serverless-httpapi-failonwarnings
   */
  readonly failOnWarnings?: boolean | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-httpapi.html#cfn-serverless-httpapi-routesettings
   */
  readonly routeSettings?: cdk.IResolvable | CfnHttpApi.RouteSettingsProperty;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-httpapi.html#cfn-serverless-httpapi-stagename
   */
  readonly stageName?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-httpapi.html#cfn-serverless-httpapi-stagevariables
   */
  readonly stageVariables?: cdk.IResolvable | Record<string, string>;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-httpapi.html#cfn-serverless-httpapi-tags
   */
  readonly tags?: Record<string, string>;
}

/**
 * Determine whether the given properties match those of a \`AccessLogSettingProperty\`
 *
 * @param properties - the TypeScript properties of a \`AccessLogSettingProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnHttpApiAccessLogSettingPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("destinationArn", cdk.validateString)(properties.destinationArn));
  errors.collect(cdk.propertyValidator("format", cdk.validateString)(properties.format));
  return errors.wrap("supplied properties not correct for \\"AccessLogSettingProperty\\"");
}

// @ts-ignore TS6133
function convertCfnHttpApiAccessLogSettingPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnHttpApiAccessLogSettingPropertyValidator(properties).assertSuccess();
  return {
    "DestinationArn": cdk.stringToCloudFormation(properties.destinationArn),
    "Format": cdk.stringToCloudFormation(properties.format)
  };
}

// @ts-ignore TS6133
function CfnHttpApiAccessLogSettingPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnHttpApi.AccessLogSettingProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnHttpApi.AccessLogSettingProperty>();
  ret.addPropertyResult("destinationArn", "DestinationArn", (properties.DestinationArn != null ? cfn_parse.FromCloudFormation.getString(properties.DestinationArn) : undefined));
  ret.addPropertyResult("format", "Format", (properties.Format != null ? cfn_parse.FromCloudFormation.getString(properties.Format) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`HttpApiAuthProperty\`
 *
 * @param properties - the TypeScript properties of a \`HttpApiAuthProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnHttpApiHttpApiAuthPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("authorizers", cdk.validateObject)(properties.authorizers));
  errors.collect(cdk.propertyValidator("defaultAuthorizer", cdk.validateString)(properties.defaultAuthorizer));
  return errors.wrap("supplied properties not correct for \\"HttpApiAuthProperty\\"");
}

// @ts-ignore TS6133
function convertCfnHttpApiHttpApiAuthPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnHttpApiHttpApiAuthPropertyValidator(properties).assertSuccess();
  return {
    "Authorizers": cdk.objectToCloudFormation(properties.authorizers),
    "DefaultAuthorizer": cdk.stringToCloudFormation(properties.defaultAuthorizer)
  };
}

// @ts-ignore TS6133
function CfnHttpApiHttpApiAuthPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnHttpApi.HttpApiAuthProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnHttpApi.HttpApiAuthProperty>();
  ret.addPropertyResult("authorizers", "Authorizers", (properties.Authorizers != null ? cfn_parse.FromCloudFormation.getAny(properties.Authorizers) : undefined));
  ret.addPropertyResult("defaultAuthorizer", "DefaultAuthorizer", (properties.DefaultAuthorizer != null ? cfn_parse.FromCloudFormation.getString(properties.DefaultAuthorizer) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CorsConfigurationObjectProperty\`
 *
 * @param properties - the TypeScript properties of a \`CorsConfigurationObjectProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnHttpApiCorsConfigurationObjectPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("allowCredentials", cdk.validateBoolean)(properties.allowCredentials));
  errors.collect(cdk.propertyValidator("allowHeaders", cdk.listValidator(cdk.validateString))(properties.allowHeaders));
  errors.collect(cdk.propertyValidator("allowMethods", cdk.listValidator(cdk.validateString))(properties.allowMethods));
  errors.collect(cdk.propertyValidator("allowOrigins", cdk.listValidator(cdk.validateString))(properties.allowOrigins));
  errors.collect(cdk.propertyValidator("exposeHeaders", cdk.listValidator(cdk.validateString))(properties.exposeHeaders));
  errors.collect(cdk.propertyValidator("maxAge", cdk.validateNumber)(properties.maxAge));
  return errors.wrap("supplied properties not correct for \\"CorsConfigurationObjectProperty\\"");
}

// @ts-ignore TS6133
function convertCfnHttpApiCorsConfigurationObjectPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnHttpApiCorsConfigurationObjectPropertyValidator(properties).assertSuccess();
  return {
    "AllowCredentials": cdk.booleanToCloudFormation(properties.allowCredentials),
    "AllowHeaders": cdk.listMapper(cdk.stringToCloudFormation)(properties.allowHeaders),
    "AllowMethods": cdk.listMapper(cdk.stringToCloudFormation)(properties.allowMethods),
    "AllowOrigins": cdk.listMapper(cdk.stringToCloudFormation)(properties.allowOrigins),
    "ExposeHeaders": cdk.listMapper(cdk.stringToCloudFormation)(properties.exposeHeaders),
    "MaxAge": cdk.numberToCloudFormation(properties.maxAge)
  };
}

// @ts-ignore TS6133
function CfnHttpApiCorsConfigurationObjectPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnHttpApi.CorsConfigurationObjectProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnHttpApi.CorsConfigurationObjectProperty>();
  ret.addPropertyResult("allowCredentials", "AllowCredentials", (properties.AllowCredentials != null ? cfn_parse.FromCloudFormation.getBoolean(properties.AllowCredentials) : undefined));
  ret.addPropertyResult("allowHeaders", "AllowHeaders", (properties.AllowHeaders != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.AllowHeaders) : undefined));
  ret.addPropertyResult("allowMethods", "AllowMethods", (properties.AllowMethods != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.AllowMethods) : undefined));
  ret.addPropertyResult("allowOrigins", "AllowOrigins", (properties.AllowOrigins != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.AllowOrigins) : undefined));
  ret.addPropertyResult("exposeHeaders", "ExposeHeaders", (properties.ExposeHeaders != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.ExposeHeaders) : undefined));
  ret.addPropertyResult("maxAge", "MaxAge", (properties.MaxAge != null ? cfn_parse.FromCloudFormation.getNumber(properties.MaxAge) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`RouteSettingsProperty\`
 *
 * @param properties - the TypeScript properties of a \`RouteSettingsProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnHttpApiRouteSettingsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("dataTraceEnabled", cdk.validateBoolean)(properties.dataTraceEnabled));
  errors.collect(cdk.propertyValidator("detailedMetricsEnabled", cdk.validateBoolean)(properties.detailedMetricsEnabled));
  errors.collect(cdk.propertyValidator("loggingLevel", cdk.validateString)(properties.loggingLevel));
  errors.collect(cdk.propertyValidator("throttlingBurstLimit", cdk.validateNumber)(properties.throttlingBurstLimit));
  errors.collect(cdk.propertyValidator("throttlingRateLimit", cdk.validateNumber)(properties.throttlingRateLimit));
  return errors.wrap("supplied properties not correct for \\"RouteSettingsProperty\\"");
}

// @ts-ignore TS6133
function convertCfnHttpApiRouteSettingsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnHttpApiRouteSettingsPropertyValidator(properties).assertSuccess();
  return {
    "DataTraceEnabled": cdk.booleanToCloudFormation(properties.dataTraceEnabled),
    "DetailedMetricsEnabled": cdk.booleanToCloudFormation(properties.detailedMetricsEnabled),
    "LoggingLevel": cdk.stringToCloudFormation(properties.loggingLevel),
    "ThrottlingBurstLimit": cdk.numberToCloudFormation(properties.throttlingBurstLimit),
    "ThrottlingRateLimit": cdk.numberToCloudFormation(properties.throttlingRateLimit)
  };
}

// @ts-ignore TS6133
function CfnHttpApiRouteSettingsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnHttpApi.RouteSettingsProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnHttpApi.RouteSettingsProperty>();
  ret.addPropertyResult("dataTraceEnabled", "DataTraceEnabled", (properties.DataTraceEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.DataTraceEnabled) : undefined));
  ret.addPropertyResult("detailedMetricsEnabled", "DetailedMetricsEnabled", (properties.DetailedMetricsEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.DetailedMetricsEnabled) : undefined));
  ret.addPropertyResult("loggingLevel", "LoggingLevel", (properties.LoggingLevel != null ? cfn_parse.FromCloudFormation.getString(properties.LoggingLevel) : undefined));
  ret.addPropertyResult("throttlingBurstLimit", "ThrottlingBurstLimit", (properties.ThrottlingBurstLimit != null ? cfn_parse.FromCloudFormation.getNumber(properties.ThrottlingBurstLimit) : undefined));
  ret.addPropertyResult("throttlingRateLimit", "ThrottlingRateLimit", (properties.ThrottlingRateLimit != null ? cfn_parse.FromCloudFormation.getNumber(properties.ThrottlingRateLimit) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`S3LocationProperty\`
 *
 * @param properties - the TypeScript properties of a \`S3LocationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnHttpApiS3LocationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("bucket", cdk.requiredValidator)(properties.bucket));
  errors.collect(cdk.propertyValidator("bucket", cdk.validateString)(properties.bucket));
  errors.collect(cdk.propertyValidator("key", cdk.requiredValidator)(properties.key));
  errors.collect(cdk.propertyValidator("key", cdk.validateString)(properties.key));
  errors.collect(cdk.propertyValidator("version", cdk.requiredValidator)(properties.version));
  errors.collect(cdk.propertyValidator("version", cdk.validateNumber)(properties.version));
  return errors.wrap("supplied properties not correct for \\"S3LocationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnHttpApiS3LocationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnHttpApiS3LocationPropertyValidator(properties).assertSuccess();
  return {
    "Bucket": cdk.stringToCloudFormation(properties.bucket),
    "Key": cdk.stringToCloudFormation(properties.key),
    "Version": cdk.numberToCloudFormation(properties.version)
  };
}

// @ts-ignore TS6133
function CfnHttpApiS3LocationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnHttpApi.S3LocationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnHttpApi.S3LocationProperty>();
  ret.addPropertyResult("bucket", "Bucket", (properties.Bucket != null ? cfn_parse.FromCloudFormation.getString(properties.Bucket) : undefined));
  ret.addPropertyResult("key", "Key", (properties.Key != null ? cfn_parse.FromCloudFormation.getString(properties.Key) : undefined));
  ret.addPropertyResult("version", "Version", (properties.Version != null ? cfn_parse.FromCloudFormation.getNumber(properties.Version) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`MutualTlsAuthenticationProperty\`
 *
 * @param properties - the TypeScript properties of a \`MutualTlsAuthenticationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnHttpApiMutualTlsAuthenticationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("truststoreUri", cdk.validateString)(properties.truststoreUri));
  errors.collect(cdk.propertyValidator("truststoreVersion", cdk.validateBoolean)(properties.truststoreVersion));
  return errors.wrap("supplied properties not correct for \\"MutualTlsAuthenticationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnHttpApiMutualTlsAuthenticationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnHttpApiMutualTlsAuthenticationPropertyValidator(properties).assertSuccess();
  return {
    "TruststoreUri": cdk.stringToCloudFormation(properties.truststoreUri),
    "TruststoreVersion": cdk.booleanToCloudFormation(properties.truststoreVersion)
  };
}

// @ts-ignore TS6133
function CfnHttpApiMutualTlsAuthenticationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnHttpApi.MutualTlsAuthenticationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnHttpApi.MutualTlsAuthenticationProperty>();
  ret.addPropertyResult("truststoreUri", "TruststoreUri", (properties.TruststoreUri != null ? cfn_parse.FromCloudFormation.getString(properties.TruststoreUri) : undefined));
  ret.addPropertyResult("truststoreVersion", "TruststoreVersion", (properties.TruststoreVersion != null ? cfn_parse.FromCloudFormation.getBoolean(properties.TruststoreVersion) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`Route53ConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`Route53ConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnHttpApiRoute53ConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("distributedDomainName", cdk.validateString)(properties.distributedDomainName));
  errors.collect(cdk.propertyValidator("evaluateTargetHealth", cdk.validateBoolean)(properties.evaluateTargetHealth));
  errors.collect(cdk.propertyValidator("hostedZoneId", cdk.validateString)(properties.hostedZoneId));
  errors.collect(cdk.propertyValidator("hostedZoneName", cdk.validateString)(properties.hostedZoneName));
  errors.collect(cdk.propertyValidator("ipV6", cdk.validateBoolean)(properties.ipV6));
  return errors.wrap("supplied properties not correct for \\"Route53ConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnHttpApiRoute53ConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnHttpApiRoute53ConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "DistributedDomainName": cdk.stringToCloudFormation(properties.distributedDomainName),
    "EvaluateTargetHealth": cdk.booleanToCloudFormation(properties.evaluateTargetHealth),
    "HostedZoneId": cdk.stringToCloudFormation(properties.hostedZoneId),
    "HostedZoneName": cdk.stringToCloudFormation(properties.hostedZoneName),
    "IpV6": cdk.booleanToCloudFormation(properties.ipV6)
  };
}

// @ts-ignore TS6133
function CfnHttpApiRoute53ConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnHttpApi.Route53ConfigurationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnHttpApi.Route53ConfigurationProperty>();
  ret.addPropertyResult("distributedDomainName", "DistributedDomainName", (properties.DistributedDomainName != null ? cfn_parse.FromCloudFormation.getString(properties.DistributedDomainName) : undefined));
  ret.addPropertyResult("evaluateTargetHealth", "EvaluateTargetHealth", (properties.EvaluateTargetHealth != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EvaluateTargetHealth) : undefined));
  ret.addPropertyResult("hostedZoneId", "HostedZoneId", (properties.HostedZoneId != null ? cfn_parse.FromCloudFormation.getString(properties.HostedZoneId) : undefined));
  ret.addPropertyResult("hostedZoneName", "HostedZoneName", (properties.HostedZoneName != null ? cfn_parse.FromCloudFormation.getString(properties.HostedZoneName) : undefined));
  ret.addPropertyResult("ipV6", "IpV6", (properties.IpV6 != null ? cfn_parse.FromCloudFormation.getBoolean(properties.IpV6) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`HttpApiDomainConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`HttpApiDomainConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnHttpApiHttpApiDomainConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("basePath", cdk.validateString)(properties.basePath));
  errors.collect(cdk.propertyValidator("certificateArn", cdk.requiredValidator)(properties.certificateArn));
  errors.collect(cdk.propertyValidator("certificateArn", cdk.validateString)(properties.certificateArn));
  errors.collect(cdk.propertyValidator("domainName", cdk.requiredValidator)(properties.domainName));
  errors.collect(cdk.propertyValidator("domainName", cdk.validateString)(properties.domainName));
  errors.collect(cdk.propertyValidator("endpointConfiguration", cdk.validateString)(properties.endpointConfiguration));
  errors.collect(cdk.propertyValidator("mutualTlsAuthentication", CfnHttpApiMutualTlsAuthenticationPropertyValidator)(properties.mutualTlsAuthentication));
  errors.collect(cdk.propertyValidator("route53", CfnHttpApiRoute53ConfigurationPropertyValidator)(properties.route53));
  errors.collect(cdk.propertyValidator("securityPolicy", cdk.validateString)(properties.securityPolicy));
  return errors.wrap("supplied properties not correct for \\"HttpApiDomainConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnHttpApiHttpApiDomainConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnHttpApiHttpApiDomainConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "BasePath": cdk.stringToCloudFormation(properties.basePath),
    "CertificateArn": cdk.stringToCloudFormation(properties.certificateArn),
    "DomainName": cdk.stringToCloudFormation(properties.domainName),
    "EndpointConfiguration": cdk.stringToCloudFormation(properties.endpointConfiguration),
    "MutualTlsAuthentication": convertCfnHttpApiMutualTlsAuthenticationPropertyToCloudFormation(properties.mutualTlsAuthentication),
    "Route53": convertCfnHttpApiRoute53ConfigurationPropertyToCloudFormation(properties.route53),
    "SecurityPolicy": cdk.stringToCloudFormation(properties.securityPolicy)
  };
}

// @ts-ignore TS6133
function CfnHttpApiHttpApiDomainConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnHttpApi.HttpApiDomainConfigurationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnHttpApi.HttpApiDomainConfigurationProperty>();
  ret.addPropertyResult("basePath", "BasePath", (properties.BasePath != null ? cfn_parse.FromCloudFormation.getString(properties.BasePath) : undefined));
  ret.addPropertyResult("certificateArn", "CertificateArn", (properties.CertificateArn != null ? cfn_parse.FromCloudFormation.getString(properties.CertificateArn) : undefined));
  ret.addPropertyResult("domainName", "DomainName", (properties.DomainName != null ? cfn_parse.FromCloudFormation.getString(properties.DomainName) : undefined));
  ret.addPropertyResult("endpointConfiguration", "EndpointConfiguration", (properties.EndpointConfiguration != null ? cfn_parse.FromCloudFormation.getString(properties.EndpointConfiguration) : undefined));
  ret.addPropertyResult("mutualTlsAuthentication", "MutualTlsAuthentication", (properties.MutualTlsAuthentication != null ? CfnHttpApiMutualTlsAuthenticationPropertyFromCloudFormation(properties.MutualTlsAuthentication) : undefined));
  ret.addPropertyResult("route53", "Route53", (properties.Route53 != null ? CfnHttpApiRoute53ConfigurationPropertyFromCloudFormation(properties.Route53) : undefined));
  ret.addPropertyResult("securityPolicy", "SecurityPolicy", (properties.SecurityPolicy != null ? cfn_parse.FromCloudFormation.getString(properties.SecurityPolicy) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnHttpApiProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnHttpApiProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnHttpApiPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("accessLogSetting", CfnHttpApiAccessLogSettingPropertyValidator)(properties.accessLogSetting));
  errors.collect(cdk.propertyValidator("auth", CfnHttpApiHttpApiAuthPropertyValidator)(properties.auth));
  errors.collect(cdk.propertyValidator("corsConfiguration", cdk.unionValidator(cdk.validateBoolean, CfnHttpApiCorsConfigurationObjectPropertyValidator))(properties.corsConfiguration));
  errors.collect(cdk.propertyValidator("defaultRouteSettings", CfnHttpApiRouteSettingsPropertyValidator)(properties.defaultRouteSettings));
  errors.collect(cdk.propertyValidator("definitionBody", cdk.validateObject)(properties.definitionBody));
  errors.collect(cdk.propertyValidator("definitionUri", cdk.unionValidator(CfnHttpApiS3LocationPropertyValidator, cdk.validateString))(properties.definitionUri));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("disableExecuteApiEndpoint", cdk.validateBoolean)(properties.disableExecuteApiEndpoint));
  errors.collect(cdk.propertyValidator("domain", CfnHttpApiHttpApiDomainConfigurationPropertyValidator)(properties.domain));
  errors.collect(cdk.propertyValidator("failOnWarnings", cdk.validateBoolean)(properties.failOnWarnings));
  errors.collect(cdk.propertyValidator("routeSettings", CfnHttpApiRouteSettingsPropertyValidator)(properties.routeSettings));
  errors.collect(cdk.propertyValidator("stageName", cdk.validateString)(properties.stageName));
  errors.collect(cdk.propertyValidator("stageVariables", cdk.hashValidator(cdk.validateString))(properties.stageVariables));
  errors.collect(cdk.propertyValidator("tags", cdk.hashValidator(cdk.validateString))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnHttpApiProps\\"");
}

// @ts-ignore TS6133
function convertCfnHttpApiPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnHttpApiPropsValidator(properties).assertSuccess();
  return {
    "AccessLogSetting": convertCfnHttpApiAccessLogSettingPropertyToCloudFormation(properties.accessLogSetting),
    "Auth": convertCfnHttpApiHttpApiAuthPropertyToCloudFormation(properties.auth),
    "CorsConfiguration": cdk.unionMapper([cdk.validateBoolean, CfnHttpApiCorsConfigurationObjectPropertyValidator], [cdk.booleanToCloudFormation, convertCfnHttpApiCorsConfigurationObjectPropertyToCloudFormation])(properties.corsConfiguration),
    "DefaultRouteSettings": convertCfnHttpApiRouteSettingsPropertyToCloudFormation(properties.defaultRouteSettings),
    "DefinitionBody": cdk.objectToCloudFormation(properties.definitionBody),
    "DefinitionUri": cdk.unionMapper([CfnHttpApiS3LocationPropertyValidator, cdk.validateString], [convertCfnHttpApiS3LocationPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.definitionUri),
    "Description": cdk.stringToCloudFormation(properties.description),
    "DisableExecuteApiEndpoint": cdk.booleanToCloudFormation(properties.disableExecuteApiEndpoint),
    "Domain": convertCfnHttpApiHttpApiDomainConfigurationPropertyToCloudFormation(properties.domain),
    "FailOnWarnings": cdk.booleanToCloudFormation(properties.failOnWarnings),
    "RouteSettings": convertCfnHttpApiRouteSettingsPropertyToCloudFormation(properties.routeSettings),
    "StageName": cdk.stringToCloudFormation(properties.stageName),
    "StageVariables": cdk.hashMapper(cdk.stringToCloudFormation)(properties.stageVariables),
    "Tags": cdk.hashMapper(cdk.stringToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnHttpApiPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnHttpApiProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnHttpApiProps>();
  ret.addPropertyResult("accessLogSetting", "AccessLogSetting", (properties.AccessLogSetting != null ? CfnHttpApiAccessLogSettingPropertyFromCloudFormation(properties.AccessLogSetting) : undefined));
  ret.addPropertyResult("auth", "Auth", (properties.Auth != null ? CfnHttpApiHttpApiAuthPropertyFromCloudFormation(properties.Auth) : undefined));
  ret.addPropertyResult("corsConfiguration", "CorsConfiguration", (properties.CorsConfiguration != null ? cfn_parse.FromCloudFormation.getTypeUnion([cdk.validateBoolean, CfnHttpApiCorsConfigurationObjectPropertyValidator], [cfn_parse.FromCloudFormation.getBoolean, CfnHttpApiCorsConfigurationObjectPropertyFromCloudFormation])(properties.CorsConfiguration) : undefined));
  ret.addPropertyResult("defaultRouteSettings", "DefaultRouteSettings", (properties.DefaultRouteSettings != null ? CfnHttpApiRouteSettingsPropertyFromCloudFormation(properties.DefaultRouteSettings) : undefined));
  ret.addPropertyResult("definitionBody", "DefinitionBody", (properties.DefinitionBody != null ? cfn_parse.FromCloudFormation.getAny(properties.DefinitionBody) : undefined));
  ret.addPropertyResult("definitionUri", "DefinitionUri", (properties.DefinitionUri != null ? cfn_parse.FromCloudFormation.getTypeUnion([CfnHttpApiS3LocationPropertyValidator, cdk.validateString], [CfnHttpApiS3LocationPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.DefinitionUri) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("disableExecuteApiEndpoint", "DisableExecuteApiEndpoint", (properties.DisableExecuteApiEndpoint != null ? cfn_parse.FromCloudFormation.getBoolean(properties.DisableExecuteApiEndpoint) : undefined));
  ret.addPropertyResult("domain", "Domain", (properties.Domain != null ? CfnHttpApiHttpApiDomainConfigurationPropertyFromCloudFormation(properties.Domain) : undefined));
  ret.addPropertyResult("failOnWarnings", "FailOnWarnings", (properties.FailOnWarnings != null ? cfn_parse.FromCloudFormation.getBoolean(properties.FailOnWarnings) : undefined));
  ret.addPropertyResult("routeSettings", "RouteSettings", (properties.RouteSettings != null ? CfnHttpApiRouteSettingsPropertyFromCloudFormation(properties.RouteSettings) : undefined));
  ret.addPropertyResult("stageName", "StageName", (properties.StageName != null ? cfn_parse.FromCloudFormation.getString(properties.StageName) : undefined));
  ret.addPropertyResult("stageVariables", "StageVariables", (properties.StageVariables != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getString)(properties.StageVariables) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getString)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Definition of AWS::Serverless::LayerVersion.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-layerversion.html
 */
export class CfnLayerVersion extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::Serverless::LayerVersion";

  /**
   * The \`Transform\` a template must use in order to use this resource
   */
  public static readonly REQUIRED_TRANSFORM: string = "AWS::Serverless-2016-10-31";

  /**
   * Build a CfnLayerVersion from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnLayerVersion {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnLayerVersionPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnLayerVersion(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  public compatibleRuntimes?: Array<string>;

  public contentUri?: cdk.IResolvable | CfnLayerVersion.S3LocationProperty | string;

  public description?: string;

  public layerName?: string;

  public licenseInfo?: string;

  public retentionPolicy?: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnLayerVersionProps = {}) {
    super(scope, id, {
      "type": CfnLayerVersion.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    // Automatically add the required transform
    this.stack.addTransform(CfnLayerVersion.REQUIRED_TRANSFORM);

    this.compatibleRuntimes = props.compatibleRuntimes;
    this.contentUri = props.contentUri;
    this.description = props.description;
    this.layerName = props.layerName;
    this.licenseInfo = props.licenseInfo;
    this.retentionPolicy = props.retentionPolicy;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "compatibleRuntimes": this.compatibleRuntimes,
      "contentUri": this.contentUri,
      "description": this.description,
      "layerName": this.layerName,
      "licenseInfo": this.licenseInfo,
      "retentionPolicy": this.retentionPolicy
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnLayerVersion.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnLayerVersionPropsToCloudFormation(props);
  }
}

export namespace CfnLayerVersion {
  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-layerversion-s3location.html
   */
  export interface S3LocationProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-layerversion-s3location.html#cfn-serverless-layerversion-s3location-bucket
     */
    readonly bucket: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-layerversion-s3location.html#cfn-serverless-layerversion-s3location-key
     */
    readonly key: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-layerversion-s3location.html#cfn-serverless-layerversion-s3location-version
     */
    readonly version?: number;
  }
}

/**
 * Properties for defining a \`CfnLayerVersion\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-layerversion.html
 */
export interface CfnLayerVersionProps {
  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-layerversion.html#cfn-serverless-layerversion-compatibleruntimes
   */
  readonly compatibleRuntimes?: Array<string>;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-layerversion.html#cfn-serverless-layerversion-contenturi
   */
  readonly contentUri?: cdk.IResolvable | CfnLayerVersion.S3LocationProperty | string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-layerversion.html#cfn-serverless-layerversion-description
   */
  readonly description?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-layerversion.html#cfn-serverless-layerversion-layername
   */
  readonly layerName?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-layerversion.html#cfn-serverless-layerversion-licenseinfo
   */
  readonly licenseInfo?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-layerversion.html#cfn-serverless-layerversion-retentionpolicy
   */
  readonly retentionPolicy?: string;
}

/**
 * Determine whether the given properties match those of a \`S3LocationProperty\`
 *
 * @param properties - the TypeScript properties of a \`S3LocationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLayerVersionS3LocationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("bucket", cdk.requiredValidator)(properties.bucket));
  errors.collect(cdk.propertyValidator("bucket", cdk.validateString)(properties.bucket));
  errors.collect(cdk.propertyValidator("key", cdk.requiredValidator)(properties.key));
  errors.collect(cdk.propertyValidator("key", cdk.validateString)(properties.key));
  errors.collect(cdk.propertyValidator("version", cdk.validateNumber)(properties.version));
  return errors.wrap("supplied properties not correct for \\"S3LocationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnLayerVersionS3LocationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLayerVersionS3LocationPropertyValidator(properties).assertSuccess();
  return {
    "Bucket": cdk.stringToCloudFormation(properties.bucket),
    "Key": cdk.stringToCloudFormation(properties.key),
    "Version": cdk.numberToCloudFormation(properties.version)
  };
}

// @ts-ignore TS6133
function CfnLayerVersionS3LocationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnLayerVersion.S3LocationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLayerVersion.S3LocationProperty>();
  ret.addPropertyResult("bucket", "Bucket", (properties.Bucket != null ? cfn_parse.FromCloudFormation.getString(properties.Bucket) : undefined));
  ret.addPropertyResult("key", "Key", (properties.Key != null ? cfn_parse.FromCloudFormation.getString(properties.Key) : undefined));
  ret.addPropertyResult("version", "Version", (properties.Version != null ? cfn_parse.FromCloudFormation.getNumber(properties.Version) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnLayerVersionProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnLayerVersionProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLayerVersionPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("compatibleRuntimes", cdk.listValidator(cdk.validateString))(properties.compatibleRuntimes));
  errors.collect(cdk.propertyValidator("contentUri", cdk.unionValidator(CfnLayerVersionS3LocationPropertyValidator, cdk.validateString))(properties.contentUri));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("layerName", cdk.validateString)(properties.layerName));
  errors.collect(cdk.propertyValidator("licenseInfo", cdk.validateString)(properties.licenseInfo));
  errors.collect(cdk.propertyValidator("retentionPolicy", cdk.validateString)(properties.retentionPolicy));
  return errors.wrap("supplied properties not correct for \\"CfnLayerVersionProps\\"");
}

// @ts-ignore TS6133
function convertCfnLayerVersionPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLayerVersionPropsValidator(properties).assertSuccess();
  return {
    "CompatibleRuntimes": cdk.listMapper(cdk.stringToCloudFormation)(properties.compatibleRuntimes),
    "ContentUri": cdk.unionMapper([CfnLayerVersionS3LocationPropertyValidator, cdk.validateString], [convertCfnLayerVersionS3LocationPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.contentUri),
    "Description": cdk.stringToCloudFormation(properties.description),
    "LayerName": cdk.stringToCloudFormation(properties.layerName),
    "LicenseInfo": cdk.stringToCloudFormation(properties.licenseInfo),
    "RetentionPolicy": cdk.stringToCloudFormation(properties.retentionPolicy)
  };
}

// @ts-ignore TS6133
function CfnLayerVersionPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnLayerVersionProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLayerVersionProps>();
  ret.addPropertyResult("compatibleRuntimes", "CompatibleRuntimes", (properties.CompatibleRuntimes != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.CompatibleRuntimes) : undefined));
  ret.addPropertyResult("contentUri", "ContentUri", (properties.ContentUri != null ? cfn_parse.FromCloudFormation.getTypeUnion([CfnLayerVersionS3LocationPropertyValidator, cdk.validateString], [CfnLayerVersionS3LocationPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.ContentUri) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("layerName", "LayerName", (properties.LayerName != null ? cfn_parse.FromCloudFormation.getString(properties.LayerName) : undefined));
  ret.addPropertyResult("licenseInfo", "LicenseInfo", (properties.LicenseInfo != null ? cfn_parse.FromCloudFormation.getString(properties.LicenseInfo) : undefined));
  ret.addPropertyResult("retentionPolicy", "RetentionPolicy", (properties.RetentionPolicy != null ? cfn_parse.FromCloudFormation.getString(properties.RetentionPolicy) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Definition of AWS::Serverless::SimpleTable.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-simpletable.html
 */
export class CfnSimpleTable extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::Serverless::SimpleTable";

  /**
   * The \`Transform\` a template must use in order to use this resource
   */
  public static readonly REQUIRED_TRANSFORM: string = "AWS::Serverless-2016-10-31";

  /**
   * Build a CfnSimpleTable from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnSimpleTable {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnSimpleTablePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnSimpleTable(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  public primaryKey?: cdk.IResolvable | CfnSimpleTable.PrimaryKeyProperty;

  public provisionedThroughput?: cdk.IResolvable | CfnSimpleTable.ProvisionedThroughputProperty;

  public sseSpecification?: cdk.IResolvable | CfnSimpleTable.SSESpecificationProperty;

  public tableName?: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  public tagsRaw?: Record<string, string>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnSimpleTableProps = {}) {
    super(scope, id, {
      "type": CfnSimpleTable.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    // Automatically add the required transform
    this.stack.addTransform(CfnSimpleTable.REQUIRED_TRANSFORM);

    this.primaryKey = props.primaryKey;
    this.provisionedThroughput = props.provisionedThroughput;
    this.sseSpecification = props.sseSpecification;
    this.tableName = props.tableName;
    this.tags = new cdk.TagManager(cdk.TagType.MAP, "AWS::Serverless::SimpleTable", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "primaryKey": this.primaryKey,
      "provisionedThroughput": this.provisionedThroughput,
      "sseSpecification": this.sseSpecification,
      "tableName": this.tableName,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnSimpleTable.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnSimpleTablePropsToCloudFormation(props);
  }
}

export namespace CfnSimpleTable {
  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-simpletable-primarykey.html
   */
  export interface PrimaryKeyProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-simpletable-primarykey.html#cfn-serverless-simpletable-primarykey-name
     */
    readonly name?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-simpletable-primarykey.html#cfn-serverless-simpletable-primarykey-type
     */
    readonly type: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-simpletable-provisionedthroughput.html
   */
  export interface ProvisionedThroughputProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-simpletable-provisionedthroughput.html#cfn-serverless-simpletable-provisionedthroughput-readcapacityunits
     */
    readonly readCapacityUnits?: number;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-simpletable-provisionedthroughput.html#cfn-serverless-simpletable-provisionedthroughput-writecapacityunits
     */
    readonly writeCapacityUnits: number;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-simpletable-ssespecification.html
   */
  export interface SSESpecificationProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-simpletable-ssespecification.html#cfn-serverless-simpletable-ssespecification-sseenabled
     */
    readonly sseEnabled?: boolean | cdk.IResolvable;
  }
}

/**
 * Properties for defining a \`CfnSimpleTable\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-simpletable.html
 */
export interface CfnSimpleTableProps {
  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-simpletable.html#cfn-serverless-simpletable-primarykey
   */
  readonly primaryKey?: cdk.IResolvable | CfnSimpleTable.PrimaryKeyProperty;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-simpletable.html#cfn-serverless-simpletable-provisionedthroughput
   */
  readonly provisionedThroughput?: cdk.IResolvable | CfnSimpleTable.ProvisionedThroughputProperty;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-simpletable.html#cfn-serverless-simpletable-ssespecification
   */
  readonly sseSpecification?: cdk.IResolvable | CfnSimpleTable.SSESpecificationProperty;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-simpletable.html#cfn-serverless-simpletable-tablename
   */
  readonly tableName?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-simpletable.html#cfn-serverless-simpletable-tags
   */
  readonly tags?: Record<string, string>;
}

/**
 * Determine whether the given properties match those of a \`PrimaryKeyProperty\`
 *
 * @param properties - the TypeScript properties of a \`PrimaryKeyProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSimpleTablePrimaryKeyPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  errors.collect(cdk.propertyValidator("type", cdk.requiredValidator)(properties.type));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  return errors.wrap("supplied properties not correct for \\"PrimaryKeyProperty\\"");
}

// @ts-ignore TS6133
function convertCfnSimpleTablePrimaryKeyPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSimpleTablePrimaryKeyPropertyValidator(properties).assertSuccess();
  return {
    "Name": cdk.stringToCloudFormation(properties.name),
    "Type": cdk.stringToCloudFormation(properties.type)
  };
}

// @ts-ignore TS6133
function CfnSimpleTablePrimaryKeyPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSimpleTable.PrimaryKeyProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSimpleTable.PrimaryKeyProperty>();
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ProvisionedThroughputProperty\`
 *
 * @param properties - the TypeScript properties of a \`ProvisionedThroughputProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSimpleTableProvisionedThroughputPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("readCapacityUnits", cdk.validateNumber)(properties.readCapacityUnits));
  errors.collect(cdk.propertyValidator("writeCapacityUnits", cdk.requiredValidator)(properties.writeCapacityUnits));
  errors.collect(cdk.propertyValidator("writeCapacityUnits", cdk.validateNumber)(properties.writeCapacityUnits));
  return errors.wrap("supplied properties not correct for \\"ProvisionedThroughputProperty\\"");
}

// @ts-ignore TS6133
function convertCfnSimpleTableProvisionedThroughputPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSimpleTableProvisionedThroughputPropertyValidator(properties).assertSuccess();
  return {
    "ReadCapacityUnits": cdk.numberToCloudFormation(properties.readCapacityUnits),
    "WriteCapacityUnits": cdk.numberToCloudFormation(properties.writeCapacityUnits)
  };
}

// @ts-ignore TS6133
function CfnSimpleTableProvisionedThroughputPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSimpleTable.ProvisionedThroughputProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSimpleTable.ProvisionedThroughputProperty>();
  ret.addPropertyResult("readCapacityUnits", "ReadCapacityUnits", (properties.ReadCapacityUnits != null ? cfn_parse.FromCloudFormation.getNumber(properties.ReadCapacityUnits) : undefined));
  ret.addPropertyResult("writeCapacityUnits", "WriteCapacityUnits", (properties.WriteCapacityUnits != null ? cfn_parse.FromCloudFormation.getNumber(properties.WriteCapacityUnits) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`SSESpecificationProperty\`
 *
 * @param properties - the TypeScript properties of a \`SSESpecificationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSimpleTableSSESpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("sseEnabled", cdk.validateBoolean)(properties.sseEnabled));
  return errors.wrap("supplied properties not correct for \\"SSESpecificationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnSimpleTableSSESpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSimpleTableSSESpecificationPropertyValidator(properties).assertSuccess();
  return {
    "SSEEnabled": cdk.booleanToCloudFormation(properties.sseEnabled)
  };
}

// @ts-ignore TS6133
function CfnSimpleTableSSESpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSimpleTable.SSESpecificationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSimpleTable.SSESpecificationProperty>();
  ret.addPropertyResult("sseEnabled", "SSEEnabled", (properties.SSEEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.SSEEnabled) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnSimpleTableProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnSimpleTableProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSimpleTablePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("primaryKey", CfnSimpleTablePrimaryKeyPropertyValidator)(properties.primaryKey));
  errors.collect(cdk.propertyValidator("provisionedThroughput", CfnSimpleTableProvisionedThroughputPropertyValidator)(properties.provisionedThroughput));
  errors.collect(cdk.propertyValidator("sseSpecification", CfnSimpleTableSSESpecificationPropertyValidator)(properties.sseSpecification));
  errors.collect(cdk.propertyValidator("tableName", cdk.validateString)(properties.tableName));
  errors.collect(cdk.propertyValidator("tags", cdk.hashValidator(cdk.validateString))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnSimpleTableProps\\"");
}

// @ts-ignore TS6133
function convertCfnSimpleTablePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSimpleTablePropsValidator(properties).assertSuccess();
  return {
    "PrimaryKey": convertCfnSimpleTablePrimaryKeyPropertyToCloudFormation(properties.primaryKey),
    "ProvisionedThroughput": convertCfnSimpleTableProvisionedThroughputPropertyToCloudFormation(properties.provisionedThroughput),
    "SSESpecification": convertCfnSimpleTableSSESpecificationPropertyToCloudFormation(properties.sseSpecification),
    "TableName": cdk.stringToCloudFormation(properties.tableName),
    "Tags": cdk.hashMapper(cdk.stringToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnSimpleTablePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSimpleTableProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSimpleTableProps>();
  ret.addPropertyResult("primaryKey", "PrimaryKey", (properties.PrimaryKey != null ? CfnSimpleTablePrimaryKeyPropertyFromCloudFormation(properties.PrimaryKey) : undefined));
  ret.addPropertyResult("provisionedThroughput", "ProvisionedThroughput", (properties.ProvisionedThroughput != null ? CfnSimpleTableProvisionedThroughputPropertyFromCloudFormation(properties.ProvisionedThroughput) : undefined));
  ret.addPropertyResult("sseSpecification", "SSESpecification", (properties.SSESpecification != null ? CfnSimpleTableSSESpecificationPropertyFromCloudFormation(properties.SSESpecification) : undefined));
  ret.addPropertyResult("tableName", "TableName", (properties.TableName != null ? cfn_parse.FromCloudFormation.getString(properties.TableName) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getString)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Definition of AWS::Serverless::StateMachine.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-statemachine.html
 */
export class CfnStateMachine extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::Serverless::StateMachine";

  /**
   * The \`Transform\` a template must use in order to use this resource
   */
  public static readonly REQUIRED_TRANSFORM: string = "AWS::Serverless-2016-10-31";

  /**
   * Build a CfnStateMachine from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnStateMachine {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnStateMachinePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnStateMachine(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  public definition?: any | cdk.IResolvable;

  public definitionSubstitutions?: cdk.IResolvable | Record<string, string>;

  public definitionUri?: cdk.IResolvable | CfnStateMachine.S3LocationProperty | string;

  public events?: cdk.IResolvable | Record<string, CfnStateMachine.EventSourceProperty | cdk.IResolvable>;

  public logging?: cdk.IResolvable | CfnStateMachine.LoggingConfigurationProperty;

  public name?: string;

  public permissionsBoundaries?: string;

  public policies?: Array<CfnStateMachine.IAMPolicyDocumentProperty | cdk.IResolvable | CfnStateMachine.SAMPolicyTemplateProperty | string> | CfnStateMachine.IAMPolicyDocumentProperty | cdk.IResolvable | string;

  public role?: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  public tagsRaw?: Record<string, string>;

  public tracing?: cdk.IResolvable | CfnStateMachine.TracingConfigurationProperty;

  public type?: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnStateMachineProps = {}) {
    super(scope, id, {
      "type": CfnStateMachine.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    // Automatically add the required transform
    this.stack.addTransform(CfnStateMachine.REQUIRED_TRANSFORM);

    this.definition = props.definition;
    this.definitionSubstitutions = props.definitionSubstitutions;
    this.definitionUri = props.definitionUri;
    this.events = props.events;
    this.logging = props.logging;
    this.name = props.name;
    this.permissionsBoundaries = props.permissionsBoundaries;
    this.policies = props.policies;
    this.role = props.role;
    this.tags = new cdk.TagManager(cdk.TagType.MAP, "AWS::Serverless::StateMachine", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.tracing = props.tracing;
    this.type = props.type;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "definition": this.definition,
      "definitionSubstitutions": this.definitionSubstitutions,
      "definitionUri": this.definitionUri,
      "events": this.events,
      "logging": this.logging,
      "name": this.name,
      "permissionsBoundaries": this.permissionsBoundaries,
      "policies": this.policies,
      "role": this.role,
      "tags": this.tags.renderTags(),
      "tracing": this.tracing,
      "type": this.type
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnStateMachine.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnStateMachinePropsToCloudFormation(props);
  }
}

export namespace CfnStateMachine {
  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-s3location.html
   */
  export interface S3LocationProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-s3location.html#cfn-serverless-statemachine-s3location-bucket
     */
    readonly bucket: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-s3location.html#cfn-serverless-statemachine-s3location-key
     */
    readonly key: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-s3location.html#cfn-serverless-statemachine-s3location-version
     */
    readonly version?: number;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-eventsource.html
   */
  export interface EventSourceProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-eventsource.html#cfn-serverless-statemachine-eventsource-properties
     */
    readonly properties: CfnStateMachine.ApiEventProperty | CfnStateMachine.CloudWatchEventEventProperty | CfnStateMachine.EventBridgeRuleEventProperty | cdk.IResolvable | CfnStateMachine.ScheduleEventProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-eventsource.html#cfn-serverless-statemachine-eventsource-type
     */
    readonly type: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-cloudwatcheventevent.html
   */
  export interface CloudWatchEventEventProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-cloudwatcheventevent.html#cfn-serverless-statemachine-cloudwatcheventevent-eventbusname
     */
    readonly eventBusName?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-cloudwatcheventevent.html#cfn-serverless-statemachine-cloudwatcheventevent-input
     */
    readonly input?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-cloudwatcheventevent.html#cfn-serverless-statemachine-cloudwatcheventevent-inputpath
     */
    readonly inputPath?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-cloudwatcheventevent.html#cfn-serverless-statemachine-cloudwatcheventevent-pattern
     */
    readonly pattern: any | cdk.IResolvable;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-eventbridgeruleevent.html
   */
  export interface EventBridgeRuleEventProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-eventbridgeruleevent.html#cfn-serverless-statemachine-eventbridgeruleevent-eventbusname
     */
    readonly eventBusName?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-eventbridgeruleevent.html#cfn-serverless-statemachine-eventbridgeruleevent-input
     */
    readonly input?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-eventbridgeruleevent.html#cfn-serverless-statemachine-eventbridgeruleevent-inputpath
     */
    readonly inputPath?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-eventbridgeruleevent.html#cfn-serverless-statemachine-eventbridgeruleevent-pattern
     */
    readonly pattern: any | cdk.IResolvable;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-scheduleevent.html
   */
  export interface ScheduleEventProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-scheduleevent.html#cfn-serverless-statemachine-scheduleevent-input
     */
    readonly input?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-scheduleevent.html#cfn-serverless-statemachine-scheduleevent-schedule
     */
    readonly schedule: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-apievent.html
   */
  export interface ApiEventProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-apievent.html#cfn-serverless-statemachine-apievent-method
     */
    readonly method: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-apievent.html#cfn-serverless-statemachine-apievent-path
     */
    readonly path: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-apievent.html#cfn-serverless-statemachine-apievent-restapiid
     */
    readonly restApiId?: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-loggingconfiguration.html
   */
  export interface LoggingConfigurationProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-loggingconfiguration.html#cfn-serverless-statemachine-loggingconfiguration-destinations
     */
    readonly destinations: Array<cdk.IResolvable | CfnStateMachine.LogDestinationProperty> | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-loggingconfiguration.html#cfn-serverless-statemachine-loggingconfiguration-includeexecutiondata
     */
    readonly includeExecutionData: boolean | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-loggingconfiguration.html#cfn-serverless-statemachine-loggingconfiguration-level
     */
    readonly level: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-logdestination.html
   */
  export interface LogDestinationProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-logdestination.html#cfn-serverless-statemachine-logdestination-cloudwatchlogsloggroup
     */
    readonly cloudWatchLogsLogGroup: CfnStateMachine.CloudWatchLogsLogGroupProperty | cdk.IResolvable;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-cloudwatchlogsloggroup.html
   */
  export interface CloudWatchLogsLogGroupProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-cloudwatchlogsloggroup.html#cfn-serverless-statemachine-cloudwatchlogsloggroup-loggrouparn
     */
    readonly logGroupArn: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-iampolicydocument.html
   */
  export interface IAMPolicyDocumentProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-iampolicydocument.html#cfn-serverless-statemachine-iampolicydocument-statement
     */
    readonly statement: any | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-iampolicydocument.html#cfn-serverless-statemachine-iampolicydocument-version
     */
    readonly version: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-sampolicytemplate.html
   */
  export interface SAMPolicyTemplateProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-sampolicytemplate.html#cfn-serverless-statemachine-sampolicytemplate-lambdainvokepolicy
     */
    readonly lambdaInvokePolicy?: CfnStateMachine.FunctionSAMPTProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-sampolicytemplate.html#cfn-serverless-statemachine-sampolicytemplate-stepfunctionsexecutionpolicy
     */
    readonly stepFunctionsExecutionPolicy?: cdk.IResolvable | CfnStateMachine.StateMachineSAMPTProperty;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-functionsampt.html
   */
  export interface FunctionSAMPTProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-functionsampt.html#cfn-serverless-statemachine-functionsampt-functionname
     */
    readonly functionName: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-statemachinesampt.html
   */
  export interface StateMachineSAMPTProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-statemachinesampt.html#cfn-serverless-statemachine-statemachinesampt-statemachinename
     */
    readonly stateMachineName: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-tracingconfiguration.html
   */
  export interface TracingConfigurationProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-tracingconfiguration.html#cfn-serverless-statemachine-tracingconfiguration-enabled
     */
    readonly enabled?: boolean | cdk.IResolvable;
  }
}

/**
 * Properties for defining a \`CfnStateMachine\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-statemachine.html
 */
export interface CfnStateMachineProps {
  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-statemachine.html#cfn-serverless-statemachine-definition
   */
  readonly definition?: any | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-statemachine.html#cfn-serverless-statemachine-definitionsubstitutions
   */
  readonly definitionSubstitutions?: cdk.IResolvable | Record<string, string>;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-statemachine.html#cfn-serverless-statemachine-definitionuri
   */
  readonly definitionUri?: cdk.IResolvable | CfnStateMachine.S3LocationProperty | string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-statemachine.html#cfn-serverless-statemachine-events
   */
  readonly events?: cdk.IResolvable | Record<string, CfnStateMachine.EventSourceProperty | cdk.IResolvable>;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-statemachine.html#cfn-serverless-statemachine-logging
   */
  readonly logging?: cdk.IResolvable | CfnStateMachine.LoggingConfigurationProperty;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-statemachine.html#cfn-serverless-statemachine-name
   */
  readonly name?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-statemachine.html#cfn-serverless-statemachine-permissionsboundaries
   */
  readonly permissionsBoundaries?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-statemachine.html#cfn-serverless-statemachine-policies
   */
  readonly policies?: Array<CfnStateMachine.IAMPolicyDocumentProperty | cdk.IResolvable | CfnStateMachine.SAMPolicyTemplateProperty | string> | CfnStateMachine.IAMPolicyDocumentProperty | cdk.IResolvable | string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-statemachine.html#cfn-serverless-statemachine-role
   */
  readonly role?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-statemachine.html#cfn-serverless-statemachine-tags
   */
  readonly tags?: Record<string, string>;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-statemachine.html#cfn-serverless-statemachine-tracing
   */
  readonly tracing?: cdk.IResolvable | CfnStateMachine.TracingConfigurationProperty;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-statemachine.html#cfn-serverless-statemachine-type
   */
  readonly type?: string;
}

/**
 * Determine whether the given properties match those of a \`S3LocationProperty\`
 *
 * @param properties - the TypeScript properties of a \`S3LocationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnStateMachineS3LocationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("bucket", cdk.requiredValidator)(properties.bucket));
  errors.collect(cdk.propertyValidator("bucket", cdk.validateString)(properties.bucket));
  errors.collect(cdk.propertyValidator("key", cdk.requiredValidator)(properties.key));
  errors.collect(cdk.propertyValidator("key", cdk.validateString)(properties.key));
  errors.collect(cdk.propertyValidator("version", cdk.validateNumber)(properties.version));
  return errors.wrap("supplied properties not correct for \\"S3LocationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnStateMachineS3LocationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnStateMachineS3LocationPropertyValidator(properties).assertSuccess();
  return {
    "Bucket": cdk.stringToCloudFormation(properties.bucket),
    "Key": cdk.stringToCloudFormation(properties.key),
    "Version": cdk.numberToCloudFormation(properties.version)
  };
}

// @ts-ignore TS6133
function CfnStateMachineS3LocationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnStateMachine.S3LocationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnStateMachine.S3LocationProperty>();
  ret.addPropertyResult("bucket", "Bucket", (properties.Bucket != null ? cfn_parse.FromCloudFormation.getString(properties.Bucket) : undefined));
  ret.addPropertyResult("key", "Key", (properties.Key != null ? cfn_parse.FromCloudFormation.getString(properties.Key) : undefined));
  ret.addPropertyResult("version", "Version", (properties.Version != null ? cfn_parse.FromCloudFormation.getNumber(properties.Version) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CloudWatchEventEventProperty\`
 *
 * @param properties - the TypeScript properties of a \`CloudWatchEventEventProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnStateMachineCloudWatchEventEventPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("eventBusName", cdk.validateString)(properties.eventBusName));
  errors.collect(cdk.propertyValidator("input", cdk.validateString)(properties.input));
  errors.collect(cdk.propertyValidator("inputPath", cdk.validateString)(properties.inputPath));
  errors.collect(cdk.propertyValidator("pattern", cdk.requiredValidator)(properties.pattern));
  errors.collect(cdk.propertyValidator("pattern", cdk.validateObject)(properties.pattern));
  return errors.wrap("supplied properties not correct for \\"CloudWatchEventEventProperty\\"");
}

// @ts-ignore TS6133
function convertCfnStateMachineCloudWatchEventEventPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnStateMachineCloudWatchEventEventPropertyValidator(properties).assertSuccess();
  return {
    "EventBusName": cdk.stringToCloudFormation(properties.eventBusName),
    "Input": cdk.stringToCloudFormation(properties.input),
    "InputPath": cdk.stringToCloudFormation(properties.inputPath),
    "Pattern": cdk.objectToCloudFormation(properties.pattern)
  };
}

// @ts-ignore TS6133
function CfnStateMachineCloudWatchEventEventPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnStateMachine.CloudWatchEventEventProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnStateMachine.CloudWatchEventEventProperty>();
  ret.addPropertyResult("eventBusName", "EventBusName", (properties.EventBusName != null ? cfn_parse.FromCloudFormation.getString(properties.EventBusName) : undefined));
  ret.addPropertyResult("input", "Input", (properties.Input != null ? cfn_parse.FromCloudFormation.getString(properties.Input) : undefined));
  ret.addPropertyResult("inputPath", "InputPath", (properties.InputPath != null ? cfn_parse.FromCloudFormation.getString(properties.InputPath) : undefined));
  ret.addPropertyResult("pattern", "Pattern", (properties.Pattern != null ? cfn_parse.FromCloudFormation.getAny(properties.Pattern) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`EventBridgeRuleEventProperty\`
 *
 * @param properties - the TypeScript properties of a \`EventBridgeRuleEventProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnStateMachineEventBridgeRuleEventPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("eventBusName", cdk.validateString)(properties.eventBusName));
  errors.collect(cdk.propertyValidator("input", cdk.validateString)(properties.input));
  errors.collect(cdk.propertyValidator("inputPath", cdk.validateString)(properties.inputPath));
  errors.collect(cdk.propertyValidator("pattern", cdk.requiredValidator)(properties.pattern));
  errors.collect(cdk.propertyValidator("pattern", cdk.validateObject)(properties.pattern));
  return errors.wrap("supplied properties not correct for \\"EventBridgeRuleEventProperty\\"");
}

// @ts-ignore TS6133
function convertCfnStateMachineEventBridgeRuleEventPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnStateMachineEventBridgeRuleEventPropertyValidator(properties).assertSuccess();
  return {
    "EventBusName": cdk.stringToCloudFormation(properties.eventBusName),
    "Input": cdk.stringToCloudFormation(properties.input),
    "InputPath": cdk.stringToCloudFormation(properties.inputPath),
    "Pattern": cdk.objectToCloudFormation(properties.pattern)
  };
}

// @ts-ignore TS6133
function CfnStateMachineEventBridgeRuleEventPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnStateMachine.EventBridgeRuleEventProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnStateMachine.EventBridgeRuleEventProperty>();
  ret.addPropertyResult("eventBusName", "EventBusName", (properties.EventBusName != null ? cfn_parse.FromCloudFormation.getString(properties.EventBusName) : undefined));
  ret.addPropertyResult("input", "Input", (properties.Input != null ? cfn_parse.FromCloudFormation.getString(properties.Input) : undefined));
  ret.addPropertyResult("inputPath", "InputPath", (properties.InputPath != null ? cfn_parse.FromCloudFormation.getString(properties.InputPath) : undefined));
  ret.addPropertyResult("pattern", "Pattern", (properties.Pattern != null ? cfn_parse.FromCloudFormation.getAny(properties.Pattern) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ScheduleEventProperty\`
 *
 * @param properties - the TypeScript properties of a \`ScheduleEventProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnStateMachineScheduleEventPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("input", cdk.validateString)(properties.input));
  errors.collect(cdk.propertyValidator("schedule", cdk.requiredValidator)(properties.schedule));
  errors.collect(cdk.propertyValidator("schedule", cdk.validateString)(properties.schedule));
  return errors.wrap("supplied properties not correct for \\"ScheduleEventProperty\\"");
}

// @ts-ignore TS6133
function convertCfnStateMachineScheduleEventPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnStateMachineScheduleEventPropertyValidator(properties).assertSuccess();
  return {
    "Input": cdk.stringToCloudFormation(properties.input),
    "Schedule": cdk.stringToCloudFormation(properties.schedule)
  };
}

// @ts-ignore TS6133
function CfnStateMachineScheduleEventPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnStateMachine.ScheduleEventProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnStateMachine.ScheduleEventProperty>();
  ret.addPropertyResult("input", "Input", (properties.Input != null ? cfn_parse.FromCloudFormation.getString(properties.Input) : undefined));
  ret.addPropertyResult("schedule", "Schedule", (properties.Schedule != null ? cfn_parse.FromCloudFormation.getString(properties.Schedule) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ApiEventProperty\`
 *
 * @param properties - the TypeScript properties of a \`ApiEventProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnStateMachineApiEventPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("method", cdk.requiredValidator)(properties.method));
  errors.collect(cdk.propertyValidator("method", cdk.validateString)(properties.method));
  errors.collect(cdk.propertyValidator("path", cdk.requiredValidator)(properties.path));
  errors.collect(cdk.propertyValidator("path", cdk.validateString)(properties.path));
  errors.collect(cdk.propertyValidator("restApiId", cdk.validateString)(properties.restApiId));
  return errors.wrap("supplied properties not correct for \\"ApiEventProperty\\"");
}

// @ts-ignore TS6133
function convertCfnStateMachineApiEventPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnStateMachineApiEventPropertyValidator(properties).assertSuccess();
  return {
    "Method": cdk.stringToCloudFormation(properties.method),
    "Path": cdk.stringToCloudFormation(properties.path),
    "RestApiId": cdk.stringToCloudFormation(properties.restApiId)
  };
}

// @ts-ignore TS6133
function CfnStateMachineApiEventPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnStateMachine.ApiEventProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnStateMachine.ApiEventProperty>();
  ret.addPropertyResult("method", "Method", (properties.Method != null ? cfn_parse.FromCloudFormation.getString(properties.Method) : undefined));
  ret.addPropertyResult("path", "Path", (properties.Path != null ? cfn_parse.FromCloudFormation.getString(properties.Path) : undefined));
  ret.addPropertyResult("restApiId", "RestApiId", (properties.RestApiId != null ? cfn_parse.FromCloudFormation.getString(properties.RestApiId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`EventSourceProperty\`
 *
 * @param properties - the TypeScript properties of a \`EventSourceProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnStateMachineEventSourcePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("properties", cdk.requiredValidator)(properties.properties));
  errors.collect(cdk.propertyValidator("properties", cdk.unionValidator(CfnStateMachineApiEventPropertyValidator, CfnStateMachineCloudWatchEventEventPropertyValidator, CfnStateMachineEventBridgeRuleEventPropertyValidator, CfnStateMachineScheduleEventPropertyValidator))(properties.properties));
  errors.collect(cdk.propertyValidator("type", cdk.requiredValidator)(properties.type));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  return errors.wrap("supplied properties not correct for \\"EventSourceProperty\\"");
}

// @ts-ignore TS6133
function convertCfnStateMachineEventSourcePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnStateMachineEventSourcePropertyValidator(properties).assertSuccess();
  return {
    "Properties": cdk.unionMapper([CfnStateMachineApiEventPropertyValidator, CfnStateMachineCloudWatchEventEventPropertyValidator, CfnStateMachineEventBridgeRuleEventPropertyValidator, CfnStateMachineScheduleEventPropertyValidator], [convertCfnStateMachineApiEventPropertyToCloudFormation, convertCfnStateMachineCloudWatchEventEventPropertyToCloudFormation, convertCfnStateMachineEventBridgeRuleEventPropertyToCloudFormation, convertCfnStateMachineScheduleEventPropertyToCloudFormation])(properties.properties),
    "Type": cdk.stringToCloudFormation(properties.type)
  };
}

// @ts-ignore TS6133
function CfnStateMachineEventSourcePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnStateMachine.EventSourceProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnStateMachine.EventSourceProperty>();
  ret.addPropertyResult("properties", "Properties", (properties.Properties != null ? cfn_parse.FromCloudFormation.getTypeUnion([CfnStateMachineApiEventPropertyValidator, CfnStateMachineCloudWatchEventEventPropertyValidator, CfnStateMachineEventBridgeRuleEventPropertyValidator, CfnStateMachineScheduleEventPropertyValidator], [CfnStateMachineApiEventPropertyFromCloudFormation, CfnStateMachineCloudWatchEventEventPropertyFromCloudFormation, CfnStateMachineEventBridgeRuleEventPropertyFromCloudFormation, CfnStateMachineScheduleEventPropertyFromCloudFormation])(properties.Properties) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CloudWatchLogsLogGroupProperty\`
 *
 * @param properties - the TypeScript properties of a \`CloudWatchLogsLogGroupProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnStateMachineCloudWatchLogsLogGroupPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("logGroupArn", cdk.requiredValidator)(properties.logGroupArn));
  errors.collect(cdk.propertyValidator("logGroupArn", cdk.validateString)(properties.logGroupArn));
  return errors.wrap("supplied properties not correct for \\"CloudWatchLogsLogGroupProperty\\"");
}

// @ts-ignore TS6133
function convertCfnStateMachineCloudWatchLogsLogGroupPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnStateMachineCloudWatchLogsLogGroupPropertyValidator(properties).assertSuccess();
  return {
    "LogGroupArn": cdk.stringToCloudFormation(properties.logGroupArn)
  };
}

// @ts-ignore TS6133
function CfnStateMachineCloudWatchLogsLogGroupPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnStateMachine.CloudWatchLogsLogGroupProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnStateMachine.CloudWatchLogsLogGroupProperty>();
  ret.addPropertyResult("logGroupArn", "LogGroupArn", (properties.LogGroupArn != null ? cfn_parse.FromCloudFormation.getString(properties.LogGroupArn) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`LogDestinationProperty\`
 *
 * @param properties - the TypeScript properties of a \`LogDestinationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnStateMachineLogDestinationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("cloudWatchLogsLogGroup", cdk.requiredValidator)(properties.cloudWatchLogsLogGroup));
  errors.collect(cdk.propertyValidator("cloudWatchLogsLogGroup", CfnStateMachineCloudWatchLogsLogGroupPropertyValidator)(properties.cloudWatchLogsLogGroup));
  return errors.wrap("supplied properties not correct for \\"LogDestinationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnStateMachineLogDestinationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnStateMachineLogDestinationPropertyValidator(properties).assertSuccess();
  return {
    "CloudWatchLogsLogGroup": convertCfnStateMachineCloudWatchLogsLogGroupPropertyToCloudFormation(properties.cloudWatchLogsLogGroup)
  };
}

// @ts-ignore TS6133
function CfnStateMachineLogDestinationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnStateMachine.LogDestinationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnStateMachine.LogDestinationProperty>();
  ret.addPropertyResult("cloudWatchLogsLogGroup", "CloudWatchLogsLogGroup", (properties.CloudWatchLogsLogGroup != null ? CfnStateMachineCloudWatchLogsLogGroupPropertyFromCloudFormation(properties.CloudWatchLogsLogGroup) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`LoggingConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`LoggingConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnStateMachineLoggingConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("destinations", cdk.requiredValidator)(properties.destinations));
  errors.collect(cdk.propertyValidator("destinations", cdk.listValidator(CfnStateMachineLogDestinationPropertyValidator))(properties.destinations));
  errors.collect(cdk.propertyValidator("includeExecutionData", cdk.requiredValidator)(properties.includeExecutionData));
  errors.collect(cdk.propertyValidator("includeExecutionData", cdk.validateBoolean)(properties.includeExecutionData));
  errors.collect(cdk.propertyValidator("level", cdk.requiredValidator)(properties.level));
  errors.collect(cdk.propertyValidator("level", cdk.validateString)(properties.level));
  return errors.wrap("supplied properties not correct for \\"LoggingConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnStateMachineLoggingConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnStateMachineLoggingConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "Destinations": cdk.listMapper(convertCfnStateMachineLogDestinationPropertyToCloudFormation)(properties.destinations),
    "IncludeExecutionData": cdk.booleanToCloudFormation(properties.includeExecutionData),
    "Level": cdk.stringToCloudFormation(properties.level)
  };
}

// @ts-ignore TS6133
function CfnStateMachineLoggingConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnStateMachine.LoggingConfigurationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnStateMachine.LoggingConfigurationProperty>();
  ret.addPropertyResult("destinations", "Destinations", (properties.Destinations != null ? cfn_parse.FromCloudFormation.getArray(CfnStateMachineLogDestinationPropertyFromCloudFormation)(properties.Destinations) : undefined));
  ret.addPropertyResult("includeExecutionData", "IncludeExecutionData", (properties.IncludeExecutionData != null ? cfn_parse.FromCloudFormation.getBoolean(properties.IncludeExecutionData) : undefined));
  ret.addPropertyResult("level", "Level", (properties.Level != null ? cfn_parse.FromCloudFormation.getString(properties.Level) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`IAMPolicyDocumentProperty\`
 *
 * @param properties - the TypeScript properties of a \`IAMPolicyDocumentProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnStateMachineIAMPolicyDocumentPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("statement", cdk.requiredValidator)(properties.statement));
  errors.collect(cdk.propertyValidator("statement", cdk.validateObject)(properties.statement));
  errors.collect(cdk.propertyValidator("version", cdk.requiredValidator)(properties.version));
  errors.collect(cdk.propertyValidator("version", cdk.validateString)(properties.version));
  return errors.wrap("supplied properties not correct for \\"IAMPolicyDocumentProperty\\"");
}

// @ts-ignore TS6133
function convertCfnStateMachineIAMPolicyDocumentPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnStateMachineIAMPolicyDocumentPropertyValidator(properties).assertSuccess();
  return {
    "Statement": cdk.objectToCloudFormation(properties.statement),
    "Version": cdk.stringToCloudFormation(properties.version)
  };
}

// @ts-ignore TS6133
function CfnStateMachineIAMPolicyDocumentPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnStateMachine.IAMPolicyDocumentProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnStateMachine.IAMPolicyDocumentProperty>();
  ret.addPropertyResult("statement", "Statement", (properties.Statement != null ? cfn_parse.FromCloudFormation.getAny(properties.Statement) : undefined));
  ret.addPropertyResult("version", "Version", (properties.Version != null ? cfn_parse.FromCloudFormation.getString(properties.Version) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`FunctionSAMPTProperty\`
 *
 * @param properties - the TypeScript properties of a \`FunctionSAMPTProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnStateMachineFunctionSAMPTPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("functionName", cdk.requiredValidator)(properties.functionName));
  errors.collect(cdk.propertyValidator("functionName", cdk.validateString)(properties.functionName));
  return errors.wrap("supplied properties not correct for \\"FunctionSAMPTProperty\\"");
}

// @ts-ignore TS6133
function convertCfnStateMachineFunctionSAMPTPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnStateMachineFunctionSAMPTPropertyValidator(properties).assertSuccess();
  return {
    "FunctionName": cdk.stringToCloudFormation(properties.functionName)
  };
}

// @ts-ignore TS6133
function CfnStateMachineFunctionSAMPTPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnStateMachine.FunctionSAMPTProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnStateMachine.FunctionSAMPTProperty>();
  ret.addPropertyResult("functionName", "FunctionName", (properties.FunctionName != null ? cfn_parse.FromCloudFormation.getString(properties.FunctionName) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`StateMachineSAMPTProperty\`
 *
 * @param properties - the TypeScript properties of a \`StateMachineSAMPTProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnStateMachineStateMachineSAMPTPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("stateMachineName", cdk.requiredValidator)(properties.stateMachineName));
  errors.collect(cdk.propertyValidator("stateMachineName", cdk.validateString)(properties.stateMachineName));
  return errors.wrap("supplied properties not correct for \\"StateMachineSAMPTProperty\\"");
}

// @ts-ignore TS6133
function convertCfnStateMachineStateMachineSAMPTPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnStateMachineStateMachineSAMPTPropertyValidator(properties).assertSuccess();
  return {
    "StateMachineName": cdk.stringToCloudFormation(properties.stateMachineName)
  };
}

// @ts-ignore TS6133
function CfnStateMachineStateMachineSAMPTPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnStateMachine.StateMachineSAMPTProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnStateMachine.StateMachineSAMPTProperty>();
  ret.addPropertyResult("stateMachineName", "StateMachineName", (properties.StateMachineName != null ? cfn_parse.FromCloudFormation.getString(properties.StateMachineName) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`SAMPolicyTemplateProperty\`
 *
 * @param properties - the TypeScript properties of a \`SAMPolicyTemplateProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnStateMachineSAMPolicyTemplatePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("lambdaInvokePolicy", CfnStateMachineFunctionSAMPTPropertyValidator)(properties.lambdaInvokePolicy));
  errors.collect(cdk.propertyValidator("stepFunctionsExecutionPolicy", CfnStateMachineStateMachineSAMPTPropertyValidator)(properties.stepFunctionsExecutionPolicy));
  return errors.wrap("supplied properties not correct for \\"SAMPolicyTemplateProperty\\"");
}

// @ts-ignore TS6133
function convertCfnStateMachineSAMPolicyTemplatePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnStateMachineSAMPolicyTemplatePropertyValidator(properties).assertSuccess();
  return {
    "LambdaInvokePolicy": convertCfnStateMachineFunctionSAMPTPropertyToCloudFormation(properties.lambdaInvokePolicy),
    "StepFunctionsExecutionPolicy": convertCfnStateMachineStateMachineSAMPTPropertyToCloudFormation(properties.stepFunctionsExecutionPolicy)
  };
}

// @ts-ignore TS6133
function CfnStateMachineSAMPolicyTemplatePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnStateMachine.SAMPolicyTemplateProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnStateMachine.SAMPolicyTemplateProperty>();
  ret.addPropertyResult("lambdaInvokePolicy", "LambdaInvokePolicy", (properties.LambdaInvokePolicy != null ? CfnStateMachineFunctionSAMPTPropertyFromCloudFormation(properties.LambdaInvokePolicy) : undefined));
  ret.addPropertyResult("stepFunctionsExecutionPolicy", "StepFunctionsExecutionPolicy", (properties.StepFunctionsExecutionPolicy != null ? CfnStateMachineStateMachineSAMPTPropertyFromCloudFormation(properties.StepFunctionsExecutionPolicy) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`TracingConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`TracingConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnStateMachineTracingConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("enabled", cdk.validateBoolean)(properties.enabled));
  return errors.wrap("supplied properties not correct for \\"TracingConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnStateMachineTracingConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnStateMachineTracingConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "Enabled": cdk.booleanToCloudFormation(properties.enabled)
  };
}

// @ts-ignore TS6133
function CfnStateMachineTracingConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnStateMachine.TracingConfigurationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnStateMachine.TracingConfigurationProperty>();
  ret.addPropertyResult("enabled", "Enabled", (properties.Enabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Enabled) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnStateMachineProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnStateMachineProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnStateMachinePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("definition", cdk.validateObject)(properties.definition));
  errors.collect(cdk.propertyValidator("definitionSubstitutions", cdk.hashValidator(cdk.validateString))(properties.definitionSubstitutions));
  errors.collect(cdk.propertyValidator("definitionUri", cdk.unionValidator(CfnStateMachineS3LocationPropertyValidator, cdk.validateString))(properties.definitionUri));
  errors.collect(cdk.propertyValidator("events", cdk.hashValidator(CfnStateMachineEventSourcePropertyValidator))(properties.events));
  errors.collect(cdk.propertyValidator("logging", CfnStateMachineLoggingConfigurationPropertyValidator)(properties.logging));
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  errors.collect(cdk.propertyValidator("permissionsBoundaries", cdk.validateString)(properties.permissionsBoundaries));
  errors.collect(cdk.propertyValidator("policies", cdk.unionValidator(cdk.listValidator(cdk.unionValidator(CfnStateMachineIAMPolicyDocumentPropertyValidator, CfnStateMachineSAMPolicyTemplatePropertyValidator, cdk.validateString)), CfnStateMachineIAMPolicyDocumentPropertyValidator, cdk.validateString))(properties.policies));
  errors.collect(cdk.propertyValidator("role", cdk.validateString)(properties.role));
  errors.collect(cdk.propertyValidator("tags", cdk.hashValidator(cdk.validateString))(properties.tags));
  errors.collect(cdk.propertyValidator("tracing", CfnStateMachineTracingConfigurationPropertyValidator)(properties.tracing));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  return errors.wrap("supplied properties not correct for \\"CfnStateMachineProps\\"");
}

// @ts-ignore TS6133
function convertCfnStateMachinePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnStateMachinePropsValidator(properties).assertSuccess();
  return {
    "Definition": cdk.objectToCloudFormation(properties.definition),
    "DefinitionSubstitutions": cdk.hashMapper(cdk.stringToCloudFormation)(properties.definitionSubstitutions),
    "DefinitionUri": cdk.unionMapper([CfnStateMachineS3LocationPropertyValidator, cdk.validateString], [convertCfnStateMachineS3LocationPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.definitionUri),
    "Events": cdk.hashMapper(convertCfnStateMachineEventSourcePropertyToCloudFormation)(properties.events),
    "Logging": convertCfnStateMachineLoggingConfigurationPropertyToCloudFormation(properties.logging),
    "Name": cdk.stringToCloudFormation(properties.name),
    "PermissionsBoundaries": cdk.stringToCloudFormation(properties.permissionsBoundaries),
    "Policies": cdk.unionMapper([cdk.listValidator(cdk.unionValidator(CfnStateMachineIAMPolicyDocumentPropertyValidator, CfnStateMachineSAMPolicyTemplatePropertyValidator, cdk.validateString)), CfnStateMachineIAMPolicyDocumentPropertyValidator, cdk.validateString], [cdk.listMapper(cdk.unionMapper([CfnStateMachineIAMPolicyDocumentPropertyValidator, CfnStateMachineSAMPolicyTemplatePropertyValidator, cdk.validateString], [convertCfnStateMachineIAMPolicyDocumentPropertyToCloudFormation, convertCfnStateMachineSAMPolicyTemplatePropertyToCloudFormation, cdk.stringToCloudFormation])), convertCfnStateMachineIAMPolicyDocumentPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.policies),
    "Role": cdk.stringToCloudFormation(properties.role),
    "Tags": cdk.hashMapper(cdk.stringToCloudFormation)(properties.tags),
    "Tracing": convertCfnStateMachineTracingConfigurationPropertyToCloudFormation(properties.tracing),
    "Type": cdk.stringToCloudFormation(properties.type)
  };
}

// @ts-ignore TS6133
function CfnStateMachinePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnStateMachineProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnStateMachineProps>();
  ret.addPropertyResult("definition", "Definition", (properties.Definition != null ? cfn_parse.FromCloudFormation.getAny(properties.Definition) : undefined));
  ret.addPropertyResult("definitionSubstitutions", "DefinitionSubstitutions", (properties.DefinitionSubstitutions != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getString)(properties.DefinitionSubstitutions) : undefined));
  ret.addPropertyResult("definitionUri", "DefinitionUri", (properties.DefinitionUri != null ? cfn_parse.FromCloudFormation.getTypeUnion([CfnStateMachineS3LocationPropertyValidator, cdk.validateString], [CfnStateMachineS3LocationPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.DefinitionUri) : undefined));
  ret.addPropertyResult("events", "Events", (properties.Events != null ? cfn_parse.FromCloudFormation.getMap(CfnStateMachineEventSourcePropertyFromCloudFormation)(properties.Events) : undefined));
  ret.addPropertyResult("logging", "Logging", (properties.Logging != null ? CfnStateMachineLoggingConfigurationPropertyFromCloudFormation(properties.Logging) : undefined));
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addPropertyResult("permissionsBoundaries", "PermissionsBoundaries", (properties.PermissionsBoundaries != null ? cfn_parse.FromCloudFormation.getString(properties.PermissionsBoundaries) : undefined));
  ret.addPropertyResult("policies", "Policies", (properties.Policies != null ? cfn_parse.FromCloudFormation.getTypeUnion([cdk.listValidator(cdk.unionValidator(CfnStateMachineIAMPolicyDocumentPropertyValidator, CfnStateMachineSAMPolicyTemplatePropertyValidator, cdk.validateString)), CfnStateMachineIAMPolicyDocumentPropertyValidator, cdk.validateString], [cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getTypeUnion([CfnStateMachineIAMPolicyDocumentPropertyValidator, CfnStateMachineSAMPolicyTemplatePropertyValidator, cdk.validateString], [CfnStateMachineIAMPolicyDocumentPropertyFromCloudFormation, CfnStateMachineSAMPolicyTemplatePropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])), CfnStateMachineIAMPolicyDocumentPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.Policies) : undefined));
  ret.addPropertyResult("role", "Role", (properties.Role != null ? cfn_parse.FromCloudFormation.getString(properties.Role) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getString)(properties.Tags) : undefined));
  ret.addPropertyResult("tracing", "Tracing", (properties.Tracing != null ? CfnStateMachineTracingConfigurationPropertyFromCloudFormation(properties.Tracing) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}",
}
`;

exports[`aws-scheduler 1`] = `
{
  "augmentations": undefined,
  "metrics": undefined,
  "module": "/* eslint-disable prettier/prettier,max-len */
import * as cdk from "aws-cdk-lib";
import * as constructs from "constructs";
import * as cfn_parse from "aws-cdk-lib/core/lib/helpers-internal";

/**
 * A *schedule* is the main resource you create, configure, and manage using Amazon EventBridge Scheduler.
 *
 * Every schedule has a *schedule expression* that determines when, and with what frequency, the schedule runs. EventBridge Scheduler supports three types of schedules: rate, cron, and one-time schedules. For more information about different schedule types, see [Schedule types](https://docs.aws.amazon.com/scheduler/latest/UserGuide/schedule-types.html) in the *EventBridge Scheduler User Guide* .
 *
 * When you create a schedule, you configure a target for the schedule to invoke. A target is an API operation that EventBridge Scheduler calls on your behalf every time your schedule runs. EventBridge Scheduler supports two types of targets: *templated* targets invoke common API operations across a core groups of services, and customizeable *universal* targets that you can use to call more than 6,000 operations across over 270 services. For more information about configuring targets, see [Managing targets](https://docs.aws.amazon.com/scheduler/latest/UserGuide/managing-targets.html) in the *EventBridge Scheduler User Guide* .
 *
 * For more information about managing schedules, changing the schedule state, setting up flexible time windows, and configuring a dead-letter queue for a schedule, see [Managing a schedule](https://docs.aws.amazon.com/scheduler/latest/UserGuide/managing-schedule.html) in the *EventBridge Scheduler User Guide* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-scheduler-schedule.html
 */
export class CfnSchedule extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::Scheduler::Schedule";

  /**
   * Build a CfnSchedule from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnSchedule {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnSchedulePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnSchedule(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The Amazon Resource Name (ARN) for the Amazon EventBridge Scheduler schedule.
   *
   * @cloudformationAttribute Arn
   */
  public readonly attrArn: string;

  /**
   * The description you specify for the schedule.
   */
  public description?: string;

  /**
   * The date, in UTC, before which the schedule can invoke its target.
   */
  public endDate?: string;

  /**
   * Allows you to configure a time window during which EventBridge Scheduler invokes the schedule.
   */
  public flexibleTimeWindow: CfnSchedule.FlexibleTimeWindowProperty | cdk.IResolvable;

  /**
   * The name of the schedule group associated with this schedule.
   */
  public groupName?: string;

  /**
   * The Amazon Resource Name (ARN) for the customer managed KMS key that EventBridge Scheduler will use to encrypt and decrypt your data.
   */
  public kmsKeyArn?: string;

  /**
   * The name of the schedule.
   */
  public name?: string;

  /**
   * The expression that defines when the schedule runs. The following formats are supported.
   */
  public scheduleExpression: string;

  /**
   * The timezone in which the scheduling expression is evaluated.
   */
  public scheduleExpressionTimezone?: string;

  /**
   * The date, in UTC, after which the schedule can begin invoking its target.
   */
  public startDate?: string;

  /**
   * Specifies whether the schedule is enabled or disabled.
   */
  public state?: string;

  /**
   * The schedule's target details.
   */
  public target: cdk.IResolvable | CfnSchedule.TargetProperty;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnScheduleProps) {
    super(scope, id, {
      "type": CfnSchedule.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "flexibleTimeWindow", this);
    cdk.requireProperty(props, "scheduleExpression", this);
    cdk.requireProperty(props, "target", this);

    this.attrArn = cdk.Token.asString(this.getAtt("Arn", cdk.ResolutionTypeHint.STRING));
    this.description = props.description;
    this.endDate = props.endDate;
    this.flexibleTimeWindow = props.flexibleTimeWindow;
    this.groupName = props.groupName;
    this.kmsKeyArn = props.kmsKeyArn;
    this.name = props.name;
    this.scheduleExpression = props.scheduleExpression;
    this.scheduleExpressionTimezone = props.scheduleExpressionTimezone;
    this.startDate = props.startDate;
    this.state = props.state;
    this.target = props.target;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "description": this.description,
      "endDate": this.endDate,
      "flexibleTimeWindow": this.flexibleTimeWindow,
      "groupName": this.groupName,
      "kmsKeyArn": this.kmsKeyArn,
      "name": this.name,
      "scheduleExpression": this.scheduleExpression,
      "scheduleExpressionTimezone": this.scheduleExpressionTimezone,
      "startDate": this.startDate,
      "state": this.state,
      "target": this.target
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnSchedule.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnSchedulePropsToCloudFormation(props);
  }
}

export namespace CfnSchedule {
  /**
   * Allows you to configure a time window during which EventBridge Scheduler invokes the schedule.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-flexibletimewindow.html
   */
  export interface FlexibleTimeWindowProperty {
    /**
     * The maximum time window during which a schedule can be invoked.
     *
     * *Minimum* : \`1\`
     *
     * *Maximum* : \`1440\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-flexibletimewindow.html#cfn-scheduler-schedule-flexibletimewindow-maximumwindowinminutes
     */
    readonly maximumWindowInMinutes?: number;

    /**
     * Determines whether the schedule is invoked within a flexible time window.
     *
     * *Allowed Values* : \`OFF\` | \`FLEXIBLE\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-flexibletimewindow.html#cfn-scheduler-schedule-flexibletimewindow-mode
     */
    readonly mode: string;
  }

  /**
   * The schedule's target.
   *
   * EventBridge Scheduler supports templated target that invoke common API operations, as well as universal targets that you can customize to invoke over 6,000 API operations across more than 270 services. You can only specify one templated or universal target for a schedule.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-target.html
   */
  export interface TargetProperty {
    /**
     * The Amazon Resource Name (ARN) of the target.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-target.html#cfn-scheduler-schedule-target-arn
     */
    readonly arn: string;

    /**
     * An object that contains information about an Amazon SQS queue that EventBridge Scheduler uses as a dead-letter queue for your schedule.
     *
     * If specified, EventBridge Scheduler delivers failed events that could not be successfully delivered to a target to the queue.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-target.html#cfn-scheduler-schedule-target-deadletterconfig
     */
    readonly deadLetterConfig?: CfnSchedule.DeadLetterConfigProperty | cdk.IResolvable;

    /**
     * The templated target type for the Amazon ECS [\`RunTask\`](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_RunTask.html) API operation.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-target.html#cfn-scheduler-schedule-target-ecsparameters
     */
    readonly ecsParameters?: CfnSchedule.EcsParametersProperty | cdk.IResolvable;

    /**
     * The templated target type for the EventBridge [\`PutEvents\`](https://docs.aws.amazon.com/eventbridge/latest/APIReference/API_PutEvents.html) API operation.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-target.html#cfn-scheduler-schedule-target-eventbridgeparameters
     */
    readonly eventBridgeParameters?: CfnSchedule.EventBridgeParametersProperty | cdk.IResolvable;

    /**
     * The text, or well-formed JSON, passed to the target.
     *
     * If you are configuring a templated Lambda , AWS Step Functions , or Amazon EventBridge target, the input must be a well-formed JSON. For all other target types, a JSON is not required. If you do not specify anything for this field, Amazon EventBridge Scheduler delivers a default notification to the target.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-target.html#cfn-scheduler-schedule-target-input
     */
    readonly input?: string;

    /**
     * The templated target type for the Amazon Kinesis [\`PutRecord\`](https://docs.aws.amazon.com/kinesis/latest/APIReference/API_PutRecord.html) API operation.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-target.html#cfn-scheduler-schedule-target-kinesisparameters
     */
    readonly kinesisParameters?: cdk.IResolvable | CfnSchedule.KinesisParametersProperty;

    /**
     * A \`RetryPolicy\` object that includes information about the retry policy settings, including the maximum age of an event, and the maximum number of times EventBridge Scheduler will try to deliver the event to a target.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-target.html#cfn-scheduler-schedule-target-retrypolicy
     */
    readonly retryPolicy?: cdk.IResolvable | CfnSchedule.RetryPolicyProperty;

    /**
     * The Amazon Resource Name (ARN) of the IAM role that EventBridge Scheduler will use for this target when the schedule is invoked.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-target.html#cfn-scheduler-schedule-target-rolearn
     */
    readonly roleArn: string;

    /**
     * The templated target type for the Amazon SageMaker [\`StartPipelineExecution\`](https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_StartPipelineExecution.html) API operation.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-target.html#cfn-scheduler-schedule-target-sagemakerpipelineparameters
     */
    readonly sageMakerPipelineParameters?: cdk.IResolvable | CfnSchedule.SageMakerPipelineParametersProperty;

    /**
     * The templated target type for the Amazon SQS [\`SendMessage\`](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/APIReference/API_SendMessage.html) API operation. Contains the message group ID to use when the target is a FIFO queue. If you specify an Amazon SQS FIFO queue as a target, the queue must have content-based deduplication enabled. For more information, see [Using the Amazon SQS message deduplication ID](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/using-messagededuplicationid-property.html) in the *Amazon SQS Developer Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-target.html#cfn-scheduler-schedule-target-sqsparameters
     */
    readonly sqsParameters?: cdk.IResolvable | CfnSchedule.SqsParametersProperty;
  }

  /**
   * An object that contains information about an Amazon SQS queue that EventBridge Scheduler uses as a dead-letter queue for your schedule.
   *
   * If specified, EventBridge Scheduler delivers failed events that could not be successfully delivered to a target to the queue.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-deadletterconfig.html
   */
  export interface DeadLetterConfigProperty {
    /**
     * The Amazon Resource Name (ARN) of the SQS queue specified as the destination for the dead-letter queue.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-deadletterconfig.html#cfn-scheduler-schedule-deadletterconfig-arn
     */
    readonly arn?: string;
  }

  /**
   * A \`RetryPolicy\` object that includes information about the retry policy settings, including the maximum age of an event, and the maximum number of times EventBridge Scheduler will try to deliver the event to a target.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-retrypolicy.html
   */
  export interface RetryPolicyProperty {
    /**
     * The maximum amount of time, in seconds, to continue to make retry attempts.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-retrypolicy.html#cfn-scheduler-schedule-retrypolicy-maximumeventageinseconds
     */
    readonly maximumEventAgeInSeconds?: number;

    /**
     * The maximum number of retry attempts to make before the request fails.
     *
     * Retry attempts with exponential backoff continue until either the maximum number of attempts is made or until the duration of the \`MaximumEventAgeInSeconds\` is reached.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-retrypolicy.html#cfn-scheduler-schedule-retrypolicy-maximumretryattempts
     */
    readonly maximumRetryAttempts?: number;
  }

  /**
   * The templated target type for the Amazon ECS [\`RunTask\`](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_RunTask.html) API operation.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-ecsparameters.html
   */
  export interface EcsParametersProperty {
    /**
     * The capacity provider strategy to use for the task.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-ecsparameters.html#cfn-scheduler-schedule-ecsparameters-capacityproviderstrategy
     */
    readonly capacityProviderStrategy?: Array<CfnSchedule.CapacityProviderStrategyItemProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * Specifies whether to enable Amazon ECS managed tags for the task.
     *
     * For more information, see [Tagging Your Amazon ECS Resources](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-using-tags.html) in the *Amazon ECS Developer Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-ecsparameters.html#cfn-scheduler-schedule-ecsparameters-enableecsmanagedtags
     */
    readonly enableEcsManagedTags?: boolean | cdk.IResolvable;

    /**
     * Whether or not to enable the execute command functionality for the containers in this task.
     *
     * If true, this enables execute command functionality on all containers in the task.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-ecsparameters.html#cfn-scheduler-schedule-ecsparameters-enableexecutecommand
     */
    readonly enableExecuteCommand?: boolean | cdk.IResolvable;

    /**
     * Specifies an Amazon ECS task group for the task.
     *
     * The maximum length is 255 characters.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-ecsparameters.html#cfn-scheduler-schedule-ecsparameters-group
     */
    readonly group?: string;

    /**
     * Specifies the launch type on which your task is running.
     *
     * The launch type that you specify here must match one of the launch type (compatibilities) of the target task. The \`FARGATE\` value is supported only in the Regions where Fargate with Amazon ECS is supported. For more information, see [AWS Fargate on Amazon ECS](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/AWS_Fargate.html) in the *Amazon ECS Developer Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-ecsparameters.html#cfn-scheduler-schedule-ecsparameters-launchtype
     */
    readonly launchType?: string;

    /**
     * This structure specifies the network configuration for an ECS task.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-ecsparameters.html#cfn-scheduler-schedule-ecsparameters-networkconfiguration
     */
    readonly networkConfiguration?: cdk.IResolvable | CfnSchedule.NetworkConfigurationProperty;

    /**
     * An array of placement constraint objects to use for the task.
     *
     * You can specify up to 10 constraints per task (including constraints in the task definition and those specified at runtime).
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-ecsparameters.html#cfn-scheduler-schedule-ecsparameters-placementconstraints
     */
    readonly placementConstraints?: Array<cdk.IResolvable | CfnSchedule.PlacementConstraintProperty> | cdk.IResolvable;

    /**
     * The task placement strategy for a task or service.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-ecsparameters.html#cfn-scheduler-schedule-ecsparameters-placementstrategy
     */
    readonly placementStrategy?: Array<cdk.IResolvable | CfnSchedule.PlacementStrategyProperty> | cdk.IResolvable;

    /**
     * Specifies the platform version for the task.
     *
     * Specify only the numeric portion of the platform version, such as \`1.1.0\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-ecsparameters.html#cfn-scheduler-schedule-ecsparameters-platformversion
     */
    readonly platformVersion?: string;

    /**
     * Specifies whether to propagate the tags from the task definition to the task.
     *
     * If no value is specified, the tags are not propagated. Tags can only be propagated to the task during task creation. To add tags to a task after task creation, use the Amazon ECS [\`TagResource\`](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_TagResource.html) API action.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-ecsparameters.html#cfn-scheduler-schedule-ecsparameters-propagatetags
     */
    readonly propagateTags?: string;

    /**
     * The reference ID to use for the task.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-ecsparameters.html#cfn-scheduler-schedule-ecsparameters-referenceid
     */
    readonly referenceId?: string;

    /**
     * The metadata that you apply to the task to help you categorize and organize them.
     *
     * Each tag consists of a key and an optional value, both of which you define. For more information, see [\`RunTask\`](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_RunTask.html) in the *Amazon ECS API Reference* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-ecsparameters.html#cfn-scheduler-schedule-ecsparameters-tags
     */
    readonly tags?: any;

    /**
     * The number of tasks to create based on \`TaskDefinition\` .
     *
     * The default is \`1\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-ecsparameters.html#cfn-scheduler-schedule-ecsparameters-taskcount
     */
    readonly taskCount?: number;

    /**
     * The Amazon Resource Name (ARN) of the task definition to use if the event target is an Amazon ECS task.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-ecsparameters.html#cfn-scheduler-schedule-ecsparameters-taskdefinitionarn
     */
    readonly taskDefinitionArn: string;
  }

  /**
   * Specifies the network configuration for an ECS task.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-networkconfiguration.html
   */
  export interface NetworkConfigurationProperty {
    /**
     * Specifies the Amazon VPC subnets and security groups for the task, and whether a public IP address is to be used.
     *
     * This structure is relevant only for ECS tasks that use the awsvpc network mode.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-networkconfiguration.html#cfn-scheduler-schedule-networkconfiguration-awsvpcconfiguration
     */
    readonly awsvpcConfiguration?: CfnSchedule.AwsVpcConfigurationProperty | cdk.IResolvable;
  }

  /**
   * This structure specifies the VPC subnets and security groups for the task, and whether a public IP address is to be used.
   *
   * This structure is relevant only for ECS tasks that use the awsvpc network mode.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-awsvpcconfiguration.html
   */
  export interface AwsVpcConfigurationProperty {
    /**
     * Specifies whether the task's elastic network interface receives a public IP address.
     *
     * You can specify \`ENABLED\` only when \`LaunchType\` in \`EcsParameters\` is set to \`FARGATE\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-awsvpcconfiguration.html#cfn-scheduler-schedule-awsvpcconfiguration-assignpublicip
     */
    readonly assignPublicIp?: string;

    /**
     * Specifies the security groups associated with the task.
     *
     * These security groups must all be in the same VPC. You can specify as many as five security groups. If you do not specify a security group, the default security group for the VPC is used.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-awsvpcconfiguration.html#cfn-scheduler-schedule-awsvpcconfiguration-securitygroups
     */
    readonly securityGroups?: Array<string>;

    /**
     * Specifies the subnets associated with the task.
     *
     * These subnets must all be in the same VPC. You can specify as many as 16 subnets.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-awsvpcconfiguration.html#cfn-scheduler-schedule-awsvpcconfiguration-subnets
     */
    readonly subnets: Array<string>;
  }

  /**
   * The details of a capacity provider strategy.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-capacityproviderstrategyitem.html
   */
  export interface CapacityProviderStrategyItemProperty {
    /**
     * The base value designates how many tasks, at a minimum, to run on the specified capacity provider.
     *
     * Only one capacity provider in a capacity provider strategy can have a base defined. If no value is specified, the default value of \`0\` is used.
     *
     * @default - 0
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-capacityproviderstrategyitem.html#cfn-scheduler-schedule-capacityproviderstrategyitem-base
     */
    readonly base?: number;

    /**
     * The short name of the capacity provider.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-capacityproviderstrategyitem.html#cfn-scheduler-schedule-capacityproviderstrategyitem-capacityprovider
     */
    readonly capacityProvider: string;

    /**
     * The weight value designates the relative percentage of the total number of tasks launched that should use the specified capacity provider.
     *
     * The weight value is taken into consideration after the base value, if defined, is satisfied.
     *
     * @default - 0
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-capacityproviderstrategyitem.html#cfn-scheduler-schedule-capacityproviderstrategyitem-weight
     */
    readonly weight?: number;
  }

  /**
   * An object representing a constraint on task placement.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-placementconstraint.html
   */
  export interface PlacementConstraintProperty {
    /**
     * A cluster query language expression to apply to the constraint.
     *
     * You cannot specify an expression if the constraint type is \`distinctInstance\` . For more information, see [Cluster query language](https://docs.aws.amazon.com/latest/developerguide/cluster-query-language.html) in the *Amazon ECS Developer Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-placementconstraint.html#cfn-scheduler-schedule-placementconstraint-expression
     */
    readonly expression?: string;

    /**
     * The type of constraint.
     *
     * Use \`distinctInstance\` to ensure that each task in a particular group is running on a different container instance. Use \`memberOf\` to restrict the selection to a group of valid candidates.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-placementconstraint.html#cfn-scheduler-schedule-placementconstraint-type
     */
    readonly type?: string;
  }

  /**
   * The task placement strategy for a task or service.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-placementstrategy.html
   */
  export interface PlacementStrategyProperty {
    /**
     * The field to apply the placement strategy against.
     *
     * For the spread placement strategy, valid values are \`instanceId\` (or \`instanceId\` , which has the same effect), or any platform or custom attribute that is applied to a container instance, such as \`attribute:ecs.availability-zone\` . For the binpack placement strategy, valid values are \`cpu\` and \`memory\` . For the random placement strategy, this field is not used.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-placementstrategy.html#cfn-scheduler-schedule-placementstrategy-field
     */
    readonly field?: string;

    /**
     * The type of placement strategy.
     *
     * The random placement strategy randomly places tasks on available candidates. The spread placement strategy spreads placement across available candidates evenly based on the field parameter. The binpack strategy places tasks on available candidates that have the least available amount of the resource that is specified with the field parameter. For example, if you binpack on memory, a task is placed on the instance with the least amount of remaining memory (but still enough to run the task).
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-placementstrategy.html#cfn-scheduler-schedule-placementstrategy-type
     */
    readonly type?: string;
  }

  /**
   * The templated target type for the EventBridge [\`PutEvents\`](https://docs.aws.amazon.com/eventbridge/latest/APIReference/API_PutEvents.html) API operation.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-eventbridgeparameters.html
   */
  export interface EventBridgeParametersProperty {
    /**
     * A free-form string, with a maximum of 128 characters, used to decide what fields to expect in the event detail.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-eventbridgeparameters.html#cfn-scheduler-schedule-eventbridgeparameters-detailtype
     */
    readonly detailType: string;

    /**
     * The source of the event.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-eventbridgeparameters.html#cfn-scheduler-schedule-eventbridgeparameters-source
     */
    readonly source: string;
  }

  /**
   * The templated target type for the Amazon Kinesis [\`PutRecord\`](https://docs.aws.amazon.com/kinesis/latest/APIReference/API_PutRecord.html) API operation.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-kinesisparameters.html
   */
  export interface KinesisParametersProperty {
    /**
     * Specifies the shard to which EventBridge Scheduler sends the event.
     *
     * For more information, see [Amazon Kinesis Data Streams terminology and concepts](https://docs.aws.amazon.com/streams/latest/dev/key-concepts.html) in the *Amazon Kinesis Streams Developer Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-kinesisparameters.html#cfn-scheduler-schedule-kinesisparameters-partitionkey
     */
    readonly partitionKey: string;
  }

  /**
   * The templated target type for the Amazon SageMaker [\`StartPipelineExecution\`](https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_StartPipelineExecution.html) API operation.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-sagemakerpipelineparameters.html
   */
  export interface SageMakerPipelineParametersProperty {
    /**
     * List of parameter names and values to use when executing the SageMaker Model Building Pipeline.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-sagemakerpipelineparameters.html#cfn-scheduler-schedule-sagemakerpipelineparameters-pipelineparameterlist
     */
    readonly pipelineParameterList?: Array<cdk.IResolvable | CfnSchedule.SageMakerPipelineParameterProperty> | cdk.IResolvable;
  }

  /**
   * The name and value pair of a parameter to use to start execution of a SageMaker Model Building Pipeline.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-sagemakerpipelineparameter.html
   */
  export interface SageMakerPipelineParameterProperty {
    /**
     * Name of parameter to start execution of a SageMaker Model Building Pipeline.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-sagemakerpipelineparameter.html#cfn-scheduler-schedule-sagemakerpipelineparameter-name
     */
    readonly name: string;

    /**
     * Value of parameter to start execution of a SageMaker Model Building Pipeline.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-sagemakerpipelineparameter.html#cfn-scheduler-schedule-sagemakerpipelineparameter-value
     */
    readonly value: string;
  }

  /**
   * The templated target type for the Amazon SQS [\`SendMessage\`](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/APIReference/API_SendMessage.html) API operation. Contains the message group ID to use when the target is a FIFO queue. If you specify an Amazon SQS FIFO queue as a target, the queue must have content-based deduplication enabled. For more information, see [Using the Amazon SQS message deduplication ID](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/using-messagededuplicationid-property.html) in the *Amazon SQS Developer Guide* .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-sqsparameters.html
   */
  export interface SqsParametersProperty {
    /**
     * The FIFO message group ID to use as the target.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-sqsparameters.html#cfn-scheduler-schedule-sqsparameters-messagegroupid
     */
    readonly messageGroupId?: string;
  }
}

/**
 * Properties for defining a \`CfnSchedule\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-scheduler-schedule.html
 */
export interface CfnScheduleProps {
  /**
   * The description you specify for the schedule.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-scheduler-schedule.html#cfn-scheduler-schedule-description
   */
  readonly description?: string;

  /**
   * The date, in UTC, before which the schedule can invoke its target.
   *
   * Depending on the schedule's recurrence expression, invocations might stop on, or before, the \`EndDate\` you specify.
   * EventBridge Scheduler ignores \`EndDate\` for one-time schedules.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-scheduler-schedule.html#cfn-scheduler-schedule-enddate
   */
  readonly endDate?: string;

  /**
   * Allows you to configure a time window during which EventBridge Scheduler invokes the schedule.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-scheduler-schedule.html#cfn-scheduler-schedule-flexibletimewindow
   */
  readonly flexibleTimeWindow: CfnSchedule.FlexibleTimeWindowProperty | cdk.IResolvable;

  /**
   * The name of the schedule group associated with this schedule.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-scheduler-schedule.html#cfn-scheduler-schedule-groupname
   */
  readonly groupName?: string;

  /**
   * The Amazon Resource Name (ARN) for the customer managed KMS key that EventBridge Scheduler will use to encrypt and decrypt your data.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-scheduler-schedule.html#cfn-scheduler-schedule-kmskeyarn
   */
  readonly kmsKeyArn?: string;

  /**
   * The name of the schedule.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-scheduler-schedule.html#cfn-scheduler-schedule-name
   */
  readonly name?: string;

  /**
   * The expression that defines when the schedule runs. The following formats are supported.
   *
   * - \`at\` expression - \`at(yyyy-mm-ddThh:mm:ss)\`
   * - \`rate\` expression - \`rate(value unit)\`
   * - \`cron\` expression - \`cron(fields)\`
   *
   * You can use \`at\` expressions to create one-time schedules that invoke a target once, at the time and in the time zone, that you specify. You can use \`rate\` and \`cron\` expressions to create recurring schedules. Rate-based schedules are useful when you want to invoke a target at regular intervals, such as every 15 minutes or every five days. Cron-based schedules are useful when you want to invoke a target periodically at a specific time, such as at 8:00 am (UTC+0) every 1st day of the month.
   *
   * A \`cron\` expression consists of six fields separated by white spaces: \`(minutes hours day_of_month month day_of_week year)\` .
   *
   * A \`rate\` expression consists of a *value* as a positive integer, and a *unit* with the following options: \`minute\` | \`minutes\` | \`hour\` | \`hours\` | \`day\` | \`days\`
   *
   * For more information and examples, see [Schedule types on EventBridge Scheduler](https://docs.aws.amazon.com/scheduler/latest/UserGuide/schedule-types.html) in the *EventBridge Scheduler User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-scheduler-schedule.html#cfn-scheduler-schedule-scheduleexpression
   */
  readonly scheduleExpression: string;

  /**
   * The timezone in which the scheduling expression is evaluated.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-scheduler-schedule.html#cfn-scheduler-schedule-scheduleexpressiontimezone
   */
  readonly scheduleExpressionTimezone?: string;

  /**
   * The date, in UTC, after which the schedule can begin invoking its target.
   *
   * Depending on the schedule's recurrence expression, invocations might occur on, or after, the \`StartDate\` you specify.
   * EventBridge Scheduler ignores \`StartDate\` for one-time schedules.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-scheduler-schedule.html#cfn-scheduler-schedule-startdate
   */
  readonly startDate?: string;

  /**
   * Specifies whether the schedule is enabled or disabled.
   *
   * *Allowed Values* : \`ENABLED\` | \`DISABLED\`
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-scheduler-schedule.html#cfn-scheduler-schedule-state
   */
  readonly state?: string;

  /**
   * The schedule's target details.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-scheduler-schedule.html#cfn-scheduler-schedule-target
   */
  readonly target: cdk.IResolvable | CfnSchedule.TargetProperty;
}

/**
 * Determine whether the given properties match those of a \`FlexibleTimeWindowProperty\`
 *
 * @param properties - the TypeScript properties of a \`FlexibleTimeWindowProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnScheduleFlexibleTimeWindowPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("maximumWindowInMinutes", cdk.validateNumber)(properties.maximumWindowInMinutes));
  errors.collect(cdk.propertyValidator("mode", cdk.requiredValidator)(properties.mode));
  errors.collect(cdk.propertyValidator("mode", cdk.validateString)(properties.mode));
  return errors.wrap("supplied properties not correct for \\"FlexibleTimeWindowProperty\\"");
}

// @ts-ignore TS6133
function convertCfnScheduleFlexibleTimeWindowPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnScheduleFlexibleTimeWindowPropertyValidator(properties).assertSuccess();
  return {
    "MaximumWindowInMinutes": cdk.numberToCloudFormation(properties.maximumWindowInMinutes),
    "Mode": cdk.stringToCloudFormation(properties.mode)
  };
}

// @ts-ignore TS6133
function CfnScheduleFlexibleTimeWindowPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSchedule.FlexibleTimeWindowProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSchedule.FlexibleTimeWindowProperty>();
  ret.addPropertyResult("maximumWindowInMinutes", "MaximumWindowInMinutes", (properties.MaximumWindowInMinutes != null ? cfn_parse.FromCloudFormation.getNumber(properties.MaximumWindowInMinutes) : undefined));
  ret.addPropertyResult("mode", "Mode", (properties.Mode != null ? cfn_parse.FromCloudFormation.getString(properties.Mode) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`DeadLetterConfigProperty\`
 *
 * @param properties - the TypeScript properties of a \`DeadLetterConfigProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnScheduleDeadLetterConfigPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("arn", cdk.validateString)(properties.arn));
  return errors.wrap("supplied properties not correct for \\"DeadLetterConfigProperty\\"");
}

// @ts-ignore TS6133
function convertCfnScheduleDeadLetterConfigPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnScheduleDeadLetterConfigPropertyValidator(properties).assertSuccess();
  return {
    "Arn": cdk.stringToCloudFormation(properties.arn)
  };
}

// @ts-ignore TS6133
function CfnScheduleDeadLetterConfigPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSchedule.DeadLetterConfigProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSchedule.DeadLetterConfigProperty>();
  ret.addPropertyResult("arn", "Arn", (properties.Arn != null ? cfn_parse.FromCloudFormation.getString(properties.Arn) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`RetryPolicyProperty\`
 *
 * @param properties - the TypeScript properties of a \`RetryPolicyProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnScheduleRetryPolicyPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("maximumEventAgeInSeconds", cdk.validateNumber)(properties.maximumEventAgeInSeconds));
  errors.collect(cdk.propertyValidator("maximumRetryAttempts", cdk.validateNumber)(properties.maximumRetryAttempts));
  return errors.wrap("supplied properties not correct for \\"RetryPolicyProperty\\"");
}

// @ts-ignore TS6133
function convertCfnScheduleRetryPolicyPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnScheduleRetryPolicyPropertyValidator(properties).assertSuccess();
  return {
    "MaximumEventAgeInSeconds": cdk.numberToCloudFormation(properties.maximumEventAgeInSeconds),
    "MaximumRetryAttempts": cdk.numberToCloudFormation(properties.maximumRetryAttempts)
  };
}

// @ts-ignore TS6133
function CfnScheduleRetryPolicyPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSchedule.RetryPolicyProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSchedule.RetryPolicyProperty>();
  ret.addPropertyResult("maximumEventAgeInSeconds", "MaximumEventAgeInSeconds", (properties.MaximumEventAgeInSeconds != null ? cfn_parse.FromCloudFormation.getNumber(properties.MaximumEventAgeInSeconds) : undefined));
  ret.addPropertyResult("maximumRetryAttempts", "MaximumRetryAttempts", (properties.MaximumRetryAttempts != null ? cfn_parse.FromCloudFormation.getNumber(properties.MaximumRetryAttempts) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`AwsVpcConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`AwsVpcConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnScheduleAwsVpcConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("assignPublicIp", cdk.validateString)(properties.assignPublicIp));
  errors.collect(cdk.propertyValidator("securityGroups", cdk.listValidator(cdk.validateString))(properties.securityGroups));
  errors.collect(cdk.propertyValidator("subnets", cdk.requiredValidator)(properties.subnets));
  errors.collect(cdk.propertyValidator("subnets", cdk.listValidator(cdk.validateString))(properties.subnets));
  return errors.wrap("supplied properties not correct for \\"AwsVpcConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnScheduleAwsVpcConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnScheduleAwsVpcConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "AssignPublicIp": cdk.stringToCloudFormation(properties.assignPublicIp),
    "SecurityGroups": cdk.listMapper(cdk.stringToCloudFormation)(properties.securityGroups),
    "Subnets": cdk.listMapper(cdk.stringToCloudFormation)(properties.subnets)
  };
}

// @ts-ignore TS6133
function CfnScheduleAwsVpcConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSchedule.AwsVpcConfigurationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSchedule.AwsVpcConfigurationProperty>();
  ret.addPropertyResult("assignPublicIp", "AssignPublicIp", (properties.AssignPublicIp != null ? cfn_parse.FromCloudFormation.getString(properties.AssignPublicIp) : undefined));
  ret.addPropertyResult("securityGroups", "SecurityGroups", (properties.SecurityGroups != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecurityGroups) : undefined));
  ret.addPropertyResult("subnets", "Subnets", (properties.Subnets != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.Subnets) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`NetworkConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`NetworkConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnScheduleNetworkConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("awsvpcConfiguration", CfnScheduleAwsVpcConfigurationPropertyValidator)(properties.awsvpcConfiguration));
  return errors.wrap("supplied properties not correct for \\"NetworkConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnScheduleNetworkConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnScheduleNetworkConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "AwsvpcConfiguration": convertCfnScheduleAwsVpcConfigurationPropertyToCloudFormation(properties.awsvpcConfiguration)
  };
}

// @ts-ignore TS6133
function CfnScheduleNetworkConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSchedule.NetworkConfigurationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSchedule.NetworkConfigurationProperty>();
  ret.addPropertyResult("awsvpcConfiguration", "AwsvpcConfiguration", (properties.AwsvpcConfiguration != null ? CfnScheduleAwsVpcConfigurationPropertyFromCloudFormation(properties.AwsvpcConfiguration) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CapacityProviderStrategyItemProperty\`
 *
 * @param properties - the TypeScript properties of a \`CapacityProviderStrategyItemProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnScheduleCapacityProviderStrategyItemPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("base", cdk.validateNumber)(properties.base));
  errors.collect(cdk.propertyValidator("capacityProvider", cdk.requiredValidator)(properties.capacityProvider));
  errors.collect(cdk.propertyValidator("capacityProvider", cdk.validateString)(properties.capacityProvider));
  errors.collect(cdk.propertyValidator("weight", cdk.validateNumber)(properties.weight));
  return errors.wrap("supplied properties not correct for \\"CapacityProviderStrategyItemProperty\\"");
}

// @ts-ignore TS6133
function convertCfnScheduleCapacityProviderStrategyItemPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnScheduleCapacityProviderStrategyItemPropertyValidator(properties).assertSuccess();
  return {
    "Base": cdk.numberToCloudFormation(properties.base),
    "CapacityProvider": cdk.stringToCloudFormation(properties.capacityProvider),
    "Weight": cdk.numberToCloudFormation(properties.weight)
  };
}

// @ts-ignore TS6133
function CfnScheduleCapacityProviderStrategyItemPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSchedule.CapacityProviderStrategyItemProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSchedule.CapacityProviderStrategyItemProperty>();
  ret.addPropertyResult("base", "Base", (properties.Base != null ? cfn_parse.FromCloudFormation.getNumber(properties.Base) : undefined));
  ret.addPropertyResult("capacityProvider", "CapacityProvider", (properties.CapacityProvider != null ? cfn_parse.FromCloudFormation.getString(properties.CapacityProvider) : undefined));
  ret.addPropertyResult("weight", "Weight", (properties.Weight != null ? cfn_parse.FromCloudFormation.getNumber(properties.Weight) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`PlacementConstraintProperty\`
 *
 * @param properties - the TypeScript properties of a \`PlacementConstraintProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSchedulePlacementConstraintPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("expression", cdk.validateString)(properties.expression));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  return errors.wrap("supplied properties not correct for \\"PlacementConstraintProperty\\"");
}

// @ts-ignore TS6133
function convertCfnSchedulePlacementConstraintPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSchedulePlacementConstraintPropertyValidator(properties).assertSuccess();
  return {
    "Expression": cdk.stringToCloudFormation(properties.expression),
    "Type": cdk.stringToCloudFormation(properties.type)
  };
}

// @ts-ignore TS6133
function CfnSchedulePlacementConstraintPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSchedule.PlacementConstraintProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSchedule.PlacementConstraintProperty>();
  ret.addPropertyResult("expression", "Expression", (properties.Expression != null ? cfn_parse.FromCloudFormation.getString(properties.Expression) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`PlacementStrategyProperty\`
 *
 * @param properties - the TypeScript properties of a \`PlacementStrategyProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSchedulePlacementStrategyPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("field", cdk.validateString)(properties.field));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  return errors.wrap("supplied properties not correct for \\"PlacementStrategyProperty\\"");
}

// @ts-ignore TS6133
function convertCfnSchedulePlacementStrategyPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSchedulePlacementStrategyPropertyValidator(properties).assertSuccess();
  return {
    "Field": cdk.stringToCloudFormation(properties.field),
    "Type": cdk.stringToCloudFormation(properties.type)
  };
}

// @ts-ignore TS6133
function CfnSchedulePlacementStrategyPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSchedule.PlacementStrategyProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSchedule.PlacementStrategyProperty>();
  ret.addPropertyResult("field", "Field", (properties.Field != null ? cfn_parse.FromCloudFormation.getString(properties.Field) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`EcsParametersProperty\`
 *
 * @param properties - the TypeScript properties of a \`EcsParametersProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnScheduleEcsParametersPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("capacityProviderStrategy", cdk.listValidator(CfnScheduleCapacityProviderStrategyItemPropertyValidator))(properties.capacityProviderStrategy));
  errors.collect(cdk.propertyValidator("enableEcsManagedTags", cdk.validateBoolean)(properties.enableEcsManagedTags));
  errors.collect(cdk.propertyValidator("enableExecuteCommand", cdk.validateBoolean)(properties.enableExecuteCommand));
  errors.collect(cdk.propertyValidator("group", cdk.validateString)(properties.group));
  errors.collect(cdk.propertyValidator("launchType", cdk.validateString)(properties.launchType));
  errors.collect(cdk.propertyValidator("networkConfiguration", CfnScheduleNetworkConfigurationPropertyValidator)(properties.networkConfiguration));
  errors.collect(cdk.propertyValidator("placementConstraints", cdk.listValidator(CfnSchedulePlacementConstraintPropertyValidator))(properties.placementConstraints));
  errors.collect(cdk.propertyValidator("placementStrategy", cdk.listValidator(CfnSchedulePlacementStrategyPropertyValidator))(properties.placementStrategy));
  errors.collect(cdk.propertyValidator("platformVersion", cdk.validateString)(properties.platformVersion));
  errors.collect(cdk.propertyValidator("propagateTags", cdk.validateString)(properties.propagateTags));
  errors.collect(cdk.propertyValidator("referenceId", cdk.validateString)(properties.referenceId));
  errors.collect(cdk.propertyValidator("tags", cdk.validateObject)(properties.tags));
  errors.collect(cdk.propertyValidator("taskCount", cdk.validateNumber)(properties.taskCount));
  errors.collect(cdk.propertyValidator("taskDefinitionArn", cdk.requiredValidator)(properties.taskDefinitionArn));
  errors.collect(cdk.propertyValidator("taskDefinitionArn", cdk.validateString)(properties.taskDefinitionArn));
  return errors.wrap("supplied properties not correct for \\"EcsParametersProperty\\"");
}

// @ts-ignore TS6133
function convertCfnScheduleEcsParametersPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnScheduleEcsParametersPropertyValidator(properties).assertSuccess();
  return {
    "CapacityProviderStrategy": cdk.listMapper(convertCfnScheduleCapacityProviderStrategyItemPropertyToCloudFormation)(properties.capacityProviderStrategy),
    "EnableECSManagedTags": cdk.booleanToCloudFormation(properties.enableEcsManagedTags),
    "EnableExecuteCommand": cdk.booleanToCloudFormation(properties.enableExecuteCommand),
    "Group": cdk.stringToCloudFormation(properties.group),
    "LaunchType": cdk.stringToCloudFormation(properties.launchType),
    "NetworkConfiguration": convertCfnScheduleNetworkConfigurationPropertyToCloudFormation(properties.networkConfiguration),
    "PlacementConstraints": cdk.listMapper(convertCfnSchedulePlacementConstraintPropertyToCloudFormation)(properties.placementConstraints),
    "PlacementStrategy": cdk.listMapper(convertCfnSchedulePlacementStrategyPropertyToCloudFormation)(properties.placementStrategy),
    "PlatformVersion": cdk.stringToCloudFormation(properties.platformVersion),
    "PropagateTags": cdk.stringToCloudFormation(properties.propagateTags),
    "ReferenceId": cdk.stringToCloudFormation(properties.referenceId),
    "Tags": cdk.objectToCloudFormation(properties.tags),
    "TaskCount": cdk.numberToCloudFormation(properties.taskCount),
    "TaskDefinitionArn": cdk.stringToCloudFormation(properties.taskDefinitionArn)
  };
}

// @ts-ignore TS6133
function CfnScheduleEcsParametersPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSchedule.EcsParametersProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSchedule.EcsParametersProperty>();
  ret.addPropertyResult("capacityProviderStrategy", "CapacityProviderStrategy", (properties.CapacityProviderStrategy != null ? cfn_parse.FromCloudFormation.getArray(CfnScheduleCapacityProviderStrategyItemPropertyFromCloudFormation)(properties.CapacityProviderStrategy) : undefined));
  ret.addPropertyResult("enableEcsManagedTags", "EnableECSManagedTags", (properties.EnableECSManagedTags != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EnableECSManagedTags) : undefined));
  ret.addPropertyResult("enableExecuteCommand", "EnableExecuteCommand", (properties.EnableExecuteCommand != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EnableExecuteCommand) : undefined));
  ret.addPropertyResult("group", "Group", (properties.Group != null ? cfn_parse.FromCloudFormation.getString(properties.Group) : undefined));
  ret.addPropertyResult("launchType", "LaunchType", (properties.LaunchType != null ? cfn_parse.FromCloudFormation.getString(properties.LaunchType) : undefined));
  ret.addPropertyResult("networkConfiguration", "NetworkConfiguration", (properties.NetworkConfiguration != null ? CfnScheduleNetworkConfigurationPropertyFromCloudFormation(properties.NetworkConfiguration) : undefined));
  ret.addPropertyResult("placementConstraints", "PlacementConstraints", (properties.PlacementConstraints != null ? cfn_parse.FromCloudFormation.getArray(CfnSchedulePlacementConstraintPropertyFromCloudFormation)(properties.PlacementConstraints) : undefined));
  ret.addPropertyResult("placementStrategy", "PlacementStrategy", (properties.PlacementStrategy != null ? cfn_parse.FromCloudFormation.getArray(CfnSchedulePlacementStrategyPropertyFromCloudFormation)(properties.PlacementStrategy) : undefined));
  ret.addPropertyResult("platformVersion", "PlatformVersion", (properties.PlatformVersion != null ? cfn_parse.FromCloudFormation.getString(properties.PlatformVersion) : undefined));
  ret.addPropertyResult("propagateTags", "PropagateTags", (properties.PropagateTags != null ? cfn_parse.FromCloudFormation.getString(properties.PropagateTags) : undefined));
  ret.addPropertyResult("referenceId", "ReferenceId", (properties.ReferenceId != null ? cfn_parse.FromCloudFormation.getString(properties.ReferenceId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getAny(properties.Tags) : undefined));
  ret.addPropertyResult("taskCount", "TaskCount", (properties.TaskCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.TaskCount) : undefined));
  ret.addPropertyResult("taskDefinitionArn", "TaskDefinitionArn", (properties.TaskDefinitionArn != null ? cfn_parse.FromCloudFormation.getString(properties.TaskDefinitionArn) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`EventBridgeParametersProperty\`
 *
 * @param properties - the TypeScript properties of a \`EventBridgeParametersProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnScheduleEventBridgeParametersPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("detailType", cdk.requiredValidator)(properties.detailType));
  errors.collect(cdk.propertyValidator("detailType", cdk.validateString)(properties.detailType));
  errors.collect(cdk.propertyValidator("source", cdk.requiredValidator)(properties.source));
  errors.collect(cdk.propertyValidator("source", cdk.validateString)(properties.source));
  return errors.wrap("supplied properties not correct for \\"EventBridgeParametersProperty\\"");
}

// @ts-ignore TS6133
function convertCfnScheduleEventBridgeParametersPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnScheduleEventBridgeParametersPropertyValidator(properties).assertSuccess();
  return {
    "DetailType": cdk.stringToCloudFormation(properties.detailType),
    "Source": cdk.stringToCloudFormation(properties.source)
  };
}

// @ts-ignore TS6133
function CfnScheduleEventBridgeParametersPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSchedule.EventBridgeParametersProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSchedule.EventBridgeParametersProperty>();
  ret.addPropertyResult("detailType", "DetailType", (properties.DetailType != null ? cfn_parse.FromCloudFormation.getString(properties.DetailType) : undefined));
  ret.addPropertyResult("source", "Source", (properties.Source != null ? cfn_parse.FromCloudFormation.getString(properties.Source) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`KinesisParametersProperty\`
 *
 * @param properties - the TypeScript properties of a \`KinesisParametersProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnScheduleKinesisParametersPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("partitionKey", cdk.requiredValidator)(properties.partitionKey));
  errors.collect(cdk.propertyValidator("partitionKey", cdk.validateString)(properties.partitionKey));
  return errors.wrap("supplied properties not correct for \\"KinesisParametersProperty\\"");
}

// @ts-ignore TS6133
function convertCfnScheduleKinesisParametersPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnScheduleKinesisParametersPropertyValidator(properties).assertSuccess();
  return {
    "PartitionKey": cdk.stringToCloudFormation(properties.partitionKey)
  };
}

// @ts-ignore TS6133
function CfnScheduleKinesisParametersPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSchedule.KinesisParametersProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSchedule.KinesisParametersProperty>();
  ret.addPropertyResult("partitionKey", "PartitionKey", (properties.PartitionKey != null ? cfn_parse.FromCloudFormation.getString(properties.PartitionKey) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`SageMakerPipelineParameterProperty\`
 *
 * @param properties - the TypeScript properties of a \`SageMakerPipelineParameterProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnScheduleSageMakerPipelineParameterPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("name", cdk.requiredValidator)(properties.name));
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  errors.collect(cdk.propertyValidator("value", cdk.requiredValidator)(properties.value));
  errors.collect(cdk.propertyValidator("value", cdk.validateString)(properties.value));
  return errors.wrap("supplied properties not correct for \\"SageMakerPipelineParameterProperty\\"");
}

// @ts-ignore TS6133
function convertCfnScheduleSageMakerPipelineParameterPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnScheduleSageMakerPipelineParameterPropertyValidator(properties).assertSuccess();
  return {
    "Name": cdk.stringToCloudFormation(properties.name),
    "Value": cdk.stringToCloudFormation(properties.value)
  };
}

// @ts-ignore TS6133
function CfnScheduleSageMakerPipelineParameterPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSchedule.SageMakerPipelineParameterProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSchedule.SageMakerPipelineParameterProperty>();
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addPropertyResult("value", "Value", (properties.Value != null ? cfn_parse.FromCloudFormation.getString(properties.Value) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`SageMakerPipelineParametersProperty\`
 *
 * @param properties - the TypeScript properties of a \`SageMakerPipelineParametersProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnScheduleSageMakerPipelineParametersPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("pipelineParameterList", cdk.listValidator(CfnScheduleSageMakerPipelineParameterPropertyValidator))(properties.pipelineParameterList));
  return errors.wrap("supplied properties not correct for \\"SageMakerPipelineParametersProperty\\"");
}

// @ts-ignore TS6133
function convertCfnScheduleSageMakerPipelineParametersPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnScheduleSageMakerPipelineParametersPropertyValidator(properties).assertSuccess();
  return {
    "PipelineParameterList": cdk.listMapper(convertCfnScheduleSageMakerPipelineParameterPropertyToCloudFormation)(properties.pipelineParameterList)
  };
}

// @ts-ignore TS6133
function CfnScheduleSageMakerPipelineParametersPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSchedule.SageMakerPipelineParametersProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSchedule.SageMakerPipelineParametersProperty>();
  ret.addPropertyResult("pipelineParameterList", "PipelineParameterList", (properties.PipelineParameterList != null ? cfn_parse.FromCloudFormation.getArray(CfnScheduleSageMakerPipelineParameterPropertyFromCloudFormation)(properties.PipelineParameterList) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`SqsParametersProperty\`
 *
 * @param properties - the TypeScript properties of a \`SqsParametersProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnScheduleSqsParametersPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("messageGroupId", cdk.validateString)(properties.messageGroupId));
  return errors.wrap("supplied properties not correct for \\"SqsParametersProperty\\"");
}

// @ts-ignore TS6133
function convertCfnScheduleSqsParametersPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnScheduleSqsParametersPropertyValidator(properties).assertSuccess();
  return {
    "MessageGroupId": cdk.stringToCloudFormation(properties.messageGroupId)
  };
}

// @ts-ignore TS6133
function CfnScheduleSqsParametersPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSchedule.SqsParametersProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSchedule.SqsParametersProperty>();
  ret.addPropertyResult("messageGroupId", "MessageGroupId", (properties.MessageGroupId != null ? cfn_parse.FromCloudFormation.getString(properties.MessageGroupId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`TargetProperty\`
 *
 * @param properties - the TypeScript properties of a \`TargetProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnScheduleTargetPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("arn", cdk.requiredValidator)(properties.arn));
  errors.collect(cdk.propertyValidator("arn", cdk.validateString)(properties.arn));
  errors.collect(cdk.propertyValidator("deadLetterConfig", CfnScheduleDeadLetterConfigPropertyValidator)(properties.deadLetterConfig));
  errors.collect(cdk.propertyValidator("ecsParameters", CfnScheduleEcsParametersPropertyValidator)(properties.ecsParameters));
  errors.collect(cdk.propertyValidator("eventBridgeParameters", CfnScheduleEventBridgeParametersPropertyValidator)(properties.eventBridgeParameters));
  errors.collect(cdk.propertyValidator("input", cdk.validateString)(properties.input));
  errors.collect(cdk.propertyValidator("kinesisParameters", CfnScheduleKinesisParametersPropertyValidator)(properties.kinesisParameters));
  errors.collect(cdk.propertyValidator("retryPolicy", CfnScheduleRetryPolicyPropertyValidator)(properties.retryPolicy));
  errors.collect(cdk.propertyValidator("roleArn", cdk.requiredValidator)(properties.roleArn));
  errors.collect(cdk.propertyValidator("roleArn", cdk.validateString)(properties.roleArn));
  errors.collect(cdk.propertyValidator("sageMakerPipelineParameters", CfnScheduleSageMakerPipelineParametersPropertyValidator)(properties.sageMakerPipelineParameters));
  errors.collect(cdk.propertyValidator("sqsParameters", CfnScheduleSqsParametersPropertyValidator)(properties.sqsParameters));
  return errors.wrap("supplied properties not correct for \\"TargetProperty\\"");
}

// @ts-ignore TS6133
function convertCfnScheduleTargetPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnScheduleTargetPropertyValidator(properties).assertSuccess();
  return {
    "Arn": cdk.stringToCloudFormation(properties.arn),
    "DeadLetterConfig": convertCfnScheduleDeadLetterConfigPropertyToCloudFormation(properties.deadLetterConfig),
    "EcsParameters": convertCfnScheduleEcsParametersPropertyToCloudFormation(properties.ecsParameters),
    "EventBridgeParameters": convertCfnScheduleEventBridgeParametersPropertyToCloudFormation(properties.eventBridgeParameters),
    "Input": cdk.stringToCloudFormation(properties.input),
    "KinesisParameters": convertCfnScheduleKinesisParametersPropertyToCloudFormation(properties.kinesisParameters),
    "RetryPolicy": convertCfnScheduleRetryPolicyPropertyToCloudFormation(properties.retryPolicy),
    "RoleArn": cdk.stringToCloudFormation(properties.roleArn),
    "SageMakerPipelineParameters": convertCfnScheduleSageMakerPipelineParametersPropertyToCloudFormation(properties.sageMakerPipelineParameters),
    "SqsParameters": convertCfnScheduleSqsParametersPropertyToCloudFormation(properties.sqsParameters)
  };
}

// @ts-ignore TS6133
function CfnScheduleTargetPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSchedule.TargetProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSchedule.TargetProperty>();
  ret.addPropertyResult("arn", "Arn", (properties.Arn != null ? cfn_parse.FromCloudFormation.getString(properties.Arn) : undefined));
  ret.addPropertyResult("deadLetterConfig", "DeadLetterConfig", (properties.DeadLetterConfig != null ? CfnScheduleDeadLetterConfigPropertyFromCloudFormation(properties.DeadLetterConfig) : undefined));
  ret.addPropertyResult("ecsParameters", "EcsParameters", (properties.EcsParameters != null ? CfnScheduleEcsParametersPropertyFromCloudFormation(properties.EcsParameters) : undefined));
  ret.addPropertyResult("eventBridgeParameters", "EventBridgeParameters", (properties.EventBridgeParameters != null ? CfnScheduleEventBridgeParametersPropertyFromCloudFormation(properties.EventBridgeParameters) : undefined));
  ret.addPropertyResult("input", "Input", (properties.Input != null ? cfn_parse.FromCloudFormation.getString(properties.Input) : undefined));
  ret.addPropertyResult("kinesisParameters", "KinesisParameters", (properties.KinesisParameters != null ? CfnScheduleKinesisParametersPropertyFromCloudFormation(properties.KinesisParameters) : undefined));
  ret.addPropertyResult("retryPolicy", "RetryPolicy", (properties.RetryPolicy != null ? CfnScheduleRetryPolicyPropertyFromCloudFormation(properties.RetryPolicy) : undefined));
  ret.addPropertyResult("roleArn", "RoleArn", (properties.RoleArn != null ? cfn_parse.FromCloudFormation.getString(properties.RoleArn) : undefined));
  ret.addPropertyResult("sageMakerPipelineParameters", "SageMakerPipelineParameters", (properties.SageMakerPipelineParameters != null ? CfnScheduleSageMakerPipelineParametersPropertyFromCloudFormation(properties.SageMakerPipelineParameters) : undefined));
  ret.addPropertyResult("sqsParameters", "SqsParameters", (properties.SqsParameters != null ? CfnScheduleSqsParametersPropertyFromCloudFormation(properties.SqsParameters) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnScheduleProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnScheduleProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSchedulePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("endDate", cdk.validateString)(properties.endDate));
  errors.collect(cdk.propertyValidator("flexibleTimeWindow", cdk.requiredValidator)(properties.flexibleTimeWindow));
  errors.collect(cdk.propertyValidator("flexibleTimeWindow", CfnScheduleFlexibleTimeWindowPropertyValidator)(properties.flexibleTimeWindow));
  errors.collect(cdk.propertyValidator("groupName", cdk.validateString)(properties.groupName));
  errors.collect(cdk.propertyValidator("kmsKeyArn", cdk.validateString)(properties.kmsKeyArn));
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  errors.collect(cdk.propertyValidator("scheduleExpression", cdk.requiredValidator)(properties.scheduleExpression));
  errors.collect(cdk.propertyValidator("scheduleExpression", cdk.validateString)(properties.scheduleExpression));
  errors.collect(cdk.propertyValidator("scheduleExpressionTimezone", cdk.validateString)(properties.scheduleExpressionTimezone));
  errors.collect(cdk.propertyValidator("startDate", cdk.validateString)(properties.startDate));
  errors.collect(cdk.propertyValidator("state", cdk.validateString)(properties.state));
  errors.collect(cdk.propertyValidator("target", cdk.requiredValidator)(properties.target));
  errors.collect(cdk.propertyValidator("target", CfnScheduleTargetPropertyValidator)(properties.target));
  return errors.wrap("supplied properties not correct for \\"CfnScheduleProps\\"");
}

// @ts-ignore TS6133
function convertCfnSchedulePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSchedulePropsValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "EndDate": cdk.stringToCloudFormation(properties.endDate),
    "FlexibleTimeWindow": convertCfnScheduleFlexibleTimeWindowPropertyToCloudFormation(properties.flexibleTimeWindow),
    "GroupName": cdk.stringToCloudFormation(properties.groupName),
    "KmsKeyArn": cdk.stringToCloudFormation(properties.kmsKeyArn),
    "Name": cdk.stringToCloudFormation(properties.name),
    "ScheduleExpression": cdk.stringToCloudFormation(properties.scheduleExpression),
    "ScheduleExpressionTimezone": cdk.stringToCloudFormation(properties.scheduleExpressionTimezone),
    "StartDate": cdk.stringToCloudFormation(properties.startDate),
    "State": cdk.stringToCloudFormation(properties.state),
    "Target": convertCfnScheduleTargetPropertyToCloudFormation(properties.target)
  };
}

// @ts-ignore TS6133
function CfnSchedulePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnScheduleProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnScheduleProps>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("endDate", "EndDate", (properties.EndDate != null ? cfn_parse.FromCloudFormation.getString(properties.EndDate) : undefined));
  ret.addPropertyResult("flexibleTimeWindow", "FlexibleTimeWindow", (properties.FlexibleTimeWindow != null ? CfnScheduleFlexibleTimeWindowPropertyFromCloudFormation(properties.FlexibleTimeWindow) : undefined));
  ret.addPropertyResult("groupName", "GroupName", (properties.GroupName != null ? cfn_parse.FromCloudFormation.getString(properties.GroupName) : undefined));
  ret.addPropertyResult("kmsKeyArn", "KmsKeyArn", (properties.KmsKeyArn != null ? cfn_parse.FromCloudFormation.getString(properties.KmsKeyArn) : undefined));
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addPropertyResult("scheduleExpression", "ScheduleExpression", (properties.ScheduleExpression != null ? cfn_parse.FromCloudFormation.getString(properties.ScheduleExpression) : undefined));
  ret.addPropertyResult("scheduleExpressionTimezone", "ScheduleExpressionTimezone", (properties.ScheduleExpressionTimezone != null ? cfn_parse.FromCloudFormation.getString(properties.ScheduleExpressionTimezone) : undefined));
  ret.addPropertyResult("startDate", "StartDate", (properties.StartDate != null ? cfn_parse.FromCloudFormation.getString(properties.StartDate) : undefined));
  ret.addPropertyResult("state", "State", (properties.State != null ? cfn_parse.FromCloudFormation.getString(properties.State) : undefined));
  ret.addPropertyResult("target", "Target", (properties.Target != null ? CfnScheduleTargetPropertyFromCloudFormation(properties.Target) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * A *schedule group* is an Amazon EventBridge Scheduler resource you use to organize your schedules.
 *
 * Your AWS account comes with a \`default\` scheduler group. You associate a new schedule with the \`default\` group or with schedule groups that you create and manage. You can create up to [500 schedule groups](https://docs.aws.amazon.com/scheduler/latest/UserGuide/scheduler-quotas.html) in your AWS account. With EventBridge Scheduler, you apply [tags](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) to schedule groups, not to individual schedules to organize your resources.
 *
 * For more information about managing schedule groups, see [Managing a schedule group](https://docs.aws.amazon.com/scheduler/latest/UserGuide/managing-schedule-group.html) in the *EventBridge Scheduler User Guide* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-scheduler-schedulegroup.html
 */
export class CfnScheduleGroup extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::Scheduler::ScheduleGroup";

  /**
   * Build a CfnScheduleGroup from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnScheduleGroup {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnScheduleGroupPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnScheduleGroup(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The Amazon Resource Name (ARN) of the schedule group.
   *
   * @cloudformationAttribute Arn
   */
  public readonly attrArn: string;

  /**
   * The date and time at which the schedule group was created.
   *
   * @cloudformationAttribute CreationDate
   */
  public readonly attrCreationDate: string;

  /**
   * The time at which the schedule group was last modified.
   *
   * @cloudformationAttribute LastModificationDate
   */
  public readonly attrLastModificationDate: string;

  /**
   * Specifies the state of the schedule group.
   *
   * *Allowed Values* : \`ACTIVE\` | \`DELETING\`
   *
   * @cloudformationAttribute State
   */
  public readonly attrState: string;

  /**
   * The name of the schedule group.
   */
  public name?: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * An array of key-value pairs to apply to this resource.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnScheduleGroupProps = {}) {
    super(scope, id, {
      "type": CfnScheduleGroup.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.attrArn = cdk.Token.asString(this.getAtt("Arn", cdk.ResolutionTypeHint.STRING));
    this.attrCreationDate = cdk.Token.asString(this.getAtt("CreationDate", cdk.ResolutionTypeHint.STRING));
    this.attrLastModificationDate = cdk.Token.asString(this.getAtt("LastModificationDate", cdk.ResolutionTypeHint.STRING));
    this.attrState = cdk.Token.asString(this.getAtt("State", cdk.ResolutionTypeHint.STRING));
    this.name = props.name;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::Scheduler::ScheduleGroup", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "name": this.name,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnScheduleGroup.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnScheduleGroupPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnScheduleGroup\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-scheduler-schedulegroup.html
 */
export interface CfnScheduleGroupProps {
  /**
   * The name of the schedule group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-scheduler-schedulegroup.html#cfn-scheduler-schedulegroup-name
   */
  readonly name?: string;

  /**
   * An array of key-value pairs to apply to this resource.
   *
   * For more information, see [Tag](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html) .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-scheduler-schedulegroup.html#cfn-scheduler-schedulegroup-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a \`CfnScheduleGroupProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnScheduleGroupProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnScheduleGroupPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnScheduleGroupProps\\"");
}

// @ts-ignore TS6133
function convertCfnScheduleGroupPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnScheduleGroupPropsValidator(properties).assertSuccess();
  return {
    "Name": cdk.stringToCloudFormation(properties.name),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnScheduleGroupPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnScheduleGroupProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnScheduleGroupProps>();
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}",
}
`;

exports[`aws-sqs 1`] = `
{
  "augmentations": "// Copyright 2012-2023 Amazon.com, Inc. or its affiliates. All Rights Reserved.
/* eslint-disable prettier/prettier,max-len */
import * as cw from "aws-cdk-lib/aws-cloudwatch";
import { QueueBase } from "./queue-base";

declare module "./queue-base" {
  interface IQueue {
    /**
     * Return the given named metric for this Queue
     */
    metric(metricName: string, props?: cw.MetricOptions): cw.Metric;

    /**
     * The approximate age of the oldest non-deleted message in the queue.
     *
     * Maximum over 5 minutes
     */
    metricApproximateAgeOfOldestMessage(props?: cw.MetricOptions): cw.Metric;

    /**
     * The number of messages in the queue that are delayed and not available for reading immediately.
     *
     * Maximum over 5 minutes
     */
    metricApproximateNumberOfMessagesDelayed(props?: cw.MetricOptions): cw.Metric;

    /**
     * The number of messages that are in flight.
     *
     * Maximum over 5 minutes
     */
    metricApproximateNumberOfMessagesNotVisible(props?: cw.MetricOptions): cw.Metric;

    /**
     * The number of messages available for retrieval from the queue.
     *
     * Maximum over 5 minutes
     */
    metricApproximateNumberOfMessagesVisible(props?: cw.MetricOptions): cw.Metric;

    /**
     * The number of ReceiveMessage API calls that did not return a message.
     *
     * Sum over 5 minutes
     */
    metricNumberOfEmptyReceives(props?: cw.MetricOptions): cw.Metric;

    /**
     * The number of messages deleted from the queue.
     *
     * Sum over 5 minutes
     */
    metricNumberOfMessagesDeleted(props?: cw.MetricOptions): cw.Metric;

    /**
     * The number of messages returned by calls to the ReceiveMessage action.
     *
     * Sum over 5 minutes
     */
    metricNumberOfMessagesReceived(props?: cw.MetricOptions): cw.Metric;

    /**
     * The number of messages added to a queue.
     *
     * Sum over 5 minutes
     */
    metricNumberOfMessagesSent(props?: cw.MetricOptions): cw.Metric;

    /**
     * The size of messages added to a queue.
     *
     * Average over 5 minutes
     */
    metricSentMessageSize(props?: cw.MetricOptions): cw.Metric;
  }
}



declare module "./queue-base" {
  interface QueueBase {
    /**
     * Return the given named metric for this Queue
     */
    metric(metricName: string, props?: cw.MetricOptions): cw.Metric;

    /**
     * The approximate age of the oldest non-deleted message in the queue.
     *
     * Maximum over 5 minutes
     */
    metricApproximateAgeOfOldestMessage(props?: cw.MetricOptions): cw.Metric;

    /**
     * The number of messages in the queue that are delayed and not available for reading immediately.
     *
     * Maximum over 5 minutes
     */
    metricApproximateNumberOfMessagesDelayed(props?: cw.MetricOptions): cw.Metric;

    /**
     * The number of messages that are in flight.
     *
     * Maximum over 5 minutes
     */
    metricApproximateNumberOfMessagesNotVisible(props?: cw.MetricOptions): cw.Metric;

    /**
     * The number of messages available for retrieval from the queue.
     *
     * Maximum over 5 minutes
     */
    metricApproximateNumberOfMessagesVisible(props?: cw.MetricOptions): cw.Metric;

    /**
     * The number of ReceiveMessage API calls that did not return a message.
     *
     * Sum over 5 minutes
     */
    metricNumberOfEmptyReceives(props?: cw.MetricOptions): cw.Metric;

    /**
     * The number of messages deleted from the queue.
     *
     * Sum over 5 minutes
     */
    metricNumberOfMessagesDeleted(props?: cw.MetricOptions): cw.Metric;

    /**
     * The number of messages returned by calls to the ReceiveMessage action.
     *
     * Sum over 5 minutes
     */
    metricNumberOfMessagesReceived(props?: cw.MetricOptions): cw.Metric;

    /**
     * The number of messages added to a queue.
     *
     * Sum over 5 minutes
     */
    metricNumberOfMessagesSent(props?: cw.MetricOptions): cw.Metric;

    /**
     * The size of messages added to a queue.
     *
     * Average over 5 minutes
     */
    metricSentMessageSize(props?: cw.MetricOptions): cw.Metric;
  }
}

QueueBase.prototype.metric = function(metricName: string, props?: cw.MetricOptions) {
  return new cw.Metric({
    "namespace": "AWS/SQS",
    "metricName": metricName,
    "dimensionsMap": {
      "QueueName": this.queueName
    },
    ...props
  }).attachTo(this);
};
QueueBase.prototype.metricApproximateAgeOfOldestMessage = function(props?: cw.MetricOptions) {
  return this.metric("ApproximateAgeOfOldestMessage", {
    "statistic": "Maximum",
    ...props
  });
};
QueueBase.prototype.metricApproximateNumberOfMessagesDelayed = function(props?: cw.MetricOptions) {
  return this.metric("ApproximateNumberOfMessagesDelayed", {
    "statistic": "Maximum",
    ...props
  });
};
QueueBase.prototype.metricApproximateNumberOfMessagesNotVisible = function(props?: cw.MetricOptions) {
  return this.metric("ApproximateNumberOfMessagesNotVisible", {
    "statistic": "Maximum",
    ...props
  });
};
QueueBase.prototype.metricApproximateNumberOfMessagesVisible = function(props?: cw.MetricOptions) {
  return this.metric("ApproximateNumberOfMessagesVisible", {
    "statistic": "Maximum",
    ...props
  });
};
QueueBase.prototype.metricNumberOfEmptyReceives = function(props?: cw.MetricOptions) {
  return this.metric("NumberOfEmptyReceives", {
    "statistic": "Sum",
    ...props
  });
};
QueueBase.prototype.metricNumberOfMessagesDeleted = function(props?: cw.MetricOptions) {
  return this.metric("NumberOfMessagesDeleted", {
    "statistic": "Sum",
    ...props
  });
};
QueueBase.prototype.metricNumberOfMessagesReceived = function(props?: cw.MetricOptions) {
  return this.metric("NumberOfMessagesReceived", {
    "statistic": "Sum",
    ...props
  });
};
QueueBase.prototype.metricNumberOfMessagesSent = function(props?: cw.MetricOptions) {
  return this.metric("NumberOfMessagesSent", {
    "statistic": "Sum",
    ...props
  });
};
QueueBase.prototype.metricSentMessageSize = function(props?: cw.MetricOptions) {
  return this.metric("SentMessageSize", {
    "statistic": "Average",
    ...props
  });
};",
  "metrics": "/* eslint-disable prettier/prettier,max-len */
export interface MetricWithDims<D> {
  readonly namespace: string;

  readonly metricName: string;

  readonly statistic: string;

  readonly dimensionsMap: D;
}

export class SQSMetrics {
  public static numberOfMessagesSentAverage(dimensions: { QueueName: string; }): MetricWithDims<{ QueueName: string; }> {
    return {
      "namespace": "AWS/SQS",
      "metricName": "NumberOfMessagesSent",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static approximateNumberOfMessagesDelayedAverage(dimensions: { QueueName: string; }): MetricWithDims<{ QueueName: string; }> {
    return {
      "namespace": "AWS/SQS",
      "metricName": "ApproximateNumberOfMessagesDelayed",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static numberOfMessagesReceivedAverage(dimensions: { QueueName: string; }): MetricWithDims<{ QueueName: string; }> {
    return {
      "namespace": "AWS/SQS",
      "metricName": "NumberOfMessagesReceived",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static numberOfMessagesDeletedAverage(dimensions: { QueueName: string; }): MetricWithDims<{ QueueName: string; }> {
    return {
      "namespace": "AWS/SQS",
      "metricName": "NumberOfMessagesDeleted",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static approximateNumberOfMessagesNotVisibleAverage(dimensions: { QueueName: string; }): MetricWithDims<{ QueueName: string; }> {
    return {
      "namespace": "AWS/SQS",
      "metricName": "ApproximateNumberOfMessagesNotVisible",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static approximateNumberOfMessagesVisibleAverage(dimensions: { QueueName: string; }): MetricWithDims<{ QueueName: string; }> {
    return {
      "namespace": "AWS/SQS",
      "metricName": "ApproximateNumberOfMessagesVisible",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static approximateAgeOfOldestMessageAverage(dimensions: { QueueName: string; }): MetricWithDims<{ QueueName: string; }> {
    return {
      "namespace": "AWS/SQS",
      "metricName": "ApproximateAgeOfOldestMessage",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static numberOfEmptyReceivesAverage(dimensions: { QueueName: string; }): MetricWithDims<{ QueueName: string; }> {
    return {
      "namespace": "AWS/SQS",
      "metricName": "NumberOfEmptyReceives",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static sentMessageSizeAverage(dimensions: { QueueName: string; }): MetricWithDims<{ QueueName: string; }> {
    return {
      "namespace": "AWS/SQS",
      "metricName": "SentMessageSize",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }
}",
  "module": "/* eslint-disable prettier/prettier,max-len */
import * as cdk from "aws-cdk-lib";
import * as constructs from "constructs";
import * as cfn_parse from "aws-cdk-lib/core/lib/helpers-internal";

/**
 * The \`AWS::SQS::Queue\` resource creates an Amazon SQS standard or FIFO queue.
 *
 * Keep the following caveats in mind:
 *
 * - If you don't specify the \`FifoQueue\` property, Amazon SQS creates a standard queue.
 *
 * > You can't change the queue type after you create it and you can't convert an existing standard queue into a FIFO queue. You must either create a new FIFO queue for your application or delete your existing standard queue and recreate it as a FIFO queue. For more information, see [Moving from a standard queue to a FIFO queue](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/FIFO-queues-moving.html) in the *Amazon SQS Developer Guide* .
 * - If you don't provide a value for a property, the queue is created with the default value for the property.
 * - If you delete a queue, you must wait at least 60 seconds before creating a queue with the same name.
 * - To successfully create a new queue, you must provide a queue name that adheres to the [limits related to queues](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/limits-queues.html) and is unique within the scope of your queues.
 *
 * For more information about creating FIFO (first-in-first-out) queues, see [Creating an Amazon SQS queue ( AWS CloudFormation )](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/screate-queue-cloudformation.html) in the *Amazon SQS Developer Guide* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html
 */
export class CfnQueue extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::SQS::Queue";

  /**
   * Build a CfnQueue from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnQueue {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnQueuePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnQueue(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * Returns the Amazon Resource Name (ARN) of the queue. For example: \`arn:aws:sqs:us-east-2:123456789012:mystack-myqueue-15PG5C2FC1CW8\` .
   *
   * @cloudformationAttribute Arn
   */
  public readonly attrArn: string;

  /**
   * Returns the queue name. For example: \`mystack-myqueue-1VF9BKQH5BJVI\` .
   *
   * @cloudformationAttribute QueueName
   */
  public readonly attrQueueName: string;

  /**
   * Returns the URLs of the queues from the policy.
   *
   * @cloudformationAttribute QueueUrl
   */
  public readonly attrQueueUrl: string;

  /**
   * For first-in-first-out (FIFO) queues, specifies whether to enable content-based deduplication.
   */
  public contentBasedDeduplication?: boolean | cdk.IResolvable;

  /**
   * For high throughput for FIFO queues, specifies whether message deduplication occurs at the message group or queue level.
   */
  public deduplicationScope?: string;

  /**
   * The time in seconds for which the delivery of all messages in the queue is delayed.
   */
  public delaySeconds?: number;

  /**
   * If set to true, creates a FIFO queue.
   */
  public fifoQueue?: boolean | cdk.IResolvable;

  /**
   * For high throughput for FIFO queues, specifies whether the FIFO queue throughput quota applies to the entire queue or per message group.
   */
  public fifoThroughputLimit?: string;

  /**
   * The length of time in seconds for which Amazon SQS can reuse a data key to encrypt or decrypt messages before calling AWS KMS again.
   */
  public kmsDataKeyReusePeriodSeconds?: number;

  /**
   * The ID of an AWS Key Management Service (KMS) for Amazon SQS , or a custom KMS.
   */
  public kmsMasterKeyId?: string;

  /**
   * The limit of how many bytes that a message can contain before Amazon SQS rejects it.
   */
  public maximumMessageSize?: number;

  /**
   * The number of seconds that Amazon SQS retains a message.
   */
  public messageRetentionPeriod?: number;

  /**
   * A name for the queue.
   */
  public queueName?: string;

  /**
   * Specifies the duration, in seconds, that the ReceiveMessage action call waits until a message is in the queue in order to include it in the response, rather than returning an empty response if a message isn't yet available.
   */
  public receiveMessageWaitTimeSeconds?: number;

  /**
   * The string that includes the parameters for the permissions for the dead-letter queue redrive permission and which source queues can specify dead-letter queues as a JSON object.
   */
  public redriveAllowPolicy?: any | cdk.IResolvable;

  /**
   * The string that includes the parameters for the dead-letter queue functionality of the source queue as a JSON object.
   */
  public redrivePolicy?: any | cdk.IResolvable;

  /**
   * Enables server-side queue encryption using SQS owned encryption keys.
   */
  public sqsManagedSseEnabled?: boolean | cdk.IResolvable;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags that you attach to this queue.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The length of time during which a message will be unavailable after a message is delivered from the queue.
   */
  public visibilityTimeout?: number;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnQueueProps = {}) {
    super(scope, id, {
      "type": CfnQueue.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.attrArn = cdk.Token.asString(this.getAtt("Arn", cdk.ResolutionTypeHint.STRING));
    this.attrQueueName = cdk.Token.asString(this.getAtt("QueueName", cdk.ResolutionTypeHint.STRING));
    this.attrQueueUrl = cdk.Token.asString(this.getAtt("QueueUrl", cdk.ResolutionTypeHint.STRING));
    this.contentBasedDeduplication = props.contentBasedDeduplication;
    this.deduplicationScope = props.deduplicationScope;
    this.delaySeconds = props.delaySeconds;
    this.fifoQueue = props.fifoQueue;
    this.fifoThroughputLimit = props.fifoThroughputLimit;
    this.kmsDataKeyReusePeriodSeconds = props.kmsDataKeyReusePeriodSeconds;
    this.kmsMasterKeyId = props.kmsMasterKeyId;
    this.maximumMessageSize = props.maximumMessageSize;
    this.messageRetentionPeriod = props.messageRetentionPeriod;
    this.queueName = props.queueName;
    this.receiveMessageWaitTimeSeconds = props.receiveMessageWaitTimeSeconds;
    this.redriveAllowPolicy = props.redriveAllowPolicy;
    this.redrivePolicy = props.redrivePolicy;
    this.sqsManagedSseEnabled = props.sqsManagedSseEnabled;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::SQS::Queue", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.visibilityTimeout = props.visibilityTimeout;
    if ((this.node.scope != null && cdk.Resource.isResource(this.node.scope))) {
      this.node.addValidation({
        "validate": () => ((this.cfnOptions.deletionPolicy === undefined) ? ["'AWS::SQS::Queue' is a stateful resource type, and you must specify a Removal Policy for it. Call 'resource.applyRemovalPolicy()'."] : [])
      });
    }
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "contentBasedDeduplication": this.contentBasedDeduplication,
      "deduplicationScope": this.deduplicationScope,
      "delaySeconds": this.delaySeconds,
      "fifoQueue": this.fifoQueue,
      "fifoThroughputLimit": this.fifoThroughputLimit,
      "kmsDataKeyReusePeriodSeconds": this.kmsDataKeyReusePeriodSeconds,
      "kmsMasterKeyId": this.kmsMasterKeyId,
      "maximumMessageSize": this.maximumMessageSize,
      "messageRetentionPeriod": this.messageRetentionPeriod,
      "queueName": this.queueName,
      "receiveMessageWaitTimeSeconds": this.receiveMessageWaitTimeSeconds,
      "redriveAllowPolicy": this.redriveAllowPolicy,
      "redrivePolicy": this.redrivePolicy,
      "sqsManagedSseEnabled": this.sqsManagedSseEnabled,
      "tags": this.tags.renderTags(),
      "visibilityTimeout": this.visibilityTimeout
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnQueue.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnQueuePropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnQueue\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html
 */
export interface CfnQueueProps {
  /**
   * For first-in-first-out (FIFO) queues, specifies whether to enable content-based deduplication.
   *
   * During the deduplication interval, Amazon SQS treats messages that are sent with identical content as duplicates and delivers only one copy of the message. For more information, see the \`ContentBasedDeduplication\` attribute for the \`[CreateQueue](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/APIReference/API_CreateQueue.html)\` action in the *Amazon SQS API Reference* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-contentbaseddeduplication
   */
  readonly contentBasedDeduplication?: boolean | cdk.IResolvable;

  /**
   * For high throughput for FIFO queues, specifies whether message deduplication occurs at the message group or queue level.
   *
   * Valid values are \`messageGroup\` and \`queue\` .
   *
   * To enable high throughput for a FIFO queue, set this attribute to \`messageGroup\` *and* set the \`FifoThroughputLimit\` attribute to \`perMessageGroupId\` . If you set these attributes to anything other than these values, normal throughput is in effect and deduplication occurs as specified. For more information, see [High throughput for FIFO queues](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/high-throughput-fifo.html) and [Quotas related to messages](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/quotas-messages.html) in the *Amazon SQS Developer Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-deduplicationscope
   */
  readonly deduplicationScope?: string;

  /**
   * The time in seconds for which the delivery of all messages in the queue is delayed.
   *
   * You can specify an integer value of \`0\` to \`900\` (15 minutes). The default value is \`0\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-delayseconds
   */
  readonly delaySeconds?: number;

  /**
   * If set to true, creates a FIFO queue.
   *
   * If you don't specify this property, Amazon SQS creates a standard queue. For more information, see [FIFO queues](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/FIFO-queues.html) in the *Amazon SQS Developer Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-fifoqueue
   */
  readonly fifoQueue?: boolean | cdk.IResolvable;

  /**
   * For high throughput for FIFO queues, specifies whether the FIFO queue throughput quota applies to the entire queue or per message group.
   *
   * Valid values are \`perQueue\` and \`perMessageGroupId\` .
   *
   * To enable high throughput for a FIFO queue, set this attribute to \`perMessageGroupId\` *and* set the \`DeduplicationScope\` attribute to \`messageGroup\` . If you set these attributes to anything other than these values, normal throughput is in effect and deduplication occurs as specified. For more information, see [High throughput for FIFO queues](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/high-throughput-fifo.html) and [Quotas related to messages](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/quotas-messages.html) in the *Amazon SQS Developer Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-fifothroughputlimit
   */
  readonly fifoThroughputLimit?: string;

  /**
   * The length of time in seconds for which Amazon SQS can reuse a data key to encrypt or decrypt messages before calling AWS KMS again.
   *
   * The value must be an integer between 60 (1 minute) and 86,400 (24 hours). The default is 300 (5 minutes).
   *
   * > A shorter time period provides better security, but results in more calls to AWS KMS , which might incur charges after Free Tier. For more information, see [Encryption at rest](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-server-side-encryption.html#sqs-how-does-the-data-key-reuse-period-work) in the *Amazon SQS Developer Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-kmsdatakeyreuseperiodseconds
   */
  readonly kmsDataKeyReusePeriodSeconds?: number;

  /**
   * The ID of an AWS Key Management Service (KMS) for Amazon SQS , or a custom KMS.
   *
   * To use the AWS managed KMS for Amazon SQS , specify a (default) alias ARN, alias name (e.g. \`alias/aws/sqs\` ), key ARN, or key ID. For more information, see the following:
   *
   * - [Encryption at rest](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-server-side-encryption.html) in the *Amazon SQS Developer Guide*
   * - [CreateQueue](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/APIReference/API_CreateQueue.html) in the *Amazon SQS API Reference*
   * - [Request Parameters](https://docs.aws.amazon.com/kms/latest/APIReference/API_DescribeKey.html#API_DescribeKey_RequestParameters) in the *AWS Key Management Service API Reference*
   * - The Key Management Service (KMS) section of the [AWS Key Management Service Best Practices](https://docs.aws.amazon.com/https://d0.awsstatic.com/whitepapers/aws-kms-best-practices.pdf) whitepaper
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-kmsmasterkeyid
   */
  readonly kmsMasterKeyId?: string;

  /**
   * The limit of how many bytes that a message can contain before Amazon SQS rejects it.
   *
   * You can specify an integer value from \`1,024\` bytes (1 KiB) to \`262,144\` bytes (256 KiB). The default value is \`262,144\` (256 KiB).
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-maximummessagesize
   */
  readonly maximumMessageSize?: number;

  /**
   * The number of seconds that Amazon SQS retains a message.
   *
   * You can specify an integer value from \`60\` seconds (1 minute) to \`1,209,600\` seconds (14 days). The default value is \`345,600\` seconds (4 days).
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-messageretentionperiod
   */
  readonly messageRetentionPeriod?: number;

  /**
   * A name for the queue.
   *
   * To create a FIFO queue, the name of your FIFO queue must end with the \`.fifo\` suffix. For more information, see [FIFO queues](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/FIFO-queues.html) in the *Amazon SQS Developer Guide* .
   *
   * If you don't specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the queue name. For more information, see [Name type](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-name.html) in the *AWS CloudFormation User Guide* .
   *
   * > If you specify a name, you can't perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you must replace the resource, specify a new name.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-queuename
   */
  readonly queueName?: string;

  /**
   * Specifies the duration, in seconds, that the ReceiveMessage action call waits until a message is in the queue in order to include it in the response, rather than returning an empty response if a message isn't yet available.
   *
   * You can specify an integer from 1 to 20. Short polling is used as the default or when you specify 0 for this property. For more information, see [Consuming messages using long polling](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-short-and-long-polling.html#sqs-long-polling) in the *Amazon SQS Developer Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-receivemessagewaittimeseconds
   */
  readonly receiveMessageWaitTimeSeconds?: number;

  /**
   * The string that includes the parameters for the permissions for the dead-letter queue redrive permission and which source queues can specify dead-letter queues as a JSON object.
   *
   * The parameters are as follows:
   *
   * - \`redrivePermission\` : The permission type that defines which source queues can specify the current queue as the dead-letter queue. Valid values are:
   *
   * - \`allowAll\` : (Default) Any source queues in this AWS account in the same Region can specify this queue as the dead-letter queue.
   * - \`denyAll\` : No source queues can specify this queue as the dead-letter queue.
   * - \`byQueue\` : Only queues specified by the \`sourceQueueArns\` parameter can specify this queue as the dead-letter queue.
   * - \`sourceQueueArns\` : The Amazon Resource Names (ARN)s of the source queues that can specify this queue as the dead-letter queue and redrive messages. You can specify this parameter only when the \`redrivePermission\` parameter is set to \`byQueue\` . You can specify up to 10 source queue ARNs. To allow more than 10 source queues to specify dead-letter queues, set the \`redrivePermission\` parameter to \`allowAll\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-redriveallowpolicy
   */
  readonly redriveAllowPolicy?: any | cdk.IResolvable;

  /**
   * The string that includes the parameters for the dead-letter queue functionality of the source queue as a JSON object.
   *
   * The parameters are as follows:
   *
   * - \`deadLetterTargetArn\` : The Amazon Resource Name (ARN) of the dead-letter queue to which Amazon SQS moves messages after the value of \`maxReceiveCount\` is exceeded.
   * - \`maxReceiveCount\` : The number of times a message is delivered to the source queue before being moved to the dead-letter queue. When the \`ReceiveCount\` for a message exceeds the \`maxReceiveCount\` for a queue, Amazon SQS moves the message to the dead-letter-queue.
   *
   * > The dead-letter queue of a FIFO queue must also be a FIFO queue. Similarly, the dead-letter queue of a standard queue must also be a standard queue.
   *
   * *JSON*
   *
   * \`{ "deadLetterTargetArn" : *String* , "maxReceiveCount" : *Integer* }\`
   *
   * *YAML*
   *
   * \`deadLetterTargetArn : *String*\`
   *
   * \`maxReceiveCount : *Integer*\`
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-redrivepolicy
   */
  readonly redrivePolicy?: any | cdk.IResolvable;

  /**
   * Enables server-side queue encryption using SQS owned encryption keys.
   *
   * Only one server-side encryption option is supported per queue (for example, [SSE-KMS](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-configure-sse-existing-queue.html) or [SSE-SQS](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-configure-sqs-sse-queue.html) ).
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-sqsmanagedsseenabled
   */
  readonly sqsManagedSseEnabled?: boolean | cdk.IResolvable;

  /**
   * The tags that you attach to this queue.
   *
   * For more information, see [Resource tag](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html) in the *AWS CloudFormation User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The length of time during which a message will be unavailable after a message is delivered from the queue.
   *
   * This blocks other components from receiving the same message and gives the initial component time to process and delete the message from the queue.
   *
   * Values must be from 0 to 43,200 seconds (12 hours). If you don't specify a value, AWS CloudFormation uses the default value of 30 seconds.
   *
   * For more information about Amazon SQS queue visibility timeouts, see [Visibility timeout](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-visibility-timeout.html) in the *Amazon SQS Developer Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-visibilitytimeout
   */
  readonly visibilityTimeout?: number;
}

/**
 * Determine whether the given properties match those of a \`CfnQueueProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnQueueProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnQueuePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("contentBasedDeduplication", cdk.validateBoolean)(properties.contentBasedDeduplication));
  errors.collect(cdk.propertyValidator("deduplicationScope", cdk.validateString)(properties.deduplicationScope));
  errors.collect(cdk.propertyValidator("delaySeconds", cdk.validateNumber)(properties.delaySeconds));
  errors.collect(cdk.propertyValidator("fifoQueue", cdk.validateBoolean)(properties.fifoQueue));
  errors.collect(cdk.propertyValidator("fifoThroughputLimit", cdk.validateString)(properties.fifoThroughputLimit));
  errors.collect(cdk.propertyValidator("kmsDataKeyReusePeriodSeconds", cdk.validateNumber)(properties.kmsDataKeyReusePeriodSeconds));
  errors.collect(cdk.propertyValidator("kmsMasterKeyId", cdk.validateString)(properties.kmsMasterKeyId));
  errors.collect(cdk.propertyValidator("maximumMessageSize", cdk.validateNumber)(properties.maximumMessageSize));
  errors.collect(cdk.propertyValidator("messageRetentionPeriod", cdk.validateNumber)(properties.messageRetentionPeriod));
  errors.collect(cdk.propertyValidator("queueName", cdk.validateString)(properties.queueName));
  errors.collect(cdk.propertyValidator("receiveMessageWaitTimeSeconds", cdk.validateNumber)(properties.receiveMessageWaitTimeSeconds));
  errors.collect(cdk.propertyValidator("redriveAllowPolicy", cdk.validateObject)(properties.redriveAllowPolicy));
  errors.collect(cdk.propertyValidator("redrivePolicy", cdk.validateObject)(properties.redrivePolicy));
  errors.collect(cdk.propertyValidator("sqsManagedSseEnabled", cdk.validateBoolean)(properties.sqsManagedSseEnabled));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("visibilityTimeout", cdk.validateNumber)(properties.visibilityTimeout));
  return errors.wrap("supplied properties not correct for \\"CfnQueueProps\\"");
}

// @ts-ignore TS6133
function convertCfnQueuePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnQueuePropsValidator(properties).assertSuccess();
  return {
    "ContentBasedDeduplication": cdk.booleanToCloudFormation(properties.contentBasedDeduplication),
    "DeduplicationScope": cdk.stringToCloudFormation(properties.deduplicationScope),
    "DelaySeconds": cdk.numberToCloudFormation(properties.delaySeconds),
    "FifoQueue": cdk.booleanToCloudFormation(properties.fifoQueue),
    "FifoThroughputLimit": cdk.stringToCloudFormation(properties.fifoThroughputLimit),
    "KmsDataKeyReusePeriodSeconds": cdk.numberToCloudFormation(properties.kmsDataKeyReusePeriodSeconds),
    "KmsMasterKeyId": cdk.stringToCloudFormation(properties.kmsMasterKeyId),
    "MaximumMessageSize": cdk.numberToCloudFormation(properties.maximumMessageSize),
    "MessageRetentionPeriod": cdk.numberToCloudFormation(properties.messageRetentionPeriod),
    "QueueName": cdk.stringToCloudFormation(properties.queueName),
    "ReceiveMessageWaitTimeSeconds": cdk.numberToCloudFormation(properties.receiveMessageWaitTimeSeconds),
    "RedriveAllowPolicy": cdk.objectToCloudFormation(properties.redriveAllowPolicy),
    "RedrivePolicy": cdk.objectToCloudFormation(properties.redrivePolicy),
    "SqsManagedSseEnabled": cdk.booleanToCloudFormation(properties.sqsManagedSseEnabled),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "VisibilityTimeout": cdk.numberToCloudFormation(properties.visibilityTimeout)
  };
}

// @ts-ignore TS6133
function CfnQueuePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnQueueProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnQueueProps>();
  ret.addPropertyResult("contentBasedDeduplication", "ContentBasedDeduplication", (properties.ContentBasedDeduplication != null ? cfn_parse.FromCloudFormation.getBoolean(properties.ContentBasedDeduplication) : undefined));
  ret.addPropertyResult("deduplicationScope", "DeduplicationScope", (properties.DeduplicationScope != null ? cfn_parse.FromCloudFormation.getString(properties.DeduplicationScope) : undefined));
  ret.addPropertyResult("delaySeconds", "DelaySeconds", (properties.DelaySeconds != null ? cfn_parse.FromCloudFormation.getNumber(properties.DelaySeconds) : undefined));
  ret.addPropertyResult("fifoQueue", "FifoQueue", (properties.FifoQueue != null ? cfn_parse.FromCloudFormation.getBoolean(properties.FifoQueue) : undefined));
  ret.addPropertyResult("fifoThroughputLimit", "FifoThroughputLimit", (properties.FifoThroughputLimit != null ? cfn_parse.FromCloudFormation.getString(properties.FifoThroughputLimit) : undefined));
  ret.addPropertyResult("kmsDataKeyReusePeriodSeconds", "KmsDataKeyReusePeriodSeconds", (properties.KmsDataKeyReusePeriodSeconds != null ? cfn_parse.FromCloudFormation.getNumber(properties.KmsDataKeyReusePeriodSeconds) : undefined));
  ret.addPropertyResult("kmsMasterKeyId", "KmsMasterKeyId", (properties.KmsMasterKeyId != null ? cfn_parse.FromCloudFormation.getString(properties.KmsMasterKeyId) : undefined));
  ret.addPropertyResult("maximumMessageSize", "MaximumMessageSize", (properties.MaximumMessageSize != null ? cfn_parse.FromCloudFormation.getNumber(properties.MaximumMessageSize) : undefined));
  ret.addPropertyResult("messageRetentionPeriod", "MessageRetentionPeriod", (properties.MessageRetentionPeriod != null ? cfn_parse.FromCloudFormation.getNumber(properties.MessageRetentionPeriod) : undefined));
  ret.addPropertyResult("queueName", "QueueName", (properties.QueueName != null ? cfn_parse.FromCloudFormation.getString(properties.QueueName) : undefined));
  ret.addPropertyResult("receiveMessageWaitTimeSeconds", "ReceiveMessageWaitTimeSeconds", (properties.ReceiveMessageWaitTimeSeconds != null ? cfn_parse.FromCloudFormation.getNumber(properties.ReceiveMessageWaitTimeSeconds) : undefined));
  ret.addPropertyResult("redriveAllowPolicy", "RedriveAllowPolicy", (properties.RedriveAllowPolicy != null ? cfn_parse.FromCloudFormation.getAny(properties.RedriveAllowPolicy) : undefined));
  ret.addPropertyResult("redrivePolicy", "RedrivePolicy", (properties.RedrivePolicy != null ? cfn_parse.FromCloudFormation.getAny(properties.RedrivePolicy) : undefined));
  ret.addPropertyResult("sqsManagedSseEnabled", "SqsManagedSseEnabled", (properties.SqsManagedSseEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.SqsManagedSseEnabled) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("visibilityTimeout", "VisibilityTimeout", (properties.VisibilityTimeout != null ? cfn_parse.FromCloudFormation.getNumber(properties.VisibilityTimeout) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * The \`AWS::SQS::QueuePolicy\` type applies a policy to Amazon SQS queues.
 *
 * For an example snippet, see [Declaring an Amazon SQS policy](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/quickref-iam.html#scenario-sqs-policy) in the *AWS CloudFormation User Guide* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queuepolicy.html
 */
export class CfnQueuePolicy extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::SQS::QueuePolicy";

  /**
   * Build a CfnQueuePolicy from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnQueuePolicy {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnQueuePolicyPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnQueuePolicy(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * A policy document that contains the permissions for the specified Amazon SQS queues.
   */
  public policyDocument: any | cdk.IResolvable;

  /**
   * The URLs of the queues to which you want to add the policy.
   */
  public queues: Array<string>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnQueuePolicyProps) {
    super(scope, id, {
      "type": CfnQueuePolicy.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "policyDocument", this);
    cdk.requireProperty(props, "queues", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.policyDocument = props.policyDocument;
    this.queues = props.queues;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "policyDocument": this.policyDocument,
      "queues": this.queues
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnQueuePolicy.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnQueuePolicyPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnQueuePolicy\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queuepolicy.html
 */
export interface CfnQueuePolicyProps {
  /**
   * A policy document that contains the permissions for the specified Amazon SQS queues.
   *
   * For more information about Amazon SQS policies, see [Using custom policies with the Amazon SQS access policy language](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-creating-custom-policies.html) in the *Amazon SQS Developer Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queuepolicy.html#cfn-sqs-queuepolicy-policydocument
   */
  readonly policyDocument: any | cdk.IResolvable;

  /**
   * The URLs of the queues to which you want to add the policy.
   *
   * You can use the \`[Ref](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference-ref.html)\` function to specify an \`[AWS::SQS::Queue](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sqs-queues.html)\` resource.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queuepolicy.html#cfn-sqs-queuepolicy-queues
   */
  readonly queues: Array<string>;
}

/**
 * Determine whether the given properties match those of a \`CfnQueuePolicyProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnQueuePolicyProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnQueuePolicyPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("policyDocument", cdk.requiredValidator)(properties.policyDocument));
  errors.collect(cdk.propertyValidator("policyDocument", cdk.validateObject)(properties.policyDocument));
  errors.collect(cdk.propertyValidator("queues", cdk.requiredValidator)(properties.queues));
  errors.collect(cdk.propertyValidator("queues", cdk.listValidator(cdk.validateString))(properties.queues));
  return errors.wrap("supplied properties not correct for \\"CfnQueuePolicyProps\\"");
}

// @ts-ignore TS6133
function convertCfnQueuePolicyPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnQueuePolicyPropsValidator(properties).assertSuccess();
  return {
    "PolicyDocument": cdk.objectToCloudFormation(properties.policyDocument),
    "Queues": cdk.listMapper(cdk.stringToCloudFormation)(properties.queues)
  };
}

// @ts-ignore TS6133
function CfnQueuePolicyPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnQueuePolicyProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnQueuePolicyProps>();
  ret.addPropertyResult("policyDocument", "PolicyDocument", (properties.PolicyDocument != null ? cfn_parse.FromCloudFormation.getAny(properties.PolicyDocument) : undefined));
  ret.addPropertyResult("queues", "Queues", (properties.Queues != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.Queues) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}",
}
`;

exports[`can codegen service with arbitrary suffix 1`] = `
"/* eslint-disable prettier/prettier,max-len */
import * as cdk from "aws-cdk-lib";
import * as constructs from "constructs";
import * as cfn_parse from "aws-cdk-lib/core/lib/helpers-internal";

/**
 * Creates an Amazon Kinesis Data Analytics application.
 *
 * For information about creating a Kinesis Data Analytics application, see [Creating an Application](https://docs.aws.amazon.com/kinesisanalytics/latest/java/getting-started.html) .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-application.html
 */
export class CfnApplicationV2 extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::KinesisAnalyticsV2::Application";

  /**
   * Build a CfnApplicationV2 from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnApplicationV2 {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnApplicationV2PropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnApplicationV2(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * Use this parameter to configure the application.
   */
  public applicationConfiguration?: CfnApplicationV2.ApplicationConfigurationProperty | cdk.IResolvable;

  /**
   * The description of the application.
   */
  public applicationDescription?: string;

  /**
   * Describes the maintenance configuration for the application.
   */
  public applicationMaintenanceConfiguration?: CfnApplicationV2.ApplicationMaintenanceConfigurationProperty | cdk.IResolvable;

  /**
   * To create a Kinesis Data Analytics Studio notebook, you must set the mode to \`INTERACTIVE\` .
   */
  public applicationMode?: string;

  /**
   * The name of the application.
   */
  public applicationName?: string;

  /**
   * Identifies the run configuration (start parameters) of a Kinesis Data Analytics application.
   */
  public runConfiguration?: cdk.IResolvable | CfnApplicationV2.RunConfigurationProperty;

  /**
   * The runtime environment for the application.
   */
  public runtimeEnvironment: string;

  /**
   * Specifies the IAM role that the application uses to access external resources.
   */
  public serviceExecutionRole: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * A list of one or more tags to assign to the application.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnApplicationV2Props) {
    super(scope, id, {
      "type": CfnApplicationV2.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "runtimeEnvironment", this);
    cdk.requireProperty(props, "serviceExecutionRole", this);

    this.applicationConfiguration = props.applicationConfiguration;
    this.applicationDescription = props.applicationDescription;
    this.applicationMaintenanceConfiguration = props.applicationMaintenanceConfiguration;
    this.applicationMode = props.applicationMode;
    this.applicationName = props.applicationName;
    this.runConfiguration = props.runConfiguration;
    this.runtimeEnvironment = props.runtimeEnvironment;
    this.serviceExecutionRole = props.serviceExecutionRole;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::KinesisAnalyticsV2::Application", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "applicationConfiguration": this.applicationConfiguration,
      "applicationDescription": this.applicationDescription,
      "applicationMaintenanceConfiguration": this.applicationMaintenanceConfiguration,
      "applicationMode": this.applicationMode,
      "applicationName": this.applicationName,
      "runConfiguration": this.runConfiguration,
      "runtimeEnvironment": this.runtimeEnvironment,
      "serviceExecutionRole": this.serviceExecutionRole,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnApplicationV2.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnApplicationV2PropsToCloudFormation(props);
  }
}

export namespace CfnApplicationV2 {
  /**
   * Specifies the creation parameters for a Kinesis Data Analytics application.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-applicationconfiguration.html
   */
  export interface ApplicationConfigurationProperty {
    /**
     * The code location and type parameters for a Flink-based Kinesis Data Analytics application.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-applicationconfiguration.html#cfn-kinesisanalyticsv2-application-applicationconfiguration-applicationcodeconfiguration
     */
    readonly applicationCodeConfiguration?: CfnApplicationV2.ApplicationCodeConfigurationProperty | cdk.IResolvable;

    /**
     * Describes whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-applicationconfiguration.html#cfn-kinesisanalyticsv2-application-applicationconfiguration-applicationsnapshotconfiguration
     */
    readonly applicationSnapshotConfiguration?: CfnApplicationV2.ApplicationSnapshotConfigurationProperty | cdk.IResolvable;

    /**
     * Describes execution properties for a Flink-based Kinesis Data Analytics application.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-applicationconfiguration.html#cfn-kinesisanalyticsv2-application-applicationconfiguration-environmentproperties
     */
    readonly environmentProperties?: CfnApplicationV2.EnvironmentPropertiesProperty | cdk.IResolvable;

    /**
     * The creation and update parameters for a Flink-based Kinesis Data Analytics application.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-applicationconfiguration.html#cfn-kinesisanalyticsv2-application-applicationconfiguration-flinkapplicationconfiguration
     */
    readonly flinkApplicationConfiguration?: CfnApplicationV2.FlinkApplicationConfigurationProperty | cdk.IResolvable;

    /**
     * The creation and update parameters for a SQL-based Kinesis Data Analytics application.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-applicationconfiguration.html#cfn-kinesisanalyticsv2-application-applicationconfiguration-sqlapplicationconfiguration
     */
    readonly sqlApplicationConfiguration?: cdk.IResolvable | CfnApplicationV2.SqlApplicationConfigurationProperty;

    /**
     * The array of descriptions of VPC configurations available to the application.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-applicationconfiguration.html#cfn-kinesisanalyticsv2-application-applicationconfiguration-vpcconfigurations
     */
    readonly vpcConfigurations?: Array<cdk.IResolvable | CfnApplicationV2.VpcConfigurationProperty> | cdk.IResolvable;

    /**
     * The configuration parameters for a Kinesis Data Analytics Studio notebook.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-applicationconfiguration.html#cfn-kinesisanalyticsv2-application-applicationconfiguration-zeppelinapplicationconfiguration
     */
    readonly zeppelinApplicationConfiguration?: cdk.IResolvable | CfnApplicationV2.ZeppelinApplicationConfigurationProperty;
  }

  /**
   * Describes code configuration for an application.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-applicationcodeconfiguration.html
   */
  export interface ApplicationCodeConfigurationProperty {
    /**
     * The location and type of the application code.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-applicationcodeconfiguration.html#cfn-kinesisanalyticsv2-application-applicationcodeconfiguration-codecontent
     */
    readonly codeContent: CfnApplicationV2.CodeContentProperty | cdk.IResolvable;

    /**
     * Specifies whether the code content is in text or zip format.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-applicationcodeconfiguration.html#cfn-kinesisanalyticsv2-application-applicationcodeconfiguration-codecontenttype
     */
    readonly codeContentType: string;
  }

  /**
   * Specifies either the application code, or the location of the application code, for a Flink-based Kinesis Data Analytics application.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-codecontent.html
   */
  export interface CodeContentProperty {
    /**
     * Information about the Amazon S3 bucket that contains the application code.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-codecontent.html#cfn-kinesisanalyticsv2-application-codecontent-s3contentlocation
     */
    readonly s3ContentLocation?: cdk.IResolvable | CfnApplicationV2.S3ContentLocationProperty;

    /**
     * The text-format code for a Flink-based Kinesis Data Analytics application.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-codecontent.html#cfn-kinesisanalyticsv2-application-codecontent-textcontent
     */
    readonly textContent?: string;

    /**
     * The zip-format code for a Flink-based Kinesis Data Analytics application.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-codecontent.html#cfn-kinesisanalyticsv2-application-codecontent-zipfilecontent
     */
    readonly zipFileContent?: string;
  }

  /**
   * The location of an application or a custom artifact.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-s3contentlocation.html
   */
  export interface S3ContentLocationProperty {
    /**
     * The Amazon Resource Name (ARN) for the S3 bucket containing the application code.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-s3contentlocation.html#cfn-kinesisanalyticsv2-application-s3contentlocation-bucketarn
     */
    readonly bucketArn: string;

    /**
     * The file key for the object containing the application code.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-s3contentlocation.html#cfn-kinesisanalyticsv2-application-s3contentlocation-filekey
     */
    readonly fileKey: string;

    /**
     * The version of the object containing the application code.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-s3contentlocation.html#cfn-kinesisanalyticsv2-application-s3contentlocation-objectversion
     */
    readonly objectVersion?: string;
  }

  /**
   * Describes whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-applicationsnapshotconfiguration.html
   */
  export interface ApplicationSnapshotConfigurationProperty {
    /**
     * Describes whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-applicationsnapshotconfiguration.html#cfn-kinesisanalyticsv2-application-applicationsnapshotconfiguration-snapshotsenabled
     */
    readonly snapshotsEnabled: boolean | cdk.IResolvable;
  }

  /**
   * Describes execution properties for a Flink-based Kinesis Data Analytics application.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-environmentproperties.html
   */
  export interface EnvironmentPropertiesProperty {
    /**
     * Describes the execution property groups.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-environmentproperties.html#cfn-kinesisanalyticsv2-application-environmentproperties-propertygroups
     */
    readonly propertyGroups?: Array<cdk.IResolvable | CfnApplicationV2.PropertyGroupProperty> | cdk.IResolvable;
  }

  /**
   * Property key-value pairs passed into an application.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-propertygroup.html
   */
  export interface PropertyGroupProperty {
    /**
     * Describes the key of an application execution property key-value pair.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-propertygroup.html#cfn-kinesisanalyticsv2-application-propertygroup-propertygroupid
     */
    readonly propertyGroupId?: string;

    /**
     * Describes the value of an application execution property key-value pair.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-propertygroup.html#cfn-kinesisanalyticsv2-application-propertygroup-propertymap
     */
    readonly propertyMap?: cdk.IResolvable | Record<string, string>;
  }

  /**
   * Describes configuration parameters for a Flink-based Kinesis Data Analytics application or a Studio notebook.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-flinkapplicationconfiguration.html
   */
  export interface FlinkApplicationConfigurationProperty {
    /**
     * Describes an application's checkpointing configuration.
     *
     * Checkpointing is the process of persisting application state for fault tolerance. For more information, see [Checkpoints for Fault Tolerance](https://docs.aws.amazon.com/https://ci.apache.org/projects/flink/flink-docs-release-1.8/concepts/programming-model.html#checkpoints-for-fault-tolerance) in the [Apache Flink Documentation](https://docs.aws.amazon.com/https://ci.apache.org/projects/flink/flink-docs-release-1.8/) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-flinkapplicationconfiguration.html#cfn-kinesisanalyticsv2-application-flinkapplicationconfiguration-checkpointconfiguration
     */
    readonly checkpointConfiguration?: CfnApplicationV2.CheckpointConfigurationProperty | cdk.IResolvable;

    /**
     * Describes configuration parameters for Amazon CloudWatch logging for an application.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-flinkapplicationconfiguration.html#cfn-kinesisanalyticsv2-application-flinkapplicationconfiguration-monitoringconfiguration
     */
    readonly monitoringConfiguration?: cdk.IResolvable | CfnApplicationV2.MonitoringConfigurationProperty;

    /**
     * Describes parameters for how an application executes multiple tasks simultaneously.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-flinkapplicationconfiguration.html#cfn-kinesisanalyticsv2-application-flinkapplicationconfiguration-parallelismconfiguration
     */
    readonly parallelismConfiguration?: cdk.IResolvable | CfnApplicationV2.ParallelismConfigurationProperty;
  }

  /**
   * Describes an application's checkpointing configuration.
   *
   * Checkpointing is the process of persisting application state for fault tolerance. For more information, see [Checkpoints for Fault Tolerance](https://docs.aws.amazon.com/https://ci.apache.org/projects/flink/flink-docs-release-1.8/concepts/programming-model.html#checkpoints-for-fault-tolerance) in the [Apache Flink Documentation](https://docs.aws.amazon.com/https://ci.apache.org/projects/flink/flink-docs-release-1.8/) .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-checkpointconfiguration.html
   */
  export interface CheckpointConfigurationProperty {
    /**
     * Describes whether checkpointing is enabled for a Flink-based Kinesis Data Analytics application.
     *
     * > If \`CheckpointConfiguration.ConfigurationType\` is \`DEFAULT\` , the application will use a \`CheckpointingEnabled\` value of \`true\` , even if this value is set to another value using this API or in application code.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-checkpointconfiguration.html#cfn-kinesisanalyticsv2-application-checkpointconfiguration-checkpointingenabled
     */
    readonly checkpointingEnabled?: boolean | cdk.IResolvable;

    /**
     * Describes the interval in milliseconds between checkpoint operations.
     *
     * > If \`CheckpointConfiguration.ConfigurationType\` is \`DEFAULT\` , the application will use a \`CheckpointInterval\` value of 60000, even if this value is set to another value using this API or in application code.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-checkpointconfiguration.html#cfn-kinesisanalyticsv2-application-checkpointconfiguration-checkpointinterval
     */
    readonly checkpointInterval?: number;

    /**
     * Describes whether the application uses Kinesis Data Analytics' default checkpointing behavior.
     *
     * You must set this property to \`CUSTOM\` in order to set the \`CheckpointingEnabled\` , \`CheckpointInterval\` , or \`MinPauseBetweenCheckpoints\` parameters.
     *
     * > If this value is set to \`DEFAULT\` , the application will use the following values, even if they are set to other values using APIs or application code:
     * >
     * > - *CheckpointingEnabled:* true
     * > - *CheckpointInterval:* 60000
     * > - *MinPauseBetweenCheckpoints:* 5000
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-checkpointconfiguration.html#cfn-kinesisanalyticsv2-application-checkpointconfiguration-configurationtype
     */
    readonly configurationType: string;

    /**
     * Describes the minimum time in milliseconds after a checkpoint operation completes that a new checkpoint operation can start.
     *
     * If a checkpoint operation takes longer than the \`CheckpointInterval\` , the application otherwise performs continual checkpoint operations. For more information, see [Tuning Checkpointing](https://docs.aws.amazon.com/https://ci.apache.org/projects/flink/flink-docs-release-1.8/ops/state/large_state_tuning.html#tuning-checkpointing) in the [Apache Flink Documentation](https://docs.aws.amazon.com/https://ci.apache.org/projects/flink/flink-docs-release-1.8/) .
     *
     * > If \`CheckpointConfiguration.ConfigurationType\` is \`DEFAULT\` , the application will use a \`MinPauseBetweenCheckpoints\` value of 5000, even if this value is set using this API or in application code.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-checkpointconfiguration.html#cfn-kinesisanalyticsv2-application-checkpointconfiguration-minpausebetweencheckpoints
     */
    readonly minPauseBetweenCheckpoints?: number;
  }

  /**
   * Describes configuration parameters for Amazon CloudWatch logging for a Java-based Kinesis Data Analytics application.
   *
   * For more information about CloudWatch logging, see [Monitoring](https://docs.aws.amazon.com/kinesisanalytics/latest/java/monitoring-overview) .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-monitoringconfiguration.html
   */
  export interface MonitoringConfigurationProperty {
    /**
     * Describes whether to use the default CloudWatch logging configuration for an application.
     *
     * You must set this property to \`CUSTOM\` in order to set the \`LogLevel\` or \`MetricsLevel\` parameters.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-monitoringconfiguration.html#cfn-kinesisanalyticsv2-application-monitoringconfiguration-configurationtype
     */
    readonly configurationType: string;

    /**
     * Describes the verbosity of the CloudWatch Logs for an application.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-monitoringconfiguration.html#cfn-kinesisanalyticsv2-application-monitoringconfiguration-loglevel
     */
    readonly logLevel?: string;

    /**
     * Describes the granularity of the CloudWatch Logs for an application.
     *
     * The \`Parallelism\` level is not recommended for applications with a Parallelism over 64 due to excessive costs.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-monitoringconfiguration.html#cfn-kinesisanalyticsv2-application-monitoringconfiguration-metricslevel
     */
    readonly metricsLevel?: string;
  }

  /**
   * Describes parameters for how a Flink-based Kinesis Data Analytics application executes multiple tasks simultaneously.
   *
   * For more information about parallelism, see [Parallel Execution](https://docs.aws.amazon.com/https://ci.apache.org/projects/flink/flink-docs-release-1.8/dev/parallel.html) in the [Apache Flink Documentation](https://docs.aws.amazon.com/https://ci.apache.org/projects/flink/flink-docs-release-1.8/) .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-parallelismconfiguration.html
   */
  export interface ParallelismConfigurationProperty {
    /**
     * Describes whether the Kinesis Data Analytics service can increase the parallelism of the application in response to increased throughput.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-parallelismconfiguration.html#cfn-kinesisanalyticsv2-application-parallelismconfiguration-autoscalingenabled
     */
    readonly autoScalingEnabled?: boolean | cdk.IResolvable;

    /**
     * Describes whether the application uses the default parallelism for the Kinesis Data Analytics service.
     *
     * You must set this property to \`CUSTOM\` in order to change your application's \`AutoScalingEnabled\` , \`Parallelism\` , or \`ParallelismPerKPU\` properties.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-parallelismconfiguration.html#cfn-kinesisanalyticsv2-application-parallelismconfiguration-configurationtype
     */
    readonly configurationType: string;

    /**
     * Describes the initial number of parallel tasks that a Java-based Kinesis Data Analytics application can perform.
     *
     * The Kinesis Data Analytics service can increase this number automatically if [ParallelismConfiguration:AutoScalingEnabled](https://docs.aws.amazon.com/kinesisanalytics/latest/apiv2/API_ParallelismConfiguration.html#kinesisanalytics-Type-ParallelismConfiguration-AutoScalingEnabled.html) is set to \`true\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-parallelismconfiguration.html#cfn-kinesisanalyticsv2-application-parallelismconfiguration-parallelism
     */
    readonly parallelism?: number;

    /**
     * Describes the number of parallel tasks that a Java-based Kinesis Data Analytics application can perform per Kinesis Processing Unit (KPU) used by the application.
     *
     * For more information about KPUs, see [Amazon Kinesis Data Analytics Pricing](https://docs.aws.amazon.com/kinesis/data-analytics/pricing/) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-parallelismconfiguration.html#cfn-kinesisanalyticsv2-application-parallelismconfiguration-parallelismperkpu
     */
    readonly parallelismPerKpu?: number;
  }

  /**
   * Describes the inputs, outputs, and reference data sources for a SQL-based Kinesis Data Analytics application.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-sqlapplicationconfiguration.html
   */
  export interface SqlApplicationConfigurationProperty {
    /**
     * The array of [Input](https://docs.aws.amazon.com/kinesisanalytics/latest/apiv2/API_Input.html) objects describing the input streams used by the application.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-sqlapplicationconfiguration.html#cfn-kinesisanalyticsv2-application-sqlapplicationconfiguration-inputs
     */
    readonly inputs?: Array<CfnApplicationV2.InputProperty | cdk.IResolvable> | cdk.IResolvable;
  }

  /**
   * When you configure the application input for a SQL-based Kinesis Data Analytics application, you specify the streaming source, the in-application stream name that is created, and the mapping between the two.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-input.html
   */
  export interface InputProperty {
    /**
     * Describes the number of in-application streams to create.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-input.html#cfn-kinesisanalyticsv2-application-input-inputparallelism
     */
    readonly inputParallelism?: CfnApplicationV2.InputParallelismProperty | cdk.IResolvable;

    /**
     * The [InputProcessingConfiguration](https://docs.aws.amazon.com/kinesisanalytics/latest/apiv2/API_InputProcessingConfiguration.html) for the input. An input processor transforms records as they are received from the stream, before the application's SQL code executes. Currently, the only input processing configuration available is [InputLambdaProcessor](https://docs.aws.amazon.com/kinesisanalytics/latest/apiv2/API_InputLambdaProcessor.html) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-input.html#cfn-kinesisanalyticsv2-application-input-inputprocessingconfiguration
     */
    readonly inputProcessingConfiguration?: CfnApplicationV2.InputProcessingConfigurationProperty | cdk.IResolvable;

    /**
     * Describes the format of the data in the streaming source, and how each data element maps to corresponding columns in the in-application stream that is being created.
     *
     * Also used to describe the format of the reference data source.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-input.html#cfn-kinesisanalyticsv2-application-input-inputschema
     */
    readonly inputSchema: CfnApplicationV2.InputSchemaProperty | cdk.IResolvable;

    /**
     * If the streaming source is an Amazon Kinesis Data Firehose delivery stream, identifies the delivery stream's ARN.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-input.html#cfn-kinesisanalyticsv2-application-input-kinesisfirehoseinput
     */
    readonly kinesisFirehoseInput?: cdk.IResolvable | CfnApplicationV2.KinesisFirehoseInputProperty;

    /**
     * If the streaming source is an Amazon Kinesis data stream, identifies the stream's Amazon Resource Name (ARN).
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-input.html#cfn-kinesisanalyticsv2-application-input-kinesisstreamsinput
     */
    readonly kinesisStreamsInput?: cdk.IResolvable | CfnApplicationV2.KinesisStreamsInputProperty;

    /**
     * The name prefix to use when creating an in-application stream.
     *
     * Suppose that you specify a prefix " \`MyInApplicationStream\` ." Kinesis Data Analytics then creates one or more (as per the \`InputParallelism\` count you specified) in-application streams with the names " \`MyInApplicationStream_001\` ," " \`MyInApplicationStream_002\` ," and so on.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-input.html#cfn-kinesisanalyticsv2-application-input-nameprefix
     */
    readonly namePrefix: string;
  }

  /**
   * For a SQL-based Kinesis Data Analytics application, describes the format of the data in the streaming source, and how each data element maps to corresponding columns created in the in-application stream.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-inputschema.html
   */
  export interface InputSchemaProperty {
    /**
     * A list of \`RecordColumn\` objects.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-inputschema.html#cfn-kinesisanalyticsv2-application-inputschema-recordcolumns
     */
    readonly recordColumns: Array<cdk.IResolvable | CfnApplicationV2.RecordColumnProperty> | cdk.IResolvable;

    /**
     * Specifies the encoding of the records in the streaming source.
     *
     * For example, UTF-8.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-inputschema.html#cfn-kinesisanalyticsv2-application-inputschema-recordencoding
     */
    readonly recordEncoding?: string;

    /**
     * Specifies the format of the records on the streaming source.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-inputschema.html#cfn-kinesisanalyticsv2-application-inputschema-recordformat
     */
    readonly recordFormat: cdk.IResolvable | CfnApplicationV2.RecordFormatProperty;
  }

  /**
   * For a SQL-based Kinesis Data Analytics application, describes the mapping of each data element in the streaming source to the corresponding column in the in-application stream.
   *
   * Also used to describe the format of the reference data source.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-recordcolumn.html
   */
  export interface RecordColumnProperty {
    /**
     * A reference to the data element in the streaming input or the reference data source.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-recordcolumn.html#cfn-kinesisanalyticsv2-application-recordcolumn-mapping
     */
    readonly mapping?: string;

    /**
     * The name of the column that is created in the in-application input stream or reference table.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-recordcolumn.html#cfn-kinesisanalyticsv2-application-recordcolumn-name
     */
    readonly name: string;

    /**
     * The type of column created in the in-application input stream or reference table.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-recordcolumn.html#cfn-kinesisanalyticsv2-application-recordcolumn-sqltype
     */
    readonly sqlType: string;
  }

  /**
   * For a SQL-based Kinesis Data Analytics application, describes the record format and relevant mapping information that should be applied to schematize the records on the stream.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-recordformat.html
   */
  export interface RecordFormatProperty {
    /**
     * When you configure application input at the time of creating or updating an application, provides additional mapping information specific to the record format (such as JSON, CSV, or record fields delimited by some delimiter) on the streaming source.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-recordformat.html#cfn-kinesisanalyticsv2-application-recordformat-mappingparameters
     */
    readonly mappingParameters?: cdk.IResolvable | CfnApplicationV2.MappingParametersProperty;

    /**
     * The type of record format.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-recordformat.html#cfn-kinesisanalyticsv2-application-recordformat-recordformattype
     */
    readonly recordFormatType: string;
  }

  /**
   * When you configure a SQL-based Kinesis Data Analytics application's input at the time of creating or updating an application, provides additional mapping information specific to the record format (such as JSON, CSV, or record fields delimited by some delimiter) on the streaming source.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-mappingparameters.html
   */
  export interface MappingParametersProperty {
    /**
     * Provides additional mapping information when the record format uses delimiters (for example, CSV).
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-mappingparameters.html#cfn-kinesisanalyticsv2-application-mappingparameters-csvmappingparameters
     */
    readonly csvMappingParameters?: CfnApplicationV2.CSVMappingParametersProperty | cdk.IResolvable;

    /**
     * Provides additional mapping information when JSON is the record format on the streaming source.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-mappingparameters.html#cfn-kinesisanalyticsv2-application-mappingparameters-jsonmappingparameters
     */
    readonly jsonMappingParameters?: cdk.IResolvable | CfnApplicationV2.JSONMappingParametersProperty;
  }

  /**
   * For a SQL-based Kinesis Data Analytics application, provides additional mapping information when the record format uses delimiters, such as CSV.
   *
   * For example, the following sample records use CSV format, where the records use the *'\\n'* as the row delimiter and a comma (",") as the column delimiter:
   *
   * \`"name1", "address1"\`
   *
   * \`"name2", "address2"\`
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-csvmappingparameters.html
   */
  export interface CSVMappingParametersProperty {
    /**
     * The column delimiter.
     *
     * For example, in a CSV format, a comma (",") is the typical column delimiter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-csvmappingparameters.html#cfn-kinesisanalyticsv2-application-csvmappingparameters-recordcolumndelimiter
     */
    readonly recordColumnDelimiter: string;

    /**
     * The row delimiter.
     *
     * For example, in a CSV format, *'\\n'* is the typical row delimiter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-csvmappingparameters.html#cfn-kinesisanalyticsv2-application-csvmappingparameters-recordrowdelimiter
     */
    readonly recordRowDelimiter: string;
  }

  /**
   * For a SQL-based Kinesis Data Analytics application, provides additional mapping information when JSON is the record format on the streaming source.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-jsonmappingparameters.html
   */
  export interface JSONMappingParametersProperty {
    /**
     * The path to the top-level parent that contains the records.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-jsonmappingparameters.html#cfn-kinesisanalyticsv2-application-jsonmappingparameters-recordrowpath
     */
    readonly recordRowPath: string;
  }

  /**
   * Identifies a Kinesis data stream as the streaming source.
   *
   * You provide the stream's Amazon Resource Name (ARN).
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-kinesisstreamsinput.html
   */
  export interface KinesisStreamsInputProperty {
    /**
     * The ARN of the input Kinesis data stream to read.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-kinesisstreamsinput.html#cfn-kinesisanalyticsv2-application-kinesisstreamsinput-resourcearn
     */
    readonly resourceArn: string;
  }

  /**
   * For a SQL-based Kinesis Data Analytics application, identifies a Kinesis Data Firehose delivery stream as the streaming source.
   *
   * You provide the delivery stream's Amazon Resource Name (ARN).
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-kinesisfirehoseinput.html
   */
  export interface KinesisFirehoseInputProperty {
    /**
     * The Amazon Resource Name (ARN) of the delivery stream.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-kinesisfirehoseinput.html#cfn-kinesisanalyticsv2-application-kinesisfirehoseinput-resourcearn
     */
    readonly resourceArn: string;
  }

  /**
   * For an SQL-based Amazon Kinesis Data Analytics application, describes a processor that is used to preprocess the records in the stream before being processed by your application code.
   *
   * Currently, the only input processor available is [Amazon Lambda](https://docs.aws.amazon.com/lambda/) .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-inputprocessingconfiguration.html
   */
  export interface InputProcessingConfigurationProperty {
    /**
     * The [InputLambdaProcessor](https://docs.aws.amazon.com/kinesisanalytics/latest/apiv2/API_InputLambdaProcessor.html) that is used to preprocess the records in the stream before being processed by your application code.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-inputprocessingconfiguration.html#cfn-kinesisanalyticsv2-application-inputprocessingconfiguration-inputlambdaprocessor
     */
    readonly inputLambdaProcessor?: CfnApplicationV2.InputLambdaProcessorProperty | cdk.IResolvable;
  }

  /**
   * An object that contains the Amazon Resource Name (ARN) of the Amazon Lambda function that is used to preprocess records in the stream in a SQL-based Kinesis Data Analytics application.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-inputlambdaprocessor.html
   */
  export interface InputLambdaProcessorProperty {
    /**
     * The ARN of the Amazon Lambda function that operates on records in the stream.
     *
     * > To specify an earlier version of the Lambda function than the latest, include the Lambda function version in the Lambda function ARN. For more information about Lambda ARNs, see [Example ARNs: Amazon Lambda](https://docs.aws.amazon.com//general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-lambda)
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-inputlambdaprocessor.html#cfn-kinesisanalyticsv2-application-inputlambdaprocessor-resourcearn
     */
    readonly resourceArn: string;
  }

  /**
   * For a SQL-based Kinesis Data Analytics application, describes the number of in-application streams to create for a given streaming source.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-inputparallelism.html
   */
  export interface InputParallelismProperty {
    /**
     * The number of in-application streams to create.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-inputparallelism.html#cfn-kinesisanalyticsv2-application-inputparallelism-count
     */
    readonly count?: number;
  }

  /**
   * The configuration of a Kinesis Data Analytics Studio notebook.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-zeppelinapplicationconfiguration.html
   */
  export interface ZeppelinApplicationConfigurationProperty {
    /**
     * The Amazon Glue Data Catalog that you use in queries in a Kinesis Data Analytics Studio notebook.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-zeppelinapplicationconfiguration.html#cfn-kinesisanalyticsv2-application-zeppelinapplicationconfiguration-catalogconfiguration
     */
    readonly catalogConfiguration?: CfnApplicationV2.CatalogConfigurationProperty | cdk.IResolvable;

    /**
     * A list of \`CustomArtifactConfiguration\` objects.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-zeppelinapplicationconfiguration.html#cfn-kinesisanalyticsv2-application-zeppelinapplicationconfiguration-customartifactsconfiguration
     */
    readonly customArtifactsConfiguration?: Array<CfnApplicationV2.CustomArtifactConfigurationProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The information required to deploy a Kinesis Data Analytics Studio notebook as an application with durable state.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-zeppelinapplicationconfiguration.html#cfn-kinesisanalyticsv2-application-zeppelinapplicationconfiguration-deployasapplicationconfiguration
     */
    readonly deployAsApplicationConfiguration?: CfnApplicationV2.DeployAsApplicationConfigurationProperty | cdk.IResolvable;

    /**
     * The monitoring configuration of a Kinesis Data Analytics Studio notebook.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-zeppelinapplicationconfiguration.html#cfn-kinesisanalyticsv2-application-zeppelinapplicationconfiguration-monitoringconfiguration
     */
    readonly monitoringConfiguration?: cdk.IResolvable | CfnApplicationV2.ZeppelinMonitoringConfigurationProperty;
  }

  /**
   * The configuration parameters for the default Amazon Glue database.
   *
   * You use this database for SQL queries that you write in a Kinesis Data Analytics Studio notebook.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-catalogconfiguration.html
   */
  export interface CatalogConfigurationProperty {
    /**
     * The configuration parameters for the default Amazon Glue database.
     *
     * You use this database for Apache Flink SQL queries and table API transforms that you write in a Kinesis Data Analytics Studio notebook.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-catalogconfiguration.html#cfn-kinesisanalyticsv2-application-catalogconfiguration-gluedatacatalogconfiguration
     */
    readonly glueDataCatalogConfiguration?: CfnApplicationV2.GlueDataCatalogConfigurationProperty | cdk.IResolvable;
  }

  /**
   * The configuration of the Glue Data Catalog that you use for Apache Flink SQL queries and table API transforms that you write in an application.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-gluedatacatalogconfiguration.html
   */
  export interface GlueDataCatalogConfigurationProperty {
    /**
     * The Amazon Resource Name (ARN) of the database.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-gluedatacatalogconfiguration.html#cfn-kinesisanalyticsv2-application-gluedatacatalogconfiguration-databasearn
     */
    readonly databaseArn?: string;
  }

  /**
   * Describes configuration parameters for Amazon CloudWatch logging for a Kinesis Data Analytics Studio notebook.
   *
   * For more information about CloudWatch logging, see [Monitoring](https://docs.aws.amazon.com/kinesisanalytics/latest/java/monitoring-overview.html) .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-zeppelinmonitoringconfiguration.html
   */
  export interface ZeppelinMonitoringConfigurationProperty {
    /**
     * The verbosity of the CloudWatch Logs for an application.
     *
     * You can set it to \`INFO\` , \`WARN\` , \`ERROR\` , or \`DEBUG\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-zeppelinmonitoringconfiguration.html#cfn-kinesisanalyticsv2-application-zeppelinmonitoringconfiguration-loglevel
     */
    readonly logLevel?: string;
  }

  /**
   * The information required to deploy a Kinesis Data Analytics Studio notebook as an application with durable state.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-deployasapplicationconfiguration.html
   */
  export interface DeployAsApplicationConfigurationProperty {
    /**
     * The description of an Amazon S3 object that contains the Amazon Data Analytics application, including the Amazon Resource Name (ARN) of the S3 bucket, the name of the Amazon S3 object that contains the data, and the version number of the Amazon S3 object that contains the data.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-deployasapplicationconfiguration.html#cfn-kinesisanalyticsv2-application-deployasapplicationconfiguration-s3contentlocation
     */
    readonly s3ContentLocation: cdk.IResolvable | CfnApplicationV2.S3ContentBaseLocationProperty;
  }

  /**
   * The base location of the Amazon Data Analytics application.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-s3contentbaselocation.html
   */
  export interface S3ContentBaseLocationProperty {
    /**
     * The base path for the S3 bucket.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-s3contentbaselocation.html#cfn-kinesisanalyticsv2-application-s3contentbaselocation-basepath
     */
    readonly basePath?: string;

    /**
     * The Amazon Resource Name (ARN) of the S3 bucket.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-s3contentbaselocation.html#cfn-kinesisanalyticsv2-application-s3contentbaselocation-bucketarn
     */
    readonly bucketArn: string;
  }

  /**
   * The configuration of connectors and user-defined functions.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-customartifactconfiguration.html
   */
  export interface CustomArtifactConfigurationProperty {
    /**
     * Set this to either \`UDF\` or \`DEPENDENCY_JAR\` .
     *
     * \`UDF\` stands for user-defined functions. This type of artifact must be in an S3 bucket. A \`DEPENDENCY_JAR\` can be in either Maven or an S3 bucket.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-customartifactconfiguration.html#cfn-kinesisanalyticsv2-application-customartifactconfiguration-artifacttype
     */
    readonly artifactType: string;

    /**
     * The parameters required to fully specify a Maven reference.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-customartifactconfiguration.html#cfn-kinesisanalyticsv2-application-customartifactconfiguration-mavenreference
     */
    readonly mavenReference?: cdk.IResolvable | CfnApplicationV2.MavenReferenceProperty;

    /**
     * The location of the custom artifacts.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-customartifactconfiguration.html#cfn-kinesisanalyticsv2-application-customartifactconfiguration-s3contentlocation
     */
    readonly s3ContentLocation?: cdk.IResolvable | CfnApplicationV2.S3ContentLocationProperty;
  }

  /**
   * The information required to specify a Maven reference.
   *
   * You can use Maven references to specify dependency JAR files.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-mavenreference.html
   */
  export interface MavenReferenceProperty {
    /**
     * The artifact ID of the Maven reference.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-mavenreference.html#cfn-kinesisanalyticsv2-application-mavenreference-artifactid
     */
    readonly artifactId: string;

    /**
     * The group ID of the Maven reference.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-mavenreference.html#cfn-kinesisanalyticsv2-application-mavenreference-groupid
     */
    readonly groupId: string;

    /**
     * The version of the Maven reference.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-mavenreference.html#cfn-kinesisanalyticsv2-application-mavenreference-version
     */
    readonly version: string;
  }

  /**
   * Describes the parameters of a VPC used by the application.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-vpcconfiguration.html
   */
  export interface VpcConfigurationProperty {
    /**
     * The array of [SecurityGroup](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_SecurityGroup.html) IDs used by the VPC configuration.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-vpcconfiguration.html#cfn-kinesisanalyticsv2-application-vpcconfiguration-securitygroupids
     */
    readonly securityGroupIds: Array<string>;

    /**
     * The array of [Subnet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_Subnet.html) IDs used by the VPC configuration.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-vpcconfiguration.html#cfn-kinesisanalyticsv2-application-vpcconfiguration-subnetids
     */
    readonly subnetIds: Array<string>;
  }

  /**
   * Describes the starting parameters for an Kinesis Data Analytics application.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-runconfiguration.html
   */
  export interface RunConfigurationProperty {
    /**
     * Describes the restore behavior of a restarting application.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-runconfiguration.html#cfn-kinesisanalyticsv2-application-runconfiguration-applicationrestoreconfiguration
     */
    readonly applicationRestoreConfiguration?: CfnApplicationV2.ApplicationRestoreConfigurationProperty | cdk.IResolvable;

    /**
     * Describes the starting parameters for a Flink-based Kinesis Data Analytics application.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-runconfiguration.html#cfn-kinesisanalyticsv2-application-runconfiguration-flinkrunconfiguration
     */
    readonly flinkRunConfiguration?: CfnApplicationV2.FlinkRunConfigurationProperty | cdk.IResolvable;
  }

  /**
   * Specifies the method and snapshot to use when restarting an application using previously saved application state.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-applicationrestoreconfiguration.html
   */
  export interface ApplicationRestoreConfigurationProperty {
    /**
     * Specifies how the application should be restored.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-applicationrestoreconfiguration.html#cfn-kinesisanalyticsv2-application-applicationrestoreconfiguration-applicationrestoretype
     */
    readonly applicationRestoreType: string;

    /**
     * The identifier of an existing snapshot of application state to use to restart an application.
     *
     * The application uses this value if \`RESTORE_FROM_CUSTOM_SNAPSHOT\` is specified for the \`ApplicationRestoreType\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-applicationrestoreconfiguration.html#cfn-kinesisanalyticsv2-application-applicationrestoreconfiguration-snapshotname
     */
    readonly snapshotName?: string;
  }

  /**
   * Describes the starting parameters for a Flink-based Kinesis Data Analytics application.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-flinkrunconfiguration.html
   */
  export interface FlinkRunConfigurationProperty {
    /**
     * When restoring from a snapshot, specifies whether the runtime is allowed to skip a state that cannot be mapped to the new program.
     *
     * This will happen if the program is updated between snapshots to remove stateful parameters, and state data in the snapshot no longer corresponds to valid application data. For more information, see [Allowing Non-Restored State](https://docs.aws.amazon.com/https://ci.apache.org/projects/flink/flink-docs-release-1.8/ops/state/savepoints.html#allowing-non-restored-state) in the [Apache Flink documentation](https://docs.aws.amazon.com/https://ci.apache.org/projects/flink/flink-docs-release-1.8/) .
     *
     * > This value defaults to \`false\` . If you update your application without specifying this parameter, \`AllowNonRestoredState\` will be set to \`false\` , even if it was previously set to \`true\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-flinkrunconfiguration.html#cfn-kinesisanalyticsv2-application-flinkrunconfiguration-allownonrestoredstate
     */
    readonly allowNonRestoredState?: boolean | cdk.IResolvable;
  }

  /**
   * Specifies the maintence window parameters for a Kinesis Data Analytics application.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-applicationmaintenanceconfiguration.html
   */
  export interface ApplicationMaintenanceConfigurationProperty {
    /**
     * Specifies the start time of the maintence window.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-applicationmaintenanceconfiguration.html#cfn-kinesisanalyticsv2-application-applicationmaintenanceconfiguration-applicationmaintenancewindowstarttime
     */
    readonly applicationMaintenanceWindowStartTime: string;
  }
}

/**
 * Properties for defining a \`CfnApplication\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-application.html
 */
export interface CfnApplicationV2Props {
  /**
   * Use this parameter to configure the application.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-application.html#cfn-kinesisanalyticsv2-application-applicationconfiguration
   */
  readonly applicationConfiguration?: CfnApplicationV2.ApplicationConfigurationProperty | cdk.IResolvable;

  /**
   * The description of the application.
   *
   * @default - ""
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-application.html#cfn-kinesisanalyticsv2-application-applicationdescription
   */
  readonly applicationDescription?: string;

  /**
   * Describes the maintenance configuration for the application.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-application.html#cfn-kinesisanalyticsv2-application-applicationmaintenanceconfiguration
   */
  readonly applicationMaintenanceConfiguration?: CfnApplicationV2.ApplicationMaintenanceConfigurationProperty | cdk.IResolvable;

  /**
   * To create a Kinesis Data Analytics Studio notebook, you must set the mode to \`INTERACTIVE\` .
   *
   * However, for a Kinesis Data Analytics for Apache Flink application, the mode is optional.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-application.html#cfn-kinesisanalyticsv2-application-applicationmode
   */
  readonly applicationMode?: string;

  /**
   * The name of the application.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-application.html#cfn-kinesisanalyticsv2-application-applicationname
   */
  readonly applicationName?: string;

  /**
   * Identifies the run configuration (start parameters) of a Kinesis Data Analytics application.
   *
   * This section is evaluated only on stack updates for applications in running RUNNING state and has no effect during manual application start.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-application.html#cfn-kinesisanalyticsv2-application-runconfiguration
   */
  readonly runConfiguration?: cdk.IResolvable | CfnApplicationV2.RunConfigurationProperty;

  /**
   * The runtime environment for the application.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-application.html#cfn-kinesisanalyticsv2-application-runtimeenvironment
   */
  readonly runtimeEnvironment: string;

  /**
   * Specifies the IAM role that the application uses to access external resources.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-application.html#cfn-kinesisanalyticsv2-application-serviceexecutionrole
   */
  readonly serviceExecutionRole: string;

  /**
   * A list of one or more tags to assign to the application.
   *
   * A tag is a key-value pair that identifies an application. Note that the maximum number of application tags includes system tags. The maximum number of user-defined application tags is 50.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-application.html#cfn-kinesisanalyticsv2-application-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a \`S3ContentLocationProperty\`
 *
 * @param properties - the TypeScript properties of a \`S3ContentLocationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2S3ContentLocationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("bucketArn", cdk.requiredValidator)(properties.bucketArn));
  errors.collect(cdk.propertyValidator("bucketArn", cdk.validateString)(properties.bucketArn));
  errors.collect(cdk.propertyValidator("fileKey", cdk.requiredValidator)(properties.fileKey));
  errors.collect(cdk.propertyValidator("fileKey", cdk.validateString)(properties.fileKey));
  errors.collect(cdk.propertyValidator("objectVersion", cdk.validateString)(properties.objectVersion));
  return errors.wrap("supplied properties not correct for \\"S3ContentLocationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2S3ContentLocationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2S3ContentLocationPropertyValidator(properties).assertSuccess();
  return {
    "BucketARN": cdk.stringToCloudFormation(properties.bucketArn),
    "FileKey": cdk.stringToCloudFormation(properties.fileKey),
    "ObjectVersion": cdk.stringToCloudFormation(properties.objectVersion)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2S3ContentLocationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApplicationV2.S3ContentLocationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.S3ContentLocationProperty>();
  ret.addPropertyResult("bucketArn", "BucketARN", (properties.BucketARN != null ? cfn_parse.FromCloudFormation.getString(properties.BucketARN) : undefined));
  ret.addPropertyResult("fileKey", "FileKey", (properties.FileKey != null ? cfn_parse.FromCloudFormation.getString(properties.FileKey) : undefined));
  ret.addPropertyResult("objectVersion", "ObjectVersion", (properties.ObjectVersion != null ? cfn_parse.FromCloudFormation.getString(properties.ObjectVersion) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CodeContentProperty\`
 *
 * @param properties - the TypeScript properties of a \`CodeContentProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2CodeContentPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("s3ContentLocation", CfnApplicationV2S3ContentLocationPropertyValidator)(properties.s3ContentLocation));
  errors.collect(cdk.propertyValidator("textContent", cdk.validateString)(properties.textContent));
  errors.collect(cdk.propertyValidator("zipFileContent", cdk.validateString)(properties.zipFileContent));
  return errors.wrap("supplied properties not correct for \\"CodeContentProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2CodeContentPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2CodeContentPropertyValidator(properties).assertSuccess();
  return {
    "S3ContentLocation": convertCfnApplicationV2S3ContentLocationPropertyToCloudFormation(properties.s3ContentLocation),
    "TextContent": cdk.stringToCloudFormation(properties.textContent),
    "ZipFileContent": cdk.stringToCloudFormation(properties.zipFileContent)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2CodeContentPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApplicationV2.CodeContentProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.CodeContentProperty>();
  ret.addPropertyResult("s3ContentLocation", "S3ContentLocation", (properties.S3ContentLocation != null ? CfnApplicationV2S3ContentLocationPropertyFromCloudFormation(properties.S3ContentLocation) : undefined));
  ret.addPropertyResult("textContent", "TextContent", (properties.TextContent != null ? cfn_parse.FromCloudFormation.getString(properties.TextContent) : undefined));
  ret.addPropertyResult("zipFileContent", "ZipFileContent", (properties.ZipFileContent != null ? cfn_parse.FromCloudFormation.getString(properties.ZipFileContent) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ApplicationCodeConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`ApplicationCodeConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2ApplicationCodeConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("codeContent", cdk.requiredValidator)(properties.codeContent));
  errors.collect(cdk.propertyValidator("codeContent", CfnApplicationV2CodeContentPropertyValidator)(properties.codeContent));
  errors.collect(cdk.propertyValidator("codeContentType", cdk.requiredValidator)(properties.codeContentType));
  errors.collect(cdk.propertyValidator("codeContentType", cdk.validateString)(properties.codeContentType));
  return errors.wrap("supplied properties not correct for \\"ApplicationCodeConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2ApplicationCodeConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2ApplicationCodeConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "CodeContent": convertCfnApplicationV2CodeContentPropertyToCloudFormation(properties.codeContent),
    "CodeContentType": cdk.stringToCloudFormation(properties.codeContentType)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2ApplicationCodeConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApplicationV2.ApplicationCodeConfigurationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.ApplicationCodeConfigurationProperty>();
  ret.addPropertyResult("codeContent", "CodeContent", (properties.CodeContent != null ? CfnApplicationV2CodeContentPropertyFromCloudFormation(properties.CodeContent) : undefined));
  ret.addPropertyResult("codeContentType", "CodeContentType", (properties.CodeContentType != null ? cfn_parse.FromCloudFormation.getString(properties.CodeContentType) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ApplicationSnapshotConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`ApplicationSnapshotConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2ApplicationSnapshotConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("snapshotsEnabled", cdk.requiredValidator)(properties.snapshotsEnabled));
  errors.collect(cdk.propertyValidator("snapshotsEnabled", cdk.validateBoolean)(properties.snapshotsEnabled));
  return errors.wrap("supplied properties not correct for \\"ApplicationSnapshotConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2ApplicationSnapshotConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2ApplicationSnapshotConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "SnapshotsEnabled": cdk.booleanToCloudFormation(properties.snapshotsEnabled)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2ApplicationSnapshotConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApplicationV2.ApplicationSnapshotConfigurationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.ApplicationSnapshotConfigurationProperty>();
  ret.addPropertyResult("snapshotsEnabled", "SnapshotsEnabled", (properties.SnapshotsEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.SnapshotsEnabled) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`PropertyGroupProperty\`
 *
 * @param properties - the TypeScript properties of a \`PropertyGroupProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2PropertyGroupPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("propertyGroupId", cdk.validateString)(properties.propertyGroupId));
  errors.collect(cdk.propertyValidator("propertyMap", cdk.hashValidator(cdk.validateString))(properties.propertyMap));
  return errors.wrap("supplied properties not correct for \\"PropertyGroupProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2PropertyGroupPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2PropertyGroupPropertyValidator(properties).assertSuccess();
  return {
    "PropertyGroupId": cdk.stringToCloudFormation(properties.propertyGroupId),
    "PropertyMap": cdk.hashMapper(cdk.stringToCloudFormation)(properties.propertyMap)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2PropertyGroupPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApplicationV2.PropertyGroupProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.PropertyGroupProperty>();
  ret.addPropertyResult("propertyGroupId", "PropertyGroupId", (properties.PropertyGroupId != null ? cfn_parse.FromCloudFormation.getString(properties.PropertyGroupId) : undefined));
  ret.addPropertyResult("propertyMap", "PropertyMap", (properties.PropertyMap != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getString)(properties.PropertyMap) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`EnvironmentPropertiesProperty\`
 *
 * @param properties - the TypeScript properties of a \`EnvironmentPropertiesProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2EnvironmentPropertiesPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("propertyGroups", cdk.listValidator(CfnApplicationV2PropertyGroupPropertyValidator))(properties.propertyGroups));
  return errors.wrap("supplied properties not correct for \\"EnvironmentPropertiesProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2EnvironmentPropertiesPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2EnvironmentPropertiesPropertyValidator(properties).assertSuccess();
  return {
    "PropertyGroups": cdk.listMapper(convertCfnApplicationV2PropertyGroupPropertyToCloudFormation)(properties.propertyGroups)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2EnvironmentPropertiesPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApplicationV2.EnvironmentPropertiesProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.EnvironmentPropertiesProperty>();
  ret.addPropertyResult("propertyGroups", "PropertyGroups", (properties.PropertyGroups != null ? cfn_parse.FromCloudFormation.getArray(CfnApplicationV2PropertyGroupPropertyFromCloudFormation)(properties.PropertyGroups) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CheckpointConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`CheckpointConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2CheckpointConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("checkpointInterval", cdk.validateNumber)(properties.checkpointInterval));
  errors.collect(cdk.propertyValidator("checkpointingEnabled", cdk.validateBoolean)(properties.checkpointingEnabled));
  errors.collect(cdk.propertyValidator("configurationType", cdk.requiredValidator)(properties.configurationType));
  errors.collect(cdk.propertyValidator("configurationType", cdk.validateString)(properties.configurationType));
  errors.collect(cdk.propertyValidator("minPauseBetweenCheckpoints", cdk.validateNumber)(properties.minPauseBetweenCheckpoints));
  return errors.wrap("supplied properties not correct for \\"CheckpointConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2CheckpointConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2CheckpointConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "CheckpointInterval": cdk.numberToCloudFormation(properties.checkpointInterval),
    "CheckpointingEnabled": cdk.booleanToCloudFormation(properties.checkpointingEnabled),
    "ConfigurationType": cdk.stringToCloudFormation(properties.configurationType),
    "MinPauseBetweenCheckpoints": cdk.numberToCloudFormation(properties.minPauseBetweenCheckpoints)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2CheckpointConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApplicationV2.CheckpointConfigurationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.CheckpointConfigurationProperty>();
  ret.addPropertyResult("checkpointingEnabled", "CheckpointingEnabled", (properties.CheckpointingEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.CheckpointingEnabled) : undefined));
  ret.addPropertyResult("checkpointInterval", "CheckpointInterval", (properties.CheckpointInterval != null ? cfn_parse.FromCloudFormation.getNumber(properties.CheckpointInterval) : undefined));
  ret.addPropertyResult("configurationType", "ConfigurationType", (properties.ConfigurationType != null ? cfn_parse.FromCloudFormation.getString(properties.ConfigurationType) : undefined));
  ret.addPropertyResult("minPauseBetweenCheckpoints", "MinPauseBetweenCheckpoints", (properties.MinPauseBetweenCheckpoints != null ? cfn_parse.FromCloudFormation.getNumber(properties.MinPauseBetweenCheckpoints) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`MonitoringConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`MonitoringConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2MonitoringConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("configurationType", cdk.requiredValidator)(properties.configurationType));
  errors.collect(cdk.propertyValidator("configurationType", cdk.validateString)(properties.configurationType));
  errors.collect(cdk.propertyValidator("logLevel", cdk.validateString)(properties.logLevel));
  errors.collect(cdk.propertyValidator("metricsLevel", cdk.validateString)(properties.metricsLevel));
  return errors.wrap("supplied properties not correct for \\"MonitoringConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2MonitoringConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2MonitoringConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "ConfigurationType": cdk.stringToCloudFormation(properties.configurationType),
    "LogLevel": cdk.stringToCloudFormation(properties.logLevel),
    "MetricsLevel": cdk.stringToCloudFormation(properties.metricsLevel)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2MonitoringConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApplicationV2.MonitoringConfigurationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.MonitoringConfigurationProperty>();
  ret.addPropertyResult("configurationType", "ConfigurationType", (properties.ConfigurationType != null ? cfn_parse.FromCloudFormation.getString(properties.ConfigurationType) : undefined));
  ret.addPropertyResult("logLevel", "LogLevel", (properties.LogLevel != null ? cfn_parse.FromCloudFormation.getString(properties.LogLevel) : undefined));
  ret.addPropertyResult("metricsLevel", "MetricsLevel", (properties.MetricsLevel != null ? cfn_parse.FromCloudFormation.getString(properties.MetricsLevel) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ParallelismConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`ParallelismConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2ParallelismConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("autoScalingEnabled", cdk.validateBoolean)(properties.autoScalingEnabled));
  errors.collect(cdk.propertyValidator("configurationType", cdk.requiredValidator)(properties.configurationType));
  errors.collect(cdk.propertyValidator("configurationType", cdk.validateString)(properties.configurationType));
  errors.collect(cdk.propertyValidator("parallelism", cdk.validateNumber)(properties.parallelism));
  errors.collect(cdk.propertyValidator("parallelismPerKpu", cdk.validateNumber)(properties.parallelismPerKpu));
  return errors.wrap("supplied properties not correct for \\"ParallelismConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2ParallelismConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2ParallelismConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "AutoScalingEnabled": cdk.booleanToCloudFormation(properties.autoScalingEnabled),
    "ConfigurationType": cdk.stringToCloudFormation(properties.configurationType),
    "Parallelism": cdk.numberToCloudFormation(properties.parallelism),
    "ParallelismPerKPU": cdk.numberToCloudFormation(properties.parallelismPerKpu)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2ParallelismConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApplicationV2.ParallelismConfigurationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.ParallelismConfigurationProperty>();
  ret.addPropertyResult("autoScalingEnabled", "AutoScalingEnabled", (properties.AutoScalingEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.AutoScalingEnabled) : undefined));
  ret.addPropertyResult("configurationType", "ConfigurationType", (properties.ConfigurationType != null ? cfn_parse.FromCloudFormation.getString(properties.ConfigurationType) : undefined));
  ret.addPropertyResult("parallelism", "Parallelism", (properties.Parallelism != null ? cfn_parse.FromCloudFormation.getNumber(properties.Parallelism) : undefined));
  ret.addPropertyResult("parallelismPerKpu", "ParallelismPerKPU", (properties.ParallelismPerKPU != null ? cfn_parse.FromCloudFormation.getNumber(properties.ParallelismPerKPU) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`FlinkApplicationConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`FlinkApplicationConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2FlinkApplicationConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("checkpointConfiguration", CfnApplicationV2CheckpointConfigurationPropertyValidator)(properties.checkpointConfiguration));
  errors.collect(cdk.propertyValidator("monitoringConfiguration", CfnApplicationV2MonitoringConfigurationPropertyValidator)(properties.monitoringConfiguration));
  errors.collect(cdk.propertyValidator("parallelismConfiguration", CfnApplicationV2ParallelismConfigurationPropertyValidator)(properties.parallelismConfiguration));
  return errors.wrap("supplied properties not correct for \\"FlinkApplicationConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2FlinkApplicationConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2FlinkApplicationConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "CheckpointConfiguration": convertCfnApplicationV2CheckpointConfigurationPropertyToCloudFormation(properties.checkpointConfiguration),
    "MonitoringConfiguration": convertCfnApplicationV2MonitoringConfigurationPropertyToCloudFormation(properties.monitoringConfiguration),
    "ParallelismConfiguration": convertCfnApplicationV2ParallelismConfigurationPropertyToCloudFormation(properties.parallelismConfiguration)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2FlinkApplicationConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApplicationV2.FlinkApplicationConfigurationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.FlinkApplicationConfigurationProperty>();
  ret.addPropertyResult("checkpointConfiguration", "CheckpointConfiguration", (properties.CheckpointConfiguration != null ? CfnApplicationV2CheckpointConfigurationPropertyFromCloudFormation(properties.CheckpointConfiguration) : undefined));
  ret.addPropertyResult("monitoringConfiguration", "MonitoringConfiguration", (properties.MonitoringConfiguration != null ? CfnApplicationV2MonitoringConfigurationPropertyFromCloudFormation(properties.MonitoringConfiguration) : undefined));
  ret.addPropertyResult("parallelismConfiguration", "ParallelismConfiguration", (properties.ParallelismConfiguration != null ? CfnApplicationV2ParallelismConfigurationPropertyFromCloudFormation(properties.ParallelismConfiguration) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`RecordColumnProperty\`
 *
 * @param properties - the TypeScript properties of a \`RecordColumnProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2RecordColumnPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("mapping", cdk.validateString)(properties.mapping));
  errors.collect(cdk.propertyValidator("name", cdk.requiredValidator)(properties.name));
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  errors.collect(cdk.propertyValidator("sqlType", cdk.requiredValidator)(properties.sqlType));
  errors.collect(cdk.propertyValidator("sqlType", cdk.validateString)(properties.sqlType));
  return errors.wrap("supplied properties not correct for \\"RecordColumnProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2RecordColumnPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2RecordColumnPropertyValidator(properties).assertSuccess();
  return {
    "Mapping": cdk.stringToCloudFormation(properties.mapping),
    "Name": cdk.stringToCloudFormation(properties.name),
    "SqlType": cdk.stringToCloudFormation(properties.sqlType)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2RecordColumnPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApplicationV2.RecordColumnProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.RecordColumnProperty>();
  ret.addPropertyResult("mapping", "Mapping", (properties.Mapping != null ? cfn_parse.FromCloudFormation.getString(properties.Mapping) : undefined));
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addPropertyResult("sqlType", "SqlType", (properties.SqlType != null ? cfn_parse.FromCloudFormation.getString(properties.SqlType) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CSVMappingParametersProperty\`
 *
 * @param properties - the TypeScript properties of a \`CSVMappingParametersProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2CSVMappingParametersPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("recordColumnDelimiter", cdk.requiredValidator)(properties.recordColumnDelimiter));
  errors.collect(cdk.propertyValidator("recordColumnDelimiter", cdk.validateString)(properties.recordColumnDelimiter));
  errors.collect(cdk.propertyValidator("recordRowDelimiter", cdk.requiredValidator)(properties.recordRowDelimiter));
  errors.collect(cdk.propertyValidator("recordRowDelimiter", cdk.validateString)(properties.recordRowDelimiter));
  return errors.wrap("supplied properties not correct for \\"CSVMappingParametersProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2CSVMappingParametersPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2CSVMappingParametersPropertyValidator(properties).assertSuccess();
  return {
    "RecordColumnDelimiter": cdk.stringToCloudFormation(properties.recordColumnDelimiter),
    "RecordRowDelimiter": cdk.stringToCloudFormation(properties.recordRowDelimiter)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2CSVMappingParametersPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApplicationV2.CSVMappingParametersProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.CSVMappingParametersProperty>();
  ret.addPropertyResult("recordColumnDelimiter", "RecordColumnDelimiter", (properties.RecordColumnDelimiter != null ? cfn_parse.FromCloudFormation.getString(properties.RecordColumnDelimiter) : undefined));
  ret.addPropertyResult("recordRowDelimiter", "RecordRowDelimiter", (properties.RecordRowDelimiter != null ? cfn_parse.FromCloudFormation.getString(properties.RecordRowDelimiter) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`JSONMappingParametersProperty\`
 *
 * @param properties - the TypeScript properties of a \`JSONMappingParametersProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2JSONMappingParametersPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("recordRowPath", cdk.requiredValidator)(properties.recordRowPath));
  errors.collect(cdk.propertyValidator("recordRowPath", cdk.validateString)(properties.recordRowPath));
  return errors.wrap("supplied properties not correct for \\"JSONMappingParametersProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2JSONMappingParametersPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2JSONMappingParametersPropertyValidator(properties).assertSuccess();
  return {
    "RecordRowPath": cdk.stringToCloudFormation(properties.recordRowPath)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2JSONMappingParametersPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApplicationV2.JSONMappingParametersProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.JSONMappingParametersProperty>();
  ret.addPropertyResult("recordRowPath", "RecordRowPath", (properties.RecordRowPath != null ? cfn_parse.FromCloudFormation.getString(properties.RecordRowPath) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`MappingParametersProperty\`
 *
 * @param properties - the TypeScript properties of a \`MappingParametersProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2MappingParametersPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("csvMappingParameters", CfnApplicationV2CSVMappingParametersPropertyValidator)(properties.csvMappingParameters));
  errors.collect(cdk.propertyValidator("jsonMappingParameters", CfnApplicationV2JSONMappingParametersPropertyValidator)(properties.jsonMappingParameters));
  return errors.wrap("supplied properties not correct for \\"MappingParametersProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2MappingParametersPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2MappingParametersPropertyValidator(properties).assertSuccess();
  return {
    "CSVMappingParameters": convertCfnApplicationV2CSVMappingParametersPropertyToCloudFormation(properties.csvMappingParameters),
    "JSONMappingParameters": convertCfnApplicationV2JSONMappingParametersPropertyToCloudFormation(properties.jsonMappingParameters)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2MappingParametersPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApplicationV2.MappingParametersProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.MappingParametersProperty>();
  ret.addPropertyResult("csvMappingParameters", "CSVMappingParameters", (properties.CSVMappingParameters != null ? CfnApplicationV2CSVMappingParametersPropertyFromCloudFormation(properties.CSVMappingParameters) : undefined));
  ret.addPropertyResult("jsonMappingParameters", "JSONMappingParameters", (properties.JSONMappingParameters != null ? CfnApplicationV2JSONMappingParametersPropertyFromCloudFormation(properties.JSONMappingParameters) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`RecordFormatProperty\`
 *
 * @param properties - the TypeScript properties of a \`RecordFormatProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2RecordFormatPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("mappingParameters", CfnApplicationV2MappingParametersPropertyValidator)(properties.mappingParameters));
  errors.collect(cdk.propertyValidator("recordFormatType", cdk.requiredValidator)(properties.recordFormatType));
  errors.collect(cdk.propertyValidator("recordFormatType", cdk.validateString)(properties.recordFormatType));
  return errors.wrap("supplied properties not correct for \\"RecordFormatProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2RecordFormatPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2RecordFormatPropertyValidator(properties).assertSuccess();
  return {
    "MappingParameters": convertCfnApplicationV2MappingParametersPropertyToCloudFormation(properties.mappingParameters),
    "RecordFormatType": cdk.stringToCloudFormation(properties.recordFormatType)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2RecordFormatPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApplicationV2.RecordFormatProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.RecordFormatProperty>();
  ret.addPropertyResult("mappingParameters", "MappingParameters", (properties.MappingParameters != null ? CfnApplicationV2MappingParametersPropertyFromCloudFormation(properties.MappingParameters) : undefined));
  ret.addPropertyResult("recordFormatType", "RecordFormatType", (properties.RecordFormatType != null ? cfn_parse.FromCloudFormation.getString(properties.RecordFormatType) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`InputSchemaProperty\`
 *
 * @param properties - the TypeScript properties of a \`InputSchemaProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2InputSchemaPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("recordColumns", cdk.requiredValidator)(properties.recordColumns));
  errors.collect(cdk.propertyValidator("recordColumns", cdk.listValidator(CfnApplicationV2RecordColumnPropertyValidator))(properties.recordColumns));
  errors.collect(cdk.propertyValidator("recordEncoding", cdk.validateString)(properties.recordEncoding));
  errors.collect(cdk.propertyValidator("recordFormat", cdk.requiredValidator)(properties.recordFormat));
  errors.collect(cdk.propertyValidator("recordFormat", CfnApplicationV2RecordFormatPropertyValidator)(properties.recordFormat));
  return errors.wrap("supplied properties not correct for \\"InputSchemaProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2InputSchemaPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2InputSchemaPropertyValidator(properties).assertSuccess();
  return {
    "RecordColumns": cdk.listMapper(convertCfnApplicationV2RecordColumnPropertyToCloudFormation)(properties.recordColumns),
    "RecordEncoding": cdk.stringToCloudFormation(properties.recordEncoding),
    "RecordFormat": convertCfnApplicationV2RecordFormatPropertyToCloudFormation(properties.recordFormat)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2InputSchemaPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApplicationV2.InputSchemaProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.InputSchemaProperty>();
  ret.addPropertyResult("recordColumns", "RecordColumns", (properties.RecordColumns != null ? cfn_parse.FromCloudFormation.getArray(CfnApplicationV2RecordColumnPropertyFromCloudFormation)(properties.RecordColumns) : undefined));
  ret.addPropertyResult("recordEncoding", "RecordEncoding", (properties.RecordEncoding != null ? cfn_parse.FromCloudFormation.getString(properties.RecordEncoding) : undefined));
  ret.addPropertyResult("recordFormat", "RecordFormat", (properties.RecordFormat != null ? CfnApplicationV2RecordFormatPropertyFromCloudFormation(properties.RecordFormat) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`KinesisStreamsInputProperty\`
 *
 * @param properties - the TypeScript properties of a \`KinesisStreamsInputProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2KinesisStreamsInputPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("resourceArn", cdk.requiredValidator)(properties.resourceArn));
  errors.collect(cdk.propertyValidator("resourceArn", cdk.validateString)(properties.resourceArn));
  return errors.wrap("supplied properties not correct for \\"KinesisStreamsInputProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2KinesisStreamsInputPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2KinesisStreamsInputPropertyValidator(properties).assertSuccess();
  return {
    "ResourceARN": cdk.stringToCloudFormation(properties.resourceArn)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2KinesisStreamsInputPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApplicationV2.KinesisStreamsInputProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.KinesisStreamsInputProperty>();
  ret.addPropertyResult("resourceArn", "ResourceARN", (properties.ResourceARN != null ? cfn_parse.FromCloudFormation.getString(properties.ResourceARN) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`KinesisFirehoseInputProperty\`
 *
 * @param properties - the TypeScript properties of a \`KinesisFirehoseInputProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2KinesisFirehoseInputPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("resourceArn", cdk.requiredValidator)(properties.resourceArn));
  errors.collect(cdk.propertyValidator("resourceArn", cdk.validateString)(properties.resourceArn));
  return errors.wrap("supplied properties not correct for \\"KinesisFirehoseInputProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2KinesisFirehoseInputPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2KinesisFirehoseInputPropertyValidator(properties).assertSuccess();
  return {
    "ResourceARN": cdk.stringToCloudFormation(properties.resourceArn)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2KinesisFirehoseInputPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApplicationV2.KinesisFirehoseInputProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.KinesisFirehoseInputProperty>();
  ret.addPropertyResult("resourceArn", "ResourceARN", (properties.ResourceARN != null ? cfn_parse.FromCloudFormation.getString(properties.ResourceARN) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`InputLambdaProcessorProperty\`
 *
 * @param properties - the TypeScript properties of a \`InputLambdaProcessorProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2InputLambdaProcessorPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("resourceArn", cdk.requiredValidator)(properties.resourceArn));
  errors.collect(cdk.propertyValidator("resourceArn", cdk.validateString)(properties.resourceArn));
  return errors.wrap("supplied properties not correct for \\"InputLambdaProcessorProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2InputLambdaProcessorPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2InputLambdaProcessorPropertyValidator(properties).assertSuccess();
  return {
    "ResourceARN": cdk.stringToCloudFormation(properties.resourceArn)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2InputLambdaProcessorPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApplicationV2.InputLambdaProcessorProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.InputLambdaProcessorProperty>();
  ret.addPropertyResult("resourceArn", "ResourceARN", (properties.ResourceARN != null ? cfn_parse.FromCloudFormation.getString(properties.ResourceARN) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`InputProcessingConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`InputProcessingConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2InputProcessingConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("inputLambdaProcessor", CfnApplicationV2InputLambdaProcessorPropertyValidator)(properties.inputLambdaProcessor));
  return errors.wrap("supplied properties not correct for \\"InputProcessingConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2InputProcessingConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2InputProcessingConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "InputLambdaProcessor": convertCfnApplicationV2InputLambdaProcessorPropertyToCloudFormation(properties.inputLambdaProcessor)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2InputProcessingConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApplicationV2.InputProcessingConfigurationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.InputProcessingConfigurationProperty>();
  ret.addPropertyResult("inputLambdaProcessor", "InputLambdaProcessor", (properties.InputLambdaProcessor != null ? CfnApplicationV2InputLambdaProcessorPropertyFromCloudFormation(properties.InputLambdaProcessor) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`InputParallelismProperty\`
 *
 * @param properties - the TypeScript properties of a \`InputParallelismProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2InputParallelismPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("count", cdk.validateNumber)(properties.count));
  return errors.wrap("supplied properties not correct for \\"InputParallelismProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2InputParallelismPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2InputParallelismPropertyValidator(properties).assertSuccess();
  return {
    "Count": cdk.numberToCloudFormation(properties.count)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2InputParallelismPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApplicationV2.InputParallelismProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.InputParallelismProperty>();
  ret.addPropertyResult("count", "Count", (properties.Count != null ? cfn_parse.FromCloudFormation.getNumber(properties.Count) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`InputProperty\`
 *
 * @param properties - the TypeScript properties of a \`InputProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2InputPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("inputParallelism", CfnApplicationV2InputParallelismPropertyValidator)(properties.inputParallelism));
  errors.collect(cdk.propertyValidator("inputProcessingConfiguration", CfnApplicationV2InputProcessingConfigurationPropertyValidator)(properties.inputProcessingConfiguration));
  errors.collect(cdk.propertyValidator("inputSchema", cdk.requiredValidator)(properties.inputSchema));
  errors.collect(cdk.propertyValidator("inputSchema", CfnApplicationV2InputSchemaPropertyValidator)(properties.inputSchema));
  errors.collect(cdk.propertyValidator("kinesisFirehoseInput", CfnApplicationV2KinesisFirehoseInputPropertyValidator)(properties.kinesisFirehoseInput));
  errors.collect(cdk.propertyValidator("kinesisStreamsInput", CfnApplicationV2KinesisStreamsInputPropertyValidator)(properties.kinesisStreamsInput));
  errors.collect(cdk.propertyValidator("namePrefix", cdk.requiredValidator)(properties.namePrefix));
  errors.collect(cdk.propertyValidator("namePrefix", cdk.validateString)(properties.namePrefix));
  return errors.wrap("supplied properties not correct for \\"InputProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2InputPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2InputPropertyValidator(properties).assertSuccess();
  return {
    "InputParallelism": convertCfnApplicationV2InputParallelismPropertyToCloudFormation(properties.inputParallelism),
    "InputProcessingConfiguration": convertCfnApplicationV2InputProcessingConfigurationPropertyToCloudFormation(properties.inputProcessingConfiguration),
    "InputSchema": convertCfnApplicationV2InputSchemaPropertyToCloudFormation(properties.inputSchema),
    "KinesisFirehoseInput": convertCfnApplicationV2KinesisFirehoseInputPropertyToCloudFormation(properties.kinesisFirehoseInput),
    "KinesisStreamsInput": convertCfnApplicationV2KinesisStreamsInputPropertyToCloudFormation(properties.kinesisStreamsInput),
    "NamePrefix": cdk.stringToCloudFormation(properties.namePrefix)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2InputPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApplicationV2.InputProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.InputProperty>();
  ret.addPropertyResult("inputParallelism", "InputParallelism", (properties.InputParallelism != null ? CfnApplicationV2InputParallelismPropertyFromCloudFormation(properties.InputParallelism) : undefined));
  ret.addPropertyResult("inputProcessingConfiguration", "InputProcessingConfiguration", (properties.InputProcessingConfiguration != null ? CfnApplicationV2InputProcessingConfigurationPropertyFromCloudFormation(properties.InputProcessingConfiguration) : undefined));
  ret.addPropertyResult("inputSchema", "InputSchema", (properties.InputSchema != null ? CfnApplicationV2InputSchemaPropertyFromCloudFormation(properties.InputSchema) : undefined));
  ret.addPropertyResult("kinesisFirehoseInput", "KinesisFirehoseInput", (properties.KinesisFirehoseInput != null ? CfnApplicationV2KinesisFirehoseInputPropertyFromCloudFormation(properties.KinesisFirehoseInput) : undefined));
  ret.addPropertyResult("kinesisStreamsInput", "KinesisStreamsInput", (properties.KinesisStreamsInput != null ? CfnApplicationV2KinesisStreamsInputPropertyFromCloudFormation(properties.KinesisStreamsInput) : undefined));
  ret.addPropertyResult("namePrefix", "NamePrefix", (properties.NamePrefix != null ? cfn_parse.FromCloudFormation.getString(properties.NamePrefix) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`SqlApplicationConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`SqlApplicationConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2SqlApplicationConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("inputs", cdk.listValidator(CfnApplicationV2InputPropertyValidator))(properties.inputs));
  return errors.wrap("supplied properties not correct for \\"SqlApplicationConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2SqlApplicationConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2SqlApplicationConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "Inputs": cdk.listMapper(convertCfnApplicationV2InputPropertyToCloudFormation)(properties.inputs)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2SqlApplicationConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApplicationV2.SqlApplicationConfigurationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.SqlApplicationConfigurationProperty>();
  ret.addPropertyResult("inputs", "Inputs", (properties.Inputs != null ? cfn_parse.FromCloudFormation.getArray(CfnApplicationV2InputPropertyFromCloudFormation)(properties.Inputs) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`GlueDataCatalogConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`GlueDataCatalogConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2GlueDataCatalogConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("databaseArn", cdk.validateString)(properties.databaseArn));
  return errors.wrap("supplied properties not correct for \\"GlueDataCatalogConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2GlueDataCatalogConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2GlueDataCatalogConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "DatabaseARN": cdk.stringToCloudFormation(properties.databaseArn)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2GlueDataCatalogConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApplicationV2.GlueDataCatalogConfigurationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.GlueDataCatalogConfigurationProperty>();
  ret.addPropertyResult("databaseArn", "DatabaseARN", (properties.DatabaseARN != null ? cfn_parse.FromCloudFormation.getString(properties.DatabaseARN) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CatalogConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`CatalogConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2CatalogConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("glueDataCatalogConfiguration", CfnApplicationV2GlueDataCatalogConfigurationPropertyValidator)(properties.glueDataCatalogConfiguration));
  return errors.wrap("supplied properties not correct for \\"CatalogConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2CatalogConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2CatalogConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "GlueDataCatalogConfiguration": convertCfnApplicationV2GlueDataCatalogConfigurationPropertyToCloudFormation(properties.glueDataCatalogConfiguration)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2CatalogConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApplicationV2.CatalogConfigurationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.CatalogConfigurationProperty>();
  ret.addPropertyResult("glueDataCatalogConfiguration", "GlueDataCatalogConfiguration", (properties.GlueDataCatalogConfiguration != null ? CfnApplicationV2GlueDataCatalogConfigurationPropertyFromCloudFormation(properties.GlueDataCatalogConfiguration) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ZeppelinMonitoringConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`ZeppelinMonitoringConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2ZeppelinMonitoringConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("logLevel", cdk.validateString)(properties.logLevel));
  return errors.wrap("supplied properties not correct for \\"ZeppelinMonitoringConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2ZeppelinMonitoringConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2ZeppelinMonitoringConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "LogLevel": cdk.stringToCloudFormation(properties.logLevel)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2ZeppelinMonitoringConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApplicationV2.ZeppelinMonitoringConfigurationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.ZeppelinMonitoringConfigurationProperty>();
  ret.addPropertyResult("logLevel", "LogLevel", (properties.LogLevel != null ? cfn_parse.FromCloudFormation.getString(properties.LogLevel) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`S3ContentBaseLocationProperty\`
 *
 * @param properties - the TypeScript properties of a \`S3ContentBaseLocationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2S3ContentBaseLocationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("basePath", cdk.validateString)(properties.basePath));
  errors.collect(cdk.propertyValidator("bucketArn", cdk.requiredValidator)(properties.bucketArn));
  errors.collect(cdk.propertyValidator("bucketArn", cdk.validateString)(properties.bucketArn));
  return errors.wrap("supplied properties not correct for \\"S3ContentBaseLocationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2S3ContentBaseLocationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2S3ContentBaseLocationPropertyValidator(properties).assertSuccess();
  return {
    "BasePath": cdk.stringToCloudFormation(properties.basePath),
    "BucketARN": cdk.stringToCloudFormation(properties.bucketArn)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2S3ContentBaseLocationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApplicationV2.S3ContentBaseLocationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.S3ContentBaseLocationProperty>();
  ret.addPropertyResult("basePath", "BasePath", (properties.BasePath != null ? cfn_parse.FromCloudFormation.getString(properties.BasePath) : undefined));
  ret.addPropertyResult("bucketArn", "BucketARN", (properties.BucketARN != null ? cfn_parse.FromCloudFormation.getString(properties.BucketARN) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`DeployAsApplicationConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`DeployAsApplicationConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2DeployAsApplicationConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("s3ContentLocation", cdk.requiredValidator)(properties.s3ContentLocation));
  errors.collect(cdk.propertyValidator("s3ContentLocation", CfnApplicationV2S3ContentBaseLocationPropertyValidator)(properties.s3ContentLocation));
  return errors.wrap("supplied properties not correct for \\"DeployAsApplicationConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2DeployAsApplicationConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2DeployAsApplicationConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "S3ContentLocation": convertCfnApplicationV2S3ContentBaseLocationPropertyToCloudFormation(properties.s3ContentLocation)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2DeployAsApplicationConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApplicationV2.DeployAsApplicationConfigurationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.DeployAsApplicationConfigurationProperty>();
  ret.addPropertyResult("s3ContentLocation", "S3ContentLocation", (properties.S3ContentLocation != null ? CfnApplicationV2S3ContentBaseLocationPropertyFromCloudFormation(properties.S3ContentLocation) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`MavenReferenceProperty\`
 *
 * @param properties - the TypeScript properties of a \`MavenReferenceProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2MavenReferencePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("artifactId", cdk.requiredValidator)(properties.artifactId));
  errors.collect(cdk.propertyValidator("artifactId", cdk.validateString)(properties.artifactId));
  errors.collect(cdk.propertyValidator("groupId", cdk.requiredValidator)(properties.groupId));
  errors.collect(cdk.propertyValidator("groupId", cdk.validateString)(properties.groupId));
  errors.collect(cdk.propertyValidator("version", cdk.requiredValidator)(properties.version));
  errors.collect(cdk.propertyValidator("version", cdk.validateString)(properties.version));
  return errors.wrap("supplied properties not correct for \\"MavenReferenceProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2MavenReferencePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2MavenReferencePropertyValidator(properties).assertSuccess();
  return {
    "ArtifactId": cdk.stringToCloudFormation(properties.artifactId),
    "GroupId": cdk.stringToCloudFormation(properties.groupId),
    "Version": cdk.stringToCloudFormation(properties.version)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2MavenReferencePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApplicationV2.MavenReferenceProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.MavenReferenceProperty>();
  ret.addPropertyResult("artifactId", "ArtifactId", (properties.ArtifactId != null ? cfn_parse.FromCloudFormation.getString(properties.ArtifactId) : undefined));
  ret.addPropertyResult("groupId", "GroupId", (properties.GroupId != null ? cfn_parse.FromCloudFormation.getString(properties.GroupId) : undefined));
  ret.addPropertyResult("version", "Version", (properties.Version != null ? cfn_parse.FromCloudFormation.getString(properties.Version) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CustomArtifactConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`CustomArtifactConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2CustomArtifactConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("artifactType", cdk.requiredValidator)(properties.artifactType));
  errors.collect(cdk.propertyValidator("artifactType", cdk.validateString)(properties.artifactType));
  errors.collect(cdk.propertyValidator("mavenReference", CfnApplicationV2MavenReferencePropertyValidator)(properties.mavenReference));
  errors.collect(cdk.propertyValidator("s3ContentLocation", CfnApplicationV2S3ContentLocationPropertyValidator)(properties.s3ContentLocation));
  return errors.wrap("supplied properties not correct for \\"CustomArtifactConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2CustomArtifactConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2CustomArtifactConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "ArtifactType": cdk.stringToCloudFormation(properties.artifactType),
    "MavenReference": convertCfnApplicationV2MavenReferencePropertyToCloudFormation(properties.mavenReference),
    "S3ContentLocation": convertCfnApplicationV2S3ContentLocationPropertyToCloudFormation(properties.s3ContentLocation)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2CustomArtifactConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApplicationV2.CustomArtifactConfigurationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.CustomArtifactConfigurationProperty>();
  ret.addPropertyResult("artifactType", "ArtifactType", (properties.ArtifactType != null ? cfn_parse.FromCloudFormation.getString(properties.ArtifactType) : undefined));
  ret.addPropertyResult("mavenReference", "MavenReference", (properties.MavenReference != null ? CfnApplicationV2MavenReferencePropertyFromCloudFormation(properties.MavenReference) : undefined));
  ret.addPropertyResult("s3ContentLocation", "S3ContentLocation", (properties.S3ContentLocation != null ? CfnApplicationV2S3ContentLocationPropertyFromCloudFormation(properties.S3ContentLocation) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ZeppelinApplicationConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`ZeppelinApplicationConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2ZeppelinApplicationConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("catalogConfiguration", CfnApplicationV2CatalogConfigurationPropertyValidator)(properties.catalogConfiguration));
  errors.collect(cdk.propertyValidator("customArtifactsConfiguration", cdk.listValidator(CfnApplicationV2CustomArtifactConfigurationPropertyValidator))(properties.customArtifactsConfiguration));
  errors.collect(cdk.propertyValidator("deployAsApplicationConfiguration", CfnApplicationV2DeployAsApplicationConfigurationPropertyValidator)(properties.deployAsApplicationConfiguration));
  errors.collect(cdk.propertyValidator("monitoringConfiguration", CfnApplicationV2ZeppelinMonitoringConfigurationPropertyValidator)(properties.monitoringConfiguration));
  return errors.wrap("supplied properties not correct for \\"ZeppelinApplicationConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2ZeppelinApplicationConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2ZeppelinApplicationConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "CatalogConfiguration": convertCfnApplicationV2CatalogConfigurationPropertyToCloudFormation(properties.catalogConfiguration),
    "CustomArtifactsConfiguration": cdk.listMapper(convertCfnApplicationV2CustomArtifactConfigurationPropertyToCloudFormation)(properties.customArtifactsConfiguration),
    "DeployAsApplicationConfiguration": convertCfnApplicationV2DeployAsApplicationConfigurationPropertyToCloudFormation(properties.deployAsApplicationConfiguration),
    "MonitoringConfiguration": convertCfnApplicationV2ZeppelinMonitoringConfigurationPropertyToCloudFormation(properties.monitoringConfiguration)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2ZeppelinApplicationConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApplicationV2.ZeppelinApplicationConfigurationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.ZeppelinApplicationConfigurationProperty>();
  ret.addPropertyResult("catalogConfiguration", "CatalogConfiguration", (properties.CatalogConfiguration != null ? CfnApplicationV2CatalogConfigurationPropertyFromCloudFormation(properties.CatalogConfiguration) : undefined));
  ret.addPropertyResult("customArtifactsConfiguration", "CustomArtifactsConfiguration", (properties.CustomArtifactsConfiguration != null ? cfn_parse.FromCloudFormation.getArray(CfnApplicationV2CustomArtifactConfigurationPropertyFromCloudFormation)(properties.CustomArtifactsConfiguration) : undefined));
  ret.addPropertyResult("deployAsApplicationConfiguration", "DeployAsApplicationConfiguration", (properties.DeployAsApplicationConfiguration != null ? CfnApplicationV2DeployAsApplicationConfigurationPropertyFromCloudFormation(properties.DeployAsApplicationConfiguration) : undefined));
  ret.addPropertyResult("monitoringConfiguration", "MonitoringConfiguration", (properties.MonitoringConfiguration != null ? CfnApplicationV2ZeppelinMonitoringConfigurationPropertyFromCloudFormation(properties.MonitoringConfiguration) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`VpcConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`VpcConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2VpcConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("securityGroupIds", cdk.requiredValidator)(properties.securityGroupIds));
  errors.collect(cdk.propertyValidator("securityGroupIds", cdk.listValidator(cdk.validateString))(properties.securityGroupIds));
  errors.collect(cdk.propertyValidator("subnetIds", cdk.requiredValidator)(properties.subnetIds));
  errors.collect(cdk.propertyValidator("subnetIds", cdk.listValidator(cdk.validateString))(properties.subnetIds));
  return errors.wrap("supplied properties not correct for \\"VpcConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2VpcConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2VpcConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "SecurityGroupIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.securityGroupIds),
    "SubnetIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.subnetIds)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2VpcConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApplicationV2.VpcConfigurationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.VpcConfigurationProperty>();
  ret.addPropertyResult("securityGroupIds", "SecurityGroupIds", (properties.SecurityGroupIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecurityGroupIds) : undefined));
  ret.addPropertyResult("subnetIds", "SubnetIds", (properties.SubnetIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SubnetIds) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ApplicationConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`ApplicationConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2ApplicationConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("applicationCodeConfiguration", CfnApplicationV2ApplicationCodeConfigurationPropertyValidator)(properties.applicationCodeConfiguration));
  errors.collect(cdk.propertyValidator("applicationSnapshotConfiguration", CfnApplicationV2ApplicationSnapshotConfigurationPropertyValidator)(properties.applicationSnapshotConfiguration));
  errors.collect(cdk.propertyValidator("environmentProperties", CfnApplicationV2EnvironmentPropertiesPropertyValidator)(properties.environmentProperties));
  errors.collect(cdk.propertyValidator("flinkApplicationConfiguration", CfnApplicationV2FlinkApplicationConfigurationPropertyValidator)(properties.flinkApplicationConfiguration));
  errors.collect(cdk.propertyValidator("sqlApplicationConfiguration", CfnApplicationV2SqlApplicationConfigurationPropertyValidator)(properties.sqlApplicationConfiguration));
  errors.collect(cdk.propertyValidator("vpcConfigurations", cdk.listValidator(CfnApplicationV2VpcConfigurationPropertyValidator))(properties.vpcConfigurations));
  errors.collect(cdk.propertyValidator("zeppelinApplicationConfiguration", CfnApplicationV2ZeppelinApplicationConfigurationPropertyValidator)(properties.zeppelinApplicationConfiguration));
  return errors.wrap("supplied properties not correct for \\"ApplicationConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2ApplicationConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2ApplicationConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "ApplicationCodeConfiguration": convertCfnApplicationV2ApplicationCodeConfigurationPropertyToCloudFormation(properties.applicationCodeConfiguration),
    "ApplicationSnapshotConfiguration": convertCfnApplicationV2ApplicationSnapshotConfigurationPropertyToCloudFormation(properties.applicationSnapshotConfiguration),
    "EnvironmentProperties": convertCfnApplicationV2EnvironmentPropertiesPropertyToCloudFormation(properties.environmentProperties),
    "FlinkApplicationConfiguration": convertCfnApplicationV2FlinkApplicationConfigurationPropertyToCloudFormation(properties.flinkApplicationConfiguration),
    "SqlApplicationConfiguration": convertCfnApplicationV2SqlApplicationConfigurationPropertyToCloudFormation(properties.sqlApplicationConfiguration),
    "VpcConfigurations": cdk.listMapper(convertCfnApplicationV2VpcConfigurationPropertyToCloudFormation)(properties.vpcConfigurations),
    "ZeppelinApplicationConfiguration": convertCfnApplicationV2ZeppelinApplicationConfigurationPropertyToCloudFormation(properties.zeppelinApplicationConfiguration)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2ApplicationConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApplicationV2.ApplicationConfigurationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.ApplicationConfigurationProperty>();
  ret.addPropertyResult("applicationCodeConfiguration", "ApplicationCodeConfiguration", (properties.ApplicationCodeConfiguration != null ? CfnApplicationV2ApplicationCodeConfigurationPropertyFromCloudFormation(properties.ApplicationCodeConfiguration) : undefined));
  ret.addPropertyResult("applicationSnapshotConfiguration", "ApplicationSnapshotConfiguration", (properties.ApplicationSnapshotConfiguration != null ? CfnApplicationV2ApplicationSnapshotConfigurationPropertyFromCloudFormation(properties.ApplicationSnapshotConfiguration) : undefined));
  ret.addPropertyResult("environmentProperties", "EnvironmentProperties", (properties.EnvironmentProperties != null ? CfnApplicationV2EnvironmentPropertiesPropertyFromCloudFormation(properties.EnvironmentProperties) : undefined));
  ret.addPropertyResult("flinkApplicationConfiguration", "FlinkApplicationConfiguration", (properties.FlinkApplicationConfiguration != null ? CfnApplicationV2FlinkApplicationConfigurationPropertyFromCloudFormation(properties.FlinkApplicationConfiguration) : undefined));
  ret.addPropertyResult("sqlApplicationConfiguration", "SqlApplicationConfiguration", (properties.SqlApplicationConfiguration != null ? CfnApplicationV2SqlApplicationConfigurationPropertyFromCloudFormation(properties.SqlApplicationConfiguration) : undefined));
  ret.addPropertyResult("vpcConfigurations", "VpcConfigurations", (properties.VpcConfigurations != null ? cfn_parse.FromCloudFormation.getArray(CfnApplicationV2VpcConfigurationPropertyFromCloudFormation)(properties.VpcConfigurations) : undefined));
  ret.addPropertyResult("zeppelinApplicationConfiguration", "ZeppelinApplicationConfiguration", (properties.ZeppelinApplicationConfiguration != null ? CfnApplicationV2ZeppelinApplicationConfigurationPropertyFromCloudFormation(properties.ZeppelinApplicationConfiguration) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ApplicationRestoreConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`ApplicationRestoreConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2ApplicationRestoreConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("applicationRestoreType", cdk.requiredValidator)(properties.applicationRestoreType));
  errors.collect(cdk.propertyValidator("applicationRestoreType", cdk.validateString)(properties.applicationRestoreType));
  errors.collect(cdk.propertyValidator("snapshotName", cdk.validateString)(properties.snapshotName));
  return errors.wrap("supplied properties not correct for \\"ApplicationRestoreConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2ApplicationRestoreConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2ApplicationRestoreConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "ApplicationRestoreType": cdk.stringToCloudFormation(properties.applicationRestoreType),
    "SnapshotName": cdk.stringToCloudFormation(properties.snapshotName)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2ApplicationRestoreConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApplicationV2.ApplicationRestoreConfigurationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.ApplicationRestoreConfigurationProperty>();
  ret.addPropertyResult("applicationRestoreType", "ApplicationRestoreType", (properties.ApplicationRestoreType != null ? cfn_parse.FromCloudFormation.getString(properties.ApplicationRestoreType) : undefined));
  ret.addPropertyResult("snapshotName", "SnapshotName", (properties.SnapshotName != null ? cfn_parse.FromCloudFormation.getString(properties.SnapshotName) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`FlinkRunConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`FlinkRunConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2FlinkRunConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("allowNonRestoredState", cdk.validateBoolean)(properties.allowNonRestoredState));
  return errors.wrap("supplied properties not correct for \\"FlinkRunConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2FlinkRunConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2FlinkRunConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "AllowNonRestoredState": cdk.booleanToCloudFormation(properties.allowNonRestoredState)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2FlinkRunConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApplicationV2.FlinkRunConfigurationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.FlinkRunConfigurationProperty>();
  ret.addPropertyResult("allowNonRestoredState", "AllowNonRestoredState", (properties.AllowNonRestoredState != null ? cfn_parse.FromCloudFormation.getBoolean(properties.AllowNonRestoredState) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`RunConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`RunConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2RunConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("applicationRestoreConfiguration", CfnApplicationV2ApplicationRestoreConfigurationPropertyValidator)(properties.applicationRestoreConfiguration));
  errors.collect(cdk.propertyValidator("flinkRunConfiguration", CfnApplicationV2FlinkRunConfigurationPropertyValidator)(properties.flinkRunConfiguration));
  return errors.wrap("supplied properties not correct for \\"RunConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2RunConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2RunConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "ApplicationRestoreConfiguration": convertCfnApplicationV2ApplicationRestoreConfigurationPropertyToCloudFormation(properties.applicationRestoreConfiguration),
    "FlinkRunConfiguration": convertCfnApplicationV2FlinkRunConfigurationPropertyToCloudFormation(properties.flinkRunConfiguration)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2RunConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApplicationV2.RunConfigurationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.RunConfigurationProperty>();
  ret.addPropertyResult("applicationRestoreConfiguration", "ApplicationRestoreConfiguration", (properties.ApplicationRestoreConfiguration != null ? CfnApplicationV2ApplicationRestoreConfigurationPropertyFromCloudFormation(properties.ApplicationRestoreConfiguration) : undefined));
  ret.addPropertyResult("flinkRunConfiguration", "FlinkRunConfiguration", (properties.FlinkRunConfiguration != null ? CfnApplicationV2FlinkRunConfigurationPropertyFromCloudFormation(properties.FlinkRunConfiguration) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ApplicationMaintenanceConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`ApplicationMaintenanceConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2ApplicationMaintenanceConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("applicationMaintenanceWindowStartTime", cdk.requiredValidator)(properties.applicationMaintenanceWindowStartTime));
  errors.collect(cdk.propertyValidator("applicationMaintenanceWindowStartTime", cdk.validateString)(properties.applicationMaintenanceWindowStartTime));
  return errors.wrap("supplied properties not correct for \\"ApplicationMaintenanceConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2ApplicationMaintenanceConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2ApplicationMaintenanceConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "ApplicationMaintenanceWindowStartTime": cdk.stringToCloudFormation(properties.applicationMaintenanceWindowStartTime)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2ApplicationMaintenanceConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApplicationV2.ApplicationMaintenanceConfigurationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.ApplicationMaintenanceConfigurationProperty>();
  ret.addPropertyResult("applicationMaintenanceWindowStartTime", "ApplicationMaintenanceWindowStartTime", (properties.ApplicationMaintenanceWindowStartTime != null ? cfn_parse.FromCloudFormation.getString(properties.ApplicationMaintenanceWindowStartTime) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnApplicationV2Props\`
 *
 * @param properties - the TypeScript properties of a \`CfnApplicationV2Props\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2PropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("applicationConfiguration", CfnApplicationV2ApplicationConfigurationPropertyValidator)(properties.applicationConfiguration));
  errors.collect(cdk.propertyValidator("applicationDescription", cdk.validateString)(properties.applicationDescription));
  errors.collect(cdk.propertyValidator("applicationMaintenanceConfiguration", CfnApplicationV2ApplicationMaintenanceConfigurationPropertyValidator)(properties.applicationMaintenanceConfiguration));
  errors.collect(cdk.propertyValidator("applicationMode", cdk.validateString)(properties.applicationMode));
  errors.collect(cdk.propertyValidator("applicationName", cdk.validateString)(properties.applicationName));
  errors.collect(cdk.propertyValidator("runConfiguration", CfnApplicationV2RunConfigurationPropertyValidator)(properties.runConfiguration));
  errors.collect(cdk.propertyValidator("runtimeEnvironment", cdk.requiredValidator)(properties.runtimeEnvironment));
  errors.collect(cdk.propertyValidator("runtimeEnvironment", cdk.validateString)(properties.runtimeEnvironment));
  errors.collect(cdk.propertyValidator("serviceExecutionRole", cdk.requiredValidator)(properties.serviceExecutionRole));
  errors.collect(cdk.propertyValidator("serviceExecutionRole", cdk.validateString)(properties.serviceExecutionRole));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnApplicationV2Props\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2PropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2PropsValidator(properties).assertSuccess();
  return {
    "ApplicationConfiguration": convertCfnApplicationV2ApplicationConfigurationPropertyToCloudFormation(properties.applicationConfiguration),
    "ApplicationDescription": cdk.stringToCloudFormation(properties.applicationDescription),
    "ApplicationMaintenanceConfiguration": convertCfnApplicationV2ApplicationMaintenanceConfigurationPropertyToCloudFormation(properties.applicationMaintenanceConfiguration),
    "ApplicationMode": cdk.stringToCloudFormation(properties.applicationMode),
    "ApplicationName": cdk.stringToCloudFormation(properties.applicationName),
    "RunConfiguration": convertCfnApplicationV2RunConfigurationPropertyToCloudFormation(properties.runConfiguration),
    "RuntimeEnvironment": cdk.stringToCloudFormation(properties.runtimeEnvironment),
    "ServiceExecutionRole": cdk.stringToCloudFormation(properties.serviceExecutionRole),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2PropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApplicationV2Props | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2Props>();
  ret.addPropertyResult("applicationConfiguration", "ApplicationConfiguration", (properties.ApplicationConfiguration != null ? CfnApplicationV2ApplicationConfigurationPropertyFromCloudFormation(properties.ApplicationConfiguration) : undefined));
  ret.addPropertyResult("applicationDescription", "ApplicationDescription", (properties.ApplicationDescription != null ? cfn_parse.FromCloudFormation.getString(properties.ApplicationDescription) : undefined));
  ret.addPropertyResult("applicationMaintenanceConfiguration", "ApplicationMaintenanceConfiguration", (properties.ApplicationMaintenanceConfiguration != null ? CfnApplicationV2ApplicationMaintenanceConfigurationPropertyFromCloudFormation(properties.ApplicationMaintenanceConfiguration) : undefined));
  ret.addPropertyResult("applicationMode", "ApplicationMode", (properties.ApplicationMode != null ? cfn_parse.FromCloudFormation.getString(properties.ApplicationMode) : undefined));
  ret.addPropertyResult("applicationName", "ApplicationName", (properties.ApplicationName != null ? cfn_parse.FromCloudFormation.getString(properties.ApplicationName) : undefined));
  ret.addPropertyResult("runConfiguration", "RunConfiguration", (properties.RunConfiguration != null ? CfnApplicationV2RunConfigurationPropertyFromCloudFormation(properties.RunConfiguration) : undefined));
  ret.addPropertyResult("runtimeEnvironment", "RuntimeEnvironment", (properties.RuntimeEnvironment != null ? cfn_parse.FromCloudFormation.getString(properties.RuntimeEnvironment) : undefined));
  ret.addPropertyResult("serviceExecutionRole", "ServiceExecutionRole", (properties.ServiceExecutionRole != null ? cfn_parse.FromCloudFormation.getString(properties.ServiceExecutionRole) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Adds an Amazon CloudWatch log stream to monitor application configuration errors.
 *
 * > Only one *ApplicationCloudWatchLoggingOption* resource can be attached per application.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-applicationcloudwatchloggingoption.html
 */
export class CfnApplicationCloudWatchLoggingOptionV2 extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::KinesisAnalyticsV2::ApplicationCloudWatchLoggingOption";

  /**
   * Build a CfnApplicationCloudWatchLoggingOptionV2 from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnApplicationCloudWatchLoggingOptionV2 {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnApplicationCloudWatchLoggingOptionV2PropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnApplicationCloudWatchLoggingOptionV2(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The name of the application.
   */
  public applicationName: string;

  /**
   * Provides a description of Amazon CloudWatch logging options, including the log stream Amazon Resource Name (ARN).
   */
  public cloudWatchLoggingOption: CfnApplicationCloudWatchLoggingOptionV2.CloudWatchLoggingOptionProperty | cdk.IResolvable;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnApplicationCloudWatchLoggingOptionV2Props) {
    super(scope, id, {
      "type": CfnApplicationCloudWatchLoggingOptionV2.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "applicationName", this);
    cdk.requireProperty(props, "cloudWatchLoggingOption", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.applicationName = props.applicationName;
    this.cloudWatchLoggingOption = props.cloudWatchLoggingOption;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "applicationName": this.applicationName,
      "cloudWatchLoggingOption": this.cloudWatchLoggingOption
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnApplicationCloudWatchLoggingOptionV2.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnApplicationCloudWatchLoggingOptionV2PropsToCloudFormation(props);
  }
}

export namespace CfnApplicationCloudWatchLoggingOptionV2 {
  /**
   * Provides a description of Amazon CloudWatch logging options, including the log stream Amazon Resource Name (ARN).
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationcloudwatchloggingoption-cloudwatchloggingoption.html
   */
  export interface CloudWatchLoggingOptionProperty {
    /**
     * The ARN of the CloudWatch log to receive application messages.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationcloudwatchloggingoption-cloudwatchloggingoption.html#cfn-kinesisanalyticsv2-applicationcloudwatchloggingoption-cloudwatchloggingoption-logstreamarn
     */
    readonly logStreamArn: string;
  }
}

/**
 * Properties for defining a \`CfnApplicationCloudWatchLoggingOption\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-applicationcloudwatchloggingoption.html
 */
export interface CfnApplicationCloudWatchLoggingOptionV2Props {
  /**
   * The name of the application.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-applicationcloudwatchloggingoption.html#cfn-kinesisanalyticsv2-applicationcloudwatchloggingoption-applicationname
   */
  readonly applicationName: string;

  /**
   * Provides a description of Amazon CloudWatch logging options, including the log stream Amazon Resource Name (ARN).
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-applicationcloudwatchloggingoption.html#cfn-kinesisanalyticsv2-applicationcloudwatchloggingoption-cloudwatchloggingoption
   */
  readonly cloudWatchLoggingOption: CfnApplicationCloudWatchLoggingOptionV2.CloudWatchLoggingOptionProperty | cdk.IResolvable;
}

/**
 * Determine whether the given properties match those of a \`CloudWatchLoggingOptionProperty\`
 *
 * @param properties - the TypeScript properties of a \`CloudWatchLoggingOptionProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationCloudWatchLoggingOptionV2CloudWatchLoggingOptionPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("logStreamArn", cdk.requiredValidator)(properties.logStreamArn));
  errors.collect(cdk.propertyValidator("logStreamArn", cdk.validateString)(properties.logStreamArn));
  return errors.wrap("supplied properties not correct for \\"CloudWatchLoggingOptionProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationCloudWatchLoggingOptionV2CloudWatchLoggingOptionPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationCloudWatchLoggingOptionV2CloudWatchLoggingOptionPropertyValidator(properties).assertSuccess();
  return {
    "LogStreamARN": cdk.stringToCloudFormation(properties.logStreamArn)
  };
}

// @ts-ignore TS6133
function CfnApplicationCloudWatchLoggingOptionV2CloudWatchLoggingOptionPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApplicationCloudWatchLoggingOptionV2.CloudWatchLoggingOptionProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationCloudWatchLoggingOptionV2.CloudWatchLoggingOptionProperty>();
  ret.addPropertyResult("logStreamArn", "LogStreamARN", (properties.LogStreamARN != null ? cfn_parse.FromCloudFormation.getString(properties.LogStreamARN) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnApplicationCloudWatchLoggingOptionV2Props\`
 *
 * @param properties - the TypeScript properties of a \`CfnApplicationCloudWatchLoggingOptionV2Props\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationCloudWatchLoggingOptionV2PropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("applicationName", cdk.requiredValidator)(properties.applicationName));
  errors.collect(cdk.propertyValidator("applicationName", cdk.validateString)(properties.applicationName));
  errors.collect(cdk.propertyValidator("cloudWatchLoggingOption", cdk.requiredValidator)(properties.cloudWatchLoggingOption));
  errors.collect(cdk.propertyValidator("cloudWatchLoggingOption", CfnApplicationCloudWatchLoggingOptionV2CloudWatchLoggingOptionPropertyValidator)(properties.cloudWatchLoggingOption));
  return errors.wrap("supplied properties not correct for \\"CfnApplicationCloudWatchLoggingOptionV2Props\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationCloudWatchLoggingOptionV2PropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationCloudWatchLoggingOptionV2PropsValidator(properties).assertSuccess();
  return {
    "ApplicationName": cdk.stringToCloudFormation(properties.applicationName),
    "CloudWatchLoggingOption": convertCfnApplicationCloudWatchLoggingOptionV2CloudWatchLoggingOptionPropertyToCloudFormation(properties.cloudWatchLoggingOption)
  };
}

// @ts-ignore TS6133
function CfnApplicationCloudWatchLoggingOptionV2PropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApplicationCloudWatchLoggingOptionV2Props | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationCloudWatchLoggingOptionV2Props>();
  ret.addPropertyResult("applicationName", "ApplicationName", (properties.ApplicationName != null ? cfn_parse.FromCloudFormation.getString(properties.ApplicationName) : undefined));
  ret.addPropertyResult("cloudWatchLoggingOption", "CloudWatchLoggingOption", (properties.CloudWatchLoggingOption != null ? CfnApplicationCloudWatchLoggingOptionV2CloudWatchLoggingOptionPropertyFromCloudFormation(properties.CloudWatchLoggingOption) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Adds an external destination to your SQL-based Amazon Kinesis Data Analytics application.
 *
 * If you want Kinesis Data Analytics to deliver data from an in-application stream within your application to an external destination (such as an Kinesis data stream, a Kinesis Data Firehose delivery stream, or an Amazon Lambda function), you add the relevant configuration to your application using this operation. You can configure one or more outputs for your application. Each output configuration maps an in-application stream and an external destination.
 *
 * You can use one of the output configurations to deliver data from your in-application error stream to an external destination so that you can analyze the errors.
 *
 * Any configuration update, including adding a streaming source using this operation, results in a new version of the application. You can use the [DescribeApplication](https://docs.aws.amazon.com/kinesisanalytics/latest/apiv2/API_DescribeApplication.html) operation to find the current application version.
 *
 * > Creation of multiple outputs should be sequential (use of DependsOn) to avoid a problem with a stale application version ( *ConcurrentModificationException* ).
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-applicationoutput.html
 */
export class CfnApplicationOutputV2 extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::KinesisAnalyticsV2::ApplicationOutput";

  /**
   * Build a CfnApplicationOutputV2 from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnApplicationOutputV2 {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnApplicationOutputV2PropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnApplicationOutputV2(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The name of the application.
   */
  public applicationName: string;

  /**
   * Describes a SQL-based Kinesis Data Analytics application's output configuration, in which you identify an in-application stream and a destination where you want the in-application stream data to be written.
   */
  public output: cdk.IResolvable | CfnApplicationOutputV2.OutputProperty;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnApplicationOutputV2Props) {
    super(scope, id, {
      "type": CfnApplicationOutputV2.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "applicationName", this);
    cdk.requireProperty(props, "output", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.applicationName = props.applicationName;
    this.output = props.output;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "applicationName": this.applicationName,
      "output": this.output
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnApplicationOutputV2.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnApplicationOutputV2PropsToCloudFormation(props);
  }
}

export namespace CfnApplicationOutputV2 {
  /**
   * Describes a SQL-based Kinesis Data Analytics application's output configuration, in which you identify an in-application stream and a destination where you want the in-application stream data to be written.
   *
   * The destination can be a Kinesis data stream or a Kinesis Data Firehose delivery stream.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationoutput-output.html
   */
  export interface OutputProperty {
    /**
     * Describes the data format when records are written to the destination.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationoutput-output.html#cfn-kinesisanalyticsv2-applicationoutput-output-destinationschema
     */
    readonly destinationSchema: CfnApplicationOutputV2.DestinationSchemaProperty | cdk.IResolvable;

    /**
     * Identifies a Kinesis Data Firehose delivery stream as the destination.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationoutput-output.html#cfn-kinesisanalyticsv2-applicationoutput-output-kinesisfirehoseoutput
     */
    readonly kinesisFirehoseOutput?: cdk.IResolvable | CfnApplicationOutputV2.KinesisFirehoseOutputProperty;

    /**
     * Identifies a Kinesis data stream as the destination.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationoutput-output.html#cfn-kinesisanalyticsv2-applicationoutput-output-kinesisstreamsoutput
     */
    readonly kinesisStreamsOutput?: cdk.IResolvable | CfnApplicationOutputV2.KinesisStreamsOutputProperty;

    /**
     * Identifies an Amazon Lambda function as the destination.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationoutput-output.html#cfn-kinesisanalyticsv2-applicationoutput-output-lambdaoutput
     */
    readonly lambdaOutput?: cdk.IResolvable | CfnApplicationOutputV2.LambdaOutputProperty;

    /**
     * The name of the in-application stream.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationoutput-output.html#cfn-kinesisanalyticsv2-applicationoutput-output-name
     */
    readonly name?: string;
  }

  /**
   * Describes the data format when records are written to the destination in a SQL-based Kinesis Data Analytics application.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationoutput-destinationschema.html
   */
  export interface DestinationSchemaProperty {
    /**
     * Specifies the format of the records on the output stream.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationoutput-destinationschema.html#cfn-kinesisanalyticsv2-applicationoutput-destinationschema-recordformattype
     */
    readonly recordFormatType?: string;
  }

  /**
   * When you configure a SQL-based Kinesis Data Analytics application's output, identifies an Amazon Lambda function as the destination.
   *
   * You provide the function Amazon Resource Name (ARN) of the Lambda function.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationoutput-lambdaoutput.html
   */
  export interface LambdaOutputProperty {
    /**
     * The Amazon Resource Name (ARN) of the destination Lambda function to write to.
     *
     * > To specify an earlier version of the Lambda function than the latest, include the Lambda function version in the Lambda function ARN. For more information about Lambda ARNs, see [Example ARNs: Amazon Lambda](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-lambda)
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationoutput-lambdaoutput.html#cfn-kinesisanalyticsv2-applicationoutput-lambdaoutput-resourcearn
     */
    readonly resourceArn: string;
  }

  /**
   * For a SQL-based Kinesis Data Analytics application, when configuring application output, identifies a Kinesis Data Firehose delivery stream as the destination.
   *
   * You provide the stream Amazon Resource Name (ARN) of the delivery stream.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationoutput-kinesisfirehoseoutput.html
   */
  export interface KinesisFirehoseOutputProperty {
    /**
     * The ARN of the destination delivery stream to write to.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationoutput-kinesisfirehoseoutput.html#cfn-kinesisanalyticsv2-applicationoutput-kinesisfirehoseoutput-resourcearn
     */
    readonly resourceArn: string;
  }

  /**
   * When you configure a SQL-based Kinesis Data Analytics application's output, identifies a Kinesis data stream as the destination.
   *
   * You provide the stream Amazon Resource Name (ARN).
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationoutput-kinesisstreamsoutput.html
   */
  export interface KinesisStreamsOutputProperty {
    /**
     * The ARN of the destination Kinesis data stream to write to.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationoutput-kinesisstreamsoutput.html#cfn-kinesisanalyticsv2-applicationoutput-kinesisstreamsoutput-resourcearn
     */
    readonly resourceArn: string;
  }
}

/**
 * Properties for defining a \`CfnApplicationOutput\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-applicationoutput.html
 */
export interface CfnApplicationOutputV2Props {
  /**
   * The name of the application.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-applicationoutput.html#cfn-kinesisanalyticsv2-applicationoutput-applicationname
   */
  readonly applicationName: string;

  /**
   * Describes a SQL-based Kinesis Data Analytics application's output configuration, in which you identify an in-application stream and a destination where you want the in-application stream data to be written.
   *
   * The destination can be a Kinesis data stream or a Kinesis Data Firehose delivery stream.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-applicationoutput.html#cfn-kinesisanalyticsv2-applicationoutput-output
   */
  readonly output: cdk.IResolvable | CfnApplicationOutputV2.OutputProperty;
}

/**
 * Determine whether the given properties match those of a \`DestinationSchemaProperty\`
 *
 * @param properties - the TypeScript properties of a \`DestinationSchemaProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationOutputV2DestinationSchemaPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("recordFormatType", cdk.validateString)(properties.recordFormatType));
  return errors.wrap("supplied properties not correct for \\"DestinationSchemaProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationOutputV2DestinationSchemaPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationOutputV2DestinationSchemaPropertyValidator(properties).assertSuccess();
  return {
    "RecordFormatType": cdk.stringToCloudFormation(properties.recordFormatType)
  };
}

// @ts-ignore TS6133
function CfnApplicationOutputV2DestinationSchemaPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApplicationOutputV2.DestinationSchemaProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationOutputV2.DestinationSchemaProperty>();
  ret.addPropertyResult("recordFormatType", "RecordFormatType", (properties.RecordFormatType != null ? cfn_parse.FromCloudFormation.getString(properties.RecordFormatType) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`LambdaOutputProperty\`
 *
 * @param properties - the TypeScript properties of a \`LambdaOutputProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationOutputV2LambdaOutputPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("resourceArn", cdk.requiredValidator)(properties.resourceArn));
  errors.collect(cdk.propertyValidator("resourceArn", cdk.validateString)(properties.resourceArn));
  return errors.wrap("supplied properties not correct for \\"LambdaOutputProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationOutputV2LambdaOutputPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationOutputV2LambdaOutputPropertyValidator(properties).assertSuccess();
  return {
    "ResourceARN": cdk.stringToCloudFormation(properties.resourceArn)
  };
}

// @ts-ignore TS6133
function CfnApplicationOutputV2LambdaOutputPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApplicationOutputV2.LambdaOutputProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationOutputV2.LambdaOutputProperty>();
  ret.addPropertyResult("resourceArn", "ResourceARN", (properties.ResourceARN != null ? cfn_parse.FromCloudFormation.getString(properties.ResourceARN) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`KinesisFirehoseOutputProperty\`
 *
 * @param properties - the TypeScript properties of a \`KinesisFirehoseOutputProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationOutputV2KinesisFirehoseOutputPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("resourceArn", cdk.requiredValidator)(properties.resourceArn));
  errors.collect(cdk.propertyValidator("resourceArn", cdk.validateString)(properties.resourceArn));
  return errors.wrap("supplied properties not correct for \\"KinesisFirehoseOutputProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationOutputV2KinesisFirehoseOutputPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationOutputV2KinesisFirehoseOutputPropertyValidator(properties).assertSuccess();
  return {
    "ResourceARN": cdk.stringToCloudFormation(properties.resourceArn)
  };
}

// @ts-ignore TS6133
function CfnApplicationOutputV2KinesisFirehoseOutputPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApplicationOutputV2.KinesisFirehoseOutputProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationOutputV2.KinesisFirehoseOutputProperty>();
  ret.addPropertyResult("resourceArn", "ResourceARN", (properties.ResourceARN != null ? cfn_parse.FromCloudFormation.getString(properties.ResourceARN) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`KinesisStreamsOutputProperty\`
 *
 * @param properties - the TypeScript properties of a \`KinesisStreamsOutputProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationOutputV2KinesisStreamsOutputPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("resourceArn", cdk.requiredValidator)(properties.resourceArn));
  errors.collect(cdk.propertyValidator("resourceArn", cdk.validateString)(properties.resourceArn));
  return errors.wrap("supplied properties not correct for \\"KinesisStreamsOutputProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationOutputV2KinesisStreamsOutputPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationOutputV2KinesisStreamsOutputPropertyValidator(properties).assertSuccess();
  return {
    "ResourceARN": cdk.stringToCloudFormation(properties.resourceArn)
  };
}

// @ts-ignore TS6133
function CfnApplicationOutputV2KinesisStreamsOutputPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApplicationOutputV2.KinesisStreamsOutputProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationOutputV2.KinesisStreamsOutputProperty>();
  ret.addPropertyResult("resourceArn", "ResourceARN", (properties.ResourceARN != null ? cfn_parse.FromCloudFormation.getString(properties.ResourceARN) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`OutputProperty\`
 *
 * @param properties - the TypeScript properties of a \`OutputProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationOutputV2OutputPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("destinationSchema", cdk.requiredValidator)(properties.destinationSchema));
  errors.collect(cdk.propertyValidator("destinationSchema", CfnApplicationOutputV2DestinationSchemaPropertyValidator)(properties.destinationSchema));
  errors.collect(cdk.propertyValidator("kinesisFirehoseOutput", CfnApplicationOutputV2KinesisFirehoseOutputPropertyValidator)(properties.kinesisFirehoseOutput));
  errors.collect(cdk.propertyValidator("kinesisStreamsOutput", CfnApplicationOutputV2KinesisStreamsOutputPropertyValidator)(properties.kinesisStreamsOutput));
  errors.collect(cdk.propertyValidator("lambdaOutput", CfnApplicationOutputV2LambdaOutputPropertyValidator)(properties.lambdaOutput));
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  return errors.wrap("supplied properties not correct for \\"OutputProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationOutputV2OutputPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationOutputV2OutputPropertyValidator(properties).assertSuccess();
  return {
    "DestinationSchema": convertCfnApplicationOutputV2DestinationSchemaPropertyToCloudFormation(properties.destinationSchema),
    "KinesisFirehoseOutput": convertCfnApplicationOutputV2KinesisFirehoseOutputPropertyToCloudFormation(properties.kinesisFirehoseOutput),
    "KinesisStreamsOutput": convertCfnApplicationOutputV2KinesisStreamsOutputPropertyToCloudFormation(properties.kinesisStreamsOutput),
    "LambdaOutput": convertCfnApplicationOutputV2LambdaOutputPropertyToCloudFormation(properties.lambdaOutput),
    "Name": cdk.stringToCloudFormation(properties.name)
  };
}

// @ts-ignore TS6133
function CfnApplicationOutputV2OutputPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApplicationOutputV2.OutputProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationOutputV2.OutputProperty>();
  ret.addPropertyResult("destinationSchema", "DestinationSchema", (properties.DestinationSchema != null ? CfnApplicationOutputV2DestinationSchemaPropertyFromCloudFormation(properties.DestinationSchema) : undefined));
  ret.addPropertyResult("kinesisFirehoseOutput", "KinesisFirehoseOutput", (properties.KinesisFirehoseOutput != null ? CfnApplicationOutputV2KinesisFirehoseOutputPropertyFromCloudFormation(properties.KinesisFirehoseOutput) : undefined));
  ret.addPropertyResult("kinesisStreamsOutput", "KinesisStreamsOutput", (properties.KinesisStreamsOutput != null ? CfnApplicationOutputV2KinesisStreamsOutputPropertyFromCloudFormation(properties.KinesisStreamsOutput) : undefined));
  ret.addPropertyResult("lambdaOutput", "LambdaOutput", (properties.LambdaOutput != null ? CfnApplicationOutputV2LambdaOutputPropertyFromCloudFormation(properties.LambdaOutput) : undefined));
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnApplicationOutputV2Props\`
 *
 * @param properties - the TypeScript properties of a \`CfnApplicationOutputV2Props\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationOutputV2PropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("applicationName", cdk.requiredValidator)(properties.applicationName));
  errors.collect(cdk.propertyValidator("applicationName", cdk.validateString)(properties.applicationName));
  errors.collect(cdk.propertyValidator("output", cdk.requiredValidator)(properties.output));
  errors.collect(cdk.propertyValidator("output", CfnApplicationOutputV2OutputPropertyValidator)(properties.output));
  return errors.wrap("supplied properties not correct for \\"CfnApplicationOutputV2Props\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationOutputV2PropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationOutputV2PropsValidator(properties).assertSuccess();
  return {
    "ApplicationName": cdk.stringToCloudFormation(properties.applicationName),
    "Output": convertCfnApplicationOutputV2OutputPropertyToCloudFormation(properties.output)
  };
}

// @ts-ignore TS6133
function CfnApplicationOutputV2PropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApplicationOutputV2Props | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationOutputV2Props>();
  ret.addPropertyResult("applicationName", "ApplicationName", (properties.ApplicationName != null ? cfn_parse.FromCloudFormation.getString(properties.ApplicationName) : undefined));
  ret.addPropertyResult("output", "Output", (properties.Output != null ? CfnApplicationOutputV2OutputPropertyFromCloudFormation(properties.Output) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Adds a reference data source to an existing SQL-based Kinesis Data Analytics application.
 *
 * Kinesis Data Analytics reads reference data (that is, an Amazon S3 object) and creates an in-application table within your application. In the request, you provide the source (S3 bucket name and object key name), name of the in-application table to create, and the necessary mapping information that describes how data in an Amazon S3 object maps to columns in the resulting in-application table.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-applicationreferencedatasource.html
 */
export class CfnApplicationReferenceDataSourceV2 extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::KinesisAnalyticsV2::ApplicationReferenceDataSource";

  /**
   * Build a CfnApplicationReferenceDataSourceV2 from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnApplicationReferenceDataSourceV2 {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnApplicationReferenceDataSourceV2PropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnApplicationReferenceDataSourceV2(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The name of the application.
   */
  public applicationName: string;

  /**
   * For a SQL-based Kinesis Data Analytics application, describes the reference data source by providing the source information (Amazon S3 bucket name and object key name), the resulting in-application table name that is created, and the necessary schema to map the data elements in the Amazon S3 object to the in-application table.
   */
  public referenceDataSource: cdk.IResolvable | CfnApplicationReferenceDataSourceV2.ReferenceDataSourceProperty;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnApplicationReferenceDataSourceV2Props) {
    super(scope, id, {
      "type": CfnApplicationReferenceDataSourceV2.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "applicationName", this);
    cdk.requireProperty(props, "referenceDataSource", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.applicationName = props.applicationName;
    this.referenceDataSource = props.referenceDataSource;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "applicationName": this.applicationName,
      "referenceDataSource": this.referenceDataSource
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnApplicationReferenceDataSourceV2.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnApplicationReferenceDataSourceV2PropsToCloudFormation(props);
  }
}

export namespace CfnApplicationReferenceDataSourceV2 {
  /**
   * For a SQL-based Kinesis Data Analytics application, describes the reference data source by providing the source information (Amazon S3 bucket name and object key name), the resulting in-application table name that is created, and the necessary schema to map the data elements in the Amazon S3 object to the in-application table.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationreferencedatasource-referencedatasource.html
   */
  export interface ReferenceDataSourceProperty {
    /**
     * Describes the format of the data in the streaming source, and how each data element maps to corresponding columns created in the in-application stream.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationreferencedatasource-referencedatasource.html#cfn-kinesisanalyticsv2-applicationreferencedatasource-referencedatasource-referenceschema
     */
    readonly referenceSchema: cdk.IResolvable | CfnApplicationReferenceDataSourceV2.ReferenceSchemaProperty;

    /**
     * Identifies the S3 bucket and object that contains the reference data.
     *
     * A Kinesis Data Analytics application loads reference data only once. If the data changes, you call the [UpdateApplication](https://docs.aws.amazon.com/kinesisanalytics/latest/apiv2/API_UpdateApplication.html) operation to trigger reloading of data into your application.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationreferencedatasource-referencedatasource.html#cfn-kinesisanalyticsv2-applicationreferencedatasource-referencedatasource-s3referencedatasource
     */
    readonly s3ReferenceDataSource?: cdk.IResolvable | CfnApplicationReferenceDataSourceV2.S3ReferenceDataSourceProperty;

    /**
     * The name of the in-application table to create.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationreferencedatasource-referencedatasource.html#cfn-kinesisanalyticsv2-applicationreferencedatasource-referencedatasource-tablename
     */
    readonly tableName?: string;
  }

  /**
   * For a SQL-based Kinesis Data Analytics application, describes the format of the data in the streaming source, and how each data element maps to corresponding columns created in the in-application stream.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationreferencedatasource-referenceschema.html
   */
  export interface ReferenceSchemaProperty {
    /**
     * A list of \`RecordColumn\` objects.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationreferencedatasource-referenceschema.html#cfn-kinesisanalyticsv2-applicationreferencedatasource-referenceschema-recordcolumns
     */
    readonly recordColumns: Array<cdk.IResolvable | CfnApplicationReferenceDataSourceV2.RecordColumnProperty> | cdk.IResolvable;

    /**
     * Specifies the encoding of the records in the streaming source.
     *
     * For example, UTF-8.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationreferencedatasource-referenceschema.html#cfn-kinesisanalyticsv2-applicationreferencedatasource-referenceschema-recordencoding
     */
    readonly recordEncoding?: string;

    /**
     * Specifies the format of the records on the streaming source.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationreferencedatasource-referenceschema.html#cfn-kinesisanalyticsv2-applicationreferencedatasource-referenceschema-recordformat
     */
    readonly recordFormat: cdk.IResolvable | CfnApplicationReferenceDataSourceV2.RecordFormatProperty;
  }

  /**
   * For a SQL-based Kinesis Data Analytics application, describes the mapping of each data element in the streaming source to the corresponding column in the in-application stream.
   *
   * Also used to describe the format of the reference data source.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationreferencedatasource-recordcolumn.html
   */
  export interface RecordColumnProperty {
    /**
     * A reference to the data element in the streaming input or the reference data source.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationreferencedatasource-recordcolumn.html#cfn-kinesisanalyticsv2-applicationreferencedatasource-recordcolumn-mapping
     */
    readonly mapping?: string;

    /**
     * The name of the column that is created in the in-application input stream or reference table.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationreferencedatasource-recordcolumn.html#cfn-kinesisanalyticsv2-applicationreferencedatasource-recordcolumn-name
     */
    readonly name: string;

    /**
     * The type of column created in the in-application input stream or reference table.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationreferencedatasource-recordcolumn.html#cfn-kinesisanalyticsv2-applicationreferencedatasource-recordcolumn-sqltype
     */
    readonly sqlType: string;
  }

  /**
   * For a SQL-based Kinesis Data Analytics application, describes the record format and relevant mapping information that should be applied to schematize the records on the stream.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationreferencedatasource-recordformat.html
   */
  export interface RecordFormatProperty {
    /**
     * When you configure application input at the time of creating or updating an application, provides additional mapping information specific to the record format (such as JSON, CSV, or record fields delimited by some delimiter) on the streaming source.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationreferencedatasource-recordformat.html#cfn-kinesisanalyticsv2-applicationreferencedatasource-recordformat-mappingparameters
     */
    readonly mappingParameters?: cdk.IResolvable | CfnApplicationReferenceDataSourceV2.MappingParametersProperty;

    /**
     * The type of record format.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationreferencedatasource-recordformat.html#cfn-kinesisanalyticsv2-applicationreferencedatasource-recordformat-recordformattype
     */
    readonly recordFormatType: string;
  }

  /**
   * When you configure a SQL-based Kinesis Data Analytics application's input at the time of creating or updating an application, provides additional mapping information specific to the record format (such as JSON, CSV, or record fields delimited by some delimiter) on the streaming source.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationreferencedatasource-mappingparameters.html
   */
  export interface MappingParametersProperty {
    /**
     * Provides additional mapping information when the record format uses delimiters (for example, CSV).
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationreferencedatasource-mappingparameters.html#cfn-kinesisanalyticsv2-applicationreferencedatasource-mappingparameters-csvmappingparameters
     */
    readonly csvMappingParameters?: CfnApplicationReferenceDataSourceV2.CSVMappingParametersProperty | cdk.IResolvable;

    /**
     * Provides additional mapping information when JSON is the record format on the streaming source.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationreferencedatasource-mappingparameters.html#cfn-kinesisanalyticsv2-applicationreferencedatasource-mappingparameters-jsonmappingparameters
     */
    readonly jsonMappingParameters?: cdk.IResolvable | CfnApplicationReferenceDataSourceV2.JSONMappingParametersProperty;
  }

  /**
   * For a SQL-based Kinesis Data Analytics application, provides additional mapping information when JSON is the record format on the streaming source.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationreferencedatasource-jsonmappingparameters.html
   */
  export interface JSONMappingParametersProperty {
    /**
     * The path to the top-level parent that contains the records.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationreferencedatasource-jsonmappingparameters.html#cfn-kinesisanalyticsv2-applicationreferencedatasource-jsonmappingparameters-recordrowpath
     */
    readonly recordRowPath: string;
  }

  /**
   * For a SQL-based Kinesis Data Analytics application, provides additional mapping information when the record format uses delimiters, such as CSV.
   *
   * For example, the following sample records use CSV format, where the records use the *'\\n'* as the row delimiter and a comma (",") as the column delimiter:
   *
   * \`"name1", "address1"\`
   *
   * \`"name2", "address2"\`
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationreferencedatasource-csvmappingparameters.html
   */
  export interface CSVMappingParametersProperty {
    /**
     * The column delimiter.
     *
     * For example, in a CSV format, a comma (",") is the typical column delimiter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationreferencedatasource-csvmappingparameters.html#cfn-kinesisanalyticsv2-applicationreferencedatasource-csvmappingparameters-recordcolumndelimiter
     */
    readonly recordColumnDelimiter: string;

    /**
     * The row delimiter.
     *
     * For example, in a CSV format, *'\\n'* is the typical row delimiter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationreferencedatasource-csvmappingparameters.html#cfn-kinesisanalyticsv2-applicationreferencedatasource-csvmappingparameters-recordrowdelimiter
     */
    readonly recordRowDelimiter: string;
  }

  /**
   * For an SQL-based Amazon Kinesis Data Analytics application, identifies the Amazon S3 bucket and object that contains the reference data.
   *
   * A Kinesis Data Analytics application loads reference data only once. If the data changes, you call the [UpdateApplication](https://docs.aws.amazon.com/kinesisanalytics/latest/apiv2/API_UpdateApplication.html) operation to trigger reloading of data into your application.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationreferencedatasource-s3referencedatasource.html
   */
  export interface S3ReferenceDataSourceProperty {
    /**
     * The Amazon Resource Name (ARN) of the S3 bucket.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationreferencedatasource-s3referencedatasource.html#cfn-kinesisanalyticsv2-applicationreferencedatasource-s3referencedatasource-bucketarn
     */
    readonly bucketArn: string;

    /**
     * The object key name containing the reference data.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationreferencedatasource-s3referencedatasource.html#cfn-kinesisanalyticsv2-applicationreferencedatasource-s3referencedatasource-filekey
     */
    readonly fileKey: string;
  }
}

/**
 * Properties for defining a \`CfnApplicationReferenceDataSource\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-applicationreferencedatasource.html
 */
export interface CfnApplicationReferenceDataSourceV2Props {
  /**
   * The name of the application.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-applicationreferencedatasource.html#cfn-kinesisanalyticsv2-applicationreferencedatasource-applicationname
   */
  readonly applicationName: string;

  /**
   * For a SQL-based Kinesis Data Analytics application, describes the reference data source by providing the source information (Amazon S3 bucket name and object key name), the resulting in-application table name that is created, and the necessary schema to map the data elements in the Amazon S3 object to the in-application table.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-applicationreferencedatasource.html#cfn-kinesisanalyticsv2-applicationreferencedatasource-referencedatasource
   */
  readonly referenceDataSource: cdk.IResolvable | CfnApplicationReferenceDataSourceV2.ReferenceDataSourceProperty;
}

/**
 * Determine whether the given properties match those of a \`RecordColumnProperty\`
 *
 * @param properties - the TypeScript properties of a \`RecordColumnProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationReferenceDataSourceV2RecordColumnPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("mapping", cdk.validateString)(properties.mapping));
  errors.collect(cdk.propertyValidator("name", cdk.requiredValidator)(properties.name));
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  errors.collect(cdk.propertyValidator("sqlType", cdk.requiredValidator)(properties.sqlType));
  errors.collect(cdk.propertyValidator("sqlType", cdk.validateString)(properties.sqlType));
  return errors.wrap("supplied properties not correct for \\"RecordColumnProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationReferenceDataSourceV2RecordColumnPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationReferenceDataSourceV2RecordColumnPropertyValidator(properties).assertSuccess();
  return {
    "Mapping": cdk.stringToCloudFormation(properties.mapping),
    "Name": cdk.stringToCloudFormation(properties.name),
    "SqlType": cdk.stringToCloudFormation(properties.sqlType)
  };
}

// @ts-ignore TS6133
function CfnApplicationReferenceDataSourceV2RecordColumnPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApplicationReferenceDataSourceV2.RecordColumnProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationReferenceDataSourceV2.RecordColumnProperty>();
  ret.addPropertyResult("mapping", "Mapping", (properties.Mapping != null ? cfn_parse.FromCloudFormation.getString(properties.Mapping) : undefined));
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addPropertyResult("sqlType", "SqlType", (properties.SqlType != null ? cfn_parse.FromCloudFormation.getString(properties.SqlType) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`JSONMappingParametersProperty\`
 *
 * @param properties - the TypeScript properties of a \`JSONMappingParametersProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationReferenceDataSourceV2JSONMappingParametersPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("recordRowPath", cdk.requiredValidator)(properties.recordRowPath));
  errors.collect(cdk.propertyValidator("recordRowPath", cdk.validateString)(properties.recordRowPath));
  return errors.wrap("supplied properties not correct for \\"JSONMappingParametersProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationReferenceDataSourceV2JSONMappingParametersPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationReferenceDataSourceV2JSONMappingParametersPropertyValidator(properties).assertSuccess();
  return {
    "RecordRowPath": cdk.stringToCloudFormation(properties.recordRowPath)
  };
}

// @ts-ignore TS6133
function CfnApplicationReferenceDataSourceV2JSONMappingParametersPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApplicationReferenceDataSourceV2.JSONMappingParametersProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationReferenceDataSourceV2.JSONMappingParametersProperty>();
  ret.addPropertyResult("recordRowPath", "RecordRowPath", (properties.RecordRowPath != null ? cfn_parse.FromCloudFormation.getString(properties.RecordRowPath) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CSVMappingParametersProperty\`
 *
 * @param properties - the TypeScript properties of a \`CSVMappingParametersProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationReferenceDataSourceV2CSVMappingParametersPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("recordColumnDelimiter", cdk.requiredValidator)(properties.recordColumnDelimiter));
  errors.collect(cdk.propertyValidator("recordColumnDelimiter", cdk.validateString)(properties.recordColumnDelimiter));
  errors.collect(cdk.propertyValidator("recordRowDelimiter", cdk.requiredValidator)(properties.recordRowDelimiter));
  errors.collect(cdk.propertyValidator("recordRowDelimiter", cdk.validateString)(properties.recordRowDelimiter));
  return errors.wrap("supplied properties not correct for \\"CSVMappingParametersProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationReferenceDataSourceV2CSVMappingParametersPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationReferenceDataSourceV2CSVMappingParametersPropertyValidator(properties).assertSuccess();
  return {
    "RecordColumnDelimiter": cdk.stringToCloudFormation(properties.recordColumnDelimiter),
    "RecordRowDelimiter": cdk.stringToCloudFormation(properties.recordRowDelimiter)
  };
}

// @ts-ignore TS6133
function CfnApplicationReferenceDataSourceV2CSVMappingParametersPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApplicationReferenceDataSourceV2.CSVMappingParametersProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationReferenceDataSourceV2.CSVMappingParametersProperty>();
  ret.addPropertyResult("recordColumnDelimiter", "RecordColumnDelimiter", (properties.RecordColumnDelimiter != null ? cfn_parse.FromCloudFormation.getString(properties.RecordColumnDelimiter) : undefined));
  ret.addPropertyResult("recordRowDelimiter", "RecordRowDelimiter", (properties.RecordRowDelimiter != null ? cfn_parse.FromCloudFormation.getString(properties.RecordRowDelimiter) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`MappingParametersProperty\`
 *
 * @param properties - the TypeScript properties of a \`MappingParametersProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationReferenceDataSourceV2MappingParametersPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("csvMappingParameters", CfnApplicationReferenceDataSourceV2CSVMappingParametersPropertyValidator)(properties.csvMappingParameters));
  errors.collect(cdk.propertyValidator("jsonMappingParameters", CfnApplicationReferenceDataSourceV2JSONMappingParametersPropertyValidator)(properties.jsonMappingParameters));
  return errors.wrap("supplied properties not correct for \\"MappingParametersProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationReferenceDataSourceV2MappingParametersPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationReferenceDataSourceV2MappingParametersPropertyValidator(properties).assertSuccess();
  return {
    "CSVMappingParameters": convertCfnApplicationReferenceDataSourceV2CSVMappingParametersPropertyToCloudFormation(properties.csvMappingParameters),
    "JSONMappingParameters": convertCfnApplicationReferenceDataSourceV2JSONMappingParametersPropertyToCloudFormation(properties.jsonMappingParameters)
  };
}

// @ts-ignore TS6133
function CfnApplicationReferenceDataSourceV2MappingParametersPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApplicationReferenceDataSourceV2.MappingParametersProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationReferenceDataSourceV2.MappingParametersProperty>();
  ret.addPropertyResult("csvMappingParameters", "CSVMappingParameters", (properties.CSVMappingParameters != null ? CfnApplicationReferenceDataSourceV2CSVMappingParametersPropertyFromCloudFormation(properties.CSVMappingParameters) : undefined));
  ret.addPropertyResult("jsonMappingParameters", "JSONMappingParameters", (properties.JSONMappingParameters != null ? CfnApplicationReferenceDataSourceV2JSONMappingParametersPropertyFromCloudFormation(properties.JSONMappingParameters) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`RecordFormatProperty\`
 *
 * @param properties - the TypeScript properties of a \`RecordFormatProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationReferenceDataSourceV2RecordFormatPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("mappingParameters", CfnApplicationReferenceDataSourceV2MappingParametersPropertyValidator)(properties.mappingParameters));
  errors.collect(cdk.propertyValidator("recordFormatType", cdk.requiredValidator)(properties.recordFormatType));
  errors.collect(cdk.propertyValidator("recordFormatType", cdk.validateString)(properties.recordFormatType));
  return errors.wrap("supplied properties not correct for \\"RecordFormatProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationReferenceDataSourceV2RecordFormatPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationReferenceDataSourceV2RecordFormatPropertyValidator(properties).assertSuccess();
  return {
    "MappingParameters": convertCfnApplicationReferenceDataSourceV2MappingParametersPropertyToCloudFormation(properties.mappingParameters),
    "RecordFormatType": cdk.stringToCloudFormation(properties.recordFormatType)
  };
}

// @ts-ignore TS6133
function CfnApplicationReferenceDataSourceV2RecordFormatPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApplicationReferenceDataSourceV2.RecordFormatProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationReferenceDataSourceV2.RecordFormatProperty>();
  ret.addPropertyResult("mappingParameters", "MappingParameters", (properties.MappingParameters != null ? CfnApplicationReferenceDataSourceV2MappingParametersPropertyFromCloudFormation(properties.MappingParameters) : undefined));
  ret.addPropertyResult("recordFormatType", "RecordFormatType", (properties.RecordFormatType != null ? cfn_parse.FromCloudFormation.getString(properties.RecordFormatType) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ReferenceSchemaProperty\`
 *
 * @param properties - the TypeScript properties of a \`ReferenceSchemaProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationReferenceDataSourceV2ReferenceSchemaPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("recordColumns", cdk.requiredValidator)(properties.recordColumns));
  errors.collect(cdk.propertyValidator("recordColumns", cdk.listValidator(CfnApplicationReferenceDataSourceV2RecordColumnPropertyValidator))(properties.recordColumns));
  errors.collect(cdk.propertyValidator("recordEncoding", cdk.validateString)(properties.recordEncoding));
  errors.collect(cdk.propertyValidator("recordFormat", cdk.requiredValidator)(properties.recordFormat));
  errors.collect(cdk.propertyValidator("recordFormat", CfnApplicationReferenceDataSourceV2RecordFormatPropertyValidator)(properties.recordFormat));
  return errors.wrap("supplied properties not correct for \\"ReferenceSchemaProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationReferenceDataSourceV2ReferenceSchemaPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationReferenceDataSourceV2ReferenceSchemaPropertyValidator(properties).assertSuccess();
  return {
    "RecordColumns": cdk.listMapper(convertCfnApplicationReferenceDataSourceV2RecordColumnPropertyToCloudFormation)(properties.recordColumns),
    "RecordEncoding": cdk.stringToCloudFormation(properties.recordEncoding),
    "RecordFormat": convertCfnApplicationReferenceDataSourceV2RecordFormatPropertyToCloudFormation(properties.recordFormat)
  };
}

// @ts-ignore TS6133
function CfnApplicationReferenceDataSourceV2ReferenceSchemaPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApplicationReferenceDataSourceV2.ReferenceSchemaProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationReferenceDataSourceV2.ReferenceSchemaProperty>();
  ret.addPropertyResult("recordColumns", "RecordColumns", (properties.RecordColumns != null ? cfn_parse.FromCloudFormation.getArray(CfnApplicationReferenceDataSourceV2RecordColumnPropertyFromCloudFormation)(properties.RecordColumns) : undefined));
  ret.addPropertyResult("recordEncoding", "RecordEncoding", (properties.RecordEncoding != null ? cfn_parse.FromCloudFormation.getString(properties.RecordEncoding) : undefined));
  ret.addPropertyResult("recordFormat", "RecordFormat", (properties.RecordFormat != null ? CfnApplicationReferenceDataSourceV2RecordFormatPropertyFromCloudFormation(properties.RecordFormat) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`S3ReferenceDataSourceProperty\`
 *
 * @param properties - the TypeScript properties of a \`S3ReferenceDataSourceProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationReferenceDataSourceV2S3ReferenceDataSourcePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("bucketArn", cdk.requiredValidator)(properties.bucketArn));
  errors.collect(cdk.propertyValidator("bucketArn", cdk.validateString)(properties.bucketArn));
  errors.collect(cdk.propertyValidator("fileKey", cdk.requiredValidator)(properties.fileKey));
  errors.collect(cdk.propertyValidator("fileKey", cdk.validateString)(properties.fileKey));
  return errors.wrap("supplied properties not correct for \\"S3ReferenceDataSourceProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationReferenceDataSourceV2S3ReferenceDataSourcePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationReferenceDataSourceV2S3ReferenceDataSourcePropertyValidator(properties).assertSuccess();
  return {
    "BucketARN": cdk.stringToCloudFormation(properties.bucketArn),
    "FileKey": cdk.stringToCloudFormation(properties.fileKey)
  };
}

// @ts-ignore TS6133
function CfnApplicationReferenceDataSourceV2S3ReferenceDataSourcePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApplicationReferenceDataSourceV2.S3ReferenceDataSourceProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationReferenceDataSourceV2.S3ReferenceDataSourceProperty>();
  ret.addPropertyResult("bucketArn", "BucketARN", (properties.BucketARN != null ? cfn_parse.FromCloudFormation.getString(properties.BucketARN) : undefined));
  ret.addPropertyResult("fileKey", "FileKey", (properties.FileKey != null ? cfn_parse.FromCloudFormation.getString(properties.FileKey) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ReferenceDataSourceProperty\`
 *
 * @param properties - the TypeScript properties of a \`ReferenceDataSourceProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationReferenceDataSourceV2ReferenceDataSourcePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("referenceSchema", cdk.requiredValidator)(properties.referenceSchema));
  errors.collect(cdk.propertyValidator("referenceSchema", CfnApplicationReferenceDataSourceV2ReferenceSchemaPropertyValidator)(properties.referenceSchema));
  errors.collect(cdk.propertyValidator("s3ReferenceDataSource", CfnApplicationReferenceDataSourceV2S3ReferenceDataSourcePropertyValidator)(properties.s3ReferenceDataSource));
  errors.collect(cdk.propertyValidator("tableName", cdk.validateString)(properties.tableName));
  return errors.wrap("supplied properties not correct for \\"ReferenceDataSourceProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationReferenceDataSourceV2ReferenceDataSourcePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationReferenceDataSourceV2ReferenceDataSourcePropertyValidator(properties).assertSuccess();
  return {
    "ReferenceSchema": convertCfnApplicationReferenceDataSourceV2ReferenceSchemaPropertyToCloudFormation(properties.referenceSchema),
    "S3ReferenceDataSource": convertCfnApplicationReferenceDataSourceV2S3ReferenceDataSourcePropertyToCloudFormation(properties.s3ReferenceDataSource),
    "TableName": cdk.stringToCloudFormation(properties.tableName)
  };
}

// @ts-ignore TS6133
function CfnApplicationReferenceDataSourceV2ReferenceDataSourcePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApplicationReferenceDataSourceV2.ReferenceDataSourceProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationReferenceDataSourceV2.ReferenceDataSourceProperty>();
  ret.addPropertyResult("referenceSchema", "ReferenceSchema", (properties.ReferenceSchema != null ? CfnApplicationReferenceDataSourceV2ReferenceSchemaPropertyFromCloudFormation(properties.ReferenceSchema) : undefined));
  ret.addPropertyResult("s3ReferenceDataSource", "S3ReferenceDataSource", (properties.S3ReferenceDataSource != null ? CfnApplicationReferenceDataSourceV2S3ReferenceDataSourcePropertyFromCloudFormation(properties.S3ReferenceDataSource) : undefined));
  ret.addPropertyResult("tableName", "TableName", (properties.TableName != null ? cfn_parse.FromCloudFormation.getString(properties.TableName) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnApplicationReferenceDataSourceV2Props\`
 *
 * @param properties - the TypeScript properties of a \`CfnApplicationReferenceDataSourceV2Props\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationReferenceDataSourceV2PropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("applicationName", cdk.requiredValidator)(properties.applicationName));
  errors.collect(cdk.propertyValidator("applicationName", cdk.validateString)(properties.applicationName));
  errors.collect(cdk.propertyValidator("referenceDataSource", cdk.requiredValidator)(properties.referenceDataSource));
  errors.collect(cdk.propertyValidator("referenceDataSource", CfnApplicationReferenceDataSourceV2ReferenceDataSourcePropertyValidator)(properties.referenceDataSource));
  return errors.wrap("supplied properties not correct for \\"CfnApplicationReferenceDataSourceV2Props\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationReferenceDataSourceV2PropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationReferenceDataSourceV2PropsValidator(properties).assertSuccess();
  return {
    "ApplicationName": cdk.stringToCloudFormation(properties.applicationName),
    "ReferenceDataSource": convertCfnApplicationReferenceDataSourceV2ReferenceDataSourcePropertyToCloudFormation(properties.referenceDataSource)
  };
}

// @ts-ignore TS6133
function CfnApplicationReferenceDataSourceV2PropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApplicationReferenceDataSourceV2Props | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationReferenceDataSourceV2Props>();
  ret.addPropertyResult("applicationName", "ApplicationName", (properties.ApplicationName != null ? cfn_parse.FromCloudFormation.getString(properties.ApplicationName) : undefined));
  ret.addPropertyResult("referenceDataSource", "ReferenceDataSource", (properties.ReferenceDataSource != null ? CfnApplicationReferenceDataSourceV2ReferenceDataSourcePropertyFromCloudFormation(properties.ReferenceDataSource) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}"
`;
