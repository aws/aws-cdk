// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`AWS::ApiGateway::RestApi 1`] = `
{
  "augmentations": undefined,
  "metrics": "/* eslint-disable prettier/prettier,max-len */
export interface MetricWithDims<D> {
  readonly namespace: string;

  readonly metricName: string;

  readonly statistic: string;

  readonly dimensionsMap: D;
}

export class ApiGatewayMetrics {
  public static _4XxErrorSum(dimensions: { ApiName: string; Stage: string; }): MetricWithDims<{ ApiName: string; Stage: string; }>;

  public static _4XxErrorSum(dimensions: { ApiName: string; }): MetricWithDims<{ ApiName: string; }>;

  public static _4XxErrorSum(dimensions: { ApiName: string; Method: string; Resource: string; Stage: string; }): MetricWithDims<{ ApiName: string; Method: string; Resource: string; Stage: string; }>;

  public static _4XxErrorSum(dimensions: any): MetricWithDims<any> {
    return {
      "namespace": "AWS/ApiGateway",
      "metricName": "4XXError",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static _5XxErrorSum(dimensions: { ApiName: string; Stage: string; }): MetricWithDims<{ ApiName: string; Stage: string; }>;

  public static _5XxErrorSum(dimensions: { ApiName: string; }): MetricWithDims<{ ApiName: string; }>;

  public static _5XxErrorSum(dimensions: { ApiName: string; Method: string; Resource: string; Stage: string; }): MetricWithDims<{ ApiName: string; Method: string; Resource: string; Stage: string; }>;

  public static _5XxErrorSum(dimensions: any): MetricWithDims<any> {
    return {
      "namespace": "AWS/ApiGateway",
      "metricName": "5XXError",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static cacheHitCountSum(dimensions: { ApiName: string; Stage: string; }): MetricWithDims<{ ApiName: string; Stage: string; }>;

  public static cacheHitCountSum(dimensions: { ApiName: string; }): MetricWithDims<{ ApiName: string; }>;

  public static cacheHitCountSum(dimensions: { ApiName: string; Method: string; Resource: string; Stage: string; }): MetricWithDims<{ ApiName: string; Method: string; Resource: string; Stage: string; }>;

  public static cacheHitCountSum(dimensions: any): MetricWithDims<any> {
    return {
      "namespace": "AWS/ApiGateway",
      "metricName": "CacheHitCount",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static cacheMissCountSum(dimensions: { ApiName: string; Stage: string; }): MetricWithDims<{ ApiName: string; Stage: string; }>;

  public static cacheMissCountSum(dimensions: { ApiName: string; }): MetricWithDims<{ ApiName: string; }>;

  public static cacheMissCountSum(dimensions: { ApiName: string; Method: string; Resource: string; Stage: string; }): MetricWithDims<{ ApiName: string; Method: string; Resource: string; Stage: string; }>;

  public static cacheMissCountSum(dimensions: any): MetricWithDims<any> {
    return {
      "namespace": "AWS/ApiGateway",
      "metricName": "CacheMissCount",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static countSum(dimensions: { ApiName: string; Stage: string; }): MetricWithDims<{ ApiName: string; Stage: string; }>;

  public static countSum(dimensions: { ApiName: string; }): MetricWithDims<{ ApiName: string; }>;

  public static countSum(dimensions: { ApiName: string; Method: string; Resource: string; Stage: string; }): MetricWithDims<{ ApiName: string; Method: string; Resource: string; Stage: string; }>;

  public static countSum(dimensions: any): MetricWithDims<any> {
    return {
      "namespace": "AWS/ApiGateway",
      "metricName": "Count",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static integrationLatencyAverage(dimensions: { ApiName: string; Stage: string; }): MetricWithDims<{ ApiName: string; Stage: string; }>;

  public static integrationLatencyAverage(dimensions: { ApiName: string; }): MetricWithDims<{ ApiName: string; }>;

  public static integrationLatencyAverage(dimensions: { ApiName: string; Method: string; Resource: string; Stage: string; }): MetricWithDims<{ ApiName: string; Method: string; Resource: string; Stage: string; }>;

  public static integrationLatencyAverage(dimensions: any): MetricWithDims<any> {
    return {
      "namespace": "AWS/ApiGateway",
      "metricName": "IntegrationLatency",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static latencyAverage(dimensions: { ApiName: string; Stage: string; }): MetricWithDims<{ ApiName: string; Stage: string; }>;

  public static latencyAverage(dimensions: { ApiName: string; }): MetricWithDims<{ ApiName: string; }>;

  public static latencyAverage(dimensions: { ApiName: string; Method: string; Resource: string; Stage: string; }): MetricWithDims<{ ApiName: string; Method: string; Resource: string; Stage: string; }>;

  public static latencyAverage(dimensions: any): MetricWithDims<any> {
    return {
      "namespace": "AWS/ApiGateway",
      "metricName": "Latency",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }
}",
  "module": "/* eslint-disable prettier/prettier,max-len */
import * as cdk from "aws-cdk-lib";
import * as constructs from "constructs";
import * as cfn_parse from "aws-cdk-lib/core/lib/helpers-internal";

/**
 * The \`AWS::ApiGateway::RestApi\` resource creates a REST API.
 *
 * For more information, see [restapi:create](https://docs.aws.amazon.com/apigateway/latest/api/API_CreateRestApi.html) in the *Amazon API Gateway REST API Reference* .
 *
 * > On January 1, 2016, the Swagger Specification was donated to the [OpenAPI initiative](https://docs.aws.amazon.com/https://www.openapis.org/) , becoming the foundation of the OpenAPI Specification.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigateway-restapi.html
 */
export class CfnRestApi extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::ApiGateway::RestApi";

  /**
   * Build a CfnRestApi from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnRestApi {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnRestApiPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnRestApi(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The string identifier of the associated RestApi.
   *
   * @cloudformationAttribute RestApiId
   */
  public readonly attrRestApiId: string;

  /**
   * The root resource ID for a \`RestApi\` resource, such as \`a0bc123d4e\` .
   *
   * @cloudformationAttribute RootResourceId
   */
  public readonly attrRootResourceId: string;

  /**
   * The source of the API key for metering requests according to a usage plan.
   */
  public apiKeySourceType?: string;

  /**
   * The list of binary media types supported by the RestApi.
   */
  public binaryMediaTypes?: Array<string>;

  /**
   * An OpenAPI specification that defines a set of RESTful APIs in JSON format.
   */
  public body?: any | cdk.IResolvable;

  /**
   * The Amazon Simple Storage Service (Amazon S3) location that points to an OpenAPI file, which defines a set of RESTful APIs in JSON or YAML format.
   */
  public bodyS3Location?: cdk.IResolvable | CfnRestApi.S3LocationProperty;

  /**
   * The ID of the RestApi that you want to clone from.
   */
  public cloneFrom?: string;

  /**
   * The description of the RestApi.
   */
  public description?: string;

  /**
   * Specifies whether clients can invoke your API by using the default \`execute-api\` endpoint.
   */
  public disableExecuteApiEndpoint?: boolean | cdk.IResolvable;

  /**
   * A list of the endpoint types of the API.
   */
  public endpointConfiguration?: CfnRestApi.EndpointConfigurationProperty | cdk.IResolvable;

  /**
   * A query parameter to indicate whether to rollback the API update ( \`true\` ) or not ( \`false\` ) when a warning is encountered.
   */
  public failOnWarnings?: boolean | cdk.IResolvable;

  /**
   * A nullable integer that is used to enable compression (with non-negative between 0 and 10485760 (10M) bytes, inclusive) or disable compression (with a null value) on an API.
   */
  public minimumCompressionSize?: number;

  /**
   * This property applies only when you use OpenAPI to define your REST API.
   */
  public mode?: string;

  /**
   * The name of the RestApi.
   */
  public name?: string;

  /**
   * Custom header parameters as part of the request.
   */
  public parameters?: cdk.IResolvable | Record<string, string>;

  /**
   * A policy document that contains the permissions for the \`RestApi\` resource.
   */
  public policy?: any | cdk.IResolvable;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The key-value map of strings.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnRestApiProps = {}) {
    super(scope, id, {
      "type": CfnRestApi.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.attrRestApiId = cdk.Token.asString(this.getAtt("RestApiId", cdk.ResolutionTypeHint.STRING));
    this.attrRootResourceId = cdk.Token.asString(this.getAtt("RootResourceId", cdk.ResolutionTypeHint.STRING));
    this.apiKeySourceType = props.apiKeySourceType;
    this.binaryMediaTypes = props.binaryMediaTypes;
    this.body = props.body;
    this.bodyS3Location = props.bodyS3Location;
    this.cloneFrom = props.cloneFrom;
    this.description = props.description;
    this.disableExecuteApiEndpoint = props.disableExecuteApiEndpoint;
    this.endpointConfiguration = props.endpointConfiguration;
    this.failOnWarnings = props.failOnWarnings;
    this.minimumCompressionSize = props.minimumCompressionSize;
    this.mode = props.mode;
    this.name = props.name;
    this.parameters = props.parameters;
    this.policy = props.policy;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::ApiGateway::RestApi", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "apiKeySourceType": this.apiKeySourceType,
      "binaryMediaTypes": this.binaryMediaTypes,
      "body": this.body,
      "bodyS3Location": this.bodyS3Location,
      "cloneFrom": this.cloneFrom,
      "description": this.description,
      "disableExecuteApiEndpoint": this.disableExecuteApiEndpoint,
      "endpointConfiguration": this.endpointConfiguration,
      "failOnWarnings": this.failOnWarnings,
      "minimumCompressionSize": this.minimumCompressionSize,
      "mode": this.mode,
      "name": this.name,
      "parameters": this.parameters,
      "policy": this.policy,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnRestApi.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnRestApiPropsToCloudFormation(props);
  }
}

export namespace CfnRestApi {
  /**
   * \`S3Location\` is a property of the [AWS::ApiGateway::RestApi](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigateway-restapi.html) resource that specifies the Amazon S3 location of a OpenAPI (formerly Swagger) file that defines a set of RESTful APIs in JSON or YAML.
   *
   * > On January 1, 2016, the Swagger Specification was donated to the [OpenAPI initiative](https://docs.aws.amazon.com/https://www.openapis.org/) , becoming the foundation of the OpenAPI Specification.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apigateway-restapi-s3location.html
   */
  export interface S3LocationProperty {
    /**
     * The name of the S3 bucket where the OpenAPI file is stored.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apigateway-restapi-s3location.html#cfn-apigateway-restapi-s3location-bucket
     */
    readonly bucket?: string;

    /**
     * The Amazon S3 ETag (a file checksum) of the OpenAPI file.
     *
     * If you don't specify a value, API Gateway skips ETag validation of your OpenAPI file.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apigateway-restapi-s3location.html#cfn-apigateway-restapi-s3location-etag
     */
    readonly eTag?: string;

    /**
     * The file name of the OpenAPI file (Amazon S3 object name).
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apigateway-restapi-s3location.html#cfn-apigateway-restapi-s3location-key
     */
    readonly key?: string;

    /**
     * For versioning-enabled buckets, a specific version of the OpenAPI file.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apigateway-restapi-s3location.html#cfn-apigateway-restapi-s3location-version
     */
    readonly version?: string;
  }

  /**
   * The \`EndpointConfiguration\` property type specifies the endpoint types of a REST API.
   *
   * \`EndpointConfiguration\` is a property of the [AWS::ApiGateway::RestApi](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigateway-restapi.html) resource.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apigateway-restapi-endpointconfiguration.html
   */
  export interface EndpointConfigurationProperty {
    /**
     * A list of endpoint types of an API (RestApi) or its custom domain name (DomainName).
     *
     * For an edge-optimized API and its custom domain name, the endpoint type is \`"EDGE"\` . For a regional API and its custom domain name, the endpoint type is \`REGIONAL\` . For a private API, the endpoint type is \`PRIVATE\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apigateway-restapi-endpointconfiguration.html#cfn-apigateway-restapi-endpointconfiguration-types
     */
    readonly types?: Array<string>;

    /**
     * A list of VpcEndpointIds of an API (RestApi) against which to create Route53 ALIASes.
     *
     * It is only supported for \`PRIVATE\` endpoint type.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apigateway-restapi-endpointconfiguration.html#cfn-apigateway-restapi-endpointconfiguration-vpcendpointids
     */
    readonly vpcEndpointIds?: Array<string>;
  }
}

/**
 * Properties for defining a \`CfnRestApi\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigateway-restapi.html
 */
export interface CfnRestApiProps {
  /**
   * The source of the API key for metering requests according to a usage plan.
   *
   * Valid values are: \`HEADER\` to read the API key from the \`X-API-Key\` header of a request. \`AUTHORIZER\` to read the API key from the \`UsageIdentifierKey\` from a custom authorizer.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigateway-restapi.html#cfn-apigateway-restapi-apikeysourcetype
   */
  readonly apiKeySourceType?: string;

  /**
   * The list of binary media types supported by the RestApi.
   *
   * By default, the RestApi supports only UTF-8-encoded text payloads.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigateway-restapi.html#cfn-apigateway-restapi-binarymediatypes
   */
  readonly binaryMediaTypes?: Array<string>;

  /**
   * An OpenAPI specification that defines a set of RESTful APIs in JSON format.
   *
   * For YAML templates, you can also provide the specification in YAML format.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigateway-restapi.html#cfn-apigateway-restapi-body
   */
  readonly body?: any | cdk.IResolvable;

  /**
   * The Amazon Simple Storage Service (Amazon S3) location that points to an OpenAPI file, which defines a set of RESTful APIs in JSON or YAML format.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigateway-restapi.html#cfn-apigateway-restapi-bodys3location
   */
  readonly bodyS3Location?: cdk.IResolvable | CfnRestApi.S3LocationProperty;

  /**
   * The ID of the RestApi that you want to clone from.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigateway-restapi.html#cfn-apigateway-restapi-clonefrom
   */
  readonly cloneFrom?: string;

  /**
   * The description of the RestApi.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigateway-restapi.html#cfn-apigateway-restapi-description
   */
  readonly description?: string;

  /**
   * Specifies whether clients can invoke your API by using the default \`execute-api\` endpoint.
   *
   * By default, clients can invoke your API with the default \`https://{api_id}.execute-api.{region}.amazonaws.com\` endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigateway-restapi.html#cfn-apigateway-restapi-disableexecuteapiendpoint
   */
  readonly disableExecuteApiEndpoint?: boolean | cdk.IResolvable;

  /**
   * A list of the endpoint types of the API.
   *
   * Use this property when creating an API. When importing an existing API, specify the endpoint configuration types using the \`Parameters\` property.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigateway-restapi.html#cfn-apigateway-restapi-endpointconfiguration
   */
  readonly endpointConfiguration?: CfnRestApi.EndpointConfigurationProperty | cdk.IResolvable;

  /**
   * A query parameter to indicate whether to rollback the API update ( \`true\` ) or not ( \`false\` ) when a warning is encountered.
   *
   * The default value is \`false\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigateway-restapi.html#cfn-apigateway-restapi-failonwarnings
   */
  readonly failOnWarnings?: boolean | cdk.IResolvable;

  /**
   * A nullable integer that is used to enable compression (with non-negative between 0 and 10485760 (10M) bytes, inclusive) or disable compression (with a null value) on an API.
   *
   * When compression is enabled, compression or decompression is not applied on the payload if the payload size is smaller than this value. Setting it to zero allows compression for any payload size.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigateway-restapi.html#cfn-apigateway-restapi-minimumcompressionsize
   */
  readonly minimumCompressionSize?: number;

  /**
   * This property applies only when you use OpenAPI to define your REST API.
   *
   * The \`Mode\` determines how API Gateway handles resource updates.
   *
   * Valid values are \`overwrite\` or \`merge\` .
   *
   * For \`overwrite\` , the new API definition replaces the existing one. The existing API identifier remains unchanged.
   *
   * For \`merge\` , the new API definition is merged with the existing API.
   *
   * If you don't specify this property, a default value is chosen. For REST APIs created before March 29, 2021, the default is \`overwrite\` . For REST APIs created after March 29, 2021, the new API definition takes precedence, but any container types such as endpoint configurations and binary media types are merged with the existing API.
   *
   * Use the default mode to define top-level \`RestApi\` properties in addition to using OpenAPI. Generally, it's preferred to use API Gateway's OpenAPI extensions to model these properties.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigateway-restapi.html#cfn-apigateway-restapi-mode
   */
  readonly mode?: string;

  /**
   * The name of the RestApi.
   *
   * A name is required if the REST API is not based on an OpenAPI specification.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigateway-restapi.html#cfn-apigateway-restapi-name
   */
  readonly name?: string;

  /**
   * Custom header parameters as part of the request.
   *
   * For example, to exclude DocumentationParts from an imported API, set \`ignore=documentation\` as a \`parameters\` value, as in the AWS CLI command of \`aws apigateway import-rest-api --parameters ignore=documentation --body 'file:///path/to/imported-api-body.json'\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigateway-restapi.html#cfn-apigateway-restapi-parameters
   */
  readonly parameters?: cdk.IResolvable | Record<string, string>;

  /**
   * A policy document that contains the permissions for the \`RestApi\` resource.
   *
   * To set the ARN for the policy, use the \`!Join\` intrinsic function with \`""\` as delimiter and values of \`"execute-api:/"\` and \`"*"\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigateway-restapi.html#cfn-apigateway-restapi-policy
   */
  readonly policy?: any | cdk.IResolvable;

  /**
   * The key-value map of strings.
   *
   * The valid character set is [a-zA-Z+-=._:/]. The tag key can be up to 128 characters and must not start with \`aws:\` . The tag value can be up to 256 characters.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigateway-restapi.html#cfn-apigateway-restapi-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a \`S3LocationProperty\`
 *
 * @param properties - the TypeScript properties of a \`S3LocationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnRestApiS3LocationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("bucket", cdk.validateString)(properties.bucket));
  errors.collect(cdk.propertyValidator("eTag", cdk.validateString)(properties.eTag));
  errors.collect(cdk.propertyValidator("key", cdk.validateString)(properties.key));
  errors.collect(cdk.propertyValidator("version", cdk.validateString)(properties.version));
  return errors.wrap("supplied properties not correct for \\"S3LocationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnRestApiS3LocationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnRestApiS3LocationPropertyValidator(properties).assertSuccess();
  return {
    "Bucket": cdk.stringToCloudFormation(properties.bucket),
    "ETag": cdk.stringToCloudFormation(properties.eTag),
    "Key": cdk.stringToCloudFormation(properties.key),
    "Version": cdk.stringToCloudFormation(properties.version)
  };
}

// @ts-ignore TS6133
function CfnRestApiS3LocationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnRestApi.S3LocationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnRestApi.S3LocationProperty>();
  ret.addPropertyResult("bucket", "Bucket", (properties.Bucket != null ? cfn_parse.FromCloudFormation.getString(properties.Bucket) : undefined));
  ret.addPropertyResult("eTag", "ETag", (properties.ETag != null ? cfn_parse.FromCloudFormation.getString(properties.ETag) : undefined));
  ret.addPropertyResult("key", "Key", (properties.Key != null ? cfn_parse.FromCloudFormation.getString(properties.Key) : undefined));
  ret.addPropertyResult("version", "Version", (properties.Version != null ? cfn_parse.FromCloudFormation.getString(properties.Version) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`EndpointConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`EndpointConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnRestApiEndpointConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("types", cdk.listValidator(cdk.validateString))(properties.types));
  errors.collect(cdk.propertyValidator("vpcEndpointIds", cdk.listValidator(cdk.validateString))(properties.vpcEndpointIds));
  return errors.wrap("supplied properties not correct for \\"EndpointConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnRestApiEndpointConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnRestApiEndpointConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "Types": cdk.listMapper(cdk.stringToCloudFormation)(properties.types),
    "VpcEndpointIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.vpcEndpointIds)
  };
}

// @ts-ignore TS6133
function CfnRestApiEndpointConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnRestApi.EndpointConfigurationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnRestApi.EndpointConfigurationProperty>();
  ret.addPropertyResult("types", "Types", (properties.Types != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.Types) : undefined));
  ret.addPropertyResult("vpcEndpointIds", "VpcEndpointIds", (properties.VpcEndpointIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.VpcEndpointIds) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnRestApiProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnRestApiProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnRestApiPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("apiKeySourceType", cdk.validateString)(properties.apiKeySourceType));
  errors.collect(cdk.propertyValidator("binaryMediaTypes", cdk.listValidator(cdk.validateString))(properties.binaryMediaTypes));
  errors.collect(cdk.propertyValidator("body", cdk.validateObject)(properties.body));
  errors.collect(cdk.propertyValidator("bodyS3Location", CfnRestApiS3LocationPropertyValidator)(properties.bodyS3Location));
  errors.collect(cdk.propertyValidator("cloneFrom", cdk.validateString)(properties.cloneFrom));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("disableExecuteApiEndpoint", cdk.validateBoolean)(properties.disableExecuteApiEndpoint));
  errors.collect(cdk.propertyValidator("endpointConfiguration", CfnRestApiEndpointConfigurationPropertyValidator)(properties.endpointConfiguration));
  errors.collect(cdk.propertyValidator("failOnWarnings", cdk.validateBoolean)(properties.failOnWarnings));
  errors.collect(cdk.propertyValidator("minimumCompressionSize", cdk.validateNumber)(properties.minimumCompressionSize));
  errors.collect(cdk.propertyValidator("mode", cdk.validateString)(properties.mode));
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  errors.collect(cdk.propertyValidator("parameters", cdk.hashValidator(cdk.validateString))(properties.parameters));
  errors.collect(cdk.propertyValidator("policy", cdk.validateObject)(properties.policy));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnRestApiProps\\"");
}

// @ts-ignore TS6133
function convertCfnRestApiPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnRestApiPropsValidator(properties).assertSuccess();
  return {
    "ApiKeySourceType": cdk.stringToCloudFormation(properties.apiKeySourceType),
    "BinaryMediaTypes": cdk.listMapper(cdk.stringToCloudFormation)(properties.binaryMediaTypes),
    "Body": cdk.objectToCloudFormation(properties.body),
    "BodyS3Location": convertCfnRestApiS3LocationPropertyToCloudFormation(properties.bodyS3Location),
    "CloneFrom": cdk.stringToCloudFormation(properties.cloneFrom),
    "Description": cdk.stringToCloudFormation(properties.description),
    "DisableExecuteApiEndpoint": cdk.booleanToCloudFormation(properties.disableExecuteApiEndpoint),
    "EndpointConfiguration": convertCfnRestApiEndpointConfigurationPropertyToCloudFormation(properties.endpointConfiguration),
    "FailOnWarnings": cdk.booleanToCloudFormation(properties.failOnWarnings),
    "MinimumCompressionSize": cdk.numberToCloudFormation(properties.minimumCompressionSize),
    "Mode": cdk.stringToCloudFormation(properties.mode),
    "Name": cdk.stringToCloudFormation(properties.name),
    "Parameters": cdk.hashMapper(cdk.stringToCloudFormation)(properties.parameters),
    "Policy": cdk.objectToCloudFormation(properties.policy),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnRestApiPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnRestApiProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnRestApiProps>();
  ret.addPropertyResult("apiKeySourceType", "ApiKeySourceType", (properties.ApiKeySourceType != null ? cfn_parse.FromCloudFormation.getString(properties.ApiKeySourceType) : undefined));
  ret.addPropertyResult("binaryMediaTypes", "BinaryMediaTypes", (properties.BinaryMediaTypes != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.BinaryMediaTypes) : undefined));
  ret.addPropertyResult("body", "Body", (properties.Body != null ? cfn_parse.FromCloudFormation.getAny(properties.Body) : undefined));
  ret.addPropertyResult("bodyS3Location", "BodyS3Location", (properties.BodyS3Location != null ? CfnRestApiS3LocationPropertyFromCloudFormation(properties.BodyS3Location) : undefined));
  ret.addPropertyResult("cloneFrom", "CloneFrom", (properties.CloneFrom != null ? cfn_parse.FromCloudFormation.getString(properties.CloneFrom) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("disableExecuteApiEndpoint", "DisableExecuteApiEndpoint", (properties.DisableExecuteApiEndpoint != null ? cfn_parse.FromCloudFormation.getBoolean(properties.DisableExecuteApiEndpoint) : undefined));
  ret.addPropertyResult("endpointConfiguration", "EndpointConfiguration", (properties.EndpointConfiguration != null ? CfnRestApiEndpointConfigurationPropertyFromCloudFormation(properties.EndpointConfiguration) : undefined));
  ret.addPropertyResult("failOnWarnings", "FailOnWarnings", (properties.FailOnWarnings != null ? cfn_parse.FromCloudFormation.getBoolean(properties.FailOnWarnings) : undefined));
  ret.addPropertyResult("minimumCompressionSize", "MinimumCompressionSize", (properties.MinimumCompressionSize != null ? cfn_parse.FromCloudFormation.getNumber(properties.MinimumCompressionSize) : undefined));
  ret.addPropertyResult("mode", "Mode", (properties.Mode != null ? cfn_parse.FromCloudFormation.getString(properties.Mode) : undefined));
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addPropertyResult("parameters", "Parameters", (properties.Parameters != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getString)(properties.Parameters) : undefined));
  ret.addPropertyResult("policy", "Policy", (properties.Policy != null ? cfn_parse.FromCloudFormation.getAny(properties.Policy) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}",
}
`;

exports[`AWS::IAM::Role 1`] = `
{
  "augmentations": undefined,
  "metrics": undefined,
  "module": "/* eslint-disable prettier/prettier,max-len */
import * as cdk from "aws-cdk-lib";
import * as constructs from "constructs";
import * as cfn_parse from "aws-cdk-lib/core/lib/helpers-internal";

/**
 * Creates a new role for your AWS account .
 *
 * For more information about roles, see [IAM roles](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles.html) in the *IAM User Guide* . For information about quotas for role names and the number of roles you can create, see [IAM and AWS STS quotas](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-quotas.html) in the *IAM User Guide* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-role.html
 */
export class CfnRole extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::IAM::Role";

  /**
   * Build a CfnRole from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnRole {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnRolePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnRole(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * Returns the Amazon Resource Name (ARN) for the role. For example:
   *
   * \`{"Fn::GetAtt" : ["MyRole", "Arn"] }\`
   *
   * This will return a value such as \`arn:aws:iam::1234567890:role/MyRole-AJJHDSKSDF\` .
   *
   * @cloudformationAttribute Arn
   */
  public readonly attrArn: string;

  /**
   * Returns the stable and unique string identifying the role. For example, \`AIDAJQABLZS4A3QDU576Q\` .
   *
   * For more information about IDs, see [IAM Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html) in the *IAM User Guide* .
   *
   * @cloudformationAttribute RoleId
   */
  public readonly attrRoleId: string;

  /**
   * The trust policy that is associated with this role.
   */
  public assumeRolePolicyDocument: any | cdk.IResolvable;

  /**
   * A description of the role that you provide.
   */
  public description?: string;

  /**
   * A list of Amazon Resource Names (ARNs) of the IAM managed policies that you want to attach to the role.
   */
  public managedPolicyArns?: Array<string>;

  /**
   * The maximum session duration (in seconds) that you want to set for the specified role.
   */
  public maxSessionDuration?: number;

  /**
   * The path to the role. For more information about paths, see [IAM Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the *IAM User Guide* .
   */
  public path?: string;

  /**
   * The ARN of the policy used to set the permissions boundary for the role.
   */
  public permissionsBoundary?: string;

  /**
   * Adds or updates an inline policy document that is embedded in the specified IAM role.
   */
  public policies?: Array<cdk.IResolvable | CfnRole.PolicyProperty> | cdk.IResolvable;

  /**
   * A name for the IAM role, up to 64 characters in length.
   */
  public roleName?: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * A list of tags that are attached to the role.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnRoleProps) {
    super(scope, id, {
      "type": CfnRole.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "assumeRolePolicyDocument", this);

    this.attrArn = cdk.Token.asString(this.getAtt("Arn", cdk.ResolutionTypeHint.STRING));
    this.attrRoleId = cdk.Token.asString(this.getAtt("RoleId", cdk.ResolutionTypeHint.STRING));
    this.assumeRolePolicyDocument = props.assumeRolePolicyDocument;
    this.description = props.description;
    this.managedPolicyArns = props.managedPolicyArns;
    this.maxSessionDuration = props.maxSessionDuration;
    this.path = props.path;
    this.permissionsBoundary = props.permissionsBoundary;
    this.policies = props.policies;
    this.roleName = props.roleName;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::IAM::Role", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "assumeRolePolicyDocument": this.assumeRolePolicyDocument,
      "description": this.description,
      "managedPolicyArns": this.managedPolicyArns,
      "maxSessionDuration": this.maxSessionDuration,
      "path": this.path,
      "permissionsBoundary": this.permissionsBoundary,
      "policies": this.policies,
      "roleName": this.roleName,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnRole.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnRolePropsToCloudFormation(props);
  }
}

export namespace CfnRole {
  /**
   * Contains information about an attached policy.
   *
   * An attached policy is a managed policy that has been attached to a user, group, or role.
   *
   * For more information about managed policies, refer to [Managed Policies and Inline Policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-vs-inline.html) in the *IAM User Guide* .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iam-role-policy.html
   */
  export interface PolicyProperty {
    /**
     * The entire contents of the policy that defines permissions.
     *
     * For more information, see [Overview of JSON policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#access_policies-json) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iam-role-policy.html#cfn-iam-role-policy-policydocument
     */
    readonly policyDocument: any | cdk.IResolvable;

    /**
     * The friendly name (not ARN) identifying the policy.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iam-role-policy.html#cfn-iam-role-policy-policyname
     */
    readonly policyName: string;
  }
}

/**
 * Properties for defining a \`CfnRole\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-role.html
 */
export interface CfnRoleProps {
  /**
   * The trust policy that is associated with this role.
   *
   * Trust policies define which entities can assume the role. You can associate only one trust policy with a role. For an example of a policy that can be used to assume a role, see [Template Examples](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-role.html#aws-resource-iam-role--examples) . For more information about the elements that you can use in an IAM policy, see [IAM Policy Elements Reference](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements.html) in the *IAM User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-role.html#cfn-iam-role-assumerolepolicydocument
   */
  readonly assumeRolePolicyDocument: any | cdk.IResolvable;

  /**
   * A description of the role that you provide.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-role.html#cfn-iam-role-description
   */
  readonly description?: string;

  /**
   * A list of Amazon Resource Names (ARNs) of the IAM managed policies that you want to attach to the role.
   *
   * For more information about ARNs, see [Amazon Resource Names (ARNs) and AWS Service Namespaces](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the *AWS General Reference* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-role.html#cfn-iam-role-managedpolicyarns
   */
  readonly managedPolicyArns?: Array<string>;

  /**
   * The maximum session duration (in seconds) that you want to set for the specified role.
   *
   * If you do not specify a value for this setting, the default value of one hour is applied. This setting can have a value from 1 hour to 12 hours.
   *
   * Anyone who assumes the role from the AWS CLI or API can use the \`DurationSeconds\` API parameter or the \`duration-seconds\` AWS CLI parameter to request a longer session. The \`MaxSessionDuration\` setting determines the maximum duration that can be requested using the \`DurationSeconds\` parameter. If users don't specify a value for the \`DurationSeconds\` parameter, their security credentials are valid for one hour by default. This applies when you use the \`AssumeRole*\` API operations or the \`assume-role*\` AWS CLI operations but does not apply when you use those operations to create a console URL. For more information, see [Using IAM roles](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use.html) in the *IAM User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-role.html#cfn-iam-role-maxsessionduration
   */
  readonly maxSessionDuration?: number;

  /**
   * The path to the role. For more information about paths, see [IAM Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the *IAM User Guide* .
   *
   * This parameter is optional. If it is not included, it defaults to a slash (/).
   *
   * This parameter allows (through its [regex pattern](https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex) ) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! ( \`\\u0021\` ) through the DEL character ( \`\\u007F\` ), including most punctuation characters, digits, and upper and lowercased letters.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-role.html#cfn-iam-role-path
   */
  readonly path?: string;

  /**
   * The ARN of the policy used to set the permissions boundary for the role.
   *
   * For more information about permissions boundaries, see [Permissions boundaries for IAM identities](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html) in the *IAM User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-role.html#cfn-iam-role-permissionsboundary
   */
  readonly permissionsBoundary?: string;

  /**
   * Adds or updates an inline policy document that is embedded in the specified IAM role.
   *
   * When you embed an inline policy in a role, the inline policy is used as part of the role's access (permissions) policy. The role's trust policy is created at the same time as the role. You can update a role's trust policy later. For more information about IAM roles, go to [Using Roles to Delegate Permissions and Federate Identities](https://docs.aws.amazon.com/IAM/latest/UserGuide/roles-toplevel.html) .
   *
   * A role can also have an attached managed policy. For information about policies, see [Managed Policies and Inline Policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-vs-inline.html) in the *IAM User Guide* .
   *
   * For information about limits on the number of inline policies that you can embed with a role, see [Limitations on IAM Entities](https://docs.aws.amazon.com/IAM/latest/UserGuide/LimitationsOnEntities.html) in the *IAM User Guide* .
   *
   * > If an external policy (such as \`AWS::IAM::Policy\` or \`AWS::IAM::ManagedPolicy\` ) has a \`Ref\` to a role and if a resource (such as \`AWS::ECS::Service\` ) also has a \`Ref\` to the same role, add a \`DependsOn\` attribute to the resource to make the resource depend on the external policy. This dependency ensures that the role's policy is available throughout the resource's lifecycle. For example, when you delete a stack with an \`AWS::ECS::Service\` resource, the \`DependsOn\` attribute ensures that AWS CloudFormation deletes the \`AWS::ECS::Service\` resource before deleting its role's policy.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-role.html#cfn-iam-role-policies
   */
  readonly policies?: Array<cdk.IResolvable | CfnRole.PolicyProperty> | cdk.IResolvable;

  /**
   * A name for the IAM role, up to 64 characters in length.
   *
   * For valid values, see the \`RoleName\` parameter for the [\`CreateRole\`](https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreateRole.html) action in the *IAM User Guide* .
   *
   * This parameter allows (per its [regex pattern](https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex) ) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-. The role name must be unique within the account. Role names are not distinguished by case. For example, you cannot create roles named both "Role1" and "role1".
   *
   * If you don't specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the role name.
   *
   * If you specify a name, you must specify the \`CAPABILITY_NAMED_IAM\` value to acknowledge your template's capabilities. For more information, see [Acknowledging IAM Resources in AWS CloudFormation Templates](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-iam-template.html#using-iam-capabilities) .
   *
   * > Naming an IAM resource can cause an unrecoverable error if you reuse the same template in multiple Regions. To prevent this, we recommend using \`Fn::Join\` and \`AWS::Region\` to create a Region-specific name, as in the following example: \`{"Fn::Join": ["", [{"Ref": "AWS::Region"}, {"Ref": "MyResourceName"}]]}\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-role.html#cfn-iam-role-rolename
   */
  readonly roleName?: string;

  /**
   * A list of tags that are attached to the role.
   *
   * For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the *IAM User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-role.html#cfn-iam-role-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a \`PolicyProperty\`
 *
 * @param properties - the TypeScript properties of a \`PolicyProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnRolePolicyPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("policyDocument", cdk.requiredValidator)(properties.policyDocument));
  errors.collect(cdk.propertyValidator("policyDocument", cdk.validateObject)(properties.policyDocument));
  errors.collect(cdk.propertyValidator("policyName", cdk.requiredValidator)(properties.policyName));
  errors.collect(cdk.propertyValidator("policyName", cdk.validateString)(properties.policyName));
  return errors.wrap("supplied properties not correct for \\"PolicyProperty\\"");
}

// @ts-ignore TS6133
function convertCfnRolePolicyPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnRolePolicyPropertyValidator(properties).assertSuccess();
  return {
    "PolicyDocument": cdk.objectToCloudFormation(properties.policyDocument),
    "PolicyName": cdk.stringToCloudFormation(properties.policyName)
  };
}

// @ts-ignore TS6133
function CfnRolePolicyPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnRole.PolicyProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnRole.PolicyProperty>();
  ret.addPropertyResult("policyDocument", "PolicyDocument", (properties.PolicyDocument != null ? cfn_parse.FromCloudFormation.getAny(properties.PolicyDocument) : undefined));
  ret.addPropertyResult("policyName", "PolicyName", (properties.PolicyName != null ? cfn_parse.FromCloudFormation.getString(properties.PolicyName) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnRoleProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnRoleProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnRolePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("assumeRolePolicyDocument", cdk.requiredValidator)(properties.assumeRolePolicyDocument));
  errors.collect(cdk.propertyValidator("assumeRolePolicyDocument", cdk.validateObject)(properties.assumeRolePolicyDocument));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("managedPolicyArns", cdk.listValidator(cdk.validateString))(properties.managedPolicyArns));
  errors.collect(cdk.propertyValidator("maxSessionDuration", cdk.validateNumber)(properties.maxSessionDuration));
  errors.collect(cdk.propertyValidator("path", cdk.validateString)(properties.path));
  errors.collect(cdk.propertyValidator("permissionsBoundary", cdk.validateString)(properties.permissionsBoundary));
  errors.collect(cdk.propertyValidator("policies", cdk.listValidator(CfnRolePolicyPropertyValidator))(properties.policies));
  errors.collect(cdk.propertyValidator("roleName", cdk.validateString)(properties.roleName));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnRoleProps\\"");
}

// @ts-ignore TS6133
function convertCfnRolePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnRolePropsValidator(properties).assertSuccess();
  return {
    "AssumeRolePolicyDocument": cdk.objectToCloudFormation(properties.assumeRolePolicyDocument),
    "Description": cdk.stringToCloudFormation(properties.description),
    "ManagedPolicyArns": cdk.listMapper(cdk.stringToCloudFormation)(properties.managedPolicyArns),
    "MaxSessionDuration": cdk.numberToCloudFormation(properties.maxSessionDuration),
    "Path": cdk.stringToCloudFormation(properties.path),
    "PermissionsBoundary": cdk.stringToCloudFormation(properties.permissionsBoundary),
    "Policies": cdk.listMapper(convertCfnRolePolicyPropertyToCloudFormation)(properties.policies),
    "RoleName": cdk.stringToCloudFormation(properties.roleName),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnRolePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnRoleProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnRoleProps>();
  ret.addPropertyResult("assumeRolePolicyDocument", "AssumeRolePolicyDocument", (properties.AssumeRolePolicyDocument != null ? cfn_parse.FromCloudFormation.getAny(properties.AssumeRolePolicyDocument) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("managedPolicyArns", "ManagedPolicyArns", (properties.ManagedPolicyArns != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.ManagedPolicyArns) : undefined));
  ret.addPropertyResult("maxSessionDuration", "MaxSessionDuration", (properties.MaxSessionDuration != null ? cfn_parse.FromCloudFormation.getNumber(properties.MaxSessionDuration) : undefined));
  ret.addPropertyResult("path", "Path", (properties.Path != null ? cfn_parse.FromCloudFormation.getString(properties.Path) : undefined));
  ret.addPropertyResult("permissionsBoundary", "PermissionsBoundary", (properties.PermissionsBoundary != null ? cfn_parse.FromCloudFormation.getString(properties.PermissionsBoundary) : undefined));
  ret.addPropertyResult("policies", "Policies", (properties.Policies != null ? cfn_parse.FromCloudFormation.getArray(CfnRolePolicyPropertyFromCloudFormation)(properties.Policies) : undefined));
  ret.addPropertyResult("roleName", "RoleName", (properties.RoleName != null ? cfn_parse.FromCloudFormation.getString(properties.RoleName) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}",
}
`;

exports[`AWS::Lambda::Function 1`] = `
{
  "augmentations": "// Copyright 2012-2023 Amazon.com, Inc. or its affiliates. All Rights Reserved.
/* eslint-disable prettier/prettier,max-len */
import * as cw from "aws-cdk-lib/aws-cloudwatch";
import { FunctionBase } from "./function-base";

declare module "./function-base" {
  interface IFunction {
    /**
     * Return the given named metric for this Function
     */
    metric(metricName: string, props?: cw.MetricOptions): cw.Metric;

    /**
     * How often this Lambda is throttled
     *
     * Sum over 5 minutes
     */
    metricThrottles(props?: cw.MetricOptions): cw.Metric;

    /**
     * How often this Lambda is invoked
     *
     * Sum over 5 minutes
     */
    metricInvocations(props?: cw.MetricOptions): cw.Metric;

    /**
     * How many invocations of this Lambda fail
     *
     * Sum over 5 minutes
     */
    metricErrors(props?: cw.MetricOptions): cw.Metric;

    /**
     * How long execution of this Lambda takes
     *
     * Average over 5 minutes
     */
    metricDuration(props?: cw.MetricOptions): cw.Metric;
  }
}



declare module "./function-base" {
  interface FunctionBase {
    /**
     * Return the given named metric for this Function
     */
    metric(metricName: string, props?: cw.MetricOptions): cw.Metric;

    /**
     * How often this Lambda is throttled
     *
     * Sum over 5 minutes
     */
    metricThrottles(props?: cw.MetricOptions): cw.Metric;

    /**
     * How often this Lambda is invoked
     *
     * Sum over 5 minutes
     */
    metricInvocations(props?: cw.MetricOptions): cw.Metric;

    /**
     * How many invocations of this Lambda fail
     *
     * Sum over 5 minutes
     */
    metricErrors(props?: cw.MetricOptions): cw.Metric;

    /**
     * How long execution of this Lambda takes
     *
     * Average over 5 minutes
     */
    metricDuration(props?: cw.MetricOptions): cw.Metric;
  }
}

FunctionBase.prototype.metric = function(metricName: string, props?: cw.MetricOptions) {
  return new cw.Metric({
    "namespace": "AWS/Lambda",
    "metricName": metricName,
    "dimensionsMap": {
      "FunctionName": this.functionName
    },
    ...props
  }).attachTo(this);
};
FunctionBase.prototype.metricThrottles = function(props?: cw.MetricOptions) {
  return this.metric("Throttles", {
    "statistic": "Sum",
    ...props
  });
};
FunctionBase.prototype.metricInvocations = function(props?: cw.MetricOptions) {
  return this.metric("Invocations", {
    "statistic": "Sum",
    ...props
  });
};
FunctionBase.prototype.metricErrors = function(props?: cw.MetricOptions) {
  return this.metric("Errors", {
    "statistic": "Sum",
    ...props
  });
};
FunctionBase.prototype.metricDuration = function(props?: cw.MetricOptions) {
  return this.metric("Duration", {
    "statistic": "Average",
    ...props
  });
};",
  "metrics": "/* eslint-disable prettier/prettier,max-len */
export interface MetricWithDims<D> {
  readonly namespace: string;

  readonly metricName: string;

  readonly statistic: string;

  readonly dimensionsMap: D;
}

export class LambdaMetrics {
  public static concurrentExecutionsMaximum(dimensions: { FunctionName: string; }): MetricWithDims<{ FunctionName: string; }>;

  public static concurrentExecutionsMaximum(dimensions: { FunctionName: string; Resource: string; }): MetricWithDims<{ FunctionName: string; Resource: string; }>;

  public static concurrentExecutionsMaximum(dimensions: { ExecutedVersion: string; FunctionName: string; Resource: string; }): MetricWithDims<{ ExecutedVersion: string; FunctionName: string; Resource: string; }>;

  public static concurrentExecutionsMaximum(dimensions: {  }): MetricWithDims<{  }>;

  public static concurrentExecutionsMaximum(dimensions: any): MetricWithDims<any> {
    return {
      "namespace": "AWS/Lambda",
      "metricName": "ConcurrentExecutions",
      "dimensionsMap": dimensions,
      "statistic": "Maximum"
    };
  }

  public static deadLetterErrorsSum(dimensions: { FunctionName: string; }): MetricWithDims<{ FunctionName: string; }>;

  public static deadLetterErrorsSum(dimensions: { FunctionName: string; Resource: string; }): MetricWithDims<{ FunctionName: string; Resource: string; }>;

  public static deadLetterErrorsSum(dimensions: { ExecutedVersion: string; FunctionName: string; Resource: string; }): MetricWithDims<{ ExecutedVersion: string; FunctionName: string; Resource: string; }>;

  public static deadLetterErrorsSum(dimensions: {  }): MetricWithDims<{  }>;

  public static deadLetterErrorsSum(dimensions: any): MetricWithDims<any> {
    return {
      "namespace": "AWS/Lambda",
      "metricName": "DeadLetterErrors",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static destinationDeliveryFailuresSum(dimensions: { FunctionName: string; }): MetricWithDims<{ FunctionName: string; }>;

  public static destinationDeliveryFailuresSum(dimensions: { FunctionName: string; Resource: string; }): MetricWithDims<{ FunctionName: string; Resource: string; }>;

  public static destinationDeliveryFailuresSum(dimensions: { ExecutedVersion: string; FunctionName: string; Resource: string; }): MetricWithDims<{ ExecutedVersion: string; FunctionName: string; Resource: string; }>;

  public static destinationDeliveryFailuresSum(dimensions: {  }): MetricWithDims<{  }>;

  public static destinationDeliveryFailuresSum(dimensions: any): MetricWithDims<any> {
    return {
      "namespace": "AWS/Lambda",
      "metricName": "DestinationDeliveryFailures",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static durationAverage(dimensions: { FunctionName: string; }): MetricWithDims<{ FunctionName: string; }>;

  public static durationAverage(dimensions: { FunctionName: string; Resource: string; }): MetricWithDims<{ FunctionName: string; Resource: string; }>;

  public static durationAverage(dimensions: { ExecutedVersion: string; FunctionName: string; Resource: string; }): MetricWithDims<{ ExecutedVersion: string; FunctionName: string; Resource: string; }>;

  public static durationAverage(dimensions: {  }): MetricWithDims<{  }>;

  public static durationAverage(dimensions: any): MetricWithDims<any> {
    return {
      "namespace": "AWS/Lambda",
      "metricName": "Duration",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static errorsSum(dimensions: { FunctionName: string; }): MetricWithDims<{ FunctionName: string; }>;

  public static errorsSum(dimensions: { FunctionName: string; Resource: string; }): MetricWithDims<{ FunctionName: string; Resource: string; }>;

  public static errorsSum(dimensions: { ExecutedVersion: string; FunctionName: string; Resource: string; }): MetricWithDims<{ ExecutedVersion: string; FunctionName: string; Resource: string; }>;

  public static errorsSum(dimensions: {  }): MetricWithDims<{  }>;

  public static errorsSum(dimensions: any): MetricWithDims<any> {
    return {
      "namespace": "AWS/Lambda",
      "metricName": "Errors",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static invocationsSum(dimensions: { FunctionName: string; }): MetricWithDims<{ FunctionName: string; }>;

  public static invocationsSum(dimensions: { FunctionName: string; Resource: string; }): MetricWithDims<{ FunctionName: string; Resource: string; }>;

  public static invocationsSum(dimensions: { ExecutedVersion: string; FunctionName: string; Resource: string; }): MetricWithDims<{ ExecutedVersion: string; FunctionName: string; Resource: string; }>;

  public static invocationsSum(dimensions: {  }): MetricWithDims<{  }>;

  public static invocationsSum(dimensions: any): MetricWithDims<any> {
    return {
      "namespace": "AWS/Lambda",
      "metricName": "Invocations",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static iteratorAgeAverage(dimensions: { FunctionName: string; }): MetricWithDims<{ FunctionName: string; }>;

  public static iteratorAgeAverage(dimensions: { FunctionName: string; Resource: string; }): MetricWithDims<{ FunctionName: string; Resource: string; }>;

  public static iteratorAgeAverage(dimensions: { ExecutedVersion: string; FunctionName: string; Resource: string; }): MetricWithDims<{ ExecutedVersion: string; FunctionName: string; Resource: string; }>;

  public static iteratorAgeAverage(dimensions: {  }): MetricWithDims<{  }>;

  public static iteratorAgeAverage(dimensions: any): MetricWithDims<any> {
    return {
      "namespace": "AWS/Lambda",
      "metricName": "IteratorAge",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static postRuntimeExtensionsDurationAverage(dimensions: { FunctionName: string; }): MetricWithDims<{ FunctionName: string; }>;

  public static postRuntimeExtensionsDurationAverage(dimensions: { FunctionName: string; Resource: string; }): MetricWithDims<{ FunctionName: string; Resource: string; }>;

  public static postRuntimeExtensionsDurationAverage(dimensions: { ExecutedVersion: string; FunctionName: string; Resource: string; }): MetricWithDims<{ ExecutedVersion: string; FunctionName: string; Resource: string; }>;

  public static postRuntimeExtensionsDurationAverage(dimensions: {  }): MetricWithDims<{  }>;

  public static postRuntimeExtensionsDurationAverage(dimensions: any): MetricWithDims<any> {
    return {
      "namespace": "AWS/Lambda",
      "metricName": "PostRuntimeExtensionsDuration",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static provisionedConcurrencyInvocationsSum(dimensions: { FunctionName: string; }): MetricWithDims<{ FunctionName: string; }>;

  public static provisionedConcurrencyInvocationsSum(dimensions: { FunctionName: string; Resource: string; }): MetricWithDims<{ FunctionName: string; Resource: string; }>;

  public static provisionedConcurrencyInvocationsSum(dimensions: { ExecutedVersion: string; FunctionName: string; Resource: string; }): MetricWithDims<{ ExecutedVersion: string; FunctionName: string; Resource: string; }>;

  public static provisionedConcurrencyInvocationsSum(dimensions: {  }): MetricWithDims<{  }>;

  public static provisionedConcurrencyInvocationsSum(dimensions: any): MetricWithDims<any> {
    return {
      "namespace": "AWS/Lambda",
      "metricName": "ProvisionedConcurrencyInvocations",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static provisionedConcurrencySpilloverInvocationsSum(dimensions: { FunctionName: string; }): MetricWithDims<{ FunctionName: string; }>;

  public static provisionedConcurrencySpilloverInvocationsSum(dimensions: { FunctionName: string; Resource: string; }): MetricWithDims<{ FunctionName: string; Resource: string; }>;

  public static provisionedConcurrencySpilloverInvocationsSum(dimensions: { ExecutedVersion: string; FunctionName: string; Resource: string; }): MetricWithDims<{ ExecutedVersion: string; FunctionName: string; Resource: string; }>;

  public static provisionedConcurrencySpilloverInvocationsSum(dimensions: {  }): MetricWithDims<{  }>;

  public static provisionedConcurrencySpilloverInvocationsSum(dimensions: any): MetricWithDims<any> {
    return {
      "namespace": "AWS/Lambda",
      "metricName": "ProvisionedConcurrencySpilloverInvocations",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static provisionedConcurrencyUtilizationMaximum(dimensions: { FunctionName: string; }): MetricWithDims<{ FunctionName: string; }>;

  public static provisionedConcurrencyUtilizationMaximum(dimensions: { FunctionName: string; Resource: string; }): MetricWithDims<{ FunctionName: string; Resource: string; }>;

  public static provisionedConcurrencyUtilizationMaximum(dimensions: { ExecutedVersion: string; FunctionName: string; Resource: string; }): MetricWithDims<{ ExecutedVersion: string; FunctionName: string; Resource: string; }>;

  public static provisionedConcurrencyUtilizationMaximum(dimensions: {  }): MetricWithDims<{  }>;

  public static provisionedConcurrencyUtilizationMaximum(dimensions: any): MetricWithDims<any> {
    return {
      "namespace": "AWS/Lambda",
      "metricName": "ProvisionedConcurrencyUtilization",
      "dimensionsMap": dimensions,
      "statistic": "Maximum"
    };
  }

  public static provisionedConcurrentExecutionsMaximum(dimensions: { FunctionName: string; }): MetricWithDims<{ FunctionName: string; }>;

  public static provisionedConcurrentExecutionsMaximum(dimensions: { FunctionName: string; Resource: string; }): MetricWithDims<{ FunctionName: string; Resource: string; }>;

  public static provisionedConcurrentExecutionsMaximum(dimensions: { ExecutedVersion: string; FunctionName: string; Resource: string; }): MetricWithDims<{ ExecutedVersion: string; FunctionName: string; Resource: string; }>;

  public static provisionedConcurrentExecutionsMaximum(dimensions: {  }): MetricWithDims<{  }>;

  public static provisionedConcurrentExecutionsMaximum(dimensions: any): MetricWithDims<any> {
    return {
      "namespace": "AWS/Lambda",
      "metricName": "ProvisionedConcurrentExecutions",
      "dimensionsMap": dimensions,
      "statistic": "Maximum"
    };
  }

  public static throttlesSum(dimensions: { FunctionName: string; }): MetricWithDims<{ FunctionName: string; }>;

  public static throttlesSum(dimensions: { FunctionName: string; Resource: string; }): MetricWithDims<{ FunctionName: string; Resource: string; }>;

  public static throttlesSum(dimensions: { ExecutedVersion: string; FunctionName: string; Resource: string; }): MetricWithDims<{ ExecutedVersion: string; FunctionName: string; Resource: string; }>;

  public static throttlesSum(dimensions: {  }): MetricWithDims<{  }>;

  public static throttlesSum(dimensions: any): MetricWithDims<any> {
    return {
      "namespace": "AWS/Lambda",
      "metricName": "Throttles",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static unreservedConcurrentExecutionsMaximum(dimensions: { FunctionName: string; }): MetricWithDims<{ FunctionName: string; }>;

  public static unreservedConcurrentExecutionsMaximum(dimensions: { FunctionName: string; Resource: string; }): MetricWithDims<{ FunctionName: string; Resource: string; }>;

  public static unreservedConcurrentExecutionsMaximum(dimensions: { ExecutedVersion: string; FunctionName: string; Resource: string; }): MetricWithDims<{ ExecutedVersion: string; FunctionName: string; Resource: string; }>;

  public static unreservedConcurrentExecutionsMaximum(dimensions: {  }): MetricWithDims<{  }>;

  public static unreservedConcurrentExecutionsMaximum(dimensions: any): MetricWithDims<any> {
    return {
      "namespace": "AWS/Lambda",
      "metricName": "UnreservedConcurrentExecutions",
      "dimensionsMap": dimensions,
      "statistic": "Maximum"
    };
  }
}",
  "module": "/* eslint-disable prettier/prettier,max-len */
import * as cdk from "aws-cdk-lib";
import * as constructs from "constructs";
import * as cfn_parse from "aws-cdk-lib/core/lib/helpers-internal";

/**
 * The \`AWS::Lambda::Function\` resource creates a Lambda function.
 *
 * To create a function, you need a [deployment package](https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-package.html) and an [execution role](https://docs.aws.amazon.com/lambda/latest/dg/lambda-intro-execution-role.html) . The deployment package is a .zip file archive or container image that contains your function code. The execution role grants the function permission to use AWS services, such as Amazon CloudWatch Logs for log streaming and AWS X-Ray for request tracing.
 *
 * You set the package type to \`Image\` if the deployment package is a [container image](https://docs.aws.amazon.com/lambda/latest/dg/lambda-images.html) . For a container image, the code property must include the URI of a container image in the Amazon ECR registry. You do not need to specify the handler and runtime properties.
 *
 * You set the package type to \`Zip\` if the deployment package is a [.zip file archive](https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-package.html#gettingstarted-package-zip) . For a .zip file archive, the code property specifies the location of the .zip file. You must also specify the handler and runtime properties. For a Python example, see [Deploy Python Lambda functions with .zip file archives](https://docs.aws.amazon.com/lambda/latest/dg/python-package.html) .
 *
 * You can use [code signing](https://docs.aws.amazon.com/lambda/latest/dg/configuration-codesigning.html) if your deployment package is a .zip file archive. To enable code signing for this function, specify the ARN of a code-signing configuration. When a user attempts to deploy a code package with \`UpdateFunctionCode\` , Lambda checks that the code package has a valid signature from a trusted publisher. The code-signing configuration includes a set of signing profiles, which define the trusted publishers for this function.
 *
 * Note that you configure [provisioned concurrency](https://docs.aws.amazon.com/lambda/latest/dg/provisioned-concurrency.html) on a \`AWS::Lambda::Version\` or a \`AWS::Lambda::Alias\` .
 *
 * For a complete introduction to Lambda functions, see [What is Lambda?](https://docs.aws.amazon.com/lambda/latest/dg/lambda-welcome.html) in the *Lambda developer guide.*
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-function.html
 */
export class CfnFunction extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::Lambda::Function";

  /**
   * Build a CfnFunction from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnFunction {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnFunctionPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnFunction(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The Amazon Resource Name (ARN) of the function.
   *
   * @cloudformationAttribute Arn
   */
  public readonly attrArn: string;

  /**
   * The function's SnapStart Response. When set to PublishedVersions, Lambda creates a snapshot of the execution environment when you publish a function version.
   *
   * @cloudformationAttribute SnapStartResponse
   */
  public readonly attrSnapStartResponse: cdk.IResolvable;

  /**
   * Applying SnapStart setting on function resource type.
   *
   * @cloudformationAttribute SnapStartResponse.ApplyOn
   */
  public readonly attrSnapStartResponseApplyOn: string;

  /**
   * Indicates whether SnapStart is activated for the specified function version.
   *
   * @cloudformationAttribute SnapStartResponse.OptimizationStatus
   */
  public readonly attrSnapStartResponseOptimizationStatus: string;

  /**
   * The instruction set architecture that the function supports.
   */
  public architectures?: Array<string>;

  /**
   * The code for the function.
   */
  public code: CfnFunction.CodeProperty | cdk.IResolvable;

  /**
   * To enable code signing for this function, specify the ARN of a code-signing configuration.
   */
  public codeSigningConfigArn?: string;

  /**
   * A dead-letter queue configuration that specifies the queue or topic where Lambda sends asynchronous events when they fail processing.
   */
  public deadLetterConfig?: CfnFunction.DeadLetterConfigProperty | cdk.IResolvable;

  /**
   * A description of the function.
   */
  public description?: string;

  /**
   * Environment variables that are accessible from function code during execution.
   */
  public environment?: CfnFunction.EnvironmentProperty | cdk.IResolvable;

  /**
   * The size of the function's \`/tmp\` directory in MB.
   */
  public ephemeralStorage?: CfnFunction.EphemeralStorageProperty | cdk.IResolvable;

  /**
   * Connection settings for an Amazon EFS file system.
   */
  public fileSystemConfigs?: Array<CfnFunction.FileSystemConfigProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * The name of the Lambda function, up to 64 characters in length.
   */
  public functionName?: string;

  /**
   * The name of the method within your code that Lambda calls to run your function.
   */
  public handler?: string;

  /**
   * Configuration values that override the container image Dockerfile settings.
   */
  public imageConfig?: CfnFunction.ImageConfigProperty | cdk.IResolvable;

  /**
   * The ARN of the AWS Key Management Service ( AWS KMS ) customer managed key that's used to encrypt your function's [environment variables](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html#configuration-envvars-encryption) . When [Lambda SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart-security.html) is activated, Lambda also uses this key is to encrypt your function's snapshot. If you deploy your function using a container image, Lambda also uses this key to encrypt your function when it's deployed. Note that this is not the same key that's used to protect your container image in the Amazon Elastic Container Registry (Amazon ECR). If you don't provide a customer managed key, Lambda uses a default service key.
   */
  public kmsKeyArn?: string;

  /**
   * A list of [function layers](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html) to add to the function's execution environment. Specify each layer by its ARN, including the version.
   */
  public layers?: Array<string>;

  /**
   * The amount of [memory available to the function](https://docs.aws.amazon.com/lambda/latest/dg/configuration-function-common.html#configuration-memory-console) at runtime. Increasing the function memory also increases its CPU allocation. The default value is 128 MB. The value can be any multiple of 1 MB.
   */
  public memorySize?: number;

  /**
   * The type of deployment package.
   */
  public packageType?: string;

  /**
   * The number of simultaneous executions to reserve for the function.
   */
  public reservedConcurrentExecutions?: number;

  /**
   * The Amazon Resource Name (ARN) of the function's execution role.
   */
  public role: string;

  /**
   * The identifier of the function's [runtime](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html) . Runtime is required if the deployment package is a .zip file archive.
   */
  public runtime?: string;

  /**
   * Sets the runtime management configuration for a function's version.
   */
  public runtimeManagementConfig?: cdk.IResolvable | CfnFunction.RuntimeManagementConfigProperty;

  /**
   * The function's [AWS Lambda SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart.html) setting.
   */
  public snapStart?: cdk.IResolvable | CfnFunction.SnapStartProperty;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * A list of [tags](https://docs.aws.amazon.com/lambda/latest/dg/tagging.html) to apply to the function.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The amount of time (in seconds) that Lambda allows a function to run before stopping it.
   */
  public timeout?: number;

  /**
   * Set \`Mode\` to \`Active\` to sample and trace a subset of incoming requests with [X-Ray](https://docs.aws.amazon.com/lambda/latest/dg/services-xray.html) .
   */
  public tracingConfig?: cdk.IResolvable | CfnFunction.TracingConfigProperty;

  /**
   * For network connectivity to AWS resources in a VPC, specify a list of security groups and subnets in the VPC.
   */
  public vpcConfig?: cdk.IResolvable | CfnFunction.VpcConfigProperty;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnFunctionProps) {
    super(scope, id, {
      "type": CfnFunction.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "code", this);
    cdk.requireProperty(props, "role", this);

    this.attrArn = cdk.Token.asString(this.getAtt("Arn", cdk.ResolutionTypeHint.STRING));
    this.attrSnapStartResponse = this.getAtt("SnapStartResponse");
    this.attrSnapStartResponseApplyOn = cdk.Token.asString(this.getAtt("SnapStartResponse.ApplyOn", cdk.ResolutionTypeHint.STRING));
    this.attrSnapStartResponseOptimizationStatus = cdk.Token.asString(this.getAtt("SnapStartResponse.OptimizationStatus", cdk.ResolutionTypeHint.STRING));
    this.architectures = props.architectures;
    this.code = props.code;
    this.codeSigningConfigArn = props.codeSigningConfigArn;
    this.deadLetterConfig = props.deadLetterConfig;
    this.description = props.description;
    this.environment = props.environment;
    this.ephemeralStorage = props.ephemeralStorage;
    this.fileSystemConfigs = props.fileSystemConfigs;
    this.functionName = props.functionName;
    this.handler = props.handler;
    this.imageConfig = props.imageConfig;
    this.kmsKeyArn = props.kmsKeyArn;
    this.layers = props.layers;
    this.memorySize = props.memorySize;
    this.packageType = props.packageType;
    this.reservedConcurrentExecutions = props.reservedConcurrentExecutions;
    this.role = props.role;
    this.runtime = props.runtime;
    this.runtimeManagementConfig = props.runtimeManagementConfig;
    this.snapStart = props.snapStart;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::Lambda::Function", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.timeout = props.timeout;
    this.tracingConfig = props.tracingConfig;
    this.vpcConfig = props.vpcConfig;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "architectures": this.architectures,
      "code": this.code,
      "codeSigningConfigArn": this.codeSigningConfigArn,
      "deadLetterConfig": this.deadLetterConfig,
      "description": this.description,
      "environment": this.environment,
      "ephemeralStorage": this.ephemeralStorage,
      "fileSystemConfigs": this.fileSystemConfigs,
      "functionName": this.functionName,
      "handler": this.handler,
      "imageConfig": this.imageConfig,
      "kmsKeyArn": this.kmsKeyArn,
      "layers": this.layers,
      "memorySize": this.memorySize,
      "packageType": this.packageType,
      "reservedConcurrentExecutions": this.reservedConcurrentExecutions,
      "role": this.role,
      "runtime": this.runtime,
      "runtimeManagementConfig": this.runtimeManagementConfig,
      "snapStart": this.snapStart,
      "tags": this.tags.renderTags(),
      "timeout": this.timeout,
      "tracingConfig": this.tracingConfig,
      "vpcConfig": this.vpcConfig
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnFunction.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnFunctionPropsToCloudFormation(props);
  }
}

export namespace CfnFunction {
  /**
   * The function's [AWS X-Ray](https://docs.aws.amazon.com/lambda/latest/dg/services-xray.html) tracing configuration. To sample and record incoming requests, set \`Mode\` to \`Active\` .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lambda-function-tracingconfig.html
   */
  export interface TracingConfigProperty {
    /**
     * The tracing mode.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lambda-function-tracingconfig.html#cfn-lambda-function-tracingconfig-mode
     */
    readonly mode?: string;
  }

  /**
   * The VPC security groups and subnets that are attached to a Lambda function.
   *
   * When you connect a function to a VPC, Lambda creates an elastic network interface for each combination of security group and subnet in the function's VPC configuration. The function can only access resources and the internet through that VPC. For more information, see [VPC Settings](https://docs.aws.amazon.com/lambda/latest/dg/configuration-vpc.html) .
   *
   * > When you delete a function, AWS CloudFormation monitors the state of its network interfaces and waits for Lambda to delete them before proceeding. If the VPC is defined in the same stack, the network interfaces need to be deleted by Lambda before AWS CloudFormation can delete the VPC's resources.
   * >
   * > To monitor network interfaces, AWS CloudFormation needs the \`ec2:DescribeNetworkInterfaces\` permission. It obtains this from the user or role that modifies the stack. If you don't provide this permission, AWS CloudFormation does not wait for network interfaces to be deleted.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lambda-function-vpcconfig.html
   */
  export interface VpcConfigProperty {
    /**
     * A list of VPC security group IDs.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lambda-function-vpcconfig.html#cfn-lambda-function-vpcconfig-securitygroupids
     */
    readonly securityGroupIds?: Array<string>;

    /**
     * A list of VPC subnet IDs.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lambda-function-vpcconfig.html#cfn-lambda-function-vpcconfig-subnetids
     */
    readonly subnetIds?: Array<string>;
  }

  /**
   * Sets the runtime management configuration for a function's version.
   *
   * For more information, see [Runtime updates](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-update.html) .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lambda-function-runtimemanagementconfig.html
   */
  export interface RuntimeManagementConfigProperty {
    /**
     * The ARN of the runtime version you want the function to use.
     *
     * > This is only required if you're using the *Manual* runtime update mode.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lambda-function-runtimemanagementconfig.html#cfn-lambda-function-runtimemanagementconfig-runtimeversionarn
     */
    readonly runtimeVersionArn?: string;

    /**
     * Specify the runtime update mode.
     *
     * - *Auto (default)* - Automatically update to the most recent and secure runtime version using a [Two-phase runtime version rollout](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-update.html#runtime-management-two-phase) . This is the best choice for most customers to ensure they always benefit from runtime updates.
     * - *FunctionUpdate* - Lambda updates the runtime of you function to the most recent and secure runtime version when you update your function. This approach synchronizes runtime updates with function deployments, giving you control over when runtime updates are applied and allowing you to detect and mitigate rare runtime update incompatibilities early. When using this setting, you need to regularly update your functions to keep their runtime up-to-date.
     * - *Manual* - You specify a runtime version in your function configuration. The function will use this runtime version indefinitely. In the rare case where a new runtime version is incompatible with an existing function, this allows you to roll back your function to an earlier runtime version. For more information, see [Roll back a runtime version](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-update.html#runtime-management-rollback) .
     *
     * *Valid Values* : \`Auto\` | \`FunctionUpdate\` | \`Manual\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lambda-function-runtimemanagementconfig.html#cfn-lambda-function-runtimemanagementconfig-updateruntimeon
     */
    readonly updateRuntimeOn: string;
  }

  /**
   * The function's [AWS Lambda SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart.html) setting.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lambda-function-snapstart.html
   */
  export interface SnapStartProperty {
    /**
     * Set \`ApplyOn\` to \`PublishedVersions\` to create a snapshot of the initialized execution environment when you publish a function version.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lambda-function-snapstart.html#cfn-lambda-function-snapstart-applyon
     */
    readonly applyOn: string;
  }

  /**
   * Details about the connection between a Lambda function and an [Amazon EFS file system](https://docs.aws.amazon.com/lambda/latest/dg/configuration-filesystem.html) .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lambda-function-filesystemconfig.html
   */
  export interface FileSystemConfigProperty {
    /**
     * The Amazon Resource Name (ARN) of the Amazon EFS access point that provides access to the file system.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lambda-function-filesystemconfig.html#cfn-lambda-function-filesystemconfig-arn
     */
    readonly arn: string;

    /**
     * The path where the function can access the file system, starting with \`/mnt/\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lambda-function-filesystemconfig.html#cfn-lambda-function-filesystemconfig-localmountpath
     */
    readonly localMountPath: string;
  }

  /**
   * Configuration values that override the container image Dockerfile settings.
   *
   * For more information, see [Container image settings](https://docs.aws.amazon.com/lambda/latest/dg/images-create.html#images-parms) .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lambda-function-imageconfig.html
   */
  export interface ImageConfigProperty {
    /**
     * Specifies parameters that you want to pass in with ENTRYPOINT.
     *
     * You can specify a maximum of 1,500 parameters in the list.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lambda-function-imageconfig.html#cfn-lambda-function-imageconfig-command
     */
    readonly command?: Array<string>;

    /**
     * Specifies the entry point to their application, which is typically the location of the runtime executable.
     *
     * You can specify a maximum of 1,500 string entries in the list.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lambda-function-imageconfig.html#cfn-lambda-function-imageconfig-entrypoint
     */
    readonly entryPoint?: Array<string>;

    /**
     * Specifies the working directory.
     *
     * The length of the directory string cannot exceed 1,000 characters.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lambda-function-imageconfig.html#cfn-lambda-function-imageconfig-workingdirectory
     */
    readonly workingDirectory?: string;
  }

  /**
   * The [dead-letter queue](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#dlq) for failed asynchronous invocations.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lambda-function-deadletterconfig.html
   */
  export interface DeadLetterConfigProperty {
    /**
     * The Amazon Resource Name (ARN) of an Amazon SQS queue or Amazon SNS topic.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lambda-function-deadletterconfig.html#cfn-lambda-function-deadletterconfig-targetarn
     */
    readonly targetArn?: string;
  }

  /**
   * The [deployment package](https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-package.html) for a Lambda function. To deploy a function defined as a container image, you specify the location of a container image in the Amazon ECR registry. For a .zip file deployment package, you can specify the location of an object in Amazon S3. For Node.js and Python functions, you can specify the function code inline in the template.
   *
   * Changes to a deployment package in Amazon S3 are not detected automatically during stack updates. To update the function code, change the object key or version in the template.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lambda-function-code.html
   */
  export interface CodeProperty {
    /**
     * URI of a [container image](https://docs.aws.amazon.com/lambda/latest/dg/lambda-images.html) in the Amazon ECR registry.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lambda-function-code.html#cfn-lambda-function-code-imageuri
     */
    readonly imageUri?: string;

    /**
     * An Amazon S3 bucket in the same AWS Region as your function.
     *
     * The bucket can be in a different AWS account .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lambda-function-code.html#cfn-lambda-function-code-s3bucket
     */
    readonly s3Bucket?: string;

    /**
     * The Amazon S3 key of the deployment package.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lambda-function-code.html#cfn-lambda-function-code-s3key
     */
    readonly s3Key?: string;

    /**
     * For versioned objects, the version of the deployment package object to use.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lambda-function-code.html#cfn-lambda-function-code-s3objectversion
     */
    readonly s3ObjectVersion?: string;

    /**
     * (Node.js and Python) The source code of your Lambda function. If you include your function source inline with this parameter, AWS CloudFormation places it in a file named \`index\` and zips it to create a [deployment package](https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-package.html) . This zip file cannot exceed 4MB. For the \`Handler\` property, the first part of the handler identifier must be \`index\` . For example, \`index.handler\` .
     *
     * For JSON, you must escape quotes and special characters such as newline ( \`\\n\` ) with a backslash.
     *
     * If you specify a function that interacts with an AWS CloudFormation custom resource, you don't have to write your own functions to send responses to the custom resource that invoked the function. AWS CloudFormation provides a response module ( [cfn-response](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/cfn-lambda-function-code-cfnresponsemodule.html) ) that simplifies sending responses. See [Using AWS Lambda with AWS CloudFormation](https://docs.aws.amazon.com/lambda/latest/dg/services-cloudformation.html) for details.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lambda-function-code.html#cfn-lambda-function-code-zipfile
     */
    readonly zipFile?: string;
  }

  /**
   * A function's environment variable settings.
   *
   * You can use environment variables to adjust your function's behavior without updating code. An environment variable is a pair of strings that are stored in a function's version-specific configuration.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lambda-function-environment.html
   */
  export interface EnvironmentProperty {
    /**
     * Environment variable key-value pairs.
     *
     * For more information, see [Using Lambda environment variables](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lambda-function-environment.html#cfn-lambda-function-environment-variables
     */
    readonly variables?: cdk.IResolvable | Record<string, string>;
  }

  /**
   * The size of the function's \`/tmp\` directory in MB.
   *
   * The default value is 512, but it can be any whole number between 512 and 10,240 MB.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lambda-function-ephemeralstorage.html
   */
  export interface EphemeralStorageProperty {
    /**
     * The size of the function's \`/tmp\` directory.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lambda-function-ephemeralstorage.html#cfn-lambda-function-ephemeralstorage-size
     */
    readonly size: number;
  }

  /**
   * The function's [SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart.html) setting.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lambda-function-snapstartresponse.html
   */
  export interface SnapStartResponseProperty {
    /**
     * When set to \`PublishedVersions\` , Lambda creates a snapshot of the execution environment when you publish a function version.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lambda-function-snapstartresponse.html#cfn-lambda-function-snapstartresponse-applyon
     */
    readonly applyOn?: string;

    /**
     * When you provide a [qualified Amazon Resource Name (ARN)](https://docs.aws.amazon.com/lambda/latest/dg/configuration-versions.html#versioning-versions-using) , this response element indicates whether SnapStart is activated for the specified function version.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lambda-function-snapstartresponse.html#cfn-lambda-function-snapstartresponse-optimizationstatus
     */
    readonly optimizationStatus?: string;
  }
}

/**
 * Properties for defining a \`CfnFunction\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-function.html
 */
export interface CfnFunctionProps {
  /**
   * The instruction set architecture that the function supports.
   *
   * Enter a string array with one of the valid values (arm64 or x86_64). The default value is \`x86_64\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-function.html#cfn-lambda-function-architectures
   */
  readonly architectures?: Array<string>;

  /**
   * The code for the function.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-function.html#cfn-lambda-function-code
   */
  readonly code: CfnFunction.CodeProperty | cdk.IResolvable;

  /**
   * To enable code signing for this function, specify the ARN of a code-signing configuration.
   *
   * A code-signing configuration
   * includes a set of signing profiles, which define the trusted publishers for this function.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-function.html#cfn-lambda-function-codesigningconfigarn
   */
  readonly codeSigningConfigArn?: string;

  /**
   * A dead-letter queue configuration that specifies the queue or topic where Lambda sends asynchronous events when they fail processing.
   *
   * For more information, see [Dead-letter queues](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#invocation-dlq) .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-function.html#cfn-lambda-function-deadletterconfig
   */
  readonly deadLetterConfig?: CfnFunction.DeadLetterConfigProperty | cdk.IResolvable;

  /**
   * A description of the function.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-function.html#cfn-lambda-function-description
   */
  readonly description?: string;

  /**
   * Environment variables that are accessible from function code during execution.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-function.html#cfn-lambda-function-environment
   */
  readonly environment?: CfnFunction.EnvironmentProperty | cdk.IResolvable;

  /**
   * The size of the function's \`/tmp\` directory in MB.
   *
   * The default value is 512, but it can be any whole number between 512 and 10,240 MB.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-function.html#cfn-lambda-function-ephemeralstorage
   */
  readonly ephemeralStorage?: CfnFunction.EphemeralStorageProperty | cdk.IResolvable;

  /**
   * Connection settings for an Amazon EFS file system.
   *
   * To connect a function to a file system, a mount target must be available in every Availability Zone that your function connects to. If your template contains an [AWS::EFS::MountTarget](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-efs-mounttarget.html) resource, you must also specify a \`DependsOn\` attribute to ensure that the mount target is created or updated before the function.
   *
   * For more information about using the \`DependsOn\` attribute, see [DependsOn Attribute](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-dependson.html) .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-function.html#cfn-lambda-function-filesystemconfigs
   */
  readonly fileSystemConfigs?: Array<CfnFunction.FileSystemConfigProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * The name of the Lambda function, up to 64 characters in length.
   *
   * If you don't specify a name, AWS CloudFormation generates one.
   *
   * If you specify a name, you cannot perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you must replace the resource, specify a new name.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-function.html#cfn-lambda-function-functionname
   */
  readonly functionName?: string;

  /**
   * The name of the method within your code that Lambda calls to run your function.
   *
   * Handler is required if the deployment package is a .zip file archive. The format includes the file name. It can also include namespaces and other qualifiers, depending on the runtime. For more information, see [Lambda programming model](https://docs.aws.amazon.com/lambda/latest/dg/foundation-progmodel.html) .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-function.html#cfn-lambda-function-handler
   */
  readonly handler?: string;

  /**
   * Configuration values that override the container image Dockerfile settings.
   *
   * For more information, see [Container image settings](https://docs.aws.amazon.com/lambda/latest/dg/images-create.html#images-parms) .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-function.html#cfn-lambda-function-imageconfig
   */
  readonly imageConfig?: CfnFunction.ImageConfigProperty | cdk.IResolvable;

  /**
   * The ARN of the AWS Key Management Service ( AWS KMS ) customer managed key that's used to encrypt your function's [environment variables](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html#configuration-envvars-encryption) . When [Lambda SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart-security.html) is activated, Lambda also uses this key is to encrypt your function's snapshot. If you deploy your function using a container image, Lambda also uses this key to encrypt your function when it's deployed. Note that this is not the same key that's used to protect your container image in the Amazon Elastic Container Registry (Amazon ECR). If you don't provide a customer managed key, Lambda uses a default service key.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-function.html#cfn-lambda-function-kmskeyarn
   */
  readonly kmsKeyArn?: string;

  /**
   * A list of [function layers](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html) to add to the function's execution environment. Specify each layer by its ARN, including the version.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-function.html#cfn-lambda-function-layers
   */
  readonly layers?: Array<string>;

  /**
   * The amount of [memory available to the function](https://docs.aws.amazon.com/lambda/latest/dg/configuration-function-common.html#configuration-memory-console) at runtime. Increasing the function memory also increases its CPU allocation. The default value is 128 MB. The value can be any multiple of 1 MB.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-function.html#cfn-lambda-function-memorysize
   */
  readonly memorySize?: number;

  /**
   * The type of deployment package.
   *
   * Set to \`Image\` for container image and set \`Zip\` for .zip file archive.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-function.html#cfn-lambda-function-packagetype
   */
  readonly packageType?: string;

  /**
   * The number of simultaneous executions to reserve for the function.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-function.html#cfn-lambda-function-reservedconcurrentexecutions
   */
  readonly reservedConcurrentExecutions?: number;

  /**
   * The Amazon Resource Name (ARN) of the function's execution role.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-function.html#cfn-lambda-function-role
   */
  readonly role: string;

  /**
   * The identifier of the function's [runtime](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html) . Runtime is required if the deployment package is a .zip file archive.
   *
   * The following list includes deprecated runtimes. For more information, see [Runtime deprecation policy](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtime-support-policy) .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-function.html#cfn-lambda-function-runtime
   */
  readonly runtime?: string;

  /**
   * Sets the runtime management configuration for a function's version.
   *
   * For more information, see [Runtime updates](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-update.html) .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-function.html#cfn-lambda-function-runtimemanagementconfig
   */
  readonly runtimeManagementConfig?: cdk.IResolvable | CfnFunction.RuntimeManagementConfigProperty;

  /**
   * The function's [AWS Lambda SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart.html) setting.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-function.html#cfn-lambda-function-snapstart
   */
  readonly snapStart?: cdk.IResolvable | CfnFunction.SnapStartProperty;

  /**
   * A list of [tags](https://docs.aws.amazon.com/lambda/latest/dg/tagging.html) to apply to the function.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-function.html#cfn-lambda-function-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The amount of time (in seconds) that Lambda allows a function to run before stopping it.
   *
   * The default is 3 seconds. The maximum allowed value is 900 seconds. For more information, see [Lambda execution environment](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-context.html) .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-function.html#cfn-lambda-function-timeout
   */
  readonly timeout?: number;

  /**
   * Set \`Mode\` to \`Active\` to sample and trace a subset of incoming requests with [X-Ray](https://docs.aws.amazon.com/lambda/latest/dg/services-xray.html) .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-function.html#cfn-lambda-function-tracingconfig
   */
  readonly tracingConfig?: cdk.IResolvable | CfnFunction.TracingConfigProperty;

  /**
   * For network connectivity to AWS resources in a VPC, specify a list of security groups and subnets in the VPC.
   *
   * When you connect a function to a VPC, it can access resources and the internet only through that VPC. For more information, see [Configuring a Lambda function to access resources in a VPC](https://docs.aws.amazon.com/lambda/latest/dg/configuration-vpc.html) .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-function.html#cfn-lambda-function-vpcconfig
   */
  readonly vpcConfig?: cdk.IResolvable | CfnFunction.VpcConfigProperty;
}

/**
 * Determine whether the given properties match those of a \`TracingConfigProperty\`
 *
 * @param properties - the TypeScript properties of a \`TracingConfigProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionTracingConfigPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("mode", cdk.validateString)(properties.mode));
  return errors.wrap("supplied properties not correct for \\"TracingConfigProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionTracingConfigPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionTracingConfigPropertyValidator(properties).assertSuccess();
  return {
    "Mode": cdk.stringToCloudFormation(properties.mode)
  };
}

// @ts-ignore TS6133
function CfnFunctionTracingConfigPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnFunction.TracingConfigProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.TracingConfigProperty>();
  ret.addPropertyResult("mode", "Mode", (properties.Mode != null ? cfn_parse.FromCloudFormation.getString(properties.Mode) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`VpcConfigProperty\`
 *
 * @param properties - the TypeScript properties of a \`VpcConfigProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionVpcConfigPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("securityGroupIds", cdk.listValidator(cdk.validateString))(properties.securityGroupIds));
  errors.collect(cdk.propertyValidator("subnetIds", cdk.listValidator(cdk.validateString))(properties.subnetIds));
  return errors.wrap("supplied properties not correct for \\"VpcConfigProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionVpcConfigPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionVpcConfigPropertyValidator(properties).assertSuccess();
  return {
    "SecurityGroupIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.securityGroupIds),
    "SubnetIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.subnetIds)
  };
}

// @ts-ignore TS6133
function CfnFunctionVpcConfigPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnFunction.VpcConfigProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.VpcConfigProperty>();
  ret.addPropertyResult("securityGroupIds", "SecurityGroupIds", (properties.SecurityGroupIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecurityGroupIds) : undefined));
  ret.addPropertyResult("subnetIds", "SubnetIds", (properties.SubnetIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SubnetIds) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`RuntimeManagementConfigProperty\`
 *
 * @param properties - the TypeScript properties of a \`RuntimeManagementConfigProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionRuntimeManagementConfigPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("runtimeVersionArn", cdk.validateString)(properties.runtimeVersionArn));
  errors.collect(cdk.propertyValidator("updateRuntimeOn", cdk.requiredValidator)(properties.updateRuntimeOn));
  errors.collect(cdk.propertyValidator("updateRuntimeOn", cdk.validateString)(properties.updateRuntimeOn));
  return errors.wrap("supplied properties not correct for \\"RuntimeManagementConfigProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionRuntimeManagementConfigPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionRuntimeManagementConfigPropertyValidator(properties).assertSuccess();
  return {
    "RuntimeVersionArn": cdk.stringToCloudFormation(properties.runtimeVersionArn),
    "UpdateRuntimeOn": cdk.stringToCloudFormation(properties.updateRuntimeOn)
  };
}

// @ts-ignore TS6133
function CfnFunctionRuntimeManagementConfigPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnFunction.RuntimeManagementConfigProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.RuntimeManagementConfigProperty>();
  ret.addPropertyResult("runtimeVersionArn", "RuntimeVersionArn", (properties.RuntimeVersionArn != null ? cfn_parse.FromCloudFormation.getString(properties.RuntimeVersionArn) : undefined));
  ret.addPropertyResult("updateRuntimeOn", "UpdateRuntimeOn", (properties.UpdateRuntimeOn != null ? cfn_parse.FromCloudFormation.getString(properties.UpdateRuntimeOn) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`SnapStartProperty\`
 *
 * @param properties - the TypeScript properties of a \`SnapStartProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionSnapStartPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("applyOn", cdk.requiredValidator)(properties.applyOn));
  errors.collect(cdk.propertyValidator("applyOn", cdk.validateString)(properties.applyOn));
  return errors.wrap("supplied properties not correct for \\"SnapStartProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionSnapStartPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionSnapStartPropertyValidator(properties).assertSuccess();
  return {
    "ApplyOn": cdk.stringToCloudFormation(properties.applyOn)
  };
}

// @ts-ignore TS6133
function CfnFunctionSnapStartPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnFunction.SnapStartProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.SnapStartProperty>();
  ret.addPropertyResult("applyOn", "ApplyOn", (properties.ApplyOn != null ? cfn_parse.FromCloudFormation.getString(properties.ApplyOn) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`FileSystemConfigProperty\`
 *
 * @param properties - the TypeScript properties of a \`FileSystemConfigProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionFileSystemConfigPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("arn", cdk.requiredValidator)(properties.arn));
  errors.collect(cdk.propertyValidator("arn", cdk.validateString)(properties.arn));
  errors.collect(cdk.propertyValidator("localMountPath", cdk.requiredValidator)(properties.localMountPath));
  errors.collect(cdk.propertyValidator("localMountPath", cdk.validateString)(properties.localMountPath));
  return errors.wrap("supplied properties not correct for \\"FileSystemConfigProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionFileSystemConfigPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionFileSystemConfigPropertyValidator(properties).assertSuccess();
  return {
    "Arn": cdk.stringToCloudFormation(properties.arn),
    "LocalMountPath": cdk.stringToCloudFormation(properties.localMountPath)
  };
}

// @ts-ignore TS6133
function CfnFunctionFileSystemConfigPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnFunction.FileSystemConfigProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.FileSystemConfigProperty>();
  ret.addPropertyResult("arn", "Arn", (properties.Arn != null ? cfn_parse.FromCloudFormation.getString(properties.Arn) : undefined));
  ret.addPropertyResult("localMountPath", "LocalMountPath", (properties.LocalMountPath != null ? cfn_parse.FromCloudFormation.getString(properties.LocalMountPath) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ImageConfigProperty\`
 *
 * @param properties - the TypeScript properties of a \`ImageConfigProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionImageConfigPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("command", cdk.listValidator(cdk.validateString))(properties.command));
  errors.collect(cdk.propertyValidator("entryPoint", cdk.listValidator(cdk.validateString))(properties.entryPoint));
  errors.collect(cdk.propertyValidator("workingDirectory", cdk.validateString)(properties.workingDirectory));
  return errors.wrap("supplied properties not correct for \\"ImageConfigProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionImageConfigPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionImageConfigPropertyValidator(properties).assertSuccess();
  return {
    "Command": cdk.listMapper(cdk.stringToCloudFormation)(properties.command),
    "EntryPoint": cdk.listMapper(cdk.stringToCloudFormation)(properties.entryPoint),
    "WorkingDirectory": cdk.stringToCloudFormation(properties.workingDirectory)
  };
}

// @ts-ignore TS6133
function CfnFunctionImageConfigPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnFunction.ImageConfigProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.ImageConfigProperty>();
  ret.addPropertyResult("command", "Command", (properties.Command != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.Command) : undefined));
  ret.addPropertyResult("entryPoint", "EntryPoint", (properties.EntryPoint != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.EntryPoint) : undefined));
  ret.addPropertyResult("workingDirectory", "WorkingDirectory", (properties.WorkingDirectory != null ? cfn_parse.FromCloudFormation.getString(properties.WorkingDirectory) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`DeadLetterConfigProperty\`
 *
 * @param properties - the TypeScript properties of a \`DeadLetterConfigProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionDeadLetterConfigPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("targetArn", cdk.validateString)(properties.targetArn));
  return errors.wrap("supplied properties not correct for \\"DeadLetterConfigProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionDeadLetterConfigPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionDeadLetterConfigPropertyValidator(properties).assertSuccess();
  return {
    "TargetArn": cdk.stringToCloudFormation(properties.targetArn)
  };
}

// @ts-ignore TS6133
function CfnFunctionDeadLetterConfigPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnFunction.DeadLetterConfigProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.DeadLetterConfigProperty>();
  ret.addPropertyResult("targetArn", "TargetArn", (properties.TargetArn != null ? cfn_parse.FromCloudFormation.getString(properties.TargetArn) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CodeProperty\`
 *
 * @param properties - the TypeScript properties of a \`CodeProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionCodePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("imageUri", cdk.validateString)(properties.imageUri));
  errors.collect(cdk.propertyValidator("s3Bucket", cdk.validateString)(properties.s3Bucket));
  errors.collect(cdk.propertyValidator("s3Key", cdk.validateString)(properties.s3Key));
  errors.collect(cdk.propertyValidator("s3ObjectVersion", cdk.validateString)(properties.s3ObjectVersion));
  errors.collect(cdk.propertyValidator("zipFile", cdk.validateString)(properties.zipFile));
  return errors.wrap("supplied properties not correct for \\"CodeProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionCodePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionCodePropertyValidator(properties).assertSuccess();
  return {
    "ImageUri": cdk.stringToCloudFormation(properties.imageUri),
    "S3Bucket": cdk.stringToCloudFormation(properties.s3Bucket),
    "S3Key": cdk.stringToCloudFormation(properties.s3Key),
    "S3ObjectVersion": cdk.stringToCloudFormation(properties.s3ObjectVersion),
    "ZipFile": cdk.stringToCloudFormation(properties.zipFile)
  };
}

// @ts-ignore TS6133
function CfnFunctionCodePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnFunction.CodeProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.CodeProperty>();
  ret.addPropertyResult("imageUri", "ImageUri", (properties.ImageUri != null ? cfn_parse.FromCloudFormation.getString(properties.ImageUri) : undefined));
  ret.addPropertyResult("s3Bucket", "S3Bucket", (properties.S3Bucket != null ? cfn_parse.FromCloudFormation.getString(properties.S3Bucket) : undefined));
  ret.addPropertyResult("s3Key", "S3Key", (properties.S3Key != null ? cfn_parse.FromCloudFormation.getString(properties.S3Key) : undefined));
  ret.addPropertyResult("s3ObjectVersion", "S3ObjectVersion", (properties.S3ObjectVersion != null ? cfn_parse.FromCloudFormation.getString(properties.S3ObjectVersion) : undefined));
  ret.addPropertyResult("zipFile", "ZipFile", (properties.ZipFile != null ? cfn_parse.FromCloudFormation.getString(properties.ZipFile) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`EnvironmentProperty\`
 *
 * @param properties - the TypeScript properties of a \`EnvironmentProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionEnvironmentPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("variables", cdk.hashValidator(cdk.validateString))(properties.variables));
  return errors.wrap("supplied properties not correct for \\"EnvironmentProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionEnvironmentPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionEnvironmentPropertyValidator(properties).assertSuccess();
  return {
    "Variables": cdk.hashMapper(cdk.stringToCloudFormation)(properties.variables)
  };
}

// @ts-ignore TS6133
function CfnFunctionEnvironmentPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnFunction.EnvironmentProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.EnvironmentProperty>();
  ret.addPropertyResult("variables", "Variables", (properties.Variables != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getString)(properties.Variables) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`EphemeralStorageProperty\`
 *
 * @param properties - the TypeScript properties of a \`EphemeralStorageProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionEphemeralStoragePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("size", cdk.requiredValidator)(properties.size));
  errors.collect(cdk.propertyValidator("size", cdk.validateNumber)(properties.size));
  return errors.wrap("supplied properties not correct for \\"EphemeralStorageProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionEphemeralStoragePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionEphemeralStoragePropertyValidator(properties).assertSuccess();
  return {
    "Size": cdk.numberToCloudFormation(properties.size)
  };
}

// @ts-ignore TS6133
function CfnFunctionEphemeralStoragePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnFunction.EphemeralStorageProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.EphemeralStorageProperty>();
  ret.addPropertyResult("size", "Size", (properties.Size != null ? cfn_parse.FromCloudFormation.getNumber(properties.Size) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`SnapStartResponseProperty\`
 *
 * @param properties - the TypeScript properties of a \`SnapStartResponseProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionSnapStartResponsePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("applyOn", cdk.validateString)(properties.applyOn));
  errors.collect(cdk.propertyValidator("optimizationStatus", cdk.validateString)(properties.optimizationStatus));
  return errors.wrap("supplied properties not correct for \\"SnapStartResponseProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionSnapStartResponsePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionSnapStartResponsePropertyValidator(properties).assertSuccess();
  return {
    "ApplyOn": cdk.stringToCloudFormation(properties.applyOn),
    "OptimizationStatus": cdk.stringToCloudFormation(properties.optimizationStatus)
  };
}

// @ts-ignore TS6133
function CfnFunctionSnapStartResponsePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnFunction.SnapStartResponseProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.SnapStartResponseProperty>();
  ret.addPropertyResult("applyOn", "ApplyOn", (properties.ApplyOn != null ? cfn_parse.FromCloudFormation.getString(properties.ApplyOn) : undefined));
  ret.addPropertyResult("optimizationStatus", "OptimizationStatus", (properties.OptimizationStatus != null ? cfn_parse.FromCloudFormation.getString(properties.OptimizationStatus) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnFunctionProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnFunctionProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("architectures", cdk.listValidator(cdk.validateString))(properties.architectures));
  errors.collect(cdk.propertyValidator("code", cdk.requiredValidator)(properties.code));
  errors.collect(cdk.propertyValidator("code", CfnFunctionCodePropertyValidator)(properties.code));
  errors.collect(cdk.propertyValidator("codeSigningConfigArn", cdk.validateString)(properties.codeSigningConfigArn));
  errors.collect(cdk.propertyValidator("deadLetterConfig", CfnFunctionDeadLetterConfigPropertyValidator)(properties.deadLetterConfig));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("environment", CfnFunctionEnvironmentPropertyValidator)(properties.environment));
  errors.collect(cdk.propertyValidator("ephemeralStorage", CfnFunctionEphemeralStoragePropertyValidator)(properties.ephemeralStorage));
  errors.collect(cdk.propertyValidator("fileSystemConfigs", cdk.listValidator(CfnFunctionFileSystemConfigPropertyValidator))(properties.fileSystemConfigs));
  errors.collect(cdk.propertyValidator("functionName", cdk.validateString)(properties.functionName));
  errors.collect(cdk.propertyValidator("handler", cdk.validateString)(properties.handler));
  errors.collect(cdk.propertyValidator("imageConfig", CfnFunctionImageConfigPropertyValidator)(properties.imageConfig));
  errors.collect(cdk.propertyValidator("kmsKeyArn", cdk.validateString)(properties.kmsKeyArn));
  errors.collect(cdk.propertyValidator("layers", cdk.listValidator(cdk.validateString))(properties.layers));
  errors.collect(cdk.propertyValidator("memorySize", cdk.validateNumber)(properties.memorySize));
  errors.collect(cdk.propertyValidator("packageType", cdk.validateString)(properties.packageType));
  errors.collect(cdk.propertyValidator("reservedConcurrentExecutions", cdk.validateNumber)(properties.reservedConcurrentExecutions));
  errors.collect(cdk.propertyValidator("role", cdk.requiredValidator)(properties.role));
  errors.collect(cdk.propertyValidator("role", cdk.validateString)(properties.role));
  errors.collect(cdk.propertyValidator("runtime", cdk.validateString)(properties.runtime));
  errors.collect(cdk.propertyValidator("runtimeManagementConfig", CfnFunctionRuntimeManagementConfigPropertyValidator)(properties.runtimeManagementConfig));
  errors.collect(cdk.propertyValidator("snapStart", CfnFunctionSnapStartPropertyValidator)(properties.snapStart));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("timeout", cdk.validateNumber)(properties.timeout));
  errors.collect(cdk.propertyValidator("tracingConfig", CfnFunctionTracingConfigPropertyValidator)(properties.tracingConfig));
  errors.collect(cdk.propertyValidator("vpcConfig", CfnFunctionVpcConfigPropertyValidator)(properties.vpcConfig));
  return errors.wrap("supplied properties not correct for \\"CfnFunctionProps\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionPropsValidator(properties).assertSuccess();
  return {
    "Architectures": cdk.listMapper(cdk.stringToCloudFormation)(properties.architectures),
    "Code": convertCfnFunctionCodePropertyToCloudFormation(properties.code),
    "CodeSigningConfigArn": cdk.stringToCloudFormation(properties.codeSigningConfigArn),
    "DeadLetterConfig": convertCfnFunctionDeadLetterConfigPropertyToCloudFormation(properties.deadLetterConfig),
    "Description": cdk.stringToCloudFormation(properties.description),
    "Environment": convertCfnFunctionEnvironmentPropertyToCloudFormation(properties.environment),
    "EphemeralStorage": convertCfnFunctionEphemeralStoragePropertyToCloudFormation(properties.ephemeralStorage),
    "FileSystemConfigs": cdk.listMapper(convertCfnFunctionFileSystemConfigPropertyToCloudFormation)(properties.fileSystemConfigs),
    "FunctionName": cdk.stringToCloudFormation(properties.functionName),
    "Handler": cdk.stringToCloudFormation(properties.handler),
    "ImageConfig": convertCfnFunctionImageConfigPropertyToCloudFormation(properties.imageConfig),
    "KmsKeyArn": cdk.stringToCloudFormation(properties.kmsKeyArn),
    "Layers": cdk.listMapper(cdk.stringToCloudFormation)(properties.layers),
    "MemorySize": cdk.numberToCloudFormation(properties.memorySize),
    "PackageType": cdk.stringToCloudFormation(properties.packageType),
    "ReservedConcurrentExecutions": cdk.numberToCloudFormation(properties.reservedConcurrentExecutions),
    "Role": cdk.stringToCloudFormation(properties.role),
    "Runtime": cdk.stringToCloudFormation(properties.runtime),
    "RuntimeManagementConfig": convertCfnFunctionRuntimeManagementConfigPropertyToCloudFormation(properties.runtimeManagementConfig),
    "SnapStart": convertCfnFunctionSnapStartPropertyToCloudFormation(properties.snapStart),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "Timeout": cdk.numberToCloudFormation(properties.timeout),
    "TracingConfig": convertCfnFunctionTracingConfigPropertyToCloudFormation(properties.tracingConfig),
    "VpcConfig": convertCfnFunctionVpcConfigPropertyToCloudFormation(properties.vpcConfig)
  };
}

// @ts-ignore TS6133
function CfnFunctionPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnFunctionProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunctionProps>();
  ret.addPropertyResult("architectures", "Architectures", (properties.Architectures != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.Architectures) : undefined));
  ret.addPropertyResult("code", "Code", (properties.Code != null ? CfnFunctionCodePropertyFromCloudFormation(properties.Code) : undefined));
  ret.addPropertyResult("codeSigningConfigArn", "CodeSigningConfigArn", (properties.CodeSigningConfigArn != null ? cfn_parse.FromCloudFormation.getString(properties.CodeSigningConfigArn) : undefined));
  ret.addPropertyResult("deadLetterConfig", "DeadLetterConfig", (properties.DeadLetterConfig != null ? CfnFunctionDeadLetterConfigPropertyFromCloudFormation(properties.DeadLetterConfig) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("environment", "Environment", (properties.Environment != null ? CfnFunctionEnvironmentPropertyFromCloudFormation(properties.Environment) : undefined));
  ret.addPropertyResult("ephemeralStorage", "EphemeralStorage", (properties.EphemeralStorage != null ? CfnFunctionEphemeralStoragePropertyFromCloudFormation(properties.EphemeralStorage) : undefined));
  ret.addPropertyResult("fileSystemConfigs", "FileSystemConfigs", (properties.FileSystemConfigs != null ? cfn_parse.FromCloudFormation.getArray(CfnFunctionFileSystemConfigPropertyFromCloudFormation)(properties.FileSystemConfigs) : undefined));
  ret.addPropertyResult("functionName", "FunctionName", (properties.FunctionName != null ? cfn_parse.FromCloudFormation.getString(properties.FunctionName) : undefined));
  ret.addPropertyResult("handler", "Handler", (properties.Handler != null ? cfn_parse.FromCloudFormation.getString(properties.Handler) : undefined));
  ret.addPropertyResult("imageConfig", "ImageConfig", (properties.ImageConfig != null ? CfnFunctionImageConfigPropertyFromCloudFormation(properties.ImageConfig) : undefined));
  ret.addPropertyResult("kmsKeyArn", "KmsKeyArn", (properties.KmsKeyArn != null ? cfn_parse.FromCloudFormation.getString(properties.KmsKeyArn) : undefined));
  ret.addPropertyResult("layers", "Layers", (properties.Layers != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.Layers) : undefined));
  ret.addPropertyResult("memorySize", "MemorySize", (properties.MemorySize != null ? cfn_parse.FromCloudFormation.getNumber(properties.MemorySize) : undefined));
  ret.addPropertyResult("packageType", "PackageType", (properties.PackageType != null ? cfn_parse.FromCloudFormation.getString(properties.PackageType) : undefined));
  ret.addPropertyResult("reservedConcurrentExecutions", "ReservedConcurrentExecutions", (properties.ReservedConcurrentExecutions != null ? cfn_parse.FromCloudFormation.getNumber(properties.ReservedConcurrentExecutions) : undefined));
  ret.addPropertyResult("role", "Role", (properties.Role != null ? cfn_parse.FromCloudFormation.getString(properties.Role) : undefined));
  ret.addPropertyResult("runtime", "Runtime", (properties.Runtime != null ? cfn_parse.FromCloudFormation.getString(properties.Runtime) : undefined));
  ret.addPropertyResult("runtimeManagementConfig", "RuntimeManagementConfig", (properties.RuntimeManagementConfig != null ? CfnFunctionRuntimeManagementConfigPropertyFromCloudFormation(properties.RuntimeManagementConfig) : undefined));
  ret.addPropertyResult("snapStart", "SnapStart", (properties.SnapStart != null ? CfnFunctionSnapStartPropertyFromCloudFormation(properties.SnapStart) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("timeout", "Timeout", (properties.Timeout != null ? cfn_parse.FromCloudFormation.getNumber(properties.Timeout) : undefined));
  ret.addPropertyResult("tracingConfig", "TracingConfig", (properties.TracingConfig != null ? CfnFunctionTracingConfigPropertyFromCloudFormation(properties.TracingConfig) : undefined));
  ret.addPropertyResult("vpcConfig", "VpcConfig", (properties.VpcConfig != null ? CfnFunctionVpcConfigPropertyFromCloudFormation(properties.VpcConfig) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}",
}
`;

exports[`AWS::RDS::DBCluster 1`] = `
{
  "augmentations": "// Copyright 2012-2023 Amazon.com, Inc. or its affiliates. All Rights Reserved.
/* eslint-disable prettier/prettier,max-len */
import * as cw from "aws-cdk-lib/aws-cloudwatch";
import { DatabaseClusterBase } from "./cluster";

declare module "./cluster-ref" {
  interface IDatabaseCluster {
    /**
     * Return the given named metric for this DBCluster
     */
    metric(metricName: string, props?: cw.MetricOptions): cw.Metric;

    /**
     * The percentage of CPU utilization.
     *
     * Average over 5 minutes
     */
    metricCPUUtilization(props?: cw.MetricOptions): cw.Metric;

    /**
     * The number of database connections in use.
     *
     * Average over 5 minutes
     */
    metricDatabaseConnections(props?: cw.MetricOptions): cw.Metric;

    /**
     * The average number of deadlocks in the database per second.
     *
     * Average over 5 minutes
     */
    metricDeadlocks(props?: cw.MetricOptions): cw.Metric;

    /**
     * The amount of time that the instance has been running, in seconds.
     *
     * Average over 5 minutes
     */
    metricEngineUptime(props?: cw.MetricOptions): cw.Metric;

    /**
     * The amount of available random access memory, in bytes.
     *
     * Average over 5 minutes
     */
    metricFreeableMemory(props?: cw.MetricOptions): cw.Metric;

    /**
     * The amount of local storage available, in bytes.
     *
     * Average over 5 minutes
     */
    metricFreeLocalStorage(props?: cw.MetricOptions): cw.Metric;

    /**
     * The amount of network throughput received from clients by each instance, in bytes per second.
     *
     * Average over 5 minutes
     */
    metricNetworkReceiveThroughput(props?: cw.MetricOptions): cw.Metric;

    /**
     * The amount of network throughput both received from and transmitted to clients by each instance, in bytes per second.
     *
     * Average over 5 minutes
     */
    metricNetworkThroughput(props?: cw.MetricOptions): cw.Metric;

    /**
     * The amount of network throughput sent to clients by each instance, in bytes per second.
     *
     * Average over 5 minutes
     */
    metricNetworkTransmitThroughput(props?: cw.MetricOptions): cw.Metric;

    /**
     * The total amount of backup storage in bytes consumed by all Aurora snapshots outside its backup retention window.
     *
     * Average over 5 minutes
     */
    metricSnapshotStorageUsed(props?: cw.MetricOptions): cw.Metric;

    /**
     * The total amount of backup storage in bytes for which you are billed.
     *
     * Average over 5 minutes
     */
    metricTotalBackupStorageBilled(props?: cw.MetricOptions): cw.Metric;

    /**
     * The amount of storage used by your Aurora DB instance, in bytes.
     *
     * Average over 5 minutes
     */
    metricVolumeBytesUsed(props?: cw.MetricOptions): cw.Metric;

    /**
     * The number of billed read I/O operations from a cluster volume, reported at 5-minute intervals.
     *
     * Average over 5 minutes
     */
    metricVolumeReadIOPs(props?: cw.MetricOptions): cw.Metric;

    /**
     * The number of write disk I/O operations to the cluster volume, reported at 5-minute intervals.
     *
     * Average over 5 minutes
     */
    metricVolumeWriteIOPs(props?: cw.MetricOptions): cw.Metric;
  }
}



declare module "./cluster" {
  interface DatabaseClusterBase {
    /**
     * Return the given named metric for this DBCluster
     */
    metric(metricName: string, props?: cw.MetricOptions): cw.Metric;

    /**
     * The percentage of CPU utilization.
     *
     * Average over 5 minutes
     */
    metricCPUUtilization(props?: cw.MetricOptions): cw.Metric;

    /**
     * The number of database connections in use.
     *
     * Average over 5 minutes
     */
    metricDatabaseConnections(props?: cw.MetricOptions): cw.Metric;

    /**
     * The average number of deadlocks in the database per second.
     *
     * Average over 5 minutes
     */
    metricDeadlocks(props?: cw.MetricOptions): cw.Metric;

    /**
     * The amount of time that the instance has been running, in seconds.
     *
     * Average over 5 minutes
     */
    metricEngineUptime(props?: cw.MetricOptions): cw.Metric;

    /**
     * The amount of available random access memory, in bytes.
     *
     * Average over 5 minutes
     */
    metricFreeableMemory(props?: cw.MetricOptions): cw.Metric;

    /**
     * The amount of local storage available, in bytes.
     *
     * Average over 5 minutes
     */
    metricFreeLocalStorage(props?: cw.MetricOptions): cw.Metric;

    /**
     * The amount of network throughput received from clients by each instance, in bytes per second.
     *
     * Average over 5 minutes
     */
    metricNetworkReceiveThroughput(props?: cw.MetricOptions): cw.Metric;

    /**
     * The amount of network throughput both received from and transmitted to clients by each instance, in bytes per second.
     *
     * Average over 5 minutes
     */
    metricNetworkThroughput(props?: cw.MetricOptions): cw.Metric;

    /**
     * The amount of network throughput sent to clients by each instance, in bytes per second.
     *
     * Average over 5 minutes
     */
    metricNetworkTransmitThroughput(props?: cw.MetricOptions): cw.Metric;

    /**
     * The total amount of backup storage in bytes consumed by all Aurora snapshots outside its backup retention window.
     *
     * Average over 5 minutes
     */
    metricSnapshotStorageUsed(props?: cw.MetricOptions): cw.Metric;

    /**
     * The total amount of backup storage in bytes for which you are billed.
     *
     * Average over 5 minutes
     */
    metricTotalBackupStorageBilled(props?: cw.MetricOptions): cw.Metric;

    /**
     * The amount of storage used by your Aurora DB instance, in bytes.
     *
     * Average over 5 minutes
     */
    metricVolumeBytesUsed(props?: cw.MetricOptions): cw.Metric;

    /**
     * The number of billed read I/O operations from a cluster volume, reported at 5-minute intervals.
     *
     * Average over 5 minutes
     */
    metricVolumeReadIOPs(props?: cw.MetricOptions): cw.Metric;

    /**
     * The number of write disk I/O operations to the cluster volume, reported at 5-minute intervals.
     *
     * Average over 5 minutes
     */
    metricVolumeWriteIOPs(props?: cw.MetricOptions): cw.Metric;
  }
}

DatabaseClusterBase.prototype.metric = function(metricName: string, props?: cw.MetricOptions) {
  return new cw.Metric({
    "namespace": "AWS/RDS",
    "metricName": metricName,
    "dimensionsMap": {
      "DBClusterIdentifier": this.clusterIdentifier
    },
    ...props
  }).attachTo(this);
};
DatabaseClusterBase.prototype.metricCPUUtilization = function(props?: cw.MetricOptions) {
  return this.metric("CPUUtilization", {
    "statistic": "Average",
    ...props
  });
};
DatabaseClusterBase.prototype.metricDatabaseConnections = function(props?: cw.MetricOptions) {
  return this.metric("DatabaseConnections", {
    "statistic": "Average",
    ...props
  });
};
DatabaseClusterBase.prototype.metricDeadlocks = function(props?: cw.MetricOptions) {
  return this.metric("Deadlocks", {
    "statistic": "Average",
    ...props
  });
};
DatabaseClusterBase.prototype.metricEngineUptime = function(props?: cw.MetricOptions) {
  return this.metric("EngineUptime", {
    "statistic": "Average",
    ...props
  });
};
DatabaseClusterBase.prototype.metricFreeableMemory = function(props?: cw.MetricOptions) {
  return this.metric("FreeableMemory", {
    "statistic": "Average",
    ...props
  });
};
DatabaseClusterBase.prototype.metricFreeLocalStorage = function(props?: cw.MetricOptions) {
  return this.metric("FreeLocalStorage", {
    "statistic": "Average",
    ...props
  });
};
DatabaseClusterBase.prototype.metricNetworkReceiveThroughput = function(props?: cw.MetricOptions) {
  return this.metric("NetworkReceiveThroughput", {
    "statistic": "Average",
    ...props
  });
};
DatabaseClusterBase.prototype.metricNetworkThroughput = function(props?: cw.MetricOptions) {
  return this.metric("NetworkThroughput", {
    "statistic": "Average",
    ...props
  });
};
DatabaseClusterBase.prototype.metricNetworkTransmitThroughput = function(props?: cw.MetricOptions) {
  return this.metric("NetworkTransmitThroughput", {
    "statistic": "Average",
    ...props
  });
};
DatabaseClusterBase.prototype.metricSnapshotStorageUsed = function(props?: cw.MetricOptions) {
  return this.metric("SnapshotStorageUsed", {
    "statistic": "Average",
    ...props
  });
};
DatabaseClusterBase.prototype.metricTotalBackupStorageBilled = function(props?: cw.MetricOptions) {
  return this.metric("TotalBackupStorageBilled", {
    "statistic": "Average",
    ...props
  });
};
DatabaseClusterBase.prototype.metricVolumeBytesUsed = function(props?: cw.MetricOptions) {
  return this.metric("VolumeBytesUsed", {
    "statistic": "Average",
    ...props
  });
};
DatabaseClusterBase.prototype.metricVolumeReadIOPs = function(props?: cw.MetricOptions) {
  return this.metric("VolumeReadIOPs", {
    "statistic": "Average",
    ...props
  });
};
DatabaseClusterBase.prototype.metricVolumeWriteIOPs = function(props?: cw.MetricOptions) {
  return this.metric("VolumeWriteIOPs", {
    "statistic": "Average",
    ...props
  });
};",
  "metrics": "/* eslint-disable prettier/prettier,max-len */
export interface MetricWithDims<D> {
  readonly namespace: string;

  readonly metricName: string;

  readonly statistic: string;

  readonly dimensionsMap: D;
}

export class RDSMetrics {
  public static cpuUtilizationAverage(dimensions: { DBInstanceIdentifier: string; }): MetricWithDims<{ DBInstanceIdentifier: string; }>;

  public static cpuUtilizationAverage(dimensions: { DBClusterIdentifier: string; }): MetricWithDims<{ DBClusterIdentifier: string; }>;

  public static cpuUtilizationAverage(dimensions: any): MetricWithDims<any> {
    return {
      "namespace": "AWS/RDS",
      "metricName": "CPUUtilization",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static databaseConnectionsSum(dimensions: { DBInstanceIdentifier: string; }): MetricWithDims<{ DBInstanceIdentifier: string; }>;

  public static databaseConnectionsSum(dimensions: { DBClusterIdentifier: string; }): MetricWithDims<{ DBClusterIdentifier: string; }>;

  public static databaseConnectionsSum(dimensions: any): MetricWithDims<any> {
    return {
      "namespace": "AWS/RDS",
      "metricName": "DatabaseConnections",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static freeStorageSpaceAverage(dimensions: { DBInstanceIdentifier: string; }): MetricWithDims<{ DBInstanceIdentifier: string; }>;

  public static freeStorageSpaceAverage(dimensions: { DBClusterIdentifier: string; }): MetricWithDims<{ DBClusterIdentifier: string; }>;

  public static freeStorageSpaceAverage(dimensions: any): MetricWithDims<any> {
    return {
      "namespace": "AWS/RDS",
      "metricName": "FreeStorageSpace",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static freeableMemoryAverage(dimensions: { DBInstanceIdentifier: string; }): MetricWithDims<{ DBInstanceIdentifier: string; }>;

  public static freeableMemoryAverage(dimensions: { DBClusterIdentifier: string; }): MetricWithDims<{ DBClusterIdentifier: string; }>;

  public static freeableMemoryAverage(dimensions: any): MetricWithDims<any> {
    return {
      "namespace": "AWS/RDS",
      "metricName": "FreeableMemory",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static readLatencyAverage(dimensions: { DBInstanceIdentifier: string; }): MetricWithDims<{ DBInstanceIdentifier: string; }>;

  public static readLatencyAverage(dimensions: { DBClusterIdentifier: string; }): MetricWithDims<{ DBClusterIdentifier: string; }>;

  public static readLatencyAverage(dimensions: any): MetricWithDims<any> {
    return {
      "namespace": "AWS/RDS",
      "metricName": "ReadLatency",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static readThroughputAverage(dimensions: { DBInstanceIdentifier: string; }): MetricWithDims<{ DBInstanceIdentifier: string; }>;

  public static readThroughputAverage(dimensions: { DBClusterIdentifier: string; }): MetricWithDims<{ DBClusterIdentifier: string; }>;

  public static readThroughputAverage(dimensions: any): MetricWithDims<any> {
    return {
      "namespace": "AWS/RDS",
      "metricName": "ReadThroughput",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static readIopsAverage(dimensions: { DBInstanceIdentifier: string; }): MetricWithDims<{ DBInstanceIdentifier: string; }>;

  public static readIopsAverage(dimensions: { DBClusterIdentifier: string; }): MetricWithDims<{ DBClusterIdentifier: string; }>;

  public static readIopsAverage(dimensions: any): MetricWithDims<any> {
    return {
      "namespace": "AWS/RDS",
      "metricName": "ReadIOPS",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static writeLatencyAverage(dimensions: { DBInstanceIdentifier: string; }): MetricWithDims<{ DBInstanceIdentifier: string; }>;

  public static writeLatencyAverage(dimensions: { DBClusterIdentifier: string; }): MetricWithDims<{ DBClusterIdentifier: string; }>;

  public static writeLatencyAverage(dimensions: any): MetricWithDims<any> {
    return {
      "namespace": "AWS/RDS",
      "metricName": "WriteLatency",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static writeThroughputAverage(dimensions: { DBInstanceIdentifier: string; }): MetricWithDims<{ DBInstanceIdentifier: string; }>;

  public static writeThroughputAverage(dimensions: { DBClusterIdentifier: string; }): MetricWithDims<{ DBClusterIdentifier: string; }>;

  public static writeThroughputAverage(dimensions: any): MetricWithDims<any> {
    return {
      "namespace": "AWS/RDS",
      "metricName": "WriteThroughput",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static writeIopsAverage(dimensions: { DBInstanceIdentifier: string; }): MetricWithDims<{ DBInstanceIdentifier: string; }>;

  public static writeIopsAverage(dimensions: { DBClusterIdentifier: string; }): MetricWithDims<{ DBClusterIdentifier: string; }>;

  public static writeIopsAverage(dimensions: any): MetricWithDims<any> {
    return {
      "namespace": "AWS/RDS",
      "metricName": "WriteIOPS",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }
}",
  "module": "/* eslint-disable prettier/prettier,max-len */
import * as cdk from "aws-cdk-lib";
import * as constructs from "constructs";
import * as cfn_parse from "aws-cdk-lib/core/lib/helpers-internal";

/**
 * The \`AWS::RDS::DBCluster\` resource creates an Amazon Aurora DB cluster or Multi-AZ DB cluster.
 *
 * For more information about creating an Aurora DB cluster, see [Creating an Amazon Aurora DB cluster](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Aurora.CreateInstance.html) in the *Amazon Aurora User Guide* .
 *
 * For more information about creating a Multi-AZ DB cluster, see [Creating a Multi-AZ DB cluster](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/create-multi-az-db-cluster.html) in the *Amazon RDS User Guide* .
 *
 * > You can only create this resource in AWS Regions where Amazon Aurora or Multi-AZ DB clusters are supported.
 *
 * *Updating DB clusters*
 *
 * When properties labeled " *Update requires:* [Replacement](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement) " are updated, AWS CloudFormation first creates a replacement DB cluster, then changes references from other dependent resources to point to the replacement DB cluster, and finally deletes the old DB cluster.
 *
 * > We highly recommend that you take a snapshot of the database before updating the stack. If you don't, you lose the data when AWS CloudFormation replaces your DB cluster. To preserve your data, perform the following procedure:
 * >
 * > - Deactivate any applications that are using the DB cluster so that there's no activity on the DB instance.
 * > - Create a snapshot of the DB cluster. For more information, see [Creating a DB Cluster Snapshot](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_CreateSnapshotCluster.html) .
 * > - If you want to restore your DB cluster using a DB cluster snapshot, modify the updated template with your DB cluster changes and add the \`SnapshotIdentifier\` property with the ID of the DB cluster snapshot that you want to use.
 * >
 * > After you restore a DB cluster with a \`SnapshotIdentifier\` property, you must specify the same \`SnapshotIdentifier\` property for any future updates to the DB cluster. When you specify this property for an update, the DB cluster is not restored from the DB cluster snapshot again, and the data in the database is not changed. However, if you don't specify the \`SnapshotIdentifier\` property, an empty DB cluster is created, and the original DB cluster is deleted. If you specify a property that is different from the previous snapshot restore property, a new DB cluster is restored from the specified \`SnapshotIdentifier\` property, and the original DB cluster is deleted.
 * > - Update the stack.
 *
 * Currently, when you are updating the stack for an Aurora Serverless DB cluster, you can't include changes to any other properties when you specify one of the following properties: \`PreferredBackupWindow\` , \`PreferredMaintenanceWindow\` , and \`Port\` . This limitation doesn't apply to provisioned DB clusters.
 *
 * For more information about updating other properties of this resource, see \`[ModifyDBCluster](https://docs.aws.amazon.com//AmazonRDS/latest/APIReference/API_ModifyDBCluster.html)\` . For more information about updating stacks, see [AWS CloudFormation Stacks Updates](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks.html) .
 *
 * *Deleting DB clusters*
 *
 * The default \`DeletionPolicy\` for \`AWS::RDS::DBCluster\` resources is \`Snapshot\` . For more information about how AWS CloudFormation deletes resources, see [DeletionPolicy Attribute](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html) .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html
 */
export class CfnDBCluster extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::RDS::DBCluster";

  /**
   * Build a CfnDBCluster from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnDBCluster {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnDBClusterPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnDBCluster(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The Amazon Resource Name (ARN) for the DB cluster.
   *
   * @cloudformationAttribute DBClusterArn
   */
  public readonly attrDbClusterArn: string;

  /**
   * The AWS Region -unique, immutable identifier for the DB cluster. This identifier is found in AWS CloudTrail log entries whenever the KMS key for the DB cluster is accessed.
   *
   * @cloudformationAttribute DBClusterResourceId
   */
  public readonly attrDbClusterResourceId: string;

  /**
   * The connection endpoint for the primary instance of the DB cluster.
   *
   * @cloudformationAttribute Endpoint
   */
  public readonly attrEndpoint: cdk.IResolvable;

  /**
   * The connection endpoint for the DB cluster. For example: \`mystack-mydbcluster-123456789012.us-east-2.rds.amazonaws.com\`
   *
   * @cloudformationAttribute Endpoint.Address
   */
  public readonly attrEndpointAddress: string;

  /**
   * The port number that will accept connections on this DB cluster. For example: \`3306\`
   *
   * @cloudformationAttribute Endpoint.Port
   */
  public readonly attrEndpointPort: string;

  /**
   * The Amazon Resource Name (ARN) of the secret.
   *
   * @cloudformationAttribute MasterUserSecret.SecretArn
   */
  public readonly attrMasterUserSecretSecretArn: string;

  /**
   * @cloudformationAttribute ReadEndpoint
   */
  public readonly attrReadEndpoint: cdk.IResolvable;

  /**
   * The reader endpoint for the DB cluster. For example: \`mystack-mydbcluster-ro-123456789012.us-east-2.rds.amazonaws.com\`
   *
   * @cloudformationAttribute ReadEndpoint.Address
   */
  public readonly attrReadEndpointAddress: string;

  /**
   * The amount of storage in gibibytes (GiB) to allocate to each DB instance in the Multi-AZ DB cluster.
   */
  public allocatedStorage?: number;

  /**
   * Provides a list of the AWS Identity and Access Management (IAM) roles that are associated with the DB cluster.
   */
  public associatedRoles?: Array<CfnDBCluster.DBClusterRoleProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * A value that indicates whether minor engine upgrades are applied automatically to the DB cluster during the maintenance window.
   */
  public autoMinorVersionUpgrade?: boolean | cdk.IResolvable;

  /**
   * A list of Availability Zones (AZs) where instances in the DB cluster can be created.
   */
  public availabilityZones?: Array<string>;

  /**
   * The target backtrack window, in seconds. To disable backtracking, set this value to 0.
   */
  public backtrackWindow?: number;

  /**
   * The number of days for which automated backups are retained.
   */
  public backupRetentionPeriod?: number;

  /**
   * A value that indicates whether to copy all tags from the DB cluster to snapshots of the DB cluster.
   */
  public copyTagsToSnapshot?: boolean | cdk.IResolvable;

  /**
   * The name of your database.
   */
  public databaseName?: string;

  /**
   * The DB cluster identifier. This parameter is stored as a lowercase string.
   */
  public dbClusterIdentifier?: string;

  /**
   * The compute and memory capacity of each DB instance in the Multi-AZ DB cluster, for example db.m6gd.xlarge. Not all DB instance classes are available in all AWS Regions , or for all database engines.
   */
  public dbClusterInstanceClass?: string;

  /**
   * The name of the DB cluster parameter group to associate with this DB cluster.
   */
  public dbClusterParameterGroupName?: string;

  /**
   * The name of the DB parameter group to apply to all instances of the DB cluster.
   */
  public dbInstanceParameterGroupName?: string;

  /**
   * A DB subnet group that you want to associate with this DB cluster.
   */
  public dbSubnetGroupName?: string;

  /**
   * Reserved for future use.
   */
  public dbSystemId?: string;

  /**
   * A value that indicates whether the DB cluster has deletion protection enabled.
   */
  public deletionProtection?: boolean | cdk.IResolvable;

  /**
   * Indicates the directory ID of the Active Directory to create the DB cluster.
   */
  public domain?: string;

  /**
   * Specifies the name of the IAM role to use when making API calls to the Directory Service.
   */
  public domainIamRoleName?: string;

  /**
   * The list of log types that need to be enabled for exporting to CloudWatch Logs.
   */
  public enableCloudwatchLogsExports?: Array<string>;

  /**
   * A value that indicates whether to enable the HTTP endpoint for an Aurora Serverless DB cluster.
   */
  public enableHttpEndpoint?: boolean | cdk.IResolvable;

  /**
   * A value that indicates whether to enable mapping of AWS Identity and Access Management (IAM) accounts to database accounts.
   */
  public enableIamDatabaseAuthentication?: boolean | cdk.IResolvable;

  /**
   * The name of the database engine to be used for this DB cluster.
   */
  public engine?: string;

  /**
   * The DB engine mode of the DB cluster, either \`provisioned\` or \`serverless\` .
   */
  public engineMode?: string;

  /**
   * The version number of the database engine to use.
   */
  public engineVersion?: string;

  /**
   * If you are configuring an Aurora global database cluster and want your Aurora DB cluster to be a secondary member in the global database cluster, specify the global cluster ID of the global database cluster.
   */
  public globalClusterIdentifier?: string;

  /**
   * The amount of Provisioned IOPS (input/output operations per second) to be initially allocated for each DB instance in the Multi-AZ DB cluster.
   */
  public iops?: number;

  /**
   * The Amazon Resource Name (ARN) of the AWS KMS key that is used to encrypt the database instances in the DB cluster, such as \`arn:aws:kms:us-east-1:012345678910:key/abcd1234-a123-456a-a12b-a123b4cd56ef\` .
   */
  public kmsKeyId?: string;

  /**
   * A value that indicates whether to manage the master user password with AWS Secrets Manager.
   */
  public manageMasterUserPassword?: boolean | cdk.IResolvable;

  /**
   * The name of the master user for the DB cluster.
   */
  public masterUsername?: string;

  /**
   * The master password for the DB instance.
   */
  public masterUserPassword?: string;

  /**
   * Contains the secret managed by RDS in AWS Secrets Manager for the master user password.
   */
  public masterUserSecret?: cdk.IResolvable | CfnDBCluster.MasterUserSecretProperty;

  /**
   * The interval, in seconds, between points when Enhanced Monitoring metrics are collected for the DB cluster.
   */
  public monitoringInterval?: number;

  /**
   * The Amazon Resource Name (ARN) for the IAM role that permits RDS to send Enhanced Monitoring metrics to Amazon CloudWatch Logs.
   */
  public monitoringRoleArn?: string;

  /**
   * The network type of the DB cluster.
   */
  public networkType?: string;

  /**
   * A value that indicates whether to turn on Performance Insights for the DB cluster.
   */
  public performanceInsightsEnabled?: boolean | cdk.IResolvable;

  /**
   * The AWS KMS key identifier for encryption of Performance Insights data.
   */
  public performanceInsightsKmsKeyId?: string;

  /**
   * The number of days to retain Performance Insights data. The default is 7 days. The following values are valid:.
   */
  public performanceInsightsRetentionPeriod?: number;

  /**
   * The port number on which the DB instances in the DB cluster accept connections.
   */
  public port?: number;

  /**
   * The daily time range during which automated backups are created.
   */
  public preferredBackupWindow?: string;

  /**
   * The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC).
   */
  public preferredMaintenanceWindow?: string;

  /**
   * A value that indicates whether the DB cluster is publicly accessible.
   */
  public publiclyAccessible?: boolean | cdk.IResolvable;

  /**
   * The Amazon Resource Name (ARN) of the source DB instance or DB cluster if this DB cluster is created as a read replica.
   */
  public replicationSourceIdentifier?: string;

  /**
   * The date and time to restore the DB cluster to.
   */
  public restoreToTime?: string;

  /**
   * The type of restore to be performed. You can specify one of the following values:.
   */
  public restoreType?: string;

  /**
   * The \`ScalingConfiguration\` property type specifies the scaling configuration of an Aurora Serverless DB cluster.
   */
  public scalingConfiguration?: cdk.IResolvable | CfnDBCluster.ScalingConfigurationProperty;

  /**
   * The \`ServerlessV2ScalingConfiguration\` property type specifies the scaling configuration of an Aurora Serverless V2 DB cluster.
   */
  public serverlessV2ScalingConfiguration?: cdk.IResolvable | CfnDBCluster.ServerlessV2ScalingConfigurationProperty;

  /**
   * The identifier for the DB snapshot or DB cluster snapshot to restore from.
   */
  public snapshotIdentifier?: string;

  /**
   * When restoring a DB cluster to a point in time, the identifier of the source DB cluster from which to restore.
   */
  public sourceDbClusterIdentifier?: string;

  /**
   * The AWS Region which contains the source DB cluster when replicating a DB cluster. For example, \`us-east-1\` .
   */
  public sourceRegion?: string;

  /**
   * Indicates whether the DB cluster is encrypted.
   */
  public storageEncrypted?: boolean | cdk.IResolvable;

  /**
   * Specifies the storage type to be associated with the DB cluster.
   */
  public storageType?: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * An optional array of key-value pairs to apply to this DB cluster.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * A value that indicates whether to restore the DB cluster to the latest restorable backup time.
   */
  public useLatestRestorableTime?: boolean | cdk.IResolvable;

  /**
   * A list of EC2 VPC security groups to associate with this DB cluster.
   */
  public vpcSecurityGroupIds?: Array<string>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnDBClusterProps = {}) {
    super(scope, id, {
      "type": CfnDBCluster.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.attrDbClusterArn = cdk.Token.asString(this.getAtt("DBClusterArn", cdk.ResolutionTypeHint.STRING));
    this.attrDbClusterResourceId = cdk.Token.asString(this.getAtt("DBClusterResourceId", cdk.ResolutionTypeHint.STRING));
    this.attrEndpoint = this.getAtt("Endpoint");
    this.attrEndpointAddress = cdk.Token.asString(this.getAtt("Endpoint.Address", cdk.ResolutionTypeHint.STRING));
    this.attrEndpointPort = cdk.Token.asString(this.getAtt("Endpoint.Port", cdk.ResolutionTypeHint.STRING));
    this.attrMasterUserSecretSecretArn = cdk.Token.asString(this.getAtt("MasterUserSecret.SecretArn", cdk.ResolutionTypeHint.STRING));
    this.attrReadEndpoint = this.getAtt("ReadEndpoint");
    this.attrReadEndpointAddress = cdk.Token.asString(this.getAtt("ReadEndpoint.Address", cdk.ResolutionTypeHint.STRING));
    this.allocatedStorage = props.allocatedStorage;
    this.associatedRoles = props.associatedRoles;
    this.autoMinorVersionUpgrade = props.autoMinorVersionUpgrade;
    this.availabilityZones = props.availabilityZones;
    this.backtrackWindow = props.backtrackWindow;
    this.backupRetentionPeriod = props.backupRetentionPeriod;
    this.copyTagsToSnapshot = props.copyTagsToSnapshot;
    this.databaseName = props.databaseName;
    this.dbClusterIdentifier = props.dbClusterIdentifier;
    this.dbClusterInstanceClass = props.dbClusterInstanceClass;
    this.dbClusterParameterGroupName = props.dbClusterParameterGroupName;
    this.dbInstanceParameterGroupName = props.dbInstanceParameterGroupName;
    this.dbSubnetGroupName = props.dbSubnetGroupName;
    this.dbSystemId = props.dbSystemId;
    this.deletionProtection = props.deletionProtection;
    this.domain = props.domain;
    this.domainIamRoleName = props.domainIamRoleName;
    this.enableCloudwatchLogsExports = props.enableCloudwatchLogsExports;
    this.enableHttpEndpoint = props.enableHttpEndpoint;
    this.enableIamDatabaseAuthentication = props.enableIamDatabaseAuthentication;
    this.engine = props.engine;
    this.engineMode = props.engineMode;
    this.engineVersion = props.engineVersion;
    this.globalClusterIdentifier = props.globalClusterIdentifier;
    this.iops = props.iops;
    this.kmsKeyId = props.kmsKeyId;
    this.manageMasterUserPassword = props.manageMasterUserPassword;
    this.masterUsername = props.masterUsername;
    this.masterUserPassword = props.masterUserPassword;
    this.masterUserSecret = props.masterUserSecret;
    this.monitoringInterval = props.monitoringInterval;
    this.monitoringRoleArn = props.monitoringRoleArn;
    this.networkType = props.networkType;
    this.performanceInsightsEnabled = props.performanceInsightsEnabled;
    this.performanceInsightsKmsKeyId = props.performanceInsightsKmsKeyId;
    this.performanceInsightsRetentionPeriod = props.performanceInsightsRetentionPeriod;
    this.port = props.port;
    this.preferredBackupWindow = props.preferredBackupWindow;
    this.preferredMaintenanceWindow = props.preferredMaintenanceWindow;
    this.publiclyAccessible = props.publiclyAccessible;
    this.replicationSourceIdentifier = props.replicationSourceIdentifier;
    this.restoreToTime = props.restoreToTime;
    this.restoreType = props.restoreType;
    this.scalingConfiguration = props.scalingConfiguration;
    this.serverlessV2ScalingConfiguration = props.serverlessV2ScalingConfiguration;
    this.snapshotIdentifier = props.snapshotIdentifier;
    this.sourceDbClusterIdentifier = props.sourceDbClusterIdentifier;
    this.sourceRegion = props.sourceRegion;
    this.storageEncrypted = props.storageEncrypted;
    this.storageType = props.storageType;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::RDS::DBCluster", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.useLatestRestorableTime = props.useLatestRestorableTime;
    this.vpcSecurityGroupIds = props.vpcSecurityGroupIds;
    if ((this.node.scope != null && cdk.Resource.isResource(this.node.scope))) {
      this.node.addValidation({
        "validate": () => ((this.cfnOptions.deletionPolicy === undefined) ? ["'AWS::RDS::DBCluster' is a stateful resource type, and you must specify a Removal Policy for it. Call 'resource.applyRemovalPolicy()'."] : [])
      });
    }
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "allocatedStorage": this.allocatedStorage,
      "associatedRoles": this.associatedRoles,
      "autoMinorVersionUpgrade": this.autoMinorVersionUpgrade,
      "availabilityZones": this.availabilityZones,
      "backtrackWindow": this.backtrackWindow,
      "backupRetentionPeriod": this.backupRetentionPeriod,
      "copyTagsToSnapshot": this.copyTagsToSnapshot,
      "databaseName": this.databaseName,
      "dbClusterIdentifier": this.dbClusterIdentifier,
      "dbClusterInstanceClass": this.dbClusterInstanceClass,
      "dbClusterParameterGroupName": this.dbClusterParameterGroupName,
      "dbInstanceParameterGroupName": this.dbInstanceParameterGroupName,
      "dbSubnetGroupName": this.dbSubnetGroupName,
      "dbSystemId": this.dbSystemId,
      "deletionProtection": this.deletionProtection,
      "domain": this.domain,
      "domainIamRoleName": this.domainIamRoleName,
      "enableCloudwatchLogsExports": this.enableCloudwatchLogsExports,
      "enableHttpEndpoint": this.enableHttpEndpoint,
      "enableIamDatabaseAuthentication": this.enableIamDatabaseAuthentication,
      "engine": this.engine,
      "engineMode": this.engineMode,
      "engineVersion": this.engineVersion,
      "globalClusterIdentifier": this.globalClusterIdentifier,
      "iops": this.iops,
      "kmsKeyId": this.kmsKeyId,
      "manageMasterUserPassword": this.manageMasterUserPassword,
      "masterUsername": this.masterUsername,
      "masterUserPassword": this.masterUserPassword,
      "masterUserSecret": this.masterUserSecret,
      "monitoringInterval": this.monitoringInterval,
      "monitoringRoleArn": this.monitoringRoleArn,
      "networkType": this.networkType,
      "performanceInsightsEnabled": this.performanceInsightsEnabled,
      "performanceInsightsKmsKeyId": this.performanceInsightsKmsKeyId,
      "performanceInsightsRetentionPeriod": this.performanceInsightsRetentionPeriod,
      "port": this.port,
      "preferredBackupWindow": this.preferredBackupWindow,
      "preferredMaintenanceWindow": this.preferredMaintenanceWindow,
      "publiclyAccessible": this.publiclyAccessible,
      "replicationSourceIdentifier": this.replicationSourceIdentifier,
      "restoreToTime": this.restoreToTime,
      "restoreType": this.restoreType,
      "scalingConfiguration": this.scalingConfiguration,
      "serverlessV2ScalingConfiguration": this.serverlessV2ScalingConfiguration,
      "snapshotIdentifier": this.snapshotIdentifier,
      "sourceDbClusterIdentifier": this.sourceDbClusterIdentifier,
      "sourceRegion": this.sourceRegion,
      "storageEncrypted": this.storageEncrypted,
      "storageType": this.storageType,
      "tags": this.tags.renderTags(),
      "useLatestRestorableTime": this.useLatestRestorableTime,
      "vpcSecurityGroupIds": this.vpcSecurityGroupIds
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnDBCluster.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnDBClusterPropsToCloudFormation(props);
  }
}

export namespace CfnDBCluster {
  /**
   * Describes an AWS Identity and Access Management (IAM) role that is associated with a DB cluster.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbcluster-dbclusterrole.html
   */
  export interface DBClusterRoleProperty {
    /**
     * The name of the feature associated with the AWS Identity and Access Management (IAM) role.
     *
     * IAM roles that are associated with a DB cluster grant permission for the DB cluster to access other AWS services on your behalf. For the list of supported feature names, see the \`SupportedFeatureNames\` description in [DBEngineVersion](https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_DBEngineVersion.html) in the *Amazon RDS API Reference* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbcluster-dbclusterrole.html#cfn-rds-dbcluster-dbclusterrole-featurename
     */
    readonly featureName?: string;

    /**
     * The Amazon Resource Name (ARN) of the IAM role that is associated with the DB cluster.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbcluster-dbclusterrole.html#cfn-rds-dbcluster-dbclusterrole-rolearn
     */
    readonly roleArn: string;
  }

  /**
   * The \`MasterUserSecret\` return value specifies the secret managed by RDS in AWS Secrets Manager for the master user password.
   *
   * For more information, see [Password management with AWS Secrets Manager](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-secrets-manager.html) in the *Amazon RDS User Guide* and [Password management with AWS Secrets Manager](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/rds-secrets-manager.html) in the *Amazon Aurora User Guide.*
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbcluster-masterusersecret.html
   */
  export interface MasterUserSecretProperty {
    /**
     * The AWS KMS key identifier that is used to encrypt the secret.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbcluster-masterusersecret.html#cfn-rds-dbcluster-masterusersecret-kmskeyid
     */
    readonly kmsKeyId?: string;

    /**
     * The Amazon Resource Name (ARN) of the secret.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbcluster-masterusersecret.html#cfn-rds-dbcluster-masterusersecret-secretarn
     */
    readonly secretArn?: string;
  }

  /**
   * The \`ServerlessV2ScalingConfiguration\` property type specifies the scaling configuration of an Aurora Serverless V2 DB cluster.
   *
   * For more information, see [Using Amazon Aurora Serverless v2](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless-v2.html) in the *Amazon Aurora User Guide* .
   *
   * If you have an Aurora cluster, you must set the \`ScalingConfigurationInfo\` attribute before you add a DB instance that uses the \`db.serverless\` DB instance class. For more information, see [Clusters that use Aurora Serverless v2 must have a capacity range specified](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless-v2.requirements.html#aurora-serverless-v2.requirements.capacity-range) in the *Amazon Aurora User Guide* .
   *
   * This property is only supported for Aurora Serverless v2. For Aurora Serverless v1, use \`ScalingConfiguration\` property.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbcluster-serverlessv2scalingconfiguration.html
   */
  export interface ServerlessV2ScalingConfigurationProperty {
    /**
     * The maximum number of Aurora capacity units (ACUs) for a DB instance in an Aurora Serverless v2 cluster.
     *
     * You can specify ACU values in half-step increments, such as 40, 40.5, 41, and so on. The largest value that you can use is 128.
     *
     * The maximum capacity must be higher than 0.5 ACUs. For more information, see [Choosing the maximum Aurora Serverless v2 capacity setting for a cluster](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless-v2.setting-capacity.html#aurora-serverless-v2.max_capacity_considerations) in the *Amazon Aurora User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbcluster-serverlessv2scalingconfiguration.html#cfn-rds-dbcluster-serverlessv2scalingconfiguration-maxcapacity
     */
    readonly maxCapacity?: number;

    /**
     * The minimum number of Aurora capacity units (ACUs) for a DB instance in an Aurora Serverless v2 cluster.
     *
     * You can specify ACU values in half-step increments, such as 8, 8.5, 9, and so on. The smallest value that you can use is 0.5.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbcluster-serverlessv2scalingconfiguration.html#cfn-rds-dbcluster-serverlessv2scalingconfiguration-mincapacity
     */
    readonly minCapacity?: number;
  }

  /**
   * The \`ScalingConfiguration\` property type specifies the scaling configuration of an Aurora Serverless DB cluster.
   *
   * For more information, see [Using Amazon Aurora Serverless](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless.html) in the *Amazon Aurora User Guide* .
   *
   * This property is only supported for Aurora Serverless v1. For Aurora Serverless v2, use \`ServerlessV2ScalingConfiguration\` property.
   *
   * Valid for: Aurora DB clusters only
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbcluster-scalingconfiguration.html
   */
  export interface ScalingConfigurationProperty {
    /**
     * A value that indicates whether to allow or disallow automatic pause for an Aurora DB cluster in \`serverless\` DB engine mode.
     *
     * A DB cluster can be paused only when it's idle (it has no connections).
     *
     * > If a DB cluster is paused for more than seven days, the DB cluster might be backed up with a snapshot. In this case, the DB cluster is restored when there is a request to connect to it.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbcluster-scalingconfiguration.html#cfn-rds-dbcluster-scalingconfiguration-autopause
     */
    readonly autoPause?: boolean | cdk.IResolvable;

    /**
     * The maximum capacity for an Aurora DB cluster in \`serverless\` DB engine mode.
     *
     * For Aurora MySQL, valid capacity values are \`1\` , \`2\` , \`4\` , \`8\` , \`16\` , \`32\` , \`64\` , \`128\` , and \`256\` .
     *
     * For Aurora PostgreSQL, valid capacity values are \`2\` , \`4\` , \`8\` , \`16\` , \`32\` , \`64\` , \`192\` , and \`384\` .
     *
     * The maximum capacity must be greater than or equal to the minimum capacity.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbcluster-scalingconfiguration.html#cfn-rds-dbcluster-scalingconfiguration-maxcapacity
     */
    readonly maxCapacity?: number;

    /**
     * The minimum capacity for an Aurora DB cluster in \`serverless\` DB engine mode.
     *
     * For Aurora MySQL, valid capacity values are \`1\` , \`2\` , \`4\` , \`8\` , \`16\` , \`32\` , \`64\` , \`128\` , and \`256\` .
     *
     * For Aurora PostgreSQL, valid capacity values are \`2\` , \`4\` , \`8\` , \`16\` , \`32\` , \`64\` , \`192\` , and \`384\` .
     *
     * The minimum capacity must be less than or equal to the maximum capacity.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbcluster-scalingconfiguration.html#cfn-rds-dbcluster-scalingconfiguration-mincapacity
     */
    readonly minCapacity?: number;

    /**
     * The amount of time, in seconds, that Aurora Serverless v1 tries to find a scaling point to perform seamless scaling before enforcing the timeout action.
     *
     * The default is 300.
     *
     * Specify a value between 60 and 600 seconds.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbcluster-scalingconfiguration.html#cfn-rds-dbcluster-scalingconfiguration-secondsbeforetimeout
     */
    readonly secondsBeforeTimeout?: number;

    /**
     * The time, in seconds, before an Aurora DB cluster in \`serverless\` mode is paused.
     *
     * Specify a value between 300 and 86,400 seconds.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbcluster-scalingconfiguration.html#cfn-rds-dbcluster-scalingconfiguration-secondsuntilautopause
     */
    readonly secondsUntilAutoPause?: number;

    /**
     * The action to take when the timeout is reached, either \`ForceApplyCapacityChange\` or \`RollbackCapacityChange\` .
     *
     * \`ForceApplyCapacityChange\` sets the capacity to the specified value as soon as possible.
     *
     * \`RollbackCapacityChange\` , the default, ignores the capacity change if a scaling point isn't found in the timeout period.
     *
     * > If you specify \`ForceApplyCapacityChange\` , connections that prevent Aurora Serverless v1 from finding a scaling point might be dropped.
     *
     * For more information, see [Autoscaling for Aurora Serverless v1](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless.how-it-works.html#aurora-serverless.how-it-works.auto-scaling) in the *Amazon Aurora User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbcluster-scalingconfiguration.html#cfn-rds-dbcluster-scalingconfiguration-timeoutaction
     */
    readonly timeoutAction?: string;
  }

  /**
   * The \`Endpoint\` return value specifies the connection endpoint for the primary instance of the DB cluster.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbcluster-endpoint.html
   */
  export interface EndpointProperty {
    /**
     * Specifies the connection endpoint for the primary instance of the DB cluster.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbcluster-endpoint.html#cfn-rds-dbcluster-endpoint-address
     */
    readonly address?: string;

    /**
     * Specifies the port that the database engine is listening on.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbcluster-endpoint.html#cfn-rds-dbcluster-endpoint-port
     */
    readonly port?: string;
  }

  /**
   * The \`ReadEndpoint\` return value specifies the reader endpoint for the DB cluster.
   *
   * The reader endpoint for a DB cluster load-balances connections across the Aurora Replicas that are available in a DB cluster. As clients request new connections to the reader endpoint, Aurora distributes the connection requests among the Aurora Replicas in the DB cluster. This functionality can help balance your read workload across multiple Aurora Replicas in your DB cluster.
   *
   * If a failover occurs, and the Aurora Replica that you are connected to is promoted to be the primary instance, your connection is dropped. To continue sending your read workload to other Aurora Replicas in the cluster, you can then reconnect to the reader endpoint.
   *
   * For more information about Aurora endpoints, see [Amazon Aurora connection management](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Aurora.Overview.Endpoints.html) in the *Amazon Aurora User Guide* .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbcluster-readendpoint.html
   */
  export interface ReadEndpointProperty {
    /**
     * The host address of the reader endpoint.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbcluster-readendpoint.html#cfn-rds-dbcluster-readendpoint-address
     */
    readonly address?: string;
  }
}

/**
 * Properties for defining a \`CfnDBCluster\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html
 */
export interface CfnDBClusterProps {
  /**
   * The amount of storage in gibibytes (GiB) to allocate to each DB instance in the Multi-AZ DB cluster.
   *
   * This setting is required to create a Multi-AZ DB cluster.
   *
   * Valid for: Multi-AZ DB clusters only
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-allocatedstorage
   */
  readonly allocatedStorage?: number;

  /**
   * Provides a list of the AWS Identity and Access Management (IAM) roles that are associated with the DB cluster.
   *
   * IAM roles that are associated with a DB cluster grant permission for the DB cluster to access other Amazon Web Services on your behalf.
   *
   * Valid for: Aurora DB clusters and Multi-AZ DB clusters
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-associatedroles
   */
  readonly associatedRoles?: Array<CfnDBCluster.DBClusterRoleProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * A value that indicates whether minor engine upgrades are applied automatically to the DB cluster during the maintenance window.
   *
   * By default, minor engine upgrades are applied automatically.
   *
   * Valid for: Multi-AZ DB clusters only
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-autominorversionupgrade
   */
  readonly autoMinorVersionUpgrade?: boolean | cdk.IResolvable;

  /**
   * A list of Availability Zones (AZs) where instances in the DB cluster can be created.
   *
   * For information on AWS Regions and Availability Zones, see [Choosing the Regions and Availability Zones](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Concepts.RegionsAndAvailabilityZones.html) in the *Amazon Aurora User Guide* .
   *
   * Valid for: Aurora DB clusters only
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-availabilityzones
   */
  readonly availabilityZones?: Array<string>;

  /**
   * The target backtrack window, in seconds. To disable backtracking, set this value to 0.
   *
   * > Currently, Backtrack is only supported for Aurora MySQL DB clusters.
   *
   * Default: 0
   *
   * Constraints:
   *
   * - If specified, this value must be set to a number from 0 to 259,200 (72 hours).
   *
   * Valid for: Aurora MySQL DB clusters only
   *
   * @default - 0
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-backtrackwindow
   */
  readonly backtrackWindow?: number;

  /**
   * The number of days for which automated backups are retained.
   *
   * Default: 1
   *
   * Constraints:
   *
   * - Must be a value from 1 to 35
   *
   * Valid for: Aurora DB clusters and Multi-AZ DB clusters
   *
   * @default - 1
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-backupretentionperiod
   */
  readonly backupRetentionPeriod?: number;

  /**
   * A value that indicates whether to copy all tags from the DB cluster to snapshots of the DB cluster.
   *
   * The default is not to copy them.
   *
   * Valid for: Aurora DB clusters and Multi-AZ DB clusters
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-copytagstosnapshot
   */
  readonly copyTagsToSnapshot?: boolean | cdk.IResolvable;

  /**
   * The name of your database.
   *
   * If you don't provide a name, then Amazon RDS won't create a database in this DB cluster. For naming constraints, see [Naming Constraints](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/CHAP_Limits.html#RDS_Limits.Constraints) in the *Amazon Aurora User Guide* .
   *
   * Valid for: Aurora DB clusters and Multi-AZ DB clusters
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-databasename
   */
  readonly databaseName?: string;

  /**
   * The DB cluster identifier. This parameter is stored as a lowercase string.
   *
   * Constraints:
   *
   * - Must contain from 1 to 63 letters, numbers, or hyphens.
   * - First character must be a letter.
   * - Can't end with a hyphen or contain two consecutive hyphens.
   *
   * Example: \`my-cluster1\`
   *
   * Valid for: Aurora DB clusters and Multi-AZ DB clusters
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-dbclusteridentifier
   */
  readonly dbClusterIdentifier?: string;

  /**
   * The compute and memory capacity of each DB instance in the Multi-AZ DB cluster, for example db.m6gd.xlarge. Not all DB instance classes are available in all AWS Regions , or for all database engines.
   *
   * For the full list of DB instance classes and availability for your engine, see [DB instance class](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.DBInstanceClass.html) in the *Amazon RDS User Guide* .
   *
   * This setting is required to create a Multi-AZ DB cluster.
   *
   * Valid for: Multi-AZ DB clusters only
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-dbclusterinstanceclass
   */
  readonly dbClusterInstanceClass?: string;

  /**
   * The name of the DB cluster parameter group to associate with this DB cluster.
   *
   * > If you apply a parameter group to an existing DB cluster, then its DB instances might need to reboot. This can result in an outage while the DB instances are rebooting.
   * >
   * > If you apply a change to parameter group associated with a stopped DB cluster, then the update stack waits until the DB cluster is started.
   *
   * To list all of the available DB cluster parameter group names, use the following command:
   *
   * \`aws rds describe-db-cluster-parameter-groups --query "DBClusterParameterGroups[].DBClusterParameterGroupName" --output text\`
   *
   * Valid for: Aurora DB clusters and Multi-AZ DB clusters
   *
   * @default - "default.aurora5.6"
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-dbclusterparametergroupname
   */
  readonly dbClusterParameterGroupName?: string;

  /**
   * The name of the DB parameter group to apply to all instances of the DB cluster.
   *
   * > When you apply a parameter group using the \`DBInstanceParameterGroupName\` parameter, the DB cluster isn't rebooted automatically. Also, parameter changes are applied immediately rather than during the next maintenance window.
   *
   * Default: The existing name setting
   *
   * Constraints:
   *
   * - The DB parameter group must be in the same DB parameter group family as this DB cluster.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-dbinstanceparametergroupname
   */
  readonly dbInstanceParameterGroupName?: string;

  /**
   * A DB subnet group that you want to associate with this DB cluster.
   *
   * If you are restoring a DB cluster to a point in time with \`RestoreType\` set to \`copy-on-write\` , and don't specify a DB subnet group name, then the DB cluster is restored with a default DB subnet group.
   *
   * Valid for: Aurora DB clusters and Multi-AZ DB clusters
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-dbsubnetgroupname
   */
  readonly dbSubnetGroupName?: string;

  /**
   * Reserved for future use.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-dbsystemid
   */
  readonly dbSystemId?: string;

  /**
   * A value that indicates whether the DB cluster has deletion protection enabled.
   *
   * The database can't be deleted when deletion protection is enabled. By default, deletion protection is disabled.
   *
   * Valid for: Aurora DB clusters and Multi-AZ DB clusters
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-deletionprotection
   */
  readonly deletionProtection?: boolean | cdk.IResolvable;

  /**
   * Indicates the directory ID of the Active Directory to create the DB cluster.
   *
   * For Amazon Aurora DB clusters, Amazon RDS can use Kerberos authentication to authenticate users that connect to the DB cluster.
   *
   * For more information, see [Kerberos authentication](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/kerberos-authentication.html) in the *Amazon Aurora User Guide* .
   *
   * Valid for: Aurora DB clusters only
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-domain
   */
  readonly domain?: string;

  /**
   * Specifies the name of the IAM role to use when making API calls to the Directory Service.
   *
   * Valid for: Aurora DB clusters only
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-domainiamrolename
   */
  readonly domainIamRoleName?: string;

  /**
   * The list of log types that need to be enabled for exporting to CloudWatch Logs.
   *
   * The values in the list depend on the DB engine being used. For more information, see [Publishing Database Logs to Amazon CloudWatch Logs](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_LogAccess.html#USER_LogAccess.Procedural.UploadtoCloudWatch) in the *Amazon Aurora User Guide* .
   *
   * *Aurora MySQL*
   *
   * Valid values: \`audit\` , \`error\` , \`general\` , \`slowquery\`
   *
   * *Aurora PostgreSQL*
   *
   * Valid values: \`postgresql\`
   *
   * Valid for: Aurora DB clusters and Multi-AZ DB clusters
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-enablecloudwatchlogsexports
   */
  readonly enableCloudwatchLogsExports?: Array<string>;

  /**
   * A value that indicates whether to enable the HTTP endpoint for an Aurora Serverless DB cluster.
   *
   * By default, the HTTP endpoint is disabled.
   *
   * When enabled, the HTTP endpoint provides a connectionless web service API for running SQL queries on the Aurora Serverless DB cluster. You can also query your database from inside the RDS console with the query editor.
   *
   * For more information, see [Using the Data API for Aurora Serverless](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/data-api.html) in the *Amazon Aurora User Guide* .
   *
   * Valid for: Aurora DB clusters only
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-enablehttpendpoint
   */
  readonly enableHttpEndpoint?: boolean | cdk.IResolvable;

  /**
   * A value that indicates whether to enable mapping of AWS Identity and Access Management (IAM) accounts to database accounts.
   *
   * By default, mapping is disabled.
   *
   * For more information, see [IAM Database Authentication](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/UsingWithRDS.IAMDBAuth.html) in the *Amazon Aurora User Guide.*
   *
   * Valid for: Aurora DB clusters only
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-enableiamdatabaseauthentication
   */
  readonly enableIamDatabaseAuthentication?: boolean | cdk.IResolvable;

  /**
   * The name of the database engine to be used for this DB cluster.
   *
   * Valid Values:
   *
   * - \`aurora-mysql\`
   * - \`aurora-postgresql\`
   * - \`mysql\`
   * - \`postgres\`
   *
   * Valid for: Aurora DB clusters and Multi-AZ DB clusters
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-engine
   */
  readonly engine?: string;

  /**
   * The DB engine mode of the DB cluster, either \`provisioned\` or \`serverless\` .
   *
   * The \`serverless\` engine mode only supports Aurora Serverless v1. Currently, AWS CloudFormation doesn't support Aurora Serverless v2.
   *
   * Limitations and requirements apply to some DB engine modes. For more information, see the following sections in the *Amazon Aurora User Guide* :
   *
   * - [Limitations of Aurora Serverless v1](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless.html#aurora-serverless.limitations)
   * - [Requirements for Aurora Serverless v2](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless-v2.requirements.html)
   * - [Limitations of parallel query](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-mysql-parallel-query.html#aurora-mysql-parallel-query-limitations)
   * - [Limitations of Aurora global databases](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-global-database.html#aurora-global-database.limitations)
   *
   * Valid for: Aurora DB clusters only
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-enginemode
   */
  readonly engineMode?: string;

  /**
   * The version number of the database engine to use.
   *
   * To list all of the available engine versions for Aurora MySQL version 2 (5.7-compatible) and version 3 (8.0-compatible), use the following command:
   *
   * \`aws rds describe-db-engine-versions --engine aurora-mysql --query "DBEngineVersions[].EngineVersion"\`
   *
   * You can supply either \`5.7\` or \`8.0\` to use the default engine version for Aurora MySQL version 2 or version 3, respectively.
   *
   * To list all of the available engine versions for Aurora PostgreSQL, use the following command:
   *
   * \`aws rds describe-db-engine-versions --engine aurora-postgresql --query "DBEngineVersions[].EngineVersion"\`
   *
   * To list all of the available engine versions for RDS for MySQL, use the following command:
   *
   * \`aws rds describe-db-engine-versions --engine mysql --query "DBEngineVersions[].EngineVersion"\`
   *
   * To list all of the available engine versions for RDS for PostgreSQL, use the following command:
   *
   * \`aws rds describe-db-engine-versions --engine postgres --query "DBEngineVersions[].EngineVersion"\`
   *
   * *Aurora MySQL*
   *
   * For information, see [Database engine updates for Amazon Aurora MySQL](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/AuroraMySQL.Updates.html) in the *Amazon Aurora User Guide* .
   *
   * *Aurora PostgreSQL*
   *
   * For information, see [Amazon Aurora PostgreSQL releases and engine versions](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/AuroraPostgreSQL.Updates.20180305.html) in the *Amazon Aurora User Guide* .
   *
   * *MySQL*
   *
   * For information, see [Amazon RDS for MySQL](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_MySQL.html#MySQL.Concepts.VersionMgmt) in the *Amazon RDS User Guide* .
   *
   * *PostgreSQL*
   *
   * For information, see [Amazon RDS for PostgreSQL](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_PostgreSQL.html#PostgreSQL.Concepts) in the *Amazon RDS User Guide* .
   *
   * Valid for: Aurora DB clusters and Multi-AZ DB clusters
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-engineversion
   */
  readonly engineVersion?: string;

  /**
   * If you are configuring an Aurora global database cluster and want your Aurora DB cluster to be a secondary member in the global database cluster, specify the global cluster ID of the global database cluster.
   *
   * To define the primary database cluster of the global cluster, use the [AWS::RDS::GlobalCluster](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-globalcluster.html) resource.
   *
   * If you aren't configuring a global database cluster, don't specify this property.
   *
   * > To remove the DB cluster from a global database cluster, specify an empty value for the \`GlobalClusterIdentifier\` property.
   *
   * For information about Aurora global databases, see [Working with Amazon Aurora Global Databases](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-global-database.html) in the *Amazon Aurora User Guide* .
   *
   * Valid for: Aurora DB clusters only
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-globalclusteridentifier
   */
  readonly globalClusterIdentifier?: string;

  /**
   * The amount of Provisioned IOPS (input/output operations per second) to be initially allocated for each DB instance in the Multi-AZ DB cluster.
   *
   * For information about valid IOPS values, see [Provisioned IOPS storage](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_Storage.html#USER_PIOPS) in the *Amazon RDS User Guide* .
   *
   * This setting is required to create a Multi-AZ DB cluster.
   *
   * Constraints: Must be a multiple between .5 and 50 of the storage amount for the DB cluster.
   *
   * Valid for: Multi-AZ DB clusters only
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-iops
   */
  readonly iops?: number;

  /**
   * The Amazon Resource Name (ARN) of the AWS KMS key that is used to encrypt the database instances in the DB cluster, such as \`arn:aws:kms:us-east-1:012345678910:key/abcd1234-a123-456a-a12b-a123b4cd56ef\` .
   *
   * If you enable the \`StorageEncrypted\` property but don't specify this property, the default KMS key is used. If you specify this property, you must set the \`StorageEncrypted\` property to \`true\` .
   *
   * If you specify the \`SnapshotIdentifier\` property, the \`StorageEncrypted\` property value is inherited from the snapshot, and if the DB cluster is encrypted, the specified \`KmsKeyId\` property is used.
   *
   * Valid for: Aurora DB clusters and Multi-AZ DB clusters
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-kmskeyid
   */
  readonly kmsKeyId?: string;

  /**
   * A value that indicates whether to manage the master user password with AWS Secrets Manager.
   *
   * For more information, see [Password management with AWS Secrets Manager](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-secrets-manager.html) in the *Amazon RDS User Guide* and [Password management with AWS Secrets Manager](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/rds-secrets-manager.html) in the *Amazon Aurora User Guide.*
   *
   * Constraints:
   *
   * - Can't manage the master user password with AWS Secrets Manager if \`MasterUserPassword\` is specified.
   *
   * Valid for: Aurora DB clusters and Multi-AZ DB clusters
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-managemasteruserpassword
   */
  readonly manageMasterUserPassword?: boolean | cdk.IResolvable;

  /**
   * The name of the master user for the DB cluster.
   *
   * > If you specify the \`SourceDBClusterIdentifier\` , \`SnapshotIdentifier\` , or \`GlobalClusterIdentifier\` property, don't specify this property. The value is inherited from the source DB cluster, the snapshot, or the primary DB cluster for the global database cluster, respectively.
   *
   * Valid for: Aurora DB clusters and Multi-AZ DB clusters
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-masterusername
   */
  readonly masterUsername?: string;

  /**
   * The master password for the DB instance.
   *
   * > If you specify the \`SourceDBClusterIdentifier\` , \`SnapshotIdentifier\` , or \`GlobalClusterIdentifier\` property, don't specify this property. The value is inherited from the source DB cluster, the snapshot, or the primary DB cluster for the global database cluster, respectively.
   *
   * Valid for: Aurora DB clusters and Multi-AZ DB clusters
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-masteruserpassword
   */
  readonly masterUserPassword?: string;

  /**
   * Contains the secret managed by RDS in AWS Secrets Manager for the master user password.
   *
   * For more information, see [Password management with AWS Secrets Manager](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-secrets-manager.html) in the *Amazon RDS User Guide* and [Password management with AWS Secrets Manager](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/rds-secrets-manager.html) in the *Amazon Aurora User Guide.*
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-masterusersecret
   */
  readonly masterUserSecret?: cdk.IResolvable | CfnDBCluster.MasterUserSecretProperty;

  /**
   * The interval, in seconds, between points when Enhanced Monitoring metrics are collected for the DB cluster.
   *
   * To turn off collecting Enhanced Monitoring metrics, specify 0. The default is 0.
   *
   * If \`MonitoringRoleArn\` is specified, also set \`MonitoringInterval\` to a value other than 0.
   *
   * Valid Values: \`0, 1, 5, 10, 15, 30, 60\`
   *
   * Valid for: Multi-AZ DB clusters only
   *
   * @default - 0
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-monitoringinterval
   */
  readonly monitoringInterval?: number;

  /**
   * The Amazon Resource Name (ARN) for the IAM role that permits RDS to send Enhanced Monitoring metrics to Amazon CloudWatch Logs.
   *
   * An example is \`arn:aws:iam:123456789012:role/emaccess\` . For information on creating a monitoring role, see [Setting up and enabling Enhanced Monitoring](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Monitoring.OS.html#USER_Monitoring.OS.Enabling) in the *Amazon RDS User Guide* .
   *
   * If \`MonitoringInterval\` is set to a value other than 0, supply a \`MonitoringRoleArn\` value.
   *
   * Valid for: Multi-AZ DB clusters only
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-monitoringrolearn
   */
  readonly monitoringRoleArn?: string;

  /**
   * The network type of the DB cluster.
   *
   * Valid values:
   *
   * - \`IPV4\`
   * - \`DUAL\`
   *
   * The network type is determined by the \`DBSubnetGroup\` specified for the DB cluster. A \`DBSubnetGroup\` can support only the IPv4 protocol or the IPv4 and IPv6 protocols ( \`DUAL\` ).
   *
   * For more information, see [Working with a DB instance in a VPC](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_VPC.WorkingWithRDSInstanceinaVPC.html) in the *Amazon Aurora User Guide.*
   *
   * Valid for: Aurora DB clusters only
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-networktype
   */
  readonly networkType?: string;

  /**
   * A value that indicates whether to turn on Performance Insights for the DB cluster.
   *
   * For more information, see [Using Amazon Performance Insights](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PerfInsights.html) in the *Amazon RDS User Guide* .
   *
   * Valid for: Multi-AZ DB clusters only
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-performanceinsightsenabled
   */
  readonly performanceInsightsEnabled?: boolean | cdk.IResolvable;

  /**
   * The AWS KMS key identifier for encryption of Performance Insights data.
   *
   * The AWS KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key.
   *
   * If you don't specify a value for \`PerformanceInsightsKMSKeyId\` , then Amazon RDS uses your default KMS key. There is a default KMS key for your AWS account . Your AWS account has a different default KMS key for each AWS Region .
   *
   * Valid for: Multi-AZ DB clusters only
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-performanceinsightskmskeyid
   */
  readonly performanceInsightsKmsKeyId?: string;

  /**
   * The number of days to retain Performance Insights data. The default is 7 days. The following values are valid:.
   *
   * - 7
   * - *month* * 31, where *month* is a number of months from 1-23
   * - 731
   *
   * For example, the following values are valid:
   *
   * - 93 (3 months * 31)
   * - 341 (11 months * 31)
   * - 589 (19 months * 31)
   * - 731
   *
   * If you specify a retention period such as 94, which isn't a valid value, RDS issues an error.
   *
   * Valid for: Multi-AZ DB clusters only
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-performanceinsightsretentionperiod
   */
  readonly performanceInsightsRetentionPeriod?: number;

  /**
   * The port number on which the DB instances in the DB cluster accept connections.
   *
   * Default:
   *
   * - When \`EngineMode\` is \`provisioned\` , \`3306\` (for both Aurora MySQL and Aurora PostgreSQL)
   * - When \`EngineMode\` is \`serverless\` :
   *
   * - \`3306\` when \`Engine\` is \`aurora\` or \`aurora-mysql\`
   * - \`5432\` when \`Engine\` is \`aurora-postgresql\`
   *
   * > The \`No interruption\` on update behavior only applies to DB clusters. If you are updating a DB instance, see [Port](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-database-instance.html#cfn-rds-dbinstance-port) for the AWS::RDS::DBInstance resource.
   *
   * Valid for: Aurora DB clusters and Multi-AZ DB clusters
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-port
   */
  readonly port?: number;

  /**
   * The daily time range during which automated backups are created.
   *
   * For more information, see [Backup Window](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Aurora.Managing.Backups.html#Aurora.Managing.Backups.BackupWindow) in the *Amazon Aurora User Guide.*
   *
   * Constraints:
   *
   * - Must be in the format \`hh24:mi-hh24:mi\` .
   * - Must be in Universal Coordinated Time (UTC).
   * - Must not conflict with the preferred maintenance window.
   * - Must be at least 30 minutes.
   *
   * Valid for: Aurora DB clusters and Multi-AZ DB clusters
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-preferredbackupwindow
   */
  readonly preferredBackupWindow?: string;

  /**
   * The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC).
   *
   * Format: \`ddd:hh24:mi-ddd:hh24:mi\`
   *
   * The default is a 30-minute window selected at random from an 8-hour block of time for each AWS Region, occurring on a random day of the week. To see the time blocks available, see [Adjusting the Preferred DB Cluster Maintenance Window](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_UpgradeDBInstance.Maintenance.html#AdjustingTheMaintenanceWindow.Aurora) in the *Amazon Aurora User Guide.*
   *
   * Valid Days: Mon, Tue, Wed, Thu, Fri, Sat, Sun.
   *
   * Constraints: Minimum 30-minute window.
   *
   * Valid for: Aurora DB clusters and Multi-AZ DB clusters
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-preferredmaintenancewindow
   */
  readonly preferredMaintenanceWindow?: string;

  /**
   * A value that indicates whether the DB cluster is publicly accessible.
   *
   * When the DB cluster is publicly accessible, its Domain Name System (DNS) endpoint resolves to the private IP address from within the DB cluster's virtual private cloud (VPC). It resolves to the public IP address from outside of the DB cluster's VPC. Access to the DB cluster is ultimately controlled by the security group it uses. That public access isn't permitted if the security group assigned to the DB cluster doesn't permit it.
   *
   * When the DB cluster isn't publicly accessible, it is an internal DB cluster with a DNS name that resolves to a private IP address.
   *
   * Default: The default behavior varies depending on whether \`DBSubnetGroupName\` is specified.
   *
   * If \`DBSubnetGroupName\` isn't specified, and \`PubliclyAccessible\` isn't specified, the following applies:
   *
   * - If the default VPC in the target Region doesn’t have an internet gateway attached to it, the DB cluster is private.
   * - If the default VPC in the target Region has an internet gateway attached to it, the DB cluster is public.
   *
   * If \`DBSubnetGroupName\` is specified, and \`PubliclyAccessible\` isn't specified, the following applies:
   *
   * - If the subnets are part of a VPC that doesn’t have an internet gateway attached to it, the DB cluster is private.
   * - If the subnets are part of a VPC that has an internet gateway attached to it, the DB cluster is public.
   *
   * Valid for: Multi-AZ DB clusters only
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-publiclyaccessible
   */
  readonly publiclyAccessible?: boolean | cdk.IResolvable;

  /**
   * The Amazon Resource Name (ARN) of the source DB instance or DB cluster if this DB cluster is created as a read replica.
   *
   * Valid for: Aurora DB clusters only
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-replicationsourceidentifier
   */
  readonly replicationSourceIdentifier?: string;

  /**
   * The date and time to restore the DB cluster to.
   *
   * Valid Values: Value must be a time in Universal Coordinated Time (UTC) format
   *
   * Constraints:
   *
   * - Must be before the latest restorable time for the DB instance
   * - Must be specified if \`UseLatestRestorableTime\` parameter isn't provided
   * - Can't be specified if the \`UseLatestRestorableTime\` parameter is enabled
   * - Can't be specified if the \`RestoreType\` parameter is \`copy-on-write\`
   *
   * Example: \`2015-03-07T23:45:00Z\`
   *
   * Valid for: Aurora DB clusters and Multi-AZ DB clusters
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-restoretotime
   */
  readonly restoreToTime?: string;

  /**
   * The type of restore to be performed. You can specify one of the following values:.
   *
   * - \`full-copy\` - The new DB cluster is restored as a full copy of the source DB cluster.
   * - \`copy-on-write\` - The new DB cluster is restored as a clone of the source DB cluster.
   *
   * If you don't specify a \`RestoreType\` value, then the new DB cluster is restored as a full copy of the source DB cluster.
   *
   * Valid for: Aurora DB clusters and Multi-AZ DB clusters
   *
   * @default - "full-copy"
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-restoretype
   */
  readonly restoreType?: string;

  /**
   * The \`ScalingConfiguration\` property type specifies the scaling configuration of an Aurora Serverless DB cluster.
   *
   * This property is only supported for Aurora Serverless v1. For Aurora Serverless v2, use \`ServerlessV2ScalingConfiguration\` property.
   *
   * Valid for: Aurora DB clusters only
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-scalingconfiguration
   */
  readonly scalingConfiguration?: cdk.IResolvable | CfnDBCluster.ScalingConfigurationProperty;

  /**
   * The \`ServerlessV2ScalingConfiguration\` property type specifies the scaling configuration of an Aurora Serverless V2 DB cluster.
   *
   * This property is only supported for Aurora Serverless v2. For Aurora Serverless v1, use \`ScalingConfiguration\` property.
   *
   * Valid for: Aurora DB clusters only
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-serverlessv2scalingconfiguration
   */
  readonly serverlessV2ScalingConfiguration?: cdk.IResolvable | CfnDBCluster.ServerlessV2ScalingConfigurationProperty;

  /**
   * The identifier for the DB snapshot or DB cluster snapshot to restore from.
   *
   * You can use either the name or the Amazon Resource Name (ARN) to specify a DB cluster snapshot. However, you can use only the ARN to specify a DB snapshot.
   *
   * After you restore a DB cluster with a \`SnapshotIdentifier\` property, you must specify the same \`SnapshotIdentifier\` property for any future updates to the DB cluster. When you specify this property for an update, the DB cluster is not restored from the snapshot again, and the data in the database is not changed. However, if you don't specify the \`SnapshotIdentifier\` property, an empty DB cluster is created, and the original DB cluster is deleted. If you specify a property that is different from the previous snapshot restore property, a new DB cluster is restored from the specified \`SnapshotIdentifier\` property, and the original DB cluster is deleted.
   *
   * If you specify the \`SnapshotIdentifier\` property to restore a DB cluster (as opposed to specifying it for DB cluster updates), then don't specify the following properties:
   *
   * - \`GlobalClusterIdentifier\`
   * - \`MasterUsername\`
   * - \`MasterUserPassword\`
   * - \`ReplicationSourceIdentifier\`
   * - \`RestoreType\`
   * - \`SourceDBClusterIdentifier\`
   * - \`SourceRegion\`
   * - \`StorageEncrypted\` (for an encrypted snapshot)
   * - \`UseLatestRestorableTime\`
   *
   * Constraints:
   *
   * - Must match the identifier of an existing Snapshot.
   *
   * Valid for: Aurora DB clusters and Multi-AZ DB clusters
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-snapshotidentifier
   */
  readonly snapshotIdentifier?: string;

  /**
   * When restoring a DB cluster to a point in time, the identifier of the source DB cluster from which to restore.
   *
   * Constraints:
   *
   * - Must match the identifier of an existing DBCluster.
   *
   * Valid for: Aurora DB clusters and Multi-AZ DB clusters
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-sourcedbclusteridentifier
   */
  readonly sourceDbClusterIdentifier?: string;

  /**
   * The AWS Region which contains the source DB cluster when replicating a DB cluster. For example, \`us-east-1\` .
   *
   * Valid for: Aurora DB clusters only
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-sourceregion
   */
  readonly sourceRegion?: string;

  /**
   * Indicates whether the DB cluster is encrypted.
   *
   * If you specify the \`KmsKeyId\` property, then you must enable encryption.
   *
   * If you specify the \`SourceDBClusterIdentifier\` property, don't specify this property. The value is inherited from the source DB cluster, and if the DB cluster is encrypted, the specified \`KmsKeyId\` property is used.
   *
   * If you specify the \`SnapshotIdentifier\` and the specified snapshot is encrypted, don't specify this property. The value is inherited from the snapshot, and the specified \`KmsKeyId\` property is used.
   *
   * If you specify the \`SnapshotIdentifier\` and the specified snapshot isn't encrypted, you can use this property to specify that the restored DB cluster is encrypted. Specify the \`KmsKeyId\` property for the KMS key to use for encryption. If you don't want the restored DB cluster to be encrypted, then don't set this property or set it to \`false\` .
   *
   * Valid for: Aurora DB clusters and Multi-AZ DB clusters
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-storageencrypted
   */
  readonly storageEncrypted?: boolean | cdk.IResolvable;

  /**
   * Specifies the storage type to be associated with the DB cluster.
   *
   * This setting is required to create a Multi-AZ DB cluster.
   *
   * When specified for a Multi-AZ DB cluster, a value for the \`Iops\` parameter is required.
   *
   * Valid values: \`aurora\` , \`aurora-iopt1\` (Aurora DB clusters); \`io1\` (Multi-AZ DB clusters)
   *
   * Default: \`aurora\` (Aurora DB clusters); \`io1\` (Multi-AZ DB clusters)
   *
   * Valid for: Aurora DB clusters and Multi-AZ DB clusters
   *
   * For more information on storage types for Aurora DB clusters, see [Storage configurations for Amazon Aurora DB clusters](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Aurora.Overview.StorageReliability.html#aurora-storage-type) . For more information on storage types for Multi-AZ DB clusters, see [Settings for creating Multi-AZ DB clusters](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/create-multi-az-db-cluster.html#create-multi-az-db-cluster-settings) .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-storagetype
   */
  readonly storageType?: string;

  /**
   * An optional array of key-value pairs to apply to this DB cluster.
   *
   * Valid for: Aurora DB clusters and Multi-AZ DB clusters
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * A value that indicates whether to restore the DB cluster to the latest restorable backup time.
   *
   * By default, the DB cluster is not restored to the latest restorable backup time.
   *
   * Valid for: Aurora DB clusters and Multi-AZ DB clusters
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-uselatestrestorabletime
   */
  readonly useLatestRestorableTime?: boolean | cdk.IResolvable;

  /**
   * A list of EC2 VPC security groups to associate with this DB cluster.
   *
   * If you plan to update the resource, don't specify VPC security groups in a shared VPC.
   *
   * Valid for: Aurora DB clusters and Multi-AZ DB clusters
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-vpcsecuritygroupids
   */
  readonly vpcSecurityGroupIds?: Array<string>;
}

/**
 * Determine whether the given properties match those of a \`DBClusterRoleProperty\`
 *
 * @param properties - the TypeScript properties of a \`DBClusterRoleProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnDBClusterDBClusterRolePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("featureName", cdk.validateString)(properties.featureName));
  errors.collect(cdk.propertyValidator("roleArn", cdk.requiredValidator)(properties.roleArn));
  errors.collect(cdk.propertyValidator("roleArn", cdk.validateString)(properties.roleArn));
  return errors.wrap("supplied properties not correct for \\"DBClusterRoleProperty\\"");
}

// @ts-ignore TS6133
function convertCfnDBClusterDBClusterRolePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnDBClusterDBClusterRolePropertyValidator(properties).assertSuccess();
  return {
    "FeatureName": cdk.stringToCloudFormation(properties.featureName),
    "RoleArn": cdk.stringToCloudFormation(properties.roleArn)
  };
}

// @ts-ignore TS6133
function CfnDBClusterDBClusterRolePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnDBCluster.DBClusterRoleProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnDBCluster.DBClusterRoleProperty>();
  ret.addPropertyResult("featureName", "FeatureName", (properties.FeatureName != null ? cfn_parse.FromCloudFormation.getString(properties.FeatureName) : undefined));
  ret.addPropertyResult("roleArn", "RoleArn", (properties.RoleArn != null ? cfn_parse.FromCloudFormation.getString(properties.RoleArn) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`MasterUserSecretProperty\`
 *
 * @param properties - the TypeScript properties of a \`MasterUserSecretProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnDBClusterMasterUserSecretPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("kmsKeyId", cdk.validateString)(properties.kmsKeyId));
  errors.collect(cdk.propertyValidator("secretArn", cdk.validateString)(properties.secretArn));
  return errors.wrap("supplied properties not correct for \\"MasterUserSecretProperty\\"");
}

// @ts-ignore TS6133
function convertCfnDBClusterMasterUserSecretPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnDBClusterMasterUserSecretPropertyValidator(properties).assertSuccess();
  return {
    "KmsKeyId": cdk.stringToCloudFormation(properties.kmsKeyId),
    "SecretArn": cdk.stringToCloudFormation(properties.secretArn)
  };
}

// @ts-ignore TS6133
function CfnDBClusterMasterUserSecretPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnDBCluster.MasterUserSecretProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnDBCluster.MasterUserSecretProperty>();
  ret.addPropertyResult("kmsKeyId", "KmsKeyId", (properties.KmsKeyId != null ? cfn_parse.FromCloudFormation.getString(properties.KmsKeyId) : undefined));
  ret.addPropertyResult("secretArn", "SecretArn", (properties.SecretArn != null ? cfn_parse.FromCloudFormation.getString(properties.SecretArn) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ServerlessV2ScalingConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`ServerlessV2ScalingConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnDBClusterServerlessV2ScalingConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("maxCapacity", cdk.validateNumber)(properties.maxCapacity));
  errors.collect(cdk.propertyValidator("minCapacity", cdk.validateNumber)(properties.minCapacity));
  return errors.wrap("supplied properties not correct for \\"ServerlessV2ScalingConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnDBClusterServerlessV2ScalingConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnDBClusterServerlessV2ScalingConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "MaxCapacity": cdk.numberToCloudFormation(properties.maxCapacity),
    "MinCapacity": cdk.numberToCloudFormation(properties.minCapacity)
  };
}

// @ts-ignore TS6133
function CfnDBClusterServerlessV2ScalingConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnDBCluster.ServerlessV2ScalingConfigurationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnDBCluster.ServerlessV2ScalingConfigurationProperty>();
  ret.addPropertyResult("maxCapacity", "MaxCapacity", (properties.MaxCapacity != null ? cfn_parse.FromCloudFormation.getNumber(properties.MaxCapacity) : undefined));
  ret.addPropertyResult("minCapacity", "MinCapacity", (properties.MinCapacity != null ? cfn_parse.FromCloudFormation.getNumber(properties.MinCapacity) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ScalingConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`ScalingConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnDBClusterScalingConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("autoPause", cdk.validateBoolean)(properties.autoPause));
  errors.collect(cdk.propertyValidator("maxCapacity", cdk.validateNumber)(properties.maxCapacity));
  errors.collect(cdk.propertyValidator("minCapacity", cdk.validateNumber)(properties.minCapacity));
  errors.collect(cdk.propertyValidator("secondsBeforeTimeout", cdk.validateNumber)(properties.secondsBeforeTimeout));
  errors.collect(cdk.propertyValidator("secondsUntilAutoPause", cdk.validateNumber)(properties.secondsUntilAutoPause));
  errors.collect(cdk.propertyValidator("timeoutAction", cdk.validateString)(properties.timeoutAction));
  return errors.wrap("supplied properties not correct for \\"ScalingConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnDBClusterScalingConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnDBClusterScalingConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "AutoPause": cdk.booleanToCloudFormation(properties.autoPause),
    "MaxCapacity": cdk.numberToCloudFormation(properties.maxCapacity),
    "MinCapacity": cdk.numberToCloudFormation(properties.minCapacity),
    "SecondsBeforeTimeout": cdk.numberToCloudFormation(properties.secondsBeforeTimeout),
    "SecondsUntilAutoPause": cdk.numberToCloudFormation(properties.secondsUntilAutoPause),
    "TimeoutAction": cdk.stringToCloudFormation(properties.timeoutAction)
  };
}

// @ts-ignore TS6133
function CfnDBClusterScalingConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnDBCluster.ScalingConfigurationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnDBCluster.ScalingConfigurationProperty>();
  ret.addPropertyResult("autoPause", "AutoPause", (properties.AutoPause != null ? cfn_parse.FromCloudFormation.getBoolean(properties.AutoPause) : undefined));
  ret.addPropertyResult("maxCapacity", "MaxCapacity", (properties.MaxCapacity != null ? cfn_parse.FromCloudFormation.getNumber(properties.MaxCapacity) : undefined));
  ret.addPropertyResult("minCapacity", "MinCapacity", (properties.MinCapacity != null ? cfn_parse.FromCloudFormation.getNumber(properties.MinCapacity) : undefined));
  ret.addPropertyResult("secondsBeforeTimeout", "SecondsBeforeTimeout", (properties.SecondsBeforeTimeout != null ? cfn_parse.FromCloudFormation.getNumber(properties.SecondsBeforeTimeout) : undefined));
  ret.addPropertyResult("secondsUntilAutoPause", "SecondsUntilAutoPause", (properties.SecondsUntilAutoPause != null ? cfn_parse.FromCloudFormation.getNumber(properties.SecondsUntilAutoPause) : undefined));
  ret.addPropertyResult("timeoutAction", "TimeoutAction", (properties.TimeoutAction != null ? cfn_parse.FromCloudFormation.getString(properties.TimeoutAction) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`EndpointProperty\`
 *
 * @param properties - the TypeScript properties of a \`EndpointProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnDBClusterEndpointPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("address", cdk.validateString)(properties.address));
  errors.collect(cdk.propertyValidator("port", cdk.validateString)(properties.port));
  return errors.wrap("supplied properties not correct for \\"EndpointProperty\\"");
}

// @ts-ignore TS6133
function convertCfnDBClusterEndpointPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnDBClusterEndpointPropertyValidator(properties).assertSuccess();
  return {
    "Address": cdk.stringToCloudFormation(properties.address),
    "Port": cdk.stringToCloudFormation(properties.port)
  };
}

// @ts-ignore TS6133
function CfnDBClusterEndpointPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnDBCluster.EndpointProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnDBCluster.EndpointProperty>();
  ret.addPropertyResult("address", "Address", (properties.Address != null ? cfn_parse.FromCloudFormation.getString(properties.Address) : undefined));
  ret.addPropertyResult("port", "Port", (properties.Port != null ? cfn_parse.FromCloudFormation.getString(properties.Port) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ReadEndpointProperty\`
 *
 * @param properties - the TypeScript properties of a \`ReadEndpointProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnDBClusterReadEndpointPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("address", cdk.validateString)(properties.address));
  return errors.wrap("supplied properties not correct for \\"ReadEndpointProperty\\"");
}

// @ts-ignore TS6133
function convertCfnDBClusterReadEndpointPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnDBClusterReadEndpointPropertyValidator(properties).assertSuccess();
  return {
    "Address": cdk.stringToCloudFormation(properties.address)
  };
}

// @ts-ignore TS6133
function CfnDBClusterReadEndpointPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnDBCluster.ReadEndpointProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnDBCluster.ReadEndpointProperty>();
  ret.addPropertyResult("address", "Address", (properties.Address != null ? cfn_parse.FromCloudFormation.getString(properties.Address) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnDBClusterProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnDBClusterProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnDBClusterPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("allocatedStorage", cdk.validateNumber)(properties.allocatedStorage));
  errors.collect(cdk.propertyValidator("associatedRoles", cdk.listValidator(CfnDBClusterDBClusterRolePropertyValidator))(properties.associatedRoles));
  errors.collect(cdk.propertyValidator("autoMinorVersionUpgrade", cdk.validateBoolean)(properties.autoMinorVersionUpgrade));
  errors.collect(cdk.propertyValidator("availabilityZones", cdk.listValidator(cdk.validateString))(properties.availabilityZones));
  errors.collect(cdk.propertyValidator("backtrackWindow", cdk.validateNumber)(properties.backtrackWindow));
  errors.collect(cdk.propertyValidator("backupRetentionPeriod", cdk.validateNumber)(properties.backupRetentionPeriod));
  errors.collect(cdk.propertyValidator("copyTagsToSnapshot", cdk.validateBoolean)(properties.copyTagsToSnapshot));
  errors.collect(cdk.propertyValidator("dbClusterIdentifier", cdk.validateString)(properties.dbClusterIdentifier));
  errors.collect(cdk.propertyValidator("dbClusterInstanceClass", cdk.validateString)(properties.dbClusterInstanceClass));
  errors.collect(cdk.propertyValidator("dbClusterParameterGroupName", cdk.validateString)(properties.dbClusterParameterGroupName));
  errors.collect(cdk.propertyValidator("dbInstanceParameterGroupName", cdk.validateString)(properties.dbInstanceParameterGroupName));
  errors.collect(cdk.propertyValidator("dbSubnetGroupName", cdk.validateString)(properties.dbSubnetGroupName));
  errors.collect(cdk.propertyValidator("dbSystemId", cdk.validateString)(properties.dbSystemId));
  errors.collect(cdk.propertyValidator("databaseName", cdk.validateString)(properties.databaseName));
  errors.collect(cdk.propertyValidator("deletionProtection", cdk.validateBoolean)(properties.deletionProtection));
  errors.collect(cdk.propertyValidator("domain", cdk.validateString)(properties.domain));
  errors.collect(cdk.propertyValidator("domainIamRoleName", cdk.validateString)(properties.domainIamRoleName));
  errors.collect(cdk.propertyValidator("enableCloudwatchLogsExports", cdk.listValidator(cdk.validateString))(properties.enableCloudwatchLogsExports));
  errors.collect(cdk.propertyValidator("enableHttpEndpoint", cdk.validateBoolean)(properties.enableHttpEndpoint));
  errors.collect(cdk.propertyValidator("enableIamDatabaseAuthentication", cdk.validateBoolean)(properties.enableIamDatabaseAuthentication));
  errors.collect(cdk.propertyValidator("engine", cdk.validateString)(properties.engine));
  errors.collect(cdk.propertyValidator("engineMode", cdk.validateString)(properties.engineMode));
  errors.collect(cdk.propertyValidator("engineVersion", cdk.validateString)(properties.engineVersion));
  errors.collect(cdk.propertyValidator("globalClusterIdentifier", cdk.validateString)(properties.globalClusterIdentifier));
  errors.collect(cdk.propertyValidator("iops", cdk.validateNumber)(properties.iops));
  errors.collect(cdk.propertyValidator("kmsKeyId", cdk.validateString)(properties.kmsKeyId));
  errors.collect(cdk.propertyValidator("manageMasterUserPassword", cdk.validateBoolean)(properties.manageMasterUserPassword));
  errors.collect(cdk.propertyValidator("masterUserPassword", cdk.validateString)(properties.masterUserPassword));
  errors.collect(cdk.propertyValidator("masterUserSecret", CfnDBClusterMasterUserSecretPropertyValidator)(properties.masterUserSecret));
  errors.collect(cdk.propertyValidator("masterUsername", cdk.validateString)(properties.masterUsername));
  errors.collect(cdk.propertyValidator("monitoringInterval", cdk.validateNumber)(properties.monitoringInterval));
  errors.collect(cdk.propertyValidator("monitoringRoleArn", cdk.validateString)(properties.monitoringRoleArn));
  errors.collect(cdk.propertyValidator("networkType", cdk.validateString)(properties.networkType));
  errors.collect(cdk.propertyValidator("performanceInsightsEnabled", cdk.validateBoolean)(properties.performanceInsightsEnabled));
  errors.collect(cdk.propertyValidator("performanceInsightsKmsKeyId", cdk.validateString)(properties.performanceInsightsKmsKeyId));
  errors.collect(cdk.propertyValidator("performanceInsightsRetentionPeriod", cdk.validateNumber)(properties.performanceInsightsRetentionPeriod));
  errors.collect(cdk.propertyValidator("port", cdk.validateNumber)(properties.port));
  errors.collect(cdk.propertyValidator("preferredBackupWindow", cdk.validateString)(properties.preferredBackupWindow));
  errors.collect(cdk.propertyValidator("preferredMaintenanceWindow", cdk.validateString)(properties.preferredMaintenanceWindow));
  errors.collect(cdk.propertyValidator("publiclyAccessible", cdk.validateBoolean)(properties.publiclyAccessible));
  errors.collect(cdk.propertyValidator("replicationSourceIdentifier", cdk.validateString)(properties.replicationSourceIdentifier));
  errors.collect(cdk.propertyValidator("restoreToTime", cdk.validateString)(properties.restoreToTime));
  errors.collect(cdk.propertyValidator("restoreType", cdk.validateString)(properties.restoreType));
  errors.collect(cdk.propertyValidator("scalingConfiguration", CfnDBClusterScalingConfigurationPropertyValidator)(properties.scalingConfiguration));
  errors.collect(cdk.propertyValidator("serverlessV2ScalingConfiguration", CfnDBClusterServerlessV2ScalingConfigurationPropertyValidator)(properties.serverlessV2ScalingConfiguration));
  errors.collect(cdk.propertyValidator("snapshotIdentifier", cdk.validateString)(properties.snapshotIdentifier));
  errors.collect(cdk.propertyValidator("sourceDbClusterIdentifier", cdk.validateString)(properties.sourceDbClusterIdentifier));
  errors.collect(cdk.propertyValidator("sourceRegion", cdk.validateString)(properties.sourceRegion));
  errors.collect(cdk.propertyValidator("storageEncrypted", cdk.validateBoolean)(properties.storageEncrypted));
  errors.collect(cdk.propertyValidator("storageType", cdk.validateString)(properties.storageType));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("useLatestRestorableTime", cdk.validateBoolean)(properties.useLatestRestorableTime));
  errors.collect(cdk.propertyValidator("vpcSecurityGroupIds", cdk.listValidator(cdk.validateString))(properties.vpcSecurityGroupIds));
  return errors.wrap("supplied properties not correct for \\"CfnDBClusterProps\\"");
}

// @ts-ignore TS6133
function convertCfnDBClusterPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnDBClusterPropsValidator(properties).assertSuccess();
  return {
    "AllocatedStorage": cdk.numberToCloudFormation(properties.allocatedStorage),
    "AssociatedRoles": cdk.listMapper(convertCfnDBClusterDBClusterRolePropertyToCloudFormation)(properties.associatedRoles),
    "AutoMinorVersionUpgrade": cdk.booleanToCloudFormation(properties.autoMinorVersionUpgrade),
    "AvailabilityZones": cdk.listMapper(cdk.stringToCloudFormation)(properties.availabilityZones),
    "BacktrackWindow": cdk.numberToCloudFormation(properties.backtrackWindow),
    "BackupRetentionPeriod": cdk.numberToCloudFormation(properties.backupRetentionPeriod),
    "CopyTagsToSnapshot": cdk.booleanToCloudFormation(properties.copyTagsToSnapshot),
    "DBClusterIdentifier": cdk.stringToCloudFormation(properties.dbClusterIdentifier),
    "DBClusterInstanceClass": cdk.stringToCloudFormation(properties.dbClusterInstanceClass),
    "DBClusterParameterGroupName": cdk.stringToCloudFormation(properties.dbClusterParameterGroupName),
    "DBInstanceParameterGroupName": cdk.stringToCloudFormation(properties.dbInstanceParameterGroupName),
    "DBSubnetGroupName": cdk.stringToCloudFormation(properties.dbSubnetGroupName),
    "DBSystemId": cdk.stringToCloudFormation(properties.dbSystemId),
    "DatabaseName": cdk.stringToCloudFormation(properties.databaseName),
    "DeletionProtection": cdk.booleanToCloudFormation(properties.deletionProtection),
    "Domain": cdk.stringToCloudFormation(properties.domain),
    "DomainIAMRoleName": cdk.stringToCloudFormation(properties.domainIamRoleName),
    "EnableCloudwatchLogsExports": cdk.listMapper(cdk.stringToCloudFormation)(properties.enableCloudwatchLogsExports),
    "EnableHttpEndpoint": cdk.booleanToCloudFormation(properties.enableHttpEndpoint),
    "EnableIAMDatabaseAuthentication": cdk.booleanToCloudFormation(properties.enableIamDatabaseAuthentication),
    "Engine": cdk.stringToCloudFormation(properties.engine),
    "EngineMode": cdk.stringToCloudFormation(properties.engineMode),
    "EngineVersion": cdk.stringToCloudFormation(properties.engineVersion),
    "GlobalClusterIdentifier": cdk.stringToCloudFormation(properties.globalClusterIdentifier),
    "Iops": cdk.numberToCloudFormation(properties.iops),
    "KmsKeyId": cdk.stringToCloudFormation(properties.kmsKeyId),
    "ManageMasterUserPassword": cdk.booleanToCloudFormation(properties.manageMasterUserPassword),
    "MasterUserPassword": cdk.stringToCloudFormation(properties.masterUserPassword),
    "MasterUserSecret": convertCfnDBClusterMasterUserSecretPropertyToCloudFormation(properties.masterUserSecret),
    "MasterUsername": cdk.stringToCloudFormation(properties.masterUsername),
    "MonitoringInterval": cdk.numberToCloudFormation(properties.monitoringInterval),
    "MonitoringRoleArn": cdk.stringToCloudFormation(properties.monitoringRoleArn),
    "NetworkType": cdk.stringToCloudFormation(properties.networkType),
    "PerformanceInsightsEnabled": cdk.booleanToCloudFormation(properties.performanceInsightsEnabled),
    "PerformanceInsightsKmsKeyId": cdk.stringToCloudFormation(properties.performanceInsightsKmsKeyId),
    "PerformanceInsightsRetentionPeriod": cdk.numberToCloudFormation(properties.performanceInsightsRetentionPeriod),
    "Port": cdk.numberToCloudFormation(properties.port),
    "PreferredBackupWindow": cdk.stringToCloudFormation(properties.preferredBackupWindow),
    "PreferredMaintenanceWindow": cdk.stringToCloudFormation(properties.preferredMaintenanceWindow),
    "PubliclyAccessible": cdk.booleanToCloudFormation(properties.publiclyAccessible),
    "ReplicationSourceIdentifier": cdk.stringToCloudFormation(properties.replicationSourceIdentifier),
    "RestoreToTime": cdk.stringToCloudFormation(properties.restoreToTime),
    "RestoreType": cdk.stringToCloudFormation(properties.restoreType),
    "ScalingConfiguration": convertCfnDBClusterScalingConfigurationPropertyToCloudFormation(properties.scalingConfiguration),
    "ServerlessV2ScalingConfiguration": convertCfnDBClusterServerlessV2ScalingConfigurationPropertyToCloudFormation(properties.serverlessV2ScalingConfiguration),
    "SnapshotIdentifier": cdk.stringToCloudFormation(properties.snapshotIdentifier),
    "SourceDBClusterIdentifier": cdk.stringToCloudFormation(properties.sourceDbClusterIdentifier),
    "SourceRegion": cdk.stringToCloudFormation(properties.sourceRegion),
    "StorageEncrypted": cdk.booleanToCloudFormation(properties.storageEncrypted),
    "StorageType": cdk.stringToCloudFormation(properties.storageType),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "UseLatestRestorableTime": cdk.booleanToCloudFormation(properties.useLatestRestorableTime),
    "VpcSecurityGroupIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.vpcSecurityGroupIds)
  };
}

// @ts-ignore TS6133
function CfnDBClusterPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnDBClusterProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnDBClusterProps>();
  ret.addPropertyResult("allocatedStorage", "AllocatedStorage", (properties.AllocatedStorage != null ? cfn_parse.FromCloudFormation.getNumber(properties.AllocatedStorage) : undefined));
  ret.addPropertyResult("associatedRoles", "AssociatedRoles", (properties.AssociatedRoles != null ? cfn_parse.FromCloudFormation.getArray(CfnDBClusterDBClusterRolePropertyFromCloudFormation)(properties.AssociatedRoles) : undefined));
  ret.addPropertyResult("autoMinorVersionUpgrade", "AutoMinorVersionUpgrade", (properties.AutoMinorVersionUpgrade != null ? cfn_parse.FromCloudFormation.getBoolean(properties.AutoMinorVersionUpgrade) : undefined));
  ret.addPropertyResult("availabilityZones", "AvailabilityZones", (properties.AvailabilityZones != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.AvailabilityZones) : undefined));
  ret.addPropertyResult("backtrackWindow", "BacktrackWindow", (properties.BacktrackWindow != null ? cfn_parse.FromCloudFormation.getNumber(properties.BacktrackWindow) : undefined));
  ret.addPropertyResult("backupRetentionPeriod", "BackupRetentionPeriod", (properties.BackupRetentionPeriod != null ? cfn_parse.FromCloudFormation.getNumber(properties.BackupRetentionPeriod) : undefined));
  ret.addPropertyResult("copyTagsToSnapshot", "CopyTagsToSnapshot", (properties.CopyTagsToSnapshot != null ? cfn_parse.FromCloudFormation.getBoolean(properties.CopyTagsToSnapshot) : undefined));
  ret.addPropertyResult("databaseName", "DatabaseName", (properties.DatabaseName != null ? cfn_parse.FromCloudFormation.getString(properties.DatabaseName) : undefined));
  ret.addPropertyResult("dbClusterIdentifier", "DBClusterIdentifier", (properties.DBClusterIdentifier != null ? cfn_parse.FromCloudFormation.getString(properties.DBClusterIdentifier) : undefined));
  ret.addPropertyResult("dbClusterInstanceClass", "DBClusterInstanceClass", (properties.DBClusterInstanceClass != null ? cfn_parse.FromCloudFormation.getString(properties.DBClusterInstanceClass) : undefined));
  ret.addPropertyResult("dbClusterParameterGroupName", "DBClusterParameterGroupName", (properties.DBClusterParameterGroupName != null ? cfn_parse.FromCloudFormation.getString(properties.DBClusterParameterGroupName) : undefined));
  ret.addPropertyResult("dbInstanceParameterGroupName", "DBInstanceParameterGroupName", (properties.DBInstanceParameterGroupName != null ? cfn_parse.FromCloudFormation.getString(properties.DBInstanceParameterGroupName) : undefined));
  ret.addPropertyResult("dbSubnetGroupName", "DBSubnetGroupName", (properties.DBSubnetGroupName != null ? cfn_parse.FromCloudFormation.getString(properties.DBSubnetGroupName) : undefined));
  ret.addPropertyResult("dbSystemId", "DBSystemId", (properties.DBSystemId != null ? cfn_parse.FromCloudFormation.getString(properties.DBSystemId) : undefined));
  ret.addPropertyResult("deletionProtection", "DeletionProtection", (properties.DeletionProtection != null ? cfn_parse.FromCloudFormation.getBoolean(properties.DeletionProtection) : undefined));
  ret.addPropertyResult("domain", "Domain", (properties.Domain != null ? cfn_parse.FromCloudFormation.getString(properties.Domain) : undefined));
  ret.addPropertyResult("domainIamRoleName", "DomainIAMRoleName", (properties.DomainIAMRoleName != null ? cfn_parse.FromCloudFormation.getString(properties.DomainIAMRoleName) : undefined));
  ret.addPropertyResult("enableCloudwatchLogsExports", "EnableCloudwatchLogsExports", (properties.EnableCloudwatchLogsExports != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.EnableCloudwatchLogsExports) : undefined));
  ret.addPropertyResult("enableHttpEndpoint", "EnableHttpEndpoint", (properties.EnableHttpEndpoint != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EnableHttpEndpoint) : undefined));
  ret.addPropertyResult("enableIamDatabaseAuthentication", "EnableIAMDatabaseAuthentication", (properties.EnableIAMDatabaseAuthentication != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EnableIAMDatabaseAuthentication) : undefined));
  ret.addPropertyResult("engine", "Engine", (properties.Engine != null ? cfn_parse.FromCloudFormation.getString(properties.Engine) : undefined));
  ret.addPropertyResult("engineMode", "EngineMode", (properties.EngineMode != null ? cfn_parse.FromCloudFormation.getString(properties.EngineMode) : undefined));
  ret.addPropertyResult("engineVersion", "EngineVersion", (properties.EngineVersion != null ? cfn_parse.FromCloudFormation.getString(properties.EngineVersion) : undefined));
  ret.addPropertyResult("globalClusterIdentifier", "GlobalClusterIdentifier", (properties.GlobalClusterIdentifier != null ? cfn_parse.FromCloudFormation.getString(properties.GlobalClusterIdentifier) : undefined));
  ret.addPropertyResult("iops", "Iops", (properties.Iops != null ? cfn_parse.FromCloudFormation.getNumber(properties.Iops) : undefined));
  ret.addPropertyResult("kmsKeyId", "KmsKeyId", (properties.KmsKeyId != null ? cfn_parse.FromCloudFormation.getString(properties.KmsKeyId) : undefined));
  ret.addPropertyResult("manageMasterUserPassword", "ManageMasterUserPassword", (properties.ManageMasterUserPassword != null ? cfn_parse.FromCloudFormation.getBoolean(properties.ManageMasterUserPassword) : undefined));
  ret.addPropertyResult("masterUsername", "MasterUsername", (properties.MasterUsername != null ? cfn_parse.FromCloudFormation.getString(properties.MasterUsername) : undefined));
  ret.addPropertyResult("masterUserPassword", "MasterUserPassword", (properties.MasterUserPassword != null ? cfn_parse.FromCloudFormation.getString(properties.MasterUserPassword) : undefined));
  ret.addPropertyResult("masterUserSecret", "MasterUserSecret", (properties.MasterUserSecret != null ? CfnDBClusterMasterUserSecretPropertyFromCloudFormation(properties.MasterUserSecret) : undefined));
  ret.addPropertyResult("monitoringInterval", "MonitoringInterval", (properties.MonitoringInterval != null ? cfn_parse.FromCloudFormation.getNumber(properties.MonitoringInterval) : undefined));
  ret.addPropertyResult("monitoringRoleArn", "MonitoringRoleArn", (properties.MonitoringRoleArn != null ? cfn_parse.FromCloudFormation.getString(properties.MonitoringRoleArn) : undefined));
  ret.addPropertyResult("networkType", "NetworkType", (properties.NetworkType != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkType) : undefined));
  ret.addPropertyResult("performanceInsightsEnabled", "PerformanceInsightsEnabled", (properties.PerformanceInsightsEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.PerformanceInsightsEnabled) : undefined));
  ret.addPropertyResult("performanceInsightsKmsKeyId", "PerformanceInsightsKmsKeyId", (properties.PerformanceInsightsKmsKeyId != null ? cfn_parse.FromCloudFormation.getString(properties.PerformanceInsightsKmsKeyId) : undefined));
  ret.addPropertyResult("performanceInsightsRetentionPeriod", "PerformanceInsightsRetentionPeriod", (properties.PerformanceInsightsRetentionPeriod != null ? cfn_parse.FromCloudFormation.getNumber(properties.PerformanceInsightsRetentionPeriod) : undefined));
  ret.addPropertyResult("port", "Port", (properties.Port != null ? cfn_parse.FromCloudFormation.getNumber(properties.Port) : undefined));
  ret.addPropertyResult("preferredBackupWindow", "PreferredBackupWindow", (properties.PreferredBackupWindow != null ? cfn_parse.FromCloudFormation.getString(properties.PreferredBackupWindow) : undefined));
  ret.addPropertyResult("preferredMaintenanceWindow", "PreferredMaintenanceWindow", (properties.PreferredMaintenanceWindow != null ? cfn_parse.FromCloudFormation.getString(properties.PreferredMaintenanceWindow) : undefined));
  ret.addPropertyResult("publiclyAccessible", "PubliclyAccessible", (properties.PubliclyAccessible != null ? cfn_parse.FromCloudFormation.getBoolean(properties.PubliclyAccessible) : undefined));
  ret.addPropertyResult("replicationSourceIdentifier", "ReplicationSourceIdentifier", (properties.ReplicationSourceIdentifier != null ? cfn_parse.FromCloudFormation.getString(properties.ReplicationSourceIdentifier) : undefined));
  ret.addPropertyResult("restoreToTime", "RestoreToTime", (properties.RestoreToTime != null ? cfn_parse.FromCloudFormation.getString(properties.RestoreToTime) : undefined));
  ret.addPropertyResult("restoreType", "RestoreType", (properties.RestoreType != null ? cfn_parse.FromCloudFormation.getString(properties.RestoreType) : undefined));
  ret.addPropertyResult("scalingConfiguration", "ScalingConfiguration", (properties.ScalingConfiguration != null ? CfnDBClusterScalingConfigurationPropertyFromCloudFormation(properties.ScalingConfiguration) : undefined));
  ret.addPropertyResult("serverlessV2ScalingConfiguration", "ServerlessV2ScalingConfiguration", (properties.ServerlessV2ScalingConfiguration != null ? CfnDBClusterServerlessV2ScalingConfigurationPropertyFromCloudFormation(properties.ServerlessV2ScalingConfiguration) : undefined));
  ret.addPropertyResult("snapshotIdentifier", "SnapshotIdentifier", (properties.SnapshotIdentifier != null ? cfn_parse.FromCloudFormation.getString(properties.SnapshotIdentifier) : undefined));
  ret.addPropertyResult("sourceDbClusterIdentifier", "SourceDBClusterIdentifier", (properties.SourceDBClusterIdentifier != null ? cfn_parse.FromCloudFormation.getString(properties.SourceDBClusterIdentifier) : undefined));
  ret.addPropertyResult("sourceRegion", "SourceRegion", (properties.SourceRegion != null ? cfn_parse.FromCloudFormation.getString(properties.SourceRegion) : undefined));
  ret.addPropertyResult("storageEncrypted", "StorageEncrypted", (properties.StorageEncrypted != null ? cfn_parse.FromCloudFormation.getBoolean(properties.StorageEncrypted) : undefined));
  ret.addPropertyResult("storageType", "StorageType", (properties.StorageType != null ? cfn_parse.FromCloudFormation.getString(properties.StorageType) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("useLatestRestorableTime", "UseLatestRestorableTime", (properties.UseLatestRestorableTime != null ? cfn_parse.FromCloudFormation.getBoolean(properties.UseLatestRestorableTime) : undefined));
  ret.addPropertyResult("vpcSecurityGroupIds", "VpcSecurityGroupIds", (properties.VpcSecurityGroupIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.VpcSecurityGroupIds) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}",
}
`;

exports[`AWS::S3::Bucket 1`] = `
{
  "augmentations": undefined,
  "metrics": "/* eslint-disable prettier/prettier,max-len */
export interface MetricWithDims<D> {
  readonly namespace: string;

  readonly metricName: string;

  readonly statistic: string;

  readonly dimensionsMap: D;
}

export class S3Metrics {
  public static bucketSizeBytesAverage(dimensions: { BucketName: string; StorageType: string; }): MetricWithDims<{ BucketName: string; StorageType: string; }> {
    return {
      "namespace": "AWS/S3",
      "metricName": "BucketSizeBytes",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static numberOfObjectsAverage(dimensions: { BucketName: string; StorageType: string; }): MetricWithDims<{ BucketName: string; StorageType: string; }> {
    return {
      "namespace": "AWS/S3",
      "metricName": "NumberOfObjects",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }
}",
  "module": "/* eslint-disable prettier/prettier,max-len */
import * as cdk from "aws-cdk-lib";
import * as constructs from "constructs";
import * as cfn_parse from "aws-cdk-lib/core/lib/helpers-internal";

/**
 * The \`AWS::S3::Bucket\` resource creates an Amazon S3 bucket in the same AWS Region where you create the AWS CloudFormation stack.
 *
 * To control how AWS CloudFormation handles the bucket when the stack is deleted, you can set a deletion policy for your bucket. You can choose to *retain* the bucket or to *delete* the bucket. For more information, see [DeletionPolicy Attribute](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html) .
 *
 * > You can only delete empty buckets. Deletion fails for buckets that have contents.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-s3-bucket.html
 */
export class CfnBucket extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::S3::Bucket";

  /**
   * Build a CfnBucket from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnBucket {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnBucketPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnBucket(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * Returns the Amazon Resource Name (ARN) of the specified bucket.
   *
   * Example: \`arn:aws:s3:::DOC-EXAMPLE-BUCKET\`
   *
   * @cloudformationAttribute Arn
   */
  public readonly attrArn: string;

  /**
   * Returns the IPv4 DNS name of the specified bucket.
   *
   * Example: \`DOC-EXAMPLE-BUCKET.s3.amazonaws.com\`
   *
   * @cloudformationAttribute DomainName
   */
  public readonly attrDomainName: string;

  /**
   * Returns the IPv6 DNS name of the specified bucket.
   *
   * Example: \`DOC-EXAMPLE-BUCKET.s3.dualstack.us-east-2.amazonaws.com\`
   *
   * For more information about dual-stack endpoints, see [Using Amazon S3 Dual-Stack Endpoints](https://docs.aws.amazon.com/AmazonS3/latest/dev/dual-stack-endpoints.html) .
   *
   * @cloudformationAttribute DualStackDomainName
   */
  public readonly attrDualStackDomainName: string;

  /**
   * Returns the regional domain name of the specified bucket.
   *
   * Example: \`DOC-EXAMPLE-BUCKET.s3.us-east-2.amazonaws.com\`
   *
   * @cloudformationAttribute RegionalDomainName
   */
  public readonly attrRegionalDomainName: string;

  /**
   * Returns the Amazon S3 website endpoint for the specified bucket.
   *
   * Example (IPv4): \`http://DOC-EXAMPLE-BUCKET.s3-website.us-east-2.amazonaws.com\`
   *
   * Example (IPv6): \`http://DOC-EXAMPLE-BUCKET.s3.dualstack.us-east-2.amazonaws.com\`
   *
   * @cloudformationAttribute WebsiteURL
   */
  public readonly attrWebsiteUrl: string;

  /**
   * Configures the transfer acceleration state for an Amazon S3 bucket.
   */
  public accelerateConfiguration?: CfnBucket.AccelerateConfigurationProperty | cdk.IResolvable;

  /**
   * A canned access control list (ACL) that grants predefined permissions to the bucket.
   */
  public accessControl?: string;

  /**
   * Specifies the configuration and any analyses for the analytics filter of an Amazon S3 bucket.
   */
  public analyticsConfigurations?: Array<CfnBucket.AnalyticsConfigurationProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * Specifies default encryption for a bucket using server-side encryption with Amazon S3-managed keys (SSE-S3), AWS KMS-managed keys (SSE-KMS), or dual-layer server-side encryption with KMS-managed keys (DSSE-KMS).
   */
  public bucketEncryption?: CfnBucket.BucketEncryptionProperty | cdk.IResolvable;

  /**
   * A name for the bucket.
   */
  public bucketName?: string;

  /**
   * Describes the cross-origin access configuration for objects in an Amazon S3 bucket.
   */
  public corsConfiguration?: CfnBucket.CorsConfigurationProperty | cdk.IResolvable;

  /**
   * Defines how Amazon S3 handles Intelligent-Tiering storage.
   */
  public intelligentTieringConfigurations?: Array<CfnBucket.IntelligentTieringConfigurationProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * Specifies the inventory configuration for an Amazon S3 bucket.
   */
  public inventoryConfigurations?: Array<CfnBucket.InventoryConfigurationProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * Specifies the lifecycle configuration for objects in an Amazon S3 bucket.
   */
  public lifecycleConfiguration?: cdk.IResolvable | CfnBucket.LifecycleConfigurationProperty;

  /**
   * Settings that define where logs are stored.
   */
  public loggingConfiguration?: cdk.IResolvable | CfnBucket.LoggingConfigurationProperty;

  /**
   * Specifies a metrics configuration for the CloudWatch request metrics (specified by the metrics configuration ID) from an Amazon S3 bucket.
   */
  public metricsConfigurations?: Array<cdk.IResolvable | CfnBucket.MetricsConfigurationProperty> | cdk.IResolvable;

  /**
   * Configuration that defines how Amazon S3 handles bucket notifications.
   */
  public notificationConfiguration?: cdk.IResolvable | CfnBucket.NotificationConfigurationProperty;

  /**
   * Places an Object Lock configuration on the specified bucket.
   */
  public objectLockConfiguration?: cdk.IResolvable | CfnBucket.ObjectLockConfigurationProperty;

  /**
   * Indicates whether this bucket has an Object Lock configuration enabled.
   */
  public objectLockEnabled?: boolean | cdk.IResolvable;

  /**
   * Configuration that defines how Amazon S3 handles Object Ownership rules.
   */
  public ownershipControls?: cdk.IResolvable | CfnBucket.OwnershipControlsProperty;

  /**
   * Configuration that defines how Amazon S3 handles public access.
   */
  public publicAccessBlockConfiguration?: cdk.IResolvable | CfnBucket.PublicAccessBlockConfigurationProperty;

  /**
   * Configuration for replicating objects in an S3 bucket.
   */
  public replicationConfiguration?: cdk.IResolvable | CfnBucket.ReplicationConfigurationProperty;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * An arbitrary set of tags (key-value pairs) for this S3 bucket.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * Enables multiple versions of all objects in this bucket.
   */
  public versioningConfiguration?: cdk.IResolvable | CfnBucket.VersioningConfigurationProperty;

  /**
   * Information used to configure the bucket as a static website.
   */
  public websiteConfiguration?: cdk.IResolvable | CfnBucket.WebsiteConfigurationProperty;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnBucketProps = {}) {
    super(scope, id, {
      "type": CfnBucket.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.attrArn = cdk.Token.asString(this.getAtt("Arn", cdk.ResolutionTypeHint.STRING));
    this.attrDomainName = cdk.Token.asString(this.getAtt("DomainName", cdk.ResolutionTypeHint.STRING));
    this.attrDualStackDomainName = cdk.Token.asString(this.getAtt("DualStackDomainName", cdk.ResolutionTypeHint.STRING));
    this.attrRegionalDomainName = cdk.Token.asString(this.getAtt("RegionalDomainName", cdk.ResolutionTypeHint.STRING));
    this.attrWebsiteUrl = cdk.Token.asString(this.getAtt("WebsiteURL", cdk.ResolutionTypeHint.STRING));
    this.accelerateConfiguration = props.accelerateConfiguration;
    this.accessControl = props.accessControl;
    this.analyticsConfigurations = props.analyticsConfigurations;
    this.bucketEncryption = props.bucketEncryption;
    this.bucketName = props.bucketName;
    this.corsConfiguration = props.corsConfiguration;
    this.intelligentTieringConfigurations = props.intelligentTieringConfigurations;
    this.inventoryConfigurations = props.inventoryConfigurations;
    this.lifecycleConfiguration = props.lifecycleConfiguration;
    this.loggingConfiguration = props.loggingConfiguration;
    this.metricsConfigurations = props.metricsConfigurations;
    this.notificationConfiguration = props.notificationConfiguration;
    this.objectLockConfiguration = props.objectLockConfiguration;
    this.objectLockEnabled = props.objectLockEnabled;
    this.ownershipControls = props.ownershipControls;
    this.publicAccessBlockConfiguration = props.publicAccessBlockConfiguration;
    this.replicationConfiguration = props.replicationConfiguration;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::S3::Bucket", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.versioningConfiguration = props.versioningConfiguration;
    this.websiteConfiguration = props.websiteConfiguration;
    if ((this.node.scope != null && cdk.Resource.isResource(this.node.scope))) {
      this.node.addValidation({
        "validate": () => ((this.cfnOptions.deletionPolicy === undefined) ? ["'AWS::S3::Bucket' is a stateful resource type, and you must specify a Removal Policy for it. Call 'resource.applyRemovalPolicy()'."] : [])
      });
    }
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "accelerateConfiguration": this.accelerateConfiguration,
      "accessControl": this.accessControl,
      "analyticsConfigurations": this.analyticsConfigurations,
      "bucketEncryption": this.bucketEncryption,
      "bucketName": this.bucketName,
      "corsConfiguration": this.corsConfiguration,
      "intelligentTieringConfigurations": this.intelligentTieringConfigurations,
      "inventoryConfigurations": this.inventoryConfigurations,
      "lifecycleConfiguration": this.lifecycleConfiguration,
      "loggingConfiguration": this.loggingConfiguration,
      "metricsConfigurations": this.metricsConfigurations,
      "notificationConfiguration": this.notificationConfiguration,
      "objectLockConfiguration": this.objectLockConfiguration,
      "objectLockEnabled": this.objectLockEnabled,
      "ownershipControls": this.ownershipControls,
      "publicAccessBlockConfiguration": this.publicAccessBlockConfiguration,
      "replicationConfiguration": this.replicationConfiguration,
      "tags": this.tags.renderTags(),
      "versioningConfiguration": this.versioningConfiguration,
      "websiteConfiguration": this.websiteConfiguration
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnBucket.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnBucketPropsToCloudFormation(props);
  }
}

export namespace CfnBucket {
  /**
   * Configures the transfer acceleration state for an Amazon S3 bucket.
   *
   * For more information, see [Amazon S3 Transfer Acceleration](https://docs.aws.amazon.com/AmazonS3/latest/dev/transfer-acceleration.html) in the *Amazon S3 User Guide* .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-accelerateconfiguration.html
   */
  export interface AccelerateConfigurationProperty {
    /**
     * Specifies the transfer acceleration status of the bucket.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-accelerateconfiguration.html#cfn-s3-bucket-accelerateconfiguration-accelerationstatus
     */
    readonly accelerationStatus: string;
  }

  /**
   * Specifies the configuration and any analyses for the analytics filter of an Amazon S3 bucket.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-analyticsconfiguration.html
   */
  export interface AnalyticsConfigurationProperty {
    /**
     * The ID that identifies the analytics configuration.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-analyticsconfiguration.html#cfn-s3-bucket-analyticsconfiguration-id
     */
    readonly id: string;

    /**
     * The prefix that an object must have to be included in the analytics results.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-analyticsconfiguration.html#cfn-s3-bucket-analyticsconfiguration-prefix
     */
    readonly prefix?: string;

    /**
     * Contains data related to access patterns to be collected and made available to analyze the tradeoffs between different storage classes.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-analyticsconfiguration.html#cfn-s3-bucket-analyticsconfiguration-storageclassanalysis
     */
    readonly storageClassAnalysis: cdk.IResolvable | CfnBucket.StorageClassAnalysisProperty;

    /**
     * The tags to use when evaluating an analytics filter.
     *
     * The analytics only includes objects that meet the filter's criteria. If no filter is specified, all of the contents of the bucket are included in the analysis.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-analyticsconfiguration.html#cfn-s3-bucket-analyticsconfiguration-tagfilters
     */
    readonly tagFilters?: Array<cdk.IResolvable | CfnBucket.TagFilterProperty> | cdk.IResolvable;
  }

  /**
   * Specifies tags to use to identify a subset of objects for an Amazon S3 bucket.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-tagfilter.html
   */
  export interface TagFilterProperty {
    /**
     * The tag key.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-tagfilter.html#cfn-s3-bucket-tagfilter-key
     */
    readonly key: string;

    /**
     * The tag value.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-tagfilter.html#cfn-s3-bucket-tagfilter-value
     */
    readonly value: string;
  }

  /**
   * Specifies data related to access patterns to be collected and made available to analyze the tradeoffs between different storage classes for an Amazon S3 bucket.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-storageclassanalysis.html
   */
  export interface StorageClassAnalysisProperty {
    /**
     * Specifies how data related to the storage class analysis for an Amazon S3 bucket should be exported.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-storageclassanalysis.html#cfn-s3-bucket-storageclassanalysis-dataexport
     */
    readonly dataExport?: CfnBucket.DataExportProperty | cdk.IResolvable;
  }

  /**
   * Specifies how data related to the storage class analysis for an Amazon S3 bucket should be exported.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-dataexport.html
   */
  export interface DataExportProperty {
    /**
     * The place to store the data for an analysis.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-dataexport.html#cfn-s3-bucket-dataexport-destination
     */
    readonly destination: CfnBucket.DestinationProperty | cdk.IResolvable;

    /**
     * The version of the output schema to use when exporting data.
     *
     * Must be \`V_1\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-dataexport.html#cfn-s3-bucket-dataexport-outputschemaversion
     */
    readonly outputSchemaVersion: string;
  }

  /**
   * Specifies information about where to publish analysis or configuration results for an Amazon S3 bucket.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-destination.html
   */
  export interface DestinationProperty {
    /**
     * The account ID that owns the destination S3 bucket.
     *
     * If no account ID is provided, the owner is not validated before exporting data.
     *
     * > Although this value is optional, we strongly recommend that you set it to help prevent problems if the destination bucket ownership changes.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-destination.html#cfn-s3-bucket-destination-bucketaccountid
     */
    readonly bucketAccountId?: string;

    /**
     * The Amazon Resource Name (ARN) of the bucket to which data is exported.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-destination.html#cfn-s3-bucket-destination-bucketarn
     */
    readonly bucketArn: string;

    /**
     * Specifies the file format used when exporting data to Amazon S3.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-destination.html#cfn-s3-bucket-destination-format
     */
    readonly format: string;

    /**
     * The prefix to use when exporting data.
     *
     * The prefix is prepended to all results.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-destination.html#cfn-s3-bucket-destination-prefix
     */
    readonly prefix?: string;
  }

  /**
   * Specifies default encryption for a bucket using server-side encryption with Amazon S3-managed keys (SSE-S3), AWS KMS-managed keys (SSE-KMS), or dual-layer server-side encryption with KMS-managed keys (DSSE-KMS).
   *
   * For information about the Amazon S3 default encryption feature, see [Amazon S3 Default Encryption for S3 Buckets](https://docs.aws.amazon.com/AmazonS3/latest/dev/bucket-encryption.html) in the *Amazon S3 User Guide* .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-bucketencryption.html
   */
  export interface BucketEncryptionProperty {
    /**
     * Specifies the default server-side-encryption configuration.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-bucketencryption.html#cfn-s3-bucket-bucketencryption-serversideencryptionconfiguration
     */
    readonly serverSideEncryptionConfiguration: Array<cdk.IResolvable | CfnBucket.ServerSideEncryptionRuleProperty> | cdk.IResolvable;
  }

  /**
   * Specifies the default server-side encryption configuration.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-serversideencryptionrule.html
   */
  export interface ServerSideEncryptionRuleProperty {
    /**
     * Specifies whether Amazon S3 should use an S3 Bucket Key with server-side encryption using KMS (SSE-KMS) for new objects in the bucket.
     *
     * Existing objects are not affected. Setting the \`BucketKeyEnabled\` element to \`true\` causes Amazon S3 to use an S3 Bucket Key. By default, S3 Bucket Key is not enabled.
     *
     * For more information, see [Amazon S3 Bucket Keys](https://docs.aws.amazon.com/AmazonS3/latest/dev/bucket-key.html) in the *Amazon S3 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-serversideencryptionrule.html#cfn-s3-bucket-serversideencryptionrule-bucketkeyenabled
     */
    readonly bucketKeyEnabled?: boolean | cdk.IResolvable;

    /**
     * Specifies the default server-side encryption to apply to new objects in the bucket.
     *
     * If a PUT Object request doesn't specify any server-side encryption, this default encryption will be applied.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-serversideencryptionrule.html#cfn-s3-bucket-serversideencryptionrule-serversideencryptionbydefault
     */
    readonly serverSideEncryptionByDefault?: cdk.IResolvable | CfnBucket.ServerSideEncryptionByDefaultProperty;
  }

  /**
   * Describes the default server-side encryption to apply to new objects in the bucket.
   *
   * If a PUT Object request doesn't specify any server-side encryption, this default encryption will be applied. If you don't specify a customer managed key at configuration, Amazon S3 automatically creates an AWS KMS key in your AWS account the first time that you add an object encrypted with SSE-KMS to a bucket. By default, Amazon S3 uses this KMS key for SSE-KMS. For more information, see [PUT Bucket encryption](https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTencryption.html) in the *Amazon S3 API Reference* .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-serversideencryptionbydefault.html
   */
  export interface ServerSideEncryptionByDefaultProperty {
    /**
     * KMS key ID to use for the default encryption. This parameter is allowed if SSEAlgorithm is aws:kms.
     *
     * You can specify the key ID, key alias, or the Amazon Resource Name (ARN) of the CMK. However, if you are using encryption with cross-account operations, you must use a fully qualified CMK ARN. For more information, see [Using encryption for cross-account operations](https://docs.aws.amazon.com/AmazonS3/latest/dev/bucket-encryption.html#bucket-encryption-update-bucket-policy) .
     *
     * For example:
     *
     * - Key ID: \`1234abcd-12ab-34cd-56ef-1234567890ab\`
     * - Key ARN: \`arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab\`
     *
     * > Amazon S3 only supports symmetric KMS keys and not asymmetric KMS keys. For more information, see [Using Symmetric and Asymmetric Keys](https://docs.aws.amazon.com//kms/latest/developerguide/symmetric-asymmetric.html) in the *AWS Key Management Service Developer Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-serversideencryptionbydefault.html#cfn-s3-bucket-serversideencryptionbydefault-kmsmasterkeyid
     */
    readonly kmsMasterKeyId?: string;

    /**
     * Server-side encryption algorithm to use for the default encryption.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-serversideencryptionbydefault.html#cfn-s3-bucket-serversideencryptionbydefault-ssealgorithm
     */
    readonly sseAlgorithm: string;
  }

  /**
   * Describes the cross-origin access configuration for objects in an Amazon S3 bucket.
   *
   * For more information, see [Enabling Cross-Origin Resource Sharing](https://docs.aws.amazon.com/AmazonS3/latest/dev/cors.html) in the *Amazon S3 User Guide* .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-corsconfiguration.html
   */
  export interface CorsConfigurationProperty {
    /**
     * A set of origins and methods (cross-origin access that you want to allow).
     *
     * You can add up to 100 rules to the configuration.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-corsconfiguration.html#cfn-s3-bucket-corsconfiguration-corsrules
     */
    readonly corsRules: Array<CfnBucket.CorsRuleProperty | cdk.IResolvable> | cdk.IResolvable;
  }

  /**
   * Specifies a cross-origin access rule for an Amazon S3 bucket.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-corsrule.html
   */
  export interface CorsRuleProperty {
    /**
     * Headers that are specified in the \`Access-Control-Request-Headers\` header.
     *
     * These headers are allowed in a preflight OPTIONS request. In response to any preflight OPTIONS request, Amazon S3 returns any requested headers that are allowed.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-corsrule.html#cfn-s3-bucket-corsrule-allowedheaders
     */
    readonly allowedHeaders?: Array<string>;

    /**
     * An HTTP method that you allow the origin to run.
     *
     * *Allowed values* : \`GET\` | \`PUT\` | \`HEAD\` | \`POST\` | \`DELETE\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-corsrule.html#cfn-s3-bucket-corsrule-allowedmethods
     */
    readonly allowedMethods: Array<string>;

    /**
     * One or more origins you want customers to be able to access the bucket from.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-corsrule.html#cfn-s3-bucket-corsrule-allowedorigins
     */
    readonly allowedOrigins: Array<string>;

    /**
     * One or more headers in the response that you want customers to be able to access from their applications (for example, from a JavaScript \`XMLHttpRequest\` object).
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-corsrule.html#cfn-s3-bucket-corsrule-exposedheaders
     */
    readonly exposedHeaders?: Array<string>;

    /**
     * A unique identifier for this rule.
     *
     * The value must be no more than 255 characters.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-corsrule.html#cfn-s3-bucket-corsrule-id
     */
    readonly id?: string;

    /**
     * The time in seconds that your browser is to cache the preflight response for the specified resource.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-corsrule.html#cfn-s3-bucket-corsrule-maxage
     */
    readonly maxAge?: number;
  }

  /**
   * Specifies the S3 Intelligent-Tiering configuration for an Amazon S3 bucket.
   *
   * For information about the S3 Intelligent-Tiering storage class, see [Storage class for automatically optimizing frequently and infrequently accessed objects](https://docs.aws.amazon.com/AmazonS3/latest/dev/storage-class-intro.html#sc-dynamic-data-access) .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-intelligenttieringconfiguration.html
   */
  export interface IntelligentTieringConfigurationProperty {
    /**
     * The ID used to identify the S3 Intelligent-Tiering configuration.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-intelligenttieringconfiguration.html#cfn-s3-bucket-intelligenttieringconfiguration-id
     */
    readonly id: string;

    /**
     * An object key name prefix that identifies the subset of objects to which the rule applies.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-intelligenttieringconfiguration.html#cfn-s3-bucket-intelligenttieringconfiguration-prefix
     */
    readonly prefix?: string;

    /**
     * Specifies the status of the configuration.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-intelligenttieringconfiguration.html#cfn-s3-bucket-intelligenttieringconfiguration-status
     */
    readonly status: string;

    /**
     * A container for a key-value pair.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-intelligenttieringconfiguration.html#cfn-s3-bucket-intelligenttieringconfiguration-tagfilters
     */
    readonly tagFilters?: Array<cdk.IResolvable | CfnBucket.TagFilterProperty> | cdk.IResolvable;

    /**
     * Specifies a list of S3 Intelligent-Tiering storage class tiers in the configuration.
     *
     * At least one tier must be defined in the list. At most, you can specify two tiers in the list, one for each available AccessTier: \`ARCHIVE_ACCESS\` and \`DEEP_ARCHIVE_ACCESS\` .
     *
     * > You only need Intelligent Tiering Configuration enabled on a bucket if you want to automatically move objects stored in the Intelligent-Tiering storage class to Archive Access or Deep Archive Access tiers.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-intelligenttieringconfiguration.html#cfn-s3-bucket-intelligenttieringconfiguration-tierings
     */
    readonly tierings: Array<cdk.IResolvable | CfnBucket.TieringProperty> | cdk.IResolvable;
  }

  /**
   * The S3 Intelligent-Tiering storage class is designed to optimize storage costs by automatically moving data to the most cost-effective storage access tier, without additional operational overhead.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-tiering.html
   */
  export interface TieringProperty {
    /**
     * S3 Intelligent-Tiering access tier.
     *
     * See [Storage class for automatically optimizing frequently and infrequently accessed objects](https://docs.aws.amazon.com/AmazonS3/latest/dev/storage-class-intro.html#sc-dynamic-data-access) for a list of access tiers in the S3 Intelligent-Tiering storage class.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-tiering.html#cfn-s3-bucket-tiering-accesstier
     */
    readonly accessTier: string;

    /**
     * The number of consecutive days of no access after which an object will be eligible to be transitioned to the corresponding tier.
     *
     * The minimum number of days specified for Archive Access tier must be at least 90 days and Deep Archive Access tier must be at least 180 days. The maximum can be up to 2 years (730 days).
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-tiering.html#cfn-s3-bucket-tiering-days
     */
    readonly days: number;
  }

  /**
   * Specifies the inventory configuration for an Amazon S3 bucket.
   *
   * For more information, see [GET Bucket inventory](https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketGETInventoryConfig.html) in the *Amazon S3 API Reference* .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-inventoryconfiguration.html
   */
  export interface InventoryConfigurationProperty {
    /**
     * Contains information about where to publish the inventory results.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-inventoryconfiguration.html#cfn-s3-bucket-inventoryconfiguration-destination
     */
    readonly destination: CfnBucket.DestinationProperty | cdk.IResolvable;

    /**
     * Specifies whether the inventory is enabled or disabled.
     *
     * If set to \`True\` , an inventory list is generated. If set to \`False\` , no inventory list is generated.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-inventoryconfiguration.html#cfn-s3-bucket-inventoryconfiguration-enabled
     */
    readonly enabled: boolean | cdk.IResolvable;

    /**
     * The ID used to identify the inventory configuration.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-inventoryconfiguration.html#cfn-s3-bucket-inventoryconfiguration-id
     */
    readonly id: string;

    /**
     * Object versions to include in the inventory list.
     *
     * If set to \`All\` , the list includes all the object versions, which adds the version-related fields \`VersionId\` , \`IsLatest\` , and \`DeleteMarker\` to the list. If set to \`Current\` , the list does not contain these version-related fields.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-inventoryconfiguration.html#cfn-s3-bucket-inventoryconfiguration-includedobjectversions
     */
    readonly includedObjectVersions: string;

    /**
     * Contains the optional fields that are included in the inventory results.
     *
     * *Valid values* : \`Size | LastModifiedDate | StorageClass | ETag | IsMultipartUploaded | ReplicationStatus | EncryptionStatus | ObjectLockRetainUntilDate | ObjectLockMode | ObjectLockLegalHoldStatus | IntelligentTieringAccessTier | BucketKeyStatus\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-inventoryconfiguration.html#cfn-s3-bucket-inventoryconfiguration-optionalfields
     */
    readonly optionalFields?: Array<string>;

    /**
     * Specifies the inventory filter prefix.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-inventoryconfiguration.html#cfn-s3-bucket-inventoryconfiguration-prefix
     */
    readonly prefix?: string;

    /**
     * Specifies the schedule for generating inventory results.
     *
     * *Allowed values* : \`Daily\` | \`Weekly\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-inventoryconfiguration.html#cfn-s3-bucket-inventoryconfiguration-schedulefrequency
     */
    readonly scheduleFrequency: string;
  }

  /**
   * Specifies the lifecycle configuration for objects in an Amazon S3 bucket.
   *
   * For more information, see [Object Lifecycle Management](https://docs.aws.amazon.com/AmazonS3/latest/dev/object-lifecycle-mgmt.html) in the *Amazon S3 User Guide* .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-lifecycleconfiguration.html
   */
  export interface LifecycleConfigurationProperty {
    /**
     * A lifecycle rule for individual objects in an Amazon S3 bucket.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-lifecycleconfiguration.html#cfn-s3-bucket-lifecycleconfiguration-rules
     */
    readonly rules: Array<cdk.IResolvable | CfnBucket.RuleProperty> | cdk.IResolvable;
  }

  /**
   * Specifies lifecycle rules for an Amazon S3 bucket.
   *
   * For more information, see [Put Bucket Lifecycle Configuration](https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTlifecycle.html) in the *Amazon S3 API Reference* .
   *
   * You must specify at least one of the following properties: \`AbortIncompleteMultipartUpload\` , \`ExpirationDate\` , \`ExpirationInDays\` , \`NoncurrentVersionExpirationInDays\` , \`NoncurrentVersionTransition\` , \`NoncurrentVersionTransitions\` , \`Transition\` , or \`Transitions\` .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-rule.html
   */
  export interface RuleProperty {
    /**
     * Specifies a lifecycle rule that stops incomplete multipart uploads to an Amazon S3 bucket.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-rule.html#cfn-s3-bucket-rule-abortincompletemultipartupload
     */
    readonly abortIncompleteMultipartUpload?: CfnBucket.AbortIncompleteMultipartUploadProperty | cdk.IResolvable;

    /**
     * Indicates when objects are deleted from Amazon S3 and Amazon S3 Glacier.
     *
     * The date value must be in ISO 8601 format. The time is always midnight UTC. If you specify an expiration and transition time, you must use the same time unit for both properties (either in days or by date). The expiration time must also be later than the transition time.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-rule.html#cfn-s3-bucket-rule-expirationdate
     */
    readonly expirationDate?: Date | cdk.IResolvable;

    /**
     * Indicates the number of days after creation when objects are deleted from Amazon S3 and Amazon S3 Glacier.
     *
     * If you specify an expiration and transition time, you must use the same time unit for both properties (either in days or by date). The expiration time must also be later than the transition time.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-rule.html#cfn-s3-bucket-rule-expirationindays
     */
    readonly expirationInDays?: number;

    /**
     * Indicates whether Amazon S3 will remove a delete marker without any noncurrent versions.
     *
     * If set to true, the delete marker will be removed if there are no noncurrent versions. This cannot be specified with \`ExpirationInDays\` , \`ExpirationDate\` , or \`TagFilters\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-rule.html#cfn-s3-bucket-rule-expiredobjectdeletemarker
     */
    readonly expiredObjectDeleteMarker?: boolean | cdk.IResolvable;

    /**
     * Unique identifier for the rule.
     *
     * The value can't be longer than 255 characters.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-rule.html#cfn-s3-bucket-rule-id
     */
    readonly id?: string;

    /**
     * Specifies when noncurrent object versions expire.
     *
     * Upon expiration, Amazon S3 permanently deletes the noncurrent object versions. You set this lifecycle configuration action on a bucket that has versioning enabled (or suspended) to request that Amazon S3 delete noncurrent object versions at a specific period in the object's lifetime.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-rule.html#cfn-s3-bucket-rule-noncurrentversionexpiration
     */
    readonly noncurrentVersionExpiration?: cdk.IResolvable | CfnBucket.NoncurrentVersionExpirationProperty;

    /**
     * (Deprecated.) For buckets with versioning enabled (or suspended), specifies the time, in days, between when a new version of the object is uploaded to the bucket and when old versions of the object expire. When object versions expire, Amazon S3 permanently deletes them. If you specify a transition and expiration time, the expiration time must be later than the transition time.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-rule.html#cfn-s3-bucket-rule-noncurrentversionexpirationindays
     */
    readonly noncurrentVersionExpirationInDays?: number;

    /**
     * (Deprecated.) For buckets with versioning enabled (or suspended), specifies when non-current objects transition to a specified storage class. If you specify a transition and expiration time, the expiration time must be later than the transition time. If you specify this property, don't specify the \`NoncurrentVersionTransitions\` property.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-rule.html#cfn-s3-bucket-rule-noncurrentversiontransition
     */
    readonly noncurrentVersionTransition?: cdk.IResolvable | CfnBucket.NoncurrentVersionTransitionProperty;

    /**
     * For buckets with versioning enabled (or suspended), one or more transition rules that specify when non-current objects transition to a specified storage class.
     *
     * If you specify a transition and expiration time, the expiration time must be later than the transition time. If you specify this property, don't specify the \`NoncurrentVersionTransition\` property.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-rule.html#cfn-s3-bucket-rule-noncurrentversiontransitions
     */
    readonly noncurrentVersionTransitions?: Array<cdk.IResolvable | CfnBucket.NoncurrentVersionTransitionProperty> | cdk.IResolvable;

    /**
     * Specifies the minimum object size in bytes for this rule to apply to.
     *
     * Objects must be larger than this value in bytes. For more information about size based rules, see [Lifecycle configuration using size-based rules](https://docs.aws.amazon.com/AmazonS3/latest/userguide/lifecycle-configuration-examples.html#lc-size-rules) in the *Amazon S3 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-rule.html#cfn-s3-bucket-rule-objectsizegreaterthan
     */
    readonly objectSizeGreaterThan?: number;

    /**
     * Specifies the maximum object size in bytes for this rule to apply to.
     *
     * Objects must be smaller than this value in bytes. For more information about sized based rules, see [Lifecycle configuration using size-based rules](https://docs.aws.amazon.com/AmazonS3/latest/userguide/lifecycle-configuration-examples.html#lc-size-rules) in the *Amazon S3 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-rule.html#cfn-s3-bucket-rule-objectsizelessthan
     */
    readonly objectSizeLessThan?: number;

    /**
     * Object key prefix that identifies one or more objects to which this rule applies.
     *
     * > Replacement must be made for object keys containing special characters (such as carriage returns) when using XML requests. For more information, see [XML related object key constraints](https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html#object-key-xml-related-constraints) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-rule.html#cfn-s3-bucket-rule-prefix
     */
    readonly prefix?: string;

    /**
     * If \`Enabled\` , the rule is currently being applied.
     *
     * If \`Disabled\` , the rule is not currently being applied.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-rule.html#cfn-s3-bucket-rule-status
     */
    readonly status: string;

    /**
     * Tags to use to identify a subset of objects to which the lifecycle rule applies.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-rule.html#cfn-s3-bucket-rule-tagfilters
     */
    readonly tagFilters?: Array<cdk.IResolvable | CfnBucket.TagFilterProperty> | cdk.IResolvable;

    /**
     * (Deprecated.) Specifies when an object transitions to a specified storage class. If you specify an expiration and transition time, you must use the same time unit for both properties (either in days or by date). The expiration time must also be later than the transition time. If you specify this property, don't specify the \`Transitions\` property.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-rule.html#cfn-s3-bucket-rule-transition
     */
    readonly transition?: cdk.IResolvable | CfnBucket.TransitionProperty;

    /**
     * One or more transition rules that specify when an object transitions to a specified storage class.
     *
     * If you specify an expiration and transition time, you must use the same time unit for both properties (either in days or by date). The expiration time must also be later than the transition time. If you specify this property, don't specify the \`Transition\` property.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-rule.html#cfn-s3-bucket-rule-transitions
     */
    readonly transitions?: Array<cdk.IResolvable | CfnBucket.TransitionProperty> | cdk.IResolvable;
  }

  /**
   * Specifies the days since the initiation of an incomplete multipart upload that Amazon S3 will wait before permanently removing all parts of the upload.
   *
   * For more information, see [Stopping Incomplete Multipart Uploads Using a Bucket Lifecycle Policy](https://docs.aws.amazon.com/AmazonS3/latest/dev/mpuoverview.html#mpu-abort-incomplete-mpu-lifecycle-config) in the *Amazon S3 User Guide* .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-abortincompletemultipartupload.html
   */
  export interface AbortIncompleteMultipartUploadProperty {
    /**
     * Specifies the number of days after which Amazon S3 stops an incomplete multipart upload.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-abortincompletemultipartupload.html#cfn-s3-bucket-abortincompletemultipartupload-daysafterinitiation
     */
    readonly daysAfterInitiation: number;
  }

  /**
   * Specifies when noncurrent object versions expire.
   *
   * Upon expiration, Amazon S3 permanently deletes the noncurrent object versions. You set this lifecycle configuration action on a bucket that has versioning enabled (or suspended) to request that Amazon S3 delete noncurrent object versions at a specific period in the object's lifetime. For more information about setting a lifecycle rule configuration, see [AWS::S3::Bucket Rule](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-lifecycleconfig-rule.html) .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-noncurrentversionexpiration.html
   */
  export interface NoncurrentVersionExpirationProperty {
    /**
     * Specifies how many noncurrent versions Amazon S3 will retain.
     *
     * If there are this many more recent noncurrent versions, Amazon S3 will take the associated action. For more information about noncurrent versions, see [Lifecycle configuration elements](https://docs.aws.amazon.com/AmazonS3/latest/userguide/intro-lifecycle-rules.html) in the *Amazon S3 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-noncurrentversionexpiration.html#cfn-s3-bucket-noncurrentversionexpiration-newernoncurrentversions
     */
    readonly newerNoncurrentVersions?: number;

    /**
     * Specifies the number of days an object is noncurrent before Amazon S3 can perform the associated action.
     *
     * For information about the noncurrent days calculations, see [How Amazon S3 Calculates When an Object Became Noncurrent](https://docs.aws.amazon.com/AmazonS3/latest/dev/intro-lifecycle-rules.html#non-current-days-calculations) in the *Amazon S3 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-noncurrentversionexpiration.html#cfn-s3-bucket-noncurrentversionexpiration-noncurrentdays
     */
    readonly noncurrentDays: number;
  }

  /**
   * Container for the transition rule that describes when noncurrent objects transition to the \`STANDARD_IA\` , \`ONEZONE_IA\` , \`INTELLIGENT_TIERING\` , \`GLACIER_IR\` , \`GLACIER\` , or \`DEEP_ARCHIVE\` storage class.
   *
   * If your bucket is versioning-enabled (or versioning is suspended), you can set this action to request that Amazon S3 transition noncurrent object versions to the \`STANDARD_IA\` , \`ONEZONE_IA\` , \`INTELLIGENT_TIERING\` , \`GLACIER_IR\` , \`GLACIER\` , or \`DEEP_ARCHIVE\` storage class at a specific period in the object's lifetime. If you specify this property, don't specify the \`NoncurrentVersionTransitions\` property.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-noncurrentversiontransition.html
   */
  export interface NoncurrentVersionTransitionProperty {
    /**
     * Specifies how many noncurrent versions Amazon S3 will retain.
     *
     * If there are this many more recent noncurrent versions, Amazon S3 will take the associated action. For more information about noncurrent versions, see [Lifecycle configuration elements](https://docs.aws.amazon.com/AmazonS3/latest/userguide/intro-lifecycle-rules.html) in the *Amazon S3 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-noncurrentversiontransition.html#cfn-s3-bucket-noncurrentversiontransition-newernoncurrentversions
     */
    readonly newerNoncurrentVersions?: number;

    /**
     * The class of storage used to store the object.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-noncurrentversiontransition.html#cfn-s3-bucket-noncurrentversiontransition-storageclass
     */
    readonly storageClass: string;

    /**
     * Specifies the number of days an object is noncurrent before Amazon S3 can perform the associated action.
     *
     * For information about the noncurrent days calculations, see [How Amazon S3 Calculates How Long an Object Has Been Noncurrent](https://docs.aws.amazon.com/AmazonS3/latest/dev/intro-lifecycle-rules.html#non-current-days-calculations) in the *Amazon S3 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-noncurrentversiontransition.html#cfn-s3-bucket-noncurrentversiontransition-transitionindays
     */
    readonly transitionInDays: number;
  }

  /**
   * Specifies when an object transitions to a specified storage class.
   *
   * For more information about Amazon S3 lifecycle configuration rules, see [Transitioning Objects Using Amazon S3 Lifecycle](https://docs.aws.amazon.com/AmazonS3/latest/dev/lifecycle-transition-general-considerations.html) in the *Amazon S3 User Guide* .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-transition.html
   */
  export interface TransitionProperty {
    /**
     * The storage class to which you want the object to transition.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-transition.html#cfn-s3-bucket-transition-storageclass
     */
    readonly storageClass: string;

    /**
     * Indicates when objects are transitioned to the specified storage class.
     *
     * The date value must be in ISO 8601 format. The time is always midnight UTC.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-transition.html#cfn-s3-bucket-transition-transitiondate
     */
    readonly transitionDate?: Date | cdk.IResolvable;

    /**
     * Indicates the number of days after creation when objects are transitioned to the specified storage class.
     *
     * The value must be a positive integer.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-transition.html#cfn-s3-bucket-transition-transitionindays
     */
    readonly transitionInDays?: number;
  }

  /**
   * Describes where logs are stored and the prefix that Amazon S3 assigns to all log object keys for a bucket.
   *
   * For examples and more information, see [PUT Bucket logging](https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTlogging.html) in the *Amazon S3 API Reference* .
   *
   * > To successfully complete the \`AWS::S3::Bucket LoggingConfiguration\` request, you must have \`s3:PutObject\` and \`s3:PutObjectAcl\` in your IAM permissions.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-loggingconfiguration.html
   */
  export interface LoggingConfigurationProperty {
    /**
     * The name of the bucket where Amazon S3 should store server access log files.
     *
     * You can store log files in any bucket that you own. By default, logs are stored in the bucket where the \`LoggingConfiguration\` property is defined.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-loggingconfiguration.html#cfn-s3-bucket-loggingconfiguration-destinationbucketname
     */
    readonly destinationBucketName?: string;

    /**
     * A prefix for all log object keys.
     *
     * If you store log files from multiple Amazon S3 buckets in a single bucket, you can use a prefix to distinguish which log files came from which bucket.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-loggingconfiguration.html#cfn-s3-bucket-loggingconfiguration-logfileprefix
     */
    readonly logFilePrefix?: string;
  }

  /**
   * Specifies a metrics configuration for the CloudWatch request metrics (specified by the metrics configuration ID) from an Amazon S3 bucket.
   *
   * If you're updating an existing metrics configuration, note that this is a full replacement of the existing metrics configuration. If you don't include the elements you want to keep, they are erased. For examples, see [AWS::S3::Bucket](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket.html#aws-properties-s3-bucket--examples) . For more information, see [PUT Bucket metrics](https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTMetricConfiguration.html) in the *Amazon S3 API Reference* .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-metricsconfiguration.html
   */
  export interface MetricsConfigurationProperty {
    /**
     * The access point that was used while performing operations on the object.
     *
     * The metrics configuration only includes objects that meet the filter's criteria.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-metricsconfiguration.html#cfn-s3-bucket-metricsconfiguration-accesspointarn
     */
    readonly accessPointArn?: string;

    /**
     * The ID used to identify the metrics configuration.
     *
     * This can be any value you choose that helps you identify your metrics configuration.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-metricsconfiguration.html#cfn-s3-bucket-metricsconfiguration-id
     */
    readonly id: string;

    /**
     * The prefix that an object must have to be included in the metrics results.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-metricsconfiguration.html#cfn-s3-bucket-metricsconfiguration-prefix
     */
    readonly prefix?: string;

    /**
     * Specifies a list of tag filters to use as a metrics configuration filter.
     *
     * The metrics configuration includes only objects that meet the filter's criteria.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-metricsconfiguration.html#cfn-s3-bucket-metricsconfiguration-tagfilters
     */
    readonly tagFilters?: Array<cdk.IResolvable | CfnBucket.TagFilterProperty> | cdk.IResolvable;
  }

  /**
   * Describes the notification configuration for an Amazon S3 bucket.
   *
   * > If you create the target resource and related permissions in the same template, you might have a circular dependency.
   * >
   * > For example, you might use the \`AWS::Lambda::Permission\` resource to grant the bucket permission to invoke an AWS Lambda function. However, AWS CloudFormation can't create the bucket until the bucket has permission to invoke the function ( AWS CloudFormation checks whether the bucket can invoke the function). If you're using Refs to pass the bucket name, this leads to a circular dependency.
   * >
   * > To avoid this dependency, you can create all resources without specifying the notification configuration. Then, update the stack with a notification configuration.
   * >
   * > For more information on permissions, see [AWS::Lambda::Permission](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-permission.html) and [Granting Permissions to Publish Event Notification Messages to a Destination](https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html#grant-destinations-permissions-to-s3) .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-notificationconfiguration.html
   */
  export interface NotificationConfigurationProperty {
    /**
     * Enables delivery of events to Amazon EventBridge.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-notificationconfiguration.html#cfn-s3-bucket-notificationconfiguration-eventbridgeconfiguration
     */
    readonly eventBridgeConfiguration?: CfnBucket.EventBridgeConfigurationProperty | cdk.IResolvable;

    /**
     * Describes the AWS Lambda functions to invoke and the events for which to invoke them.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-notificationconfiguration.html#cfn-s3-bucket-notificationconfiguration-lambdaconfigurations
     */
    readonly lambdaConfigurations?: Array<cdk.IResolvable | CfnBucket.LambdaConfigurationProperty> | cdk.IResolvable;

    /**
     * The Amazon Simple Queue Service queues to publish messages to and the events for which to publish messages.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-notificationconfiguration.html#cfn-s3-bucket-notificationconfiguration-queueconfigurations
     */
    readonly queueConfigurations?: Array<cdk.IResolvable | CfnBucket.QueueConfigurationProperty> | cdk.IResolvable;

    /**
     * The topic to which notifications are sent and the events for which notifications are generated.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-notificationconfiguration.html#cfn-s3-bucket-notificationconfiguration-topicconfigurations
     */
    readonly topicConfigurations?: Array<cdk.IResolvable | CfnBucket.TopicConfigurationProperty> | cdk.IResolvable;
  }

  /**
   * Amazon S3 can send events to Amazon EventBridge whenever certain events happen in your bucket, see [Using EventBridge](https://docs.aws.amazon.com/AmazonS3/latest/userguide/EventBridge.html) in the *Amazon S3 User Guide* .
   *
   * Unlike other destinations, delivery of events to EventBridge can be either enabled or disabled for a bucket. If enabled, all events will be sent to EventBridge and you can use EventBridge rules to route events to additional targets. For more information, see [What Is Amazon EventBridge](https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-what-is.html) in the *Amazon EventBridge User Guide*
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-eventbridgeconfiguration.html
   */
  export interface EventBridgeConfigurationProperty {
    /**
     * Enables delivery of events to Amazon EventBridge.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-eventbridgeconfiguration.html#cfn-s3-bucket-eventbridgeconfiguration-eventbridgeenabled
     */
    readonly eventBridgeEnabled: boolean | cdk.IResolvable;
  }

  /**
   * Describes the AWS Lambda functions to invoke and the events for which to invoke them.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-lambdaconfiguration.html
   */
  export interface LambdaConfigurationProperty {
    /**
     * The Amazon S3 bucket event for which to invoke the AWS Lambda function.
     *
     * For more information, see [Supported Event Types](https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html) in the *Amazon S3 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-lambdaconfiguration.html#cfn-s3-bucket-lambdaconfiguration-event
     */
    readonly event: string;

    /**
     * The filtering rules that determine which objects invoke the AWS Lambda function.
     *
     * For example, you can create a filter so that only image files with a \`.jpg\` extension invoke the function when they are added to the Amazon S3 bucket.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-lambdaconfiguration.html#cfn-s3-bucket-lambdaconfiguration-filter
     */
    readonly filter?: cdk.IResolvable | CfnBucket.NotificationFilterProperty;

    /**
     * The Amazon Resource Name (ARN) of the AWS Lambda function that Amazon S3 invokes when the specified event type occurs.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-lambdaconfiguration.html#cfn-s3-bucket-lambdaconfiguration-function
     */
    readonly function: string;
  }

  /**
   * Specifies object key name filtering rules.
   *
   * For information about key name filtering, see [Configuring event notifications using object key name filtering](https://docs.aws.amazon.com/AmazonS3/latest/userguide/notification-how-to-filtering.html) in the *Amazon S3 User Guide* .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-notificationfilter.html
   */
  export interface NotificationFilterProperty {
    /**
     * A container for object key name prefix and suffix filtering rules.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-notificationfilter.html#cfn-s3-bucket-notificationfilter-s3key
     */
    readonly s3Key: cdk.IResolvable | CfnBucket.S3KeyFilterProperty;
  }

  /**
   * A container for object key name prefix and suffix filtering rules.
   *
   * For more information about object key name filtering, see [Configuring event notifications using object key name filtering](https://docs.aws.amazon.com/AmazonS3/latest/userguide/notification-how-to-filtering.html) in the *Amazon S3 User Guide* .
   *
   * > The same type of filter rule cannot be used more than once. For example, you cannot specify two prefix rules.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-s3keyfilter.html
   */
  export interface S3KeyFilterProperty {
    /**
     * A list of containers for the key-value pair that defines the criteria for the filter rule.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-s3keyfilter.html#cfn-s3-bucket-s3keyfilter-rules
     */
    readonly rules: Array<CfnBucket.FilterRuleProperty | cdk.IResolvable> | cdk.IResolvable;
  }

  /**
   * Specifies the Amazon S3 object key name to filter on and whether to filter on the suffix or prefix of the key name.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-filterrule.html
   */
  export interface FilterRuleProperty {
    /**
     * The object key name prefix or suffix identifying one or more objects to which the filtering rule applies.
     *
     * The maximum length is 1,024 characters. Overlapping prefixes and suffixes are not supported. For more information, see [Configuring Event Notifications](https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html) in the *Amazon S3 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-filterrule.html#cfn-s3-bucket-filterrule-name
     */
    readonly name: string;

    /**
     * The value that the filter searches for in object key names.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-filterrule.html#cfn-s3-bucket-filterrule-value
     */
    readonly value: string;
  }

  /**
   * Specifies the configuration for publishing messages to an Amazon Simple Queue Service (Amazon SQS) queue when Amazon S3 detects specified events.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-queueconfiguration.html
   */
  export interface QueueConfigurationProperty {
    /**
     * The Amazon S3 bucket event about which you want to publish messages to Amazon SQS.
     *
     * For more information, see [Supported Event Types](https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html) in the *Amazon S3 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-queueconfiguration.html#cfn-s3-bucket-queueconfiguration-event
     */
    readonly event: string;

    /**
     * The filtering rules that determine which objects trigger notifications.
     *
     * For example, you can create a filter so that Amazon S3 sends notifications only when image files with a \`.jpg\` extension are added to the bucket. For more information, see [Configuring event notifications using object key name filtering](https://docs.aws.amazon.com/AmazonS3/latest/user-guide/notification-how-to-filtering.html) in the *Amazon S3 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-queueconfiguration.html#cfn-s3-bucket-queueconfiguration-filter
     */
    readonly filter?: cdk.IResolvable | CfnBucket.NotificationFilterProperty;

    /**
     * The Amazon Resource Name (ARN) of the Amazon SQS queue to which Amazon S3 publishes a message when it detects events of the specified type.
     *
     * FIFO queues are not allowed when enabling an SQS queue as the event notification destination.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-queueconfiguration.html#cfn-s3-bucket-queueconfiguration-queue
     */
    readonly queue: string;
  }

  /**
   * A container for specifying the configuration for publication of messages to an Amazon Simple Notification Service (Amazon SNS) topic when Amazon S3 detects specified events.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-topicconfiguration.html
   */
  export interface TopicConfigurationProperty {
    /**
     * The Amazon S3 bucket event about which to send notifications.
     *
     * For more information, see [Supported Event Types](https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html) in the *Amazon S3 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-topicconfiguration.html#cfn-s3-bucket-topicconfiguration-event
     */
    readonly event: string;

    /**
     * The filtering rules that determine for which objects to send notifications.
     *
     * For example, you can create a filter so that Amazon S3 sends notifications only when image files with a \`.jpg\` extension are added to the bucket.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-topicconfiguration.html#cfn-s3-bucket-topicconfiguration-filter
     */
    readonly filter?: cdk.IResolvable | CfnBucket.NotificationFilterProperty;

    /**
     * The Amazon Resource Name (ARN) of the Amazon SNS topic to which Amazon S3 publishes a message when it detects events of the specified type.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-topicconfiguration.html#cfn-s3-bucket-topicconfiguration-topic
     */
    readonly topic: string;
  }

  /**
   * Places an Object Lock configuration on the specified bucket.
   *
   * The rule specified in the Object Lock configuration will be applied by default to every new object placed in the specified bucket. For more information, see [Locking Objects](https://docs.aws.amazon.com/AmazonS3/latest/dev/object-lock.html) .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-objectlockconfiguration.html
   */
  export interface ObjectLockConfigurationProperty {
    /**
     * Indicates whether this bucket has an Object Lock configuration enabled.
     *
     * Enable \`ObjectLockEnabled\` when you apply \`ObjectLockConfiguration\` to a bucket.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-objectlockconfiguration.html#cfn-s3-bucket-objectlockconfiguration-objectlockenabled
     */
    readonly objectLockEnabled?: string;

    /**
     * Specifies the Object Lock rule for the specified object.
     *
     * Enable this rule when you apply \`ObjectLockConfiguration\` to a bucket. If Object Lock is turned on, bucket settings require both \`Mode\` and a period of either \`Days\` or \`Years\` . You cannot specify \`Days\` and \`Years\` at the same time. For more information, see [ObjectLockRule](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-objectlockrule.html) and [DefaultRetention](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-defaultretention.html) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-objectlockconfiguration.html#cfn-s3-bucket-objectlockconfiguration-rule
     */
    readonly rule?: cdk.IResolvable | CfnBucket.ObjectLockRuleProperty;
  }

  /**
   * Specifies the Object Lock rule for the specified object.
   *
   * Enable the this rule when you apply \`ObjectLockConfiguration\` to a bucket.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-objectlockrule.html
   */
  export interface ObjectLockRuleProperty {
    /**
     * The default Object Lock retention mode and period that you want to apply to new objects placed in the specified bucket.
     *
     * If Object Lock is turned on, bucket settings require both \`Mode\` and a period of either \`Days\` or \`Years\` . You cannot specify \`Days\` and \`Years\` at the same time. For more information about allowable values for mode and period, see [DefaultRetention](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-defaultretention.html) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-objectlockrule.html#cfn-s3-bucket-objectlockrule-defaultretention
     */
    readonly defaultRetention?: CfnBucket.DefaultRetentionProperty | cdk.IResolvable;
  }

  /**
   * The container element for specifying the default Object Lock retention settings for new objects placed in the specified bucket.
   *
   * > - The \`DefaultRetention\` settings require both a mode and a period.
   * > - The \`DefaultRetention\` period can be either \`Days\` or \`Years\` but you must select one. You cannot specify \`Days\` and \`Years\` at the same time.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-defaultretention.html
   */
  export interface DefaultRetentionProperty {
    /**
     * The number of days that you want to specify for the default retention period.
     *
     * If Object Lock is turned on, you must specify \`Mode\` and specify either \`Days\` or \`Years\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-defaultretention.html#cfn-s3-bucket-defaultretention-days
     */
    readonly days?: number;

    /**
     * The default Object Lock retention mode you want to apply to new objects placed in the specified bucket.
     *
     * If Object Lock is turned on, you must specify \`Mode\` and specify either \`Days\` or \`Years\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-defaultretention.html#cfn-s3-bucket-defaultretention-mode
     */
    readonly mode?: string;

    /**
     * The number of years that you want to specify for the default retention period.
     *
     * If Object Lock is turned on, you must specify \`Mode\` and specify either \`Days\` or \`Years\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-defaultretention.html#cfn-s3-bucket-defaultretention-years
     */
    readonly years?: number;
  }

  /**
   * Specifies the container element for Object Ownership rules.
   *
   * S3 Object Ownership is an Amazon S3 bucket-level setting that you can use to disable access control lists (ACLs) and take ownership of every object in your bucket, simplifying access management for data stored in Amazon S3. For more information, see [Controlling ownership of objects and disabling ACLs](https://docs.aws.amazon.com/AmazonS3/latest/userguide/about-object-ownership.html) in the *Amazon S3 User Guide* .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-ownershipcontrols.html
   */
  export interface OwnershipControlsProperty {
    /**
     * Specifies the container element for Object Ownership rules.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-ownershipcontrols.html#cfn-s3-bucket-ownershipcontrols-rules
     */
    readonly rules: Array<cdk.IResolvable | CfnBucket.OwnershipControlsRuleProperty> | cdk.IResolvable;
  }

  /**
   * Specifies an Object Ownership rule.
   *
   * S3 Object Ownership is an Amazon S3 bucket-level setting that you can use to disable access control lists (ACLs) and take ownership of every object in your bucket, simplifying access management for data stored in Amazon S3. For more information, see [Controlling ownership of objects and disabling ACLs](https://docs.aws.amazon.com/AmazonS3/latest/userguide/about-object-ownership.html) in the *Amazon S3 User Guide* .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-ownershipcontrolsrule.html
   */
  export interface OwnershipControlsRuleProperty {
    /**
     * Specifies an Object Ownership rule.
     *
     * *Allowed values* : \`BucketOwnerEnforced\` | \`ObjectWriter\` | \`BucketOwnerPreferred\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-ownershipcontrolsrule.html#cfn-s3-bucket-ownershipcontrolsrule-objectownership
     */
    readonly objectOwnership?: string;
  }

  /**
   * The PublicAccessBlock configuration that you want to apply to this Amazon S3 bucket.
   *
   * You can enable the configuration options in any combination. For more information about when Amazon S3 considers a bucket or object public, see [The Meaning of "Public"](https://docs.aws.amazon.com/AmazonS3/latest/dev/access-control-block-public-access.html#access-control-block-public-access-policy-status) in the *Amazon S3 User Guide* .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-publicaccessblockconfiguration.html
   */
  export interface PublicAccessBlockConfigurationProperty {
    /**
     * Specifies whether Amazon S3 should block public access control lists (ACLs) for this bucket and objects in this bucket.
     *
     * Setting this element to \`TRUE\` causes the following behavior:
     *
     * - PUT Bucket ACL and PUT Object ACL calls fail if the specified ACL is public.
     * - PUT Object calls fail if the request includes a public ACL.
     * - PUT Bucket calls fail if the request includes a public ACL.
     *
     * Enabling this setting doesn't affect existing policies or ACLs.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-publicaccessblockconfiguration.html#cfn-s3-bucket-publicaccessblockconfiguration-blockpublicacls
     */
    readonly blockPublicAcls?: boolean | cdk.IResolvable;

    /**
     * Specifies whether Amazon S3 should block public bucket policies for this bucket.
     *
     * Setting this element to \`TRUE\` causes Amazon S3 to reject calls to PUT Bucket policy if the specified bucket policy allows public access.
     *
     * Enabling this setting doesn't affect existing bucket policies.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-publicaccessblockconfiguration.html#cfn-s3-bucket-publicaccessblockconfiguration-blockpublicpolicy
     */
    readonly blockPublicPolicy?: boolean | cdk.IResolvable;

    /**
     * Specifies whether Amazon S3 should ignore public ACLs for this bucket and objects in this bucket.
     *
     * Setting this element to \`TRUE\` causes Amazon S3 to ignore all public ACLs on this bucket and objects in this bucket.
     *
     * Enabling this setting doesn't affect the persistence of any existing ACLs and doesn't prevent new public ACLs from being set.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-publicaccessblockconfiguration.html#cfn-s3-bucket-publicaccessblockconfiguration-ignorepublicacls
     */
    readonly ignorePublicAcls?: boolean | cdk.IResolvable;

    /**
     * Specifies whether Amazon S3 should restrict public bucket policies for this bucket.
     *
     * Setting this element to \`TRUE\` restricts access to this bucket to only AWS service principals and authorized users within this account if the bucket has a public policy.
     *
     * Enabling this setting doesn't affect previously stored bucket policies, except that public and cross-account access within any public bucket policy, including non-public delegation to specific accounts, is blocked.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-publicaccessblockconfiguration.html#cfn-s3-bucket-publicaccessblockconfiguration-restrictpublicbuckets
     */
    readonly restrictPublicBuckets?: boolean | cdk.IResolvable;
  }

  /**
   * A container for replication rules.
   *
   * You can add up to 1,000 rules. The maximum size of a replication configuration is 2 MB.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-replicationconfiguration.html
   */
  export interface ReplicationConfigurationProperty {
    /**
     * The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that Amazon S3 assumes when replicating objects.
     *
     * For more information, see [How to Set Up Replication](https://docs.aws.amazon.com/AmazonS3/latest/dev/replication-how-setup.html) in the *Amazon S3 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-replicationconfiguration.html#cfn-s3-bucket-replicationconfiguration-role
     */
    readonly role: string;

    /**
     * A container for one or more replication rules.
     *
     * A replication configuration must have at least one rule and can contain a maximum of 1,000 rules.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-replicationconfiguration.html#cfn-s3-bucket-replicationconfiguration-rules
     */
    readonly rules: Array<cdk.IResolvable | CfnBucket.ReplicationRuleProperty> | cdk.IResolvable;
  }

  /**
   * Specifies which Amazon S3 objects to replicate and where to store the replicas.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-replicationrule.html
   */
  export interface ReplicationRuleProperty {
    /**
     * Specifies whether Amazon S3 replicates delete markers.
     *
     * If you specify a \`Filter\` in your replication configuration, you must also include a \`DeleteMarkerReplication\` element. If your \`Filter\` includes a \`Tag\` element, the \`DeleteMarkerReplication\` \`Status\` must be set to Disabled, because Amazon S3 does not support replicating delete markers for tag-based rules. For an example configuration, see [Basic Rule Configuration](https://docs.aws.amazon.com/AmazonS3/latest/dev/replication-add-config.html#replication-config-min-rule-config) .
     *
     * For more information about delete marker replication, see [Basic Rule Configuration](https://docs.aws.amazon.com/AmazonS3/latest/dev/delete-marker-replication.html) .
     *
     * > If you are using an earlier version of the replication configuration, Amazon S3 handles replication of delete markers differently. For more information, see [Backward Compatibility](https://docs.aws.amazon.com/AmazonS3/latest/dev/replication-add-config.html#replication-backward-compat-considerations) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-replicationrule.html#cfn-s3-bucket-replicationrule-deletemarkerreplication
     */
    readonly deleteMarkerReplication?: CfnBucket.DeleteMarkerReplicationProperty | cdk.IResolvable;

    /**
     * A container for information about the replication destination and its configurations including enabling the S3 Replication Time Control (S3 RTC).
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-replicationrule.html#cfn-s3-bucket-replicationrule-destination
     */
    readonly destination: cdk.IResolvable | CfnBucket.ReplicationDestinationProperty;

    /**
     * A filter that identifies the subset of objects to which the replication rule applies.
     *
     * A \`Filter\` must specify exactly one \`Prefix\` , \`TagFilter\` , or an \`And\` child element. The use of the filter field indicates that this is a V2 replication configuration. This field isn't supported in a V1 replication configuration.
     *
     * > V1 replication configuration only supports filtering by key prefix. To filter using a V1 replication configuration, add the \`Prefix\` directly as a child element of the \`Rule\` element.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-replicationrule.html#cfn-s3-bucket-replicationrule-filter
     */
    readonly filter?: cdk.IResolvable | CfnBucket.ReplicationRuleFilterProperty;

    /**
     * A unique identifier for the rule.
     *
     * The maximum value is 255 characters. If you don't specify a value, AWS CloudFormation generates a random ID. When using a V2 replication configuration this property is capitalized as "ID".
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-replicationrule.html#cfn-s3-bucket-replicationrule-id
     */
    readonly id?: string;

    /**
     * An object key name prefix that identifies the object or objects to which the rule applies.
     *
     * The maximum prefix length is 1,024 characters. To include all objects in a bucket, specify an empty string. To filter using a V1 replication configuration, add the \`Prefix\` directly as a child element of the \`Rule\` element.
     *
     * > Replacement must be made for object keys containing special characters (such as carriage returns) when using XML requests. For more information, see [XML related object key constraints](https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html#object-key-xml-related-constraints) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-replicationrule.html#cfn-s3-bucket-replicationrule-prefix
     */
    readonly prefix?: string;

    /**
     * The priority indicates which rule has precedence whenever two or more replication rules conflict.
     *
     * Amazon S3 will attempt to replicate objects according to all replication rules. However, if there are two or more rules with the same destination bucket, then objects will be replicated according to the rule with the highest priority. The higher the number, the higher the priority.
     *
     * For more information, see [Replication](https://docs.aws.amazon.com/AmazonS3/latest/dev/replication.html) in the *Amazon S3 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-replicationrule.html#cfn-s3-bucket-replicationrule-priority
     */
    readonly priority?: number;

    /**
     * A container that describes additional filters for identifying the source objects that you want to replicate.
     *
     * You can choose to enable or disable the replication of these objects.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-replicationrule.html#cfn-s3-bucket-replicationrule-sourceselectioncriteria
     */
    readonly sourceSelectionCriteria?: cdk.IResolvable | CfnBucket.SourceSelectionCriteriaProperty;

    /**
     * Specifies whether the rule is enabled.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-replicationrule.html#cfn-s3-bucket-replicationrule-status
     */
    readonly status: string;
  }

  /**
   * Specifies whether Amazon S3 replicates delete markers.
   *
   * If you specify a \`Filter\` in your replication configuration, you must also include a \`DeleteMarkerReplication\` element. If your \`Filter\` includes a \`Tag\` element, the \`DeleteMarkerReplication\` \`Status\` must be set to Disabled, because Amazon S3 does not support replicating delete markers for tag-based rules. For an example configuration, see [Basic Rule Configuration](https://docs.aws.amazon.com/AmazonS3/latest/dev/replication-add-config.html#replication-config-min-rule-config) .
   *
   * For more information about delete marker replication, see [Basic Rule Configuration](https://docs.aws.amazon.com/AmazonS3/latest/dev/delete-marker-replication.html) .
   *
   * > If you are using an earlier version of the replication configuration, Amazon S3 handles replication of delete markers differently. For more information, see [Backward Compatibility](https://docs.aws.amazon.com/AmazonS3/latest/dev/replication-add-config.html#replication-backward-compat-considerations) .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-deletemarkerreplication.html
   */
  export interface DeleteMarkerReplicationProperty {
    /**
     * Indicates whether to replicate delete markers.
     *
     * Disabled by default.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-deletemarkerreplication.html#cfn-s3-bucket-deletemarkerreplication-status
     */
    readonly status?: string;
  }

  /**
   * A container for information about the replication destination and its configurations including enabling the S3 Replication Time Control (S3 RTC).
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-replicationdestination.html
   */
  export interface ReplicationDestinationProperty {
    /**
     * Specify this only in a cross-account scenario (where source and destination bucket owners are not the same), and you want to change replica ownership to the AWS account that owns the destination bucket.
     *
     * If this is not specified in the replication configuration, the replicas are owned by same AWS account that owns the source object.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-replicationdestination.html#cfn-s3-bucket-replicationdestination-accesscontroltranslation
     */
    readonly accessControlTranslation?: CfnBucket.AccessControlTranslationProperty | cdk.IResolvable;

    /**
     * Destination bucket owner account ID.
     *
     * In a cross-account scenario, if you direct Amazon S3 to change replica ownership to the AWS account that owns the destination bucket by specifying the \`AccessControlTranslation\` property, this is the account ID of the destination bucket owner. For more information, see [Cross-Region Replication Additional Configuration: Change Replica Owner](https://docs.aws.amazon.com/AmazonS3/latest/dev/crr-change-owner.html) in the *Amazon S3 User Guide* .
     *
     * If you specify the \`AccessControlTranslation\` property, the \`Account\` property is required.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-replicationdestination.html#cfn-s3-bucket-replicationdestination-account
     */
    readonly account?: string;

    /**
     * The Amazon Resource Name (ARN) of the bucket where you want Amazon S3 to store the results.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-replicationdestination.html#cfn-s3-bucket-replicationdestination-bucket
     */
    readonly bucket: string;

    /**
     * Specifies encryption-related information.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-replicationdestination.html#cfn-s3-bucket-replicationdestination-encryptionconfiguration
     */
    readonly encryptionConfiguration?: CfnBucket.EncryptionConfigurationProperty | cdk.IResolvable;

    /**
     * A container specifying replication metrics-related settings enabling replication metrics and events.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-replicationdestination.html#cfn-s3-bucket-replicationdestination-metrics
     */
    readonly metrics?: cdk.IResolvable | CfnBucket.MetricsProperty;

    /**
     * A container specifying S3 Replication Time Control (S3 RTC), including whether S3 RTC is enabled and the time when all objects and operations on objects must be replicated.
     *
     * Must be specified together with a \`Metrics\` block.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-replicationdestination.html#cfn-s3-bucket-replicationdestination-replicationtime
     */
    readonly replicationTime?: cdk.IResolvable | CfnBucket.ReplicationTimeProperty;

    /**
     * The storage class to use when replicating objects, such as S3 Standard or reduced redundancy.
     *
     * By default, Amazon S3 uses the storage class of the source object to create the object replica.
     *
     * For valid values, see the \`StorageClass\` element of the [PUT Bucket replication](https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTreplication.html) action in the *Amazon S3 API Reference* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-replicationdestination.html#cfn-s3-bucket-replicationdestination-storageclass
     */
    readonly storageClass?: string;
  }

  /**
   * Specify this only in a cross-account scenario (where source and destination bucket owners are not the same), and you want to change replica ownership to the AWS account that owns the destination bucket.
   *
   * If this is not specified in the replication configuration, the replicas are owned by same AWS account that owns the source object.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-accesscontroltranslation.html
   */
  export interface AccessControlTranslationProperty {
    /**
     * Specifies the replica ownership.
     *
     * For default and valid values, see [PUT bucket replication](https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTreplication.html) in the *Amazon S3 API Reference* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-accesscontroltranslation.html#cfn-s3-bucket-accesscontroltranslation-owner
     */
    readonly owner: string;
  }

  /**
   * Specifies encryption-related information for an Amazon S3 bucket that is a destination for replicated objects.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-encryptionconfiguration.html
   */
  export interface EncryptionConfigurationProperty {
    /**
     * Specifies the ID (Key ARN or Alias ARN) of the customer managed AWS KMS key stored in AWS Key Management Service (KMS) for the destination bucket.
     *
     * Amazon S3 uses this key to encrypt replica objects. Amazon S3 only supports symmetric encryption KMS keys. For more information, see [Asymmetric keys in AWS KMS](https://docs.aws.amazon.com//kms/latest/developerguide/symmetric-asymmetric.html) in the *AWS Key Management Service Developer Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-encryptionconfiguration.html#cfn-s3-bucket-encryptionconfiguration-replicakmskeyid
     */
    readonly replicaKmsKeyId: string;
  }

  /**
   * A container specifying replication metrics-related settings enabling replication metrics and events.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-metrics.html
   */
  export interface MetricsProperty {
    /**
     * A container specifying the time threshold for emitting the \`s3:Replication:OperationMissedThreshold\` event.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-metrics.html#cfn-s3-bucket-metrics-eventthreshold
     */
    readonly eventThreshold?: cdk.IResolvable | CfnBucket.ReplicationTimeValueProperty;

    /**
     * Specifies whether the replication metrics are enabled.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-metrics.html#cfn-s3-bucket-metrics-status
     */
    readonly status: string;
  }

  /**
   * A container specifying the time value for S3 Replication Time Control (S3 RTC) and replication metrics \`EventThreshold\` .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-replicationtimevalue.html
   */
  export interface ReplicationTimeValueProperty {
    /**
     * Contains an integer specifying time in minutes.
     *
     * Valid value: 15
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-replicationtimevalue.html#cfn-s3-bucket-replicationtimevalue-minutes
     */
    readonly minutes: number;
  }

  /**
   * A container specifying S3 Replication Time Control (S3 RTC) related information, including whether S3 RTC is enabled and the time when all objects and operations on objects must be replicated.
   *
   * Must be specified together with a \`Metrics\` block.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-replicationtime.html
   */
  export interface ReplicationTimeProperty {
    /**
     * Specifies whether the replication time is enabled.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-replicationtime.html#cfn-s3-bucket-replicationtime-status
     */
    readonly status: string;

    /**
     * A container specifying the time by which replication should be complete for all objects and operations on objects.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-replicationtime.html#cfn-s3-bucket-replicationtime-time
     */
    readonly time: cdk.IResolvable | CfnBucket.ReplicationTimeValueProperty;
  }

  /**
   * A filter that identifies the subset of objects to which the replication rule applies.
   *
   * A \`Filter\` must specify exactly one \`Prefix\` , \`TagFilter\` , or an \`And\` child element.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-replicationrulefilter.html
   */
  export interface ReplicationRuleFilterProperty {
    /**
     * A container for specifying rule filters.
     *
     * The filters determine the subset of objects to which the rule applies. This element is required only if you specify more than one filter. For example:
     *
     * - If you specify both a \`Prefix\` and a \`TagFilter\` , wrap these filters in an \`And\` tag.
     * - If you specify a filter based on multiple tags, wrap the \`TagFilter\` elements in an \`And\` tag.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-replicationrulefilter.html#cfn-s3-bucket-replicationrulefilter-and
     */
    readonly and?: cdk.IResolvable | CfnBucket.ReplicationRuleAndOperatorProperty;

    /**
     * An object key name prefix that identifies the subset of objects to which the rule applies.
     *
     * > Replacement must be made for object keys containing special characters (such as carriage returns) when using XML requests. For more information, see [XML related object key constraints](https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html#object-key-xml-related-constraints) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-replicationrulefilter.html#cfn-s3-bucket-replicationrulefilter-prefix
     */
    readonly prefix?: string;

    /**
     * A container for specifying a tag key and value.
     *
     * The rule applies only to objects that have the tag in their tag set.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-replicationrulefilter.html#cfn-s3-bucket-replicationrulefilter-tagfilter
     */
    readonly tagFilter?: cdk.IResolvable | CfnBucket.TagFilterProperty;
  }

  /**
   * A container for specifying rule filters.
   *
   * The filters determine the subset of objects to which the rule applies. This element is required only if you specify more than one filter.
   *
   * For example:
   *
   * - If you specify both a \`Prefix\` and a \`TagFilter\` , wrap these filters in an \`And\` tag.
   * - If you specify a filter based on multiple tags, wrap the \`TagFilter\` elements in an \`And\` tag
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-replicationruleandoperator.html
   */
  export interface ReplicationRuleAndOperatorProperty {
    /**
     * An object key name prefix that identifies the subset of objects to which the rule applies.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-replicationruleandoperator.html#cfn-s3-bucket-replicationruleandoperator-prefix
     */
    readonly prefix?: string;

    /**
     * An array of tags containing key and value pairs.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-replicationruleandoperator.html#cfn-s3-bucket-replicationruleandoperator-tagfilters
     */
    readonly tagFilters?: Array<cdk.IResolvable | CfnBucket.TagFilterProperty> | cdk.IResolvable;
  }

  /**
   * A container that describes additional filters for identifying the source objects that you want to replicate.
   *
   * You can choose to enable or disable the replication of these objects.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-sourceselectioncriteria.html
   */
  export interface SourceSelectionCriteriaProperty {
    /**
     * A filter that you can specify for selection for modifications on replicas.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-sourceselectioncriteria.html#cfn-s3-bucket-sourceselectioncriteria-replicamodifications
     */
    readonly replicaModifications?: cdk.IResolvable | CfnBucket.ReplicaModificationsProperty;

    /**
     * A container for filter information for the selection of Amazon S3 objects encrypted with AWS KMS.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-sourceselectioncriteria.html#cfn-s3-bucket-sourceselectioncriteria-ssekmsencryptedobjects
     */
    readonly sseKmsEncryptedObjects?: cdk.IResolvable | CfnBucket.SseKmsEncryptedObjectsProperty;
  }

  /**
   * A filter that you can specify for selection for modifications on replicas.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-replicamodifications.html
   */
  export interface ReplicaModificationsProperty {
    /**
     * Specifies whether Amazon S3 replicates modifications on replicas.
     *
     * *Allowed values* : \`Enabled\` | \`Disabled\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-replicamodifications.html#cfn-s3-bucket-replicamodifications-status
     */
    readonly status: string;
  }

  /**
   * A container for filter information for the selection of S3 objects encrypted with AWS KMS.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-ssekmsencryptedobjects.html
   */
  export interface SseKmsEncryptedObjectsProperty {
    /**
     * Specifies whether Amazon S3 replicates objects created with server-side encryption using an AWS KMS key stored in AWS Key Management Service.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-ssekmsencryptedobjects.html#cfn-s3-bucket-ssekmsencryptedobjects-status
     */
    readonly status: string;
  }

  /**
   * Describes the versioning state of an Amazon S3 bucket.
   *
   * For more information, see [PUT Bucket versioning](https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTVersioningStatus.html) in the *Amazon S3 API Reference* .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-versioningconfiguration.html
   */
  export interface VersioningConfigurationProperty {
    /**
     * The versioning state of the bucket.
     *
     * @default - "Suspended"
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-versioningconfiguration.html#cfn-s3-bucket-versioningconfiguration-status
     */
    readonly status: string;
  }

  /**
   * Specifies website configuration parameters for an Amazon S3 bucket.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-websiteconfiguration.html
   */
  export interface WebsiteConfigurationProperty {
    /**
     * The name of the error document for the website.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-websiteconfiguration.html#cfn-s3-bucket-websiteconfiguration-errordocument
     */
    readonly errorDocument?: string;

    /**
     * The name of the index document for the website.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-websiteconfiguration.html#cfn-s3-bucket-websiteconfiguration-indexdocument
     */
    readonly indexDocument?: string;

    /**
     * The redirect behavior for every request to this bucket's website endpoint.
     *
     * > If you specify this property, you can't specify any other property.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-websiteconfiguration.html#cfn-s3-bucket-websiteconfiguration-redirectallrequeststo
     */
    readonly redirectAllRequestsTo?: cdk.IResolvable | CfnBucket.RedirectAllRequestsToProperty;

    /**
     * Rules that define when a redirect is applied and the redirect behavior.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-websiteconfiguration.html#cfn-s3-bucket-websiteconfiguration-routingrules
     */
    readonly routingRules?: Array<cdk.IResolvable | CfnBucket.RoutingRuleProperty> | cdk.IResolvable;
  }

  /**
   * Specifies the redirect behavior and when a redirect is applied.
   *
   * For more information about routing rules, see [Configuring advanced conditional redirects](https://docs.aws.amazon.com/AmazonS3/latest/dev/how-to-page-redirect.html#advanced-conditional-redirects) in the *Amazon S3 User Guide* .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-routingrule.html
   */
  export interface RoutingRuleProperty {
    /**
     * Container for redirect information.
     *
     * You can redirect requests to another host, to another page, or with another protocol. In the event of an error, you can specify a different error code to return.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-routingrule.html#cfn-s3-bucket-routingrule-redirectrule
     */
    readonly redirectRule: cdk.IResolvable | CfnBucket.RedirectRuleProperty;

    /**
     * A container for describing a condition that must be met for the specified redirect to apply.
     *
     * For example, 1. If request is for pages in the \`/docs\` folder, redirect to the \`/documents\` folder. 2. If request results in HTTP error 4xx, redirect request to another host where you might process the error.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-routingrule.html#cfn-s3-bucket-routingrule-routingrulecondition
     */
    readonly routingRuleCondition?: cdk.IResolvable | CfnBucket.RoutingRuleConditionProperty;
  }

  /**
   * Specifies how requests are redirected.
   *
   * In the event of an error, you can specify a different error code to return.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-redirectrule.html
   */
  export interface RedirectRuleProperty {
    /**
     * The host name to use in the redirect request.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-redirectrule.html#cfn-s3-bucket-redirectrule-hostname
     */
    readonly hostName?: string;

    /**
     * The HTTP redirect code to use on the response.
     *
     * Not required if one of the siblings is present.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-redirectrule.html#cfn-s3-bucket-redirectrule-httpredirectcode
     */
    readonly httpRedirectCode?: string;

    /**
     * Protocol to use when redirecting requests.
     *
     * The default is the protocol that is used in the original request.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-redirectrule.html#cfn-s3-bucket-redirectrule-protocol
     */
    readonly protocol?: string;

    /**
     * The object key prefix to use in the redirect request.
     *
     * For example, to redirect requests for all pages with prefix \`docs/\` (objects in the \`docs/\` folder) to \`documents/\` , you can set a condition block with \`KeyPrefixEquals\` set to \`docs/\` and in the Redirect set \`ReplaceKeyPrefixWith\` to \`/documents\` . Not required if one of the siblings is present. Can be present only if \`ReplaceKeyWith\` is not provided.
     *
     * > Replacement must be made for object keys containing special characters (such as carriage returns) when using XML requests. For more information, see [XML related object key constraints](https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html#object-key-xml-related-constraints) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-redirectrule.html#cfn-s3-bucket-redirectrule-replacekeyprefixwith
     */
    readonly replaceKeyPrefixWith?: string;

    /**
     * The specific object key to use in the redirect request.
     *
     * For example, redirect request to \`error.html\` . Not required if one of the siblings is present. Can be present only if \`ReplaceKeyPrefixWith\` is not provided.
     *
     * > Replacement must be made for object keys containing special characters (such as carriage returns) when using XML requests. For more information, see [XML related object key constraints](https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html#object-key-xml-related-constraints) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-redirectrule.html#cfn-s3-bucket-redirectrule-replacekeywith
     */
    readonly replaceKeyWith?: string;
  }

  /**
   * A container for describing a condition that must be met for the specified redirect to apply.
   *
   * For example, 1. If request is for pages in the \`/docs\` folder, redirect to the \`/documents\` folder. 2. If request results in HTTP error 4xx, redirect request to another host where you might process the error.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-routingrulecondition.html
   */
  export interface RoutingRuleConditionProperty {
    /**
     * The HTTP error code when the redirect is applied.
     *
     * In the event of an error, if the error code equals this value, then the specified redirect is applied.
     *
     * Required when parent element \`Condition\` is specified and sibling \`KeyPrefixEquals\` is not specified. If both are specified, then both must be true for the redirect to be applied.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-routingrulecondition.html#cfn-s3-bucket-routingrulecondition-httperrorcodereturnedequals
     */
    readonly httpErrorCodeReturnedEquals?: string;

    /**
     * The object key name prefix when the redirect is applied.
     *
     * For example, to redirect requests for \`ExamplePage.html\` , the key prefix will be \`ExamplePage.html\` . To redirect request for all pages with the prefix \`docs/\` , the key prefix will be \`/docs\` , which identifies all objects in the docs/ folder.
     *
     * Required when the parent element \`Condition\` is specified and sibling \`HttpErrorCodeReturnedEquals\` is not specified. If both conditions are specified, both must be true for the redirect to be applied.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-routingrulecondition.html#cfn-s3-bucket-routingrulecondition-keyprefixequals
     */
    readonly keyPrefixEquals?: string;
  }

  /**
   * Specifies the redirect behavior of all requests to a website endpoint of an Amazon S3 bucket.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-redirectallrequeststo.html
   */
  export interface RedirectAllRequestsToProperty {
    /**
     * Name of the host where requests are redirected.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-redirectallrequeststo.html#cfn-s3-bucket-redirectallrequeststo-hostname
     */
    readonly hostName: string;

    /**
     * Protocol to use when redirecting requests.
     *
     * The default is the protocol that is used in the original request.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-redirectallrequeststo.html#cfn-s3-bucket-redirectallrequeststo-protocol
     */
    readonly protocol?: string;
  }
}

/**
 * Properties for defining a \`CfnBucket\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-s3-bucket.html
 */
export interface CfnBucketProps {
  /**
   * Configures the transfer acceleration state for an Amazon S3 bucket.
   *
   * For more information, see [Amazon S3 Transfer Acceleration](https://docs.aws.amazon.com/AmazonS3/latest/dev/transfer-acceleration.html) in the *Amazon S3 User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-s3-bucket.html#cfn-s3-bucket-accelerateconfiguration
   */
  readonly accelerateConfiguration?: CfnBucket.AccelerateConfigurationProperty | cdk.IResolvable;

  /**
   * A canned access control list (ACL) that grants predefined permissions to the bucket.
   *
   * For more information about canned ACLs, see [Canned ACL](https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl) in the *Amazon S3 User Guide* .
   *
   * Be aware that the syntax for this property differs from the information provided in the *Amazon S3 User Guide* . The AccessControl property is case-sensitive and must be one of the following values: Private, PublicRead, PublicReadWrite, AuthenticatedRead, LogDeliveryWrite, BucketOwnerRead, BucketOwnerFullControl, or AwsExecRead.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-s3-bucket.html#cfn-s3-bucket-accesscontrol
   */
  readonly accessControl?: string;

  /**
   * Specifies the configuration and any analyses for the analytics filter of an Amazon S3 bucket.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-s3-bucket.html#cfn-s3-bucket-analyticsconfigurations
   */
  readonly analyticsConfigurations?: Array<CfnBucket.AnalyticsConfigurationProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * Specifies default encryption for a bucket using server-side encryption with Amazon S3-managed keys (SSE-S3), AWS KMS-managed keys (SSE-KMS), or dual-layer server-side encryption with KMS-managed keys (DSSE-KMS).
   *
   * For information about the Amazon S3 default encryption feature, see [Amazon S3 Default Encryption for S3 Buckets](https://docs.aws.amazon.com/AmazonS3/latest/dev/bucket-encryption.html) in the *Amazon S3 User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-s3-bucket.html#cfn-s3-bucket-bucketencryption
   */
  readonly bucketEncryption?: CfnBucket.BucketEncryptionProperty | cdk.IResolvable;

  /**
   * A name for the bucket.
   *
   * If you don't specify a name, AWS CloudFormation generates a unique ID and uses that ID for the bucket name. The bucket name must contain only lowercase letters, numbers, periods (.), and dashes (-) and must follow [Amazon S3 bucket restrictions and limitations](https://docs.aws.amazon.com/AmazonS3/latest/dev/BucketRestrictions.html) . For more information, see [Rules for naming Amazon S3 buckets](https://docs.aws.amazon.com/AmazonS3/latest/dev/BucketRestrictions.html#bucketnamingrules) in the *Amazon S3 User Guide* .
   *
   * > If you specify a name, you can't perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you need to replace the resource, specify a new name.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-s3-bucket.html#cfn-s3-bucket-bucketname
   */
  readonly bucketName?: string;

  /**
   * Describes the cross-origin access configuration for objects in an Amazon S3 bucket.
   *
   * For more information, see [Enabling Cross-Origin Resource Sharing](https://docs.aws.amazon.com/AmazonS3/latest/dev/cors.html) in the *Amazon S3 User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-s3-bucket.html#cfn-s3-bucket-corsconfiguration
   */
  readonly corsConfiguration?: CfnBucket.CorsConfigurationProperty | cdk.IResolvable;

  /**
   * Defines how Amazon S3 handles Intelligent-Tiering storage.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-s3-bucket.html#cfn-s3-bucket-intelligenttieringconfigurations
   */
  readonly intelligentTieringConfigurations?: Array<CfnBucket.IntelligentTieringConfigurationProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * Specifies the inventory configuration for an Amazon S3 bucket.
   *
   * For more information, see [GET Bucket inventory](https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketGETInventoryConfig.html) in the *Amazon S3 API Reference* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-s3-bucket.html#cfn-s3-bucket-inventoryconfigurations
   */
  readonly inventoryConfigurations?: Array<CfnBucket.InventoryConfigurationProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * Specifies the lifecycle configuration for objects in an Amazon S3 bucket.
   *
   * For more information, see [Object Lifecycle Management](https://docs.aws.amazon.com/AmazonS3/latest/dev/object-lifecycle-mgmt.html) in the *Amazon S3 User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-s3-bucket.html#cfn-s3-bucket-lifecycleconfiguration
   */
  readonly lifecycleConfiguration?: cdk.IResolvable | CfnBucket.LifecycleConfigurationProperty;

  /**
   * Settings that define where logs are stored.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-s3-bucket.html#cfn-s3-bucket-loggingconfiguration
   */
  readonly loggingConfiguration?: cdk.IResolvable | CfnBucket.LoggingConfigurationProperty;

  /**
   * Specifies a metrics configuration for the CloudWatch request metrics (specified by the metrics configuration ID) from an Amazon S3 bucket.
   *
   * If you're updating an existing metrics configuration, note that this is a full replacement of the existing metrics configuration. If you don't include the elements you want to keep, they are erased. For more information, see [PutBucketMetricsConfiguration](https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTMetricConfiguration.html) .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-s3-bucket.html#cfn-s3-bucket-metricsconfigurations
   */
  readonly metricsConfigurations?: Array<cdk.IResolvable | CfnBucket.MetricsConfigurationProperty> | cdk.IResolvable;

  /**
   * Configuration that defines how Amazon S3 handles bucket notifications.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-s3-bucket.html#cfn-s3-bucket-notificationconfiguration
   */
  readonly notificationConfiguration?: cdk.IResolvable | CfnBucket.NotificationConfigurationProperty;

  /**
   * Places an Object Lock configuration on the specified bucket.
   *
   * The rule specified in the Object Lock configuration will be applied by default to every new object placed in the specified bucket. For more information, see [Locking Objects](https://docs.aws.amazon.com/AmazonS3/latest/dev/object-lock.html) .
   *
   * > - The \`DefaultRetention\` settings require both a mode and a period.
   * > - The \`DefaultRetention\` period can be either \`Days\` or \`Years\` but you must select one. You cannot specify \`Days\` and \`Years\` at the same time.
   * > - You can only enable Object Lock for new buckets. If you want to turn on Object Lock for an existing bucket, contact AWS Support.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-s3-bucket.html#cfn-s3-bucket-objectlockconfiguration
   */
  readonly objectLockConfiguration?: cdk.IResolvable | CfnBucket.ObjectLockConfigurationProperty;

  /**
   * Indicates whether this bucket has an Object Lock configuration enabled.
   *
   * Enable \`ObjectLockEnabled\` when you apply \`ObjectLockConfiguration\` to a bucket.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-s3-bucket.html#cfn-s3-bucket-objectlockenabled
   */
  readonly objectLockEnabled?: boolean | cdk.IResolvable;

  /**
   * Configuration that defines how Amazon S3 handles Object Ownership rules.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-s3-bucket.html#cfn-s3-bucket-ownershipcontrols
   */
  readonly ownershipControls?: cdk.IResolvable | CfnBucket.OwnershipControlsProperty;

  /**
   * Configuration that defines how Amazon S3 handles public access.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-s3-bucket.html#cfn-s3-bucket-publicaccessblockconfiguration
   */
  readonly publicAccessBlockConfiguration?: cdk.IResolvable | CfnBucket.PublicAccessBlockConfigurationProperty;

  /**
   * Configuration for replicating objects in an S3 bucket.
   *
   * To enable replication, you must also enable versioning by using the \`VersioningConfiguration\` property.
   *
   * Amazon S3 can store replicated objects in a single destination bucket or multiple destination buckets. The destination bucket or buckets must already exist.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-s3-bucket.html#cfn-s3-bucket-replicationconfiguration
   */
  readonly replicationConfiguration?: cdk.IResolvable | CfnBucket.ReplicationConfigurationProperty;

  /**
   * An arbitrary set of tags (key-value pairs) for this S3 bucket.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-s3-bucket.html#cfn-s3-bucket-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * Enables multiple versions of all objects in this bucket.
   *
   * You might enable versioning to prevent objects from being deleted or overwritten by mistake or to archive objects so that you can retrieve previous versions of them.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-s3-bucket.html#cfn-s3-bucket-versioningconfiguration
   */
  readonly versioningConfiguration?: cdk.IResolvable | CfnBucket.VersioningConfigurationProperty;

  /**
   * Information used to configure the bucket as a static website.
   *
   * For more information, see [Hosting Websites on Amazon S3](https://docs.aws.amazon.com/AmazonS3/latest/dev/WebsiteHosting.html) .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-s3-bucket.html#cfn-s3-bucket-websiteconfiguration
   */
  readonly websiteConfiguration?: cdk.IResolvable | CfnBucket.WebsiteConfigurationProperty;
}

/**
 * Determine whether the given properties match those of a \`AccelerateConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`AccelerateConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnBucketAccelerateConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("accelerationStatus", cdk.requiredValidator)(properties.accelerationStatus));
  errors.collect(cdk.propertyValidator("accelerationStatus", cdk.validateString)(properties.accelerationStatus));
  return errors.wrap("supplied properties not correct for \\"AccelerateConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnBucketAccelerateConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnBucketAccelerateConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "AccelerationStatus": cdk.stringToCloudFormation(properties.accelerationStatus)
  };
}

// @ts-ignore TS6133
function CfnBucketAccelerateConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnBucket.AccelerateConfigurationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnBucket.AccelerateConfigurationProperty>();
  ret.addPropertyResult("accelerationStatus", "AccelerationStatus", (properties.AccelerationStatus != null ? cfn_parse.FromCloudFormation.getString(properties.AccelerationStatus) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`TagFilterProperty\`
 *
 * @param properties - the TypeScript properties of a \`TagFilterProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnBucketTagFilterPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("key", cdk.requiredValidator)(properties.key));
  errors.collect(cdk.propertyValidator("key", cdk.validateString)(properties.key));
  errors.collect(cdk.propertyValidator("value", cdk.requiredValidator)(properties.value));
  errors.collect(cdk.propertyValidator("value", cdk.validateString)(properties.value));
  return errors.wrap("supplied properties not correct for \\"TagFilterProperty\\"");
}

// @ts-ignore TS6133
function convertCfnBucketTagFilterPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnBucketTagFilterPropertyValidator(properties).assertSuccess();
  return {
    "Key": cdk.stringToCloudFormation(properties.key),
    "Value": cdk.stringToCloudFormation(properties.value)
  };
}

// @ts-ignore TS6133
function CfnBucketTagFilterPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnBucket.TagFilterProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnBucket.TagFilterProperty>();
  ret.addPropertyResult("key", "Key", (properties.Key != null ? cfn_parse.FromCloudFormation.getString(properties.Key) : undefined));
  ret.addPropertyResult("value", "Value", (properties.Value != null ? cfn_parse.FromCloudFormation.getString(properties.Value) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`DestinationProperty\`
 *
 * @param properties - the TypeScript properties of a \`DestinationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnBucketDestinationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("bucketAccountId", cdk.validateString)(properties.bucketAccountId));
  errors.collect(cdk.propertyValidator("bucketArn", cdk.requiredValidator)(properties.bucketArn));
  errors.collect(cdk.propertyValidator("bucketArn", cdk.validateString)(properties.bucketArn));
  errors.collect(cdk.propertyValidator("format", cdk.requiredValidator)(properties.format));
  errors.collect(cdk.propertyValidator("format", cdk.validateString)(properties.format));
  errors.collect(cdk.propertyValidator("prefix", cdk.validateString)(properties.prefix));
  return errors.wrap("supplied properties not correct for \\"DestinationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnBucketDestinationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnBucketDestinationPropertyValidator(properties).assertSuccess();
  return {
    "BucketAccountId": cdk.stringToCloudFormation(properties.bucketAccountId),
    "BucketArn": cdk.stringToCloudFormation(properties.bucketArn),
    "Format": cdk.stringToCloudFormation(properties.format),
    "Prefix": cdk.stringToCloudFormation(properties.prefix)
  };
}

// @ts-ignore TS6133
function CfnBucketDestinationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnBucket.DestinationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnBucket.DestinationProperty>();
  ret.addPropertyResult("bucketAccountId", "BucketAccountId", (properties.BucketAccountId != null ? cfn_parse.FromCloudFormation.getString(properties.BucketAccountId) : undefined));
  ret.addPropertyResult("bucketArn", "BucketArn", (properties.BucketArn != null ? cfn_parse.FromCloudFormation.getString(properties.BucketArn) : undefined));
  ret.addPropertyResult("format", "Format", (properties.Format != null ? cfn_parse.FromCloudFormation.getString(properties.Format) : undefined));
  ret.addPropertyResult("prefix", "Prefix", (properties.Prefix != null ? cfn_parse.FromCloudFormation.getString(properties.Prefix) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`DataExportProperty\`
 *
 * @param properties - the TypeScript properties of a \`DataExportProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnBucketDataExportPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("destination", cdk.requiredValidator)(properties.destination));
  errors.collect(cdk.propertyValidator("destination", CfnBucketDestinationPropertyValidator)(properties.destination));
  errors.collect(cdk.propertyValidator("outputSchemaVersion", cdk.requiredValidator)(properties.outputSchemaVersion));
  errors.collect(cdk.propertyValidator("outputSchemaVersion", cdk.validateString)(properties.outputSchemaVersion));
  return errors.wrap("supplied properties not correct for \\"DataExportProperty\\"");
}

// @ts-ignore TS6133
function convertCfnBucketDataExportPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnBucketDataExportPropertyValidator(properties).assertSuccess();
  return {
    "Destination": convertCfnBucketDestinationPropertyToCloudFormation(properties.destination),
    "OutputSchemaVersion": cdk.stringToCloudFormation(properties.outputSchemaVersion)
  };
}

// @ts-ignore TS6133
function CfnBucketDataExportPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnBucket.DataExportProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnBucket.DataExportProperty>();
  ret.addPropertyResult("destination", "Destination", (properties.Destination != null ? CfnBucketDestinationPropertyFromCloudFormation(properties.Destination) : undefined));
  ret.addPropertyResult("outputSchemaVersion", "OutputSchemaVersion", (properties.OutputSchemaVersion != null ? cfn_parse.FromCloudFormation.getString(properties.OutputSchemaVersion) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`StorageClassAnalysisProperty\`
 *
 * @param properties - the TypeScript properties of a \`StorageClassAnalysisProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnBucketStorageClassAnalysisPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("dataExport", CfnBucketDataExportPropertyValidator)(properties.dataExport));
  return errors.wrap("supplied properties not correct for \\"StorageClassAnalysisProperty\\"");
}

// @ts-ignore TS6133
function convertCfnBucketStorageClassAnalysisPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnBucketStorageClassAnalysisPropertyValidator(properties).assertSuccess();
  return {
    "DataExport": convertCfnBucketDataExportPropertyToCloudFormation(properties.dataExport)
  };
}

// @ts-ignore TS6133
function CfnBucketStorageClassAnalysisPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnBucket.StorageClassAnalysisProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnBucket.StorageClassAnalysisProperty>();
  ret.addPropertyResult("dataExport", "DataExport", (properties.DataExport != null ? CfnBucketDataExportPropertyFromCloudFormation(properties.DataExport) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`AnalyticsConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`AnalyticsConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnBucketAnalyticsConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("id", cdk.requiredValidator)(properties.id));
  errors.collect(cdk.propertyValidator("id", cdk.validateString)(properties.id));
  errors.collect(cdk.propertyValidator("prefix", cdk.validateString)(properties.prefix));
  errors.collect(cdk.propertyValidator("storageClassAnalysis", cdk.requiredValidator)(properties.storageClassAnalysis));
  errors.collect(cdk.propertyValidator("storageClassAnalysis", CfnBucketStorageClassAnalysisPropertyValidator)(properties.storageClassAnalysis));
  errors.collect(cdk.propertyValidator("tagFilters", cdk.listValidator(CfnBucketTagFilterPropertyValidator))(properties.tagFilters));
  return errors.wrap("supplied properties not correct for \\"AnalyticsConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnBucketAnalyticsConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnBucketAnalyticsConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "Id": cdk.stringToCloudFormation(properties.id),
    "Prefix": cdk.stringToCloudFormation(properties.prefix),
    "StorageClassAnalysis": convertCfnBucketStorageClassAnalysisPropertyToCloudFormation(properties.storageClassAnalysis),
    "TagFilters": cdk.listMapper(convertCfnBucketTagFilterPropertyToCloudFormation)(properties.tagFilters)
  };
}

// @ts-ignore TS6133
function CfnBucketAnalyticsConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnBucket.AnalyticsConfigurationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnBucket.AnalyticsConfigurationProperty>();
  ret.addPropertyResult("id", "Id", (properties.Id != null ? cfn_parse.FromCloudFormation.getString(properties.Id) : undefined));
  ret.addPropertyResult("prefix", "Prefix", (properties.Prefix != null ? cfn_parse.FromCloudFormation.getString(properties.Prefix) : undefined));
  ret.addPropertyResult("storageClassAnalysis", "StorageClassAnalysis", (properties.StorageClassAnalysis != null ? CfnBucketStorageClassAnalysisPropertyFromCloudFormation(properties.StorageClassAnalysis) : undefined));
  ret.addPropertyResult("tagFilters", "TagFilters", (properties.TagFilters != null ? cfn_parse.FromCloudFormation.getArray(CfnBucketTagFilterPropertyFromCloudFormation)(properties.TagFilters) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ServerSideEncryptionByDefaultProperty\`
 *
 * @param properties - the TypeScript properties of a \`ServerSideEncryptionByDefaultProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnBucketServerSideEncryptionByDefaultPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("kmsMasterKeyId", cdk.validateString)(properties.kmsMasterKeyId));
  errors.collect(cdk.propertyValidator("sseAlgorithm", cdk.requiredValidator)(properties.sseAlgorithm));
  errors.collect(cdk.propertyValidator("sseAlgorithm", cdk.validateString)(properties.sseAlgorithm));
  return errors.wrap("supplied properties not correct for \\"ServerSideEncryptionByDefaultProperty\\"");
}

// @ts-ignore TS6133
function convertCfnBucketServerSideEncryptionByDefaultPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnBucketServerSideEncryptionByDefaultPropertyValidator(properties).assertSuccess();
  return {
    "KMSMasterKeyID": cdk.stringToCloudFormation(properties.kmsMasterKeyId),
    "SSEAlgorithm": cdk.stringToCloudFormation(properties.sseAlgorithm)
  };
}

// @ts-ignore TS6133
function CfnBucketServerSideEncryptionByDefaultPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnBucket.ServerSideEncryptionByDefaultProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnBucket.ServerSideEncryptionByDefaultProperty>();
  ret.addPropertyResult("kmsMasterKeyId", "KMSMasterKeyID", (properties.KMSMasterKeyID != null ? cfn_parse.FromCloudFormation.getString(properties.KMSMasterKeyID) : undefined));
  ret.addPropertyResult("sseAlgorithm", "SSEAlgorithm", (properties.SSEAlgorithm != null ? cfn_parse.FromCloudFormation.getString(properties.SSEAlgorithm) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ServerSideEncryptionRuleProperty\`
 *
 * @param properties - the TypeScript properties of a \`ServerSideEncryptionRuleProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnBucketServerSideEncryptionRulePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("bucketKeyEnabled", cdk.validateBoolean)(properties.bucketKeyEnabled));
  errors.collect(cdk.propertyValidator("serverSideEncryptionByDefault", CfnBucketServerSideEncryptionByDefaultPropertyValidator)(properties.serverSideEncryptionByDefault));
  return errors.wrap("supplied properties not correct for \\"ServerSideEncryptionRuleProperty\\"");
}

// @ts-ignore TS6133
function convertCfnBucketServerSideEncryptionRulePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnBucketServerSideEncryptionRulePropertyValidator(properties).assertSuccess();
  return {
    "BucketKeyEnabled": cdk.booleanToCloudFormation(properties.bucketKeyEnabled),
    "ServerSideEncryptionByDefault": convertCfnBucketServerSideEncryptionByDefaultPropertyToCloudFormation(properties.serverSideEncryptionByDefault)
  };
}

// @ts-ignore TS6133
function CfnBucketServerSideEncryptionRulePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnBucket.ServerSideEncryptionRuleProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnBucket.ServerSideEncryptionRuleProperty>();
  ret.addPropertyResult("bucketKeyEnabled", "BucketKeyEnabled", (properties.BucketKeyEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.BucketKeyEnabled) : undefined));
  ret.addPropertyResult("serverSideEncryptionByDefault", "ServerSideEncryptionByDefault", (properties.ServerSideEncryptionByDefault != null ? CfnBucketServerSideEncryptionByDefaultPropertyFromCloudFormation(properties.ServerSideEncryptionByDefault) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`BucketEncryptionProperty\`
 *
 * @param properties - the TypeScript properties of a \`BucketEncryptionProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnBucketBucketEncryptionPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("serverSideEncryptionConfiguration", cdk.requiredValidator)(properties.serverSideEncryptionConfiguration));
  errors.collect(cdk.propertyValidator("serverSideEncryptionConfiguration", cdk.listValidator(CfnBucketServerSideEncryptionRulePropertyValidator))(properties.serverSideEncryptionConfiguration));
  return errors.wrap("supplied properties not correct for \\"BucketEncryptionProperty\\"");
}

// @ts-ignore TS6133
function convertCfnBucketBucketEncryptionPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnBucketBucketEncryptionPropertyValidator(properties).assertSuccess();
  return {
    "ServerSideEncryptionConfiguration": cdk.listMapper(convertCfnBucketServerSideEncryptionRulePropertyToCloudFormation)(properties.serverSideEncryptionConfiguration)
  };
}

// @ts-ignore TS6133
function CfnBucketBucketEncryptionPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnBucket.BucketEncryptionProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnBucket.BucketEncryptionProperty>();
  ret.addPropertyResult("serverSideEncryptionConfiguration", "ServerSideEncryptionConfiguration", (properties.ServerSideEncryptionConfiguration != null ? cfn_parse.FromCloudFormation.getArray(CfnBucketServerSideEncryptionRulePropertyFromCloudFormation)(properties.ServerSideEncryptionConfiguration) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CorsRuleProperty\`
 *
 * @param properties - the TypeScript properties of a \`CorsRuleProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnBucketCorsRulePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("allowedHeaders", cdk.listValidator(cdk.validateString))(properties.allowedHeaders));
  errors.collect(cdk.propertyValidator("allowedMethods", cdk.requiredValidator)(properties.allowedMethods));
  errors.collect(cdk.propertyValidator("allowedMethods", cdk.listValidator(cdk.validateString))(properties.allowedMethods));
  errors.collect(cdk.propertyValidator("allowedOrigins", cdk.requiredValidator)(properties.allowedOrigins));
  errors.collect(cdk.propertyValidator("allowedOrigins", cdk.listValidator(cdk.validateString))(properties.allowedOrigins));
  errors.collect(cdk.propertyValidator("exposedHeaders", cdk.listValidator(cdk.validateString))(properties.exposedHeaders));
  errors.collect(cdk.propertyValidator("id", cdk.validateString)(properties.id));
  errors.collect(cdk.propertyValidator("maxAge", cdk.validateNumber)(properties.maxAge));
  return errors.wrap("supplied properties not correct for \\"CorsRuleProperty\\"");
}

// @ts-ignore TS6133
function convertCfnBucketCorsRulePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnBucketCorsRulePropertyValidator(properties).assertSuccess();
  return {
    "AllowedHeaders": cdk.listMapper(cdk.stringToCloudFormation)(properties.allowedHeaders),
    "AllowedMethods": cdk.listMapper(cdk.stringToCloudFormation)(properties.allowedMethods),
    "AllowedOrigins": cdk.listMapper(cdk.stringToCloudFormation)(properties.allowedOrigins),
    "ExposedHeaders": cdk.listMapper(cdk.stringToCloudFormation)(properties.exposedHeaders),
    "Id": cdk.stringToCloudFormation(properties.id),
    "MaxAge": cdk.numberToCloudFormation(properties.maxAge)
  };
}

// @ts-ignore TS6133
function CfnBucketCorsRulePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnBucket.CorsRuleProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnBucket.CorsRuleProperty>();
  ret.addPropertyResult("allowedHeaders", "AllowedHeaders", (properties.AllowedHeaders != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.AllowedHeaders) : undefined));
  ret.addPropertyResult("allowedMethods", "AllowedMethods", (properties.AllowedMethods != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.AllowedMethods) : undefined));
  ret.addPropertyResult("allowedOrigins", "AllowedOrigins", (properties.AllowedOrigins != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.AllowedOrigins) : undefined));
  ret.addPropertyResult("exposedHeaders", "ExposedHeaders", (properties.ExposedHeaders != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.ExposedHeaders) : undefined));
  ret.addPropertyResult("id", "Id", (properties.Id != null ? cfn_parse.FromCloudFormation.getString(properties.Id) : undefined));
  ret.addPropertyResult("maxAge", "MaxAge", (properties.MaxAge != null ? cfn_parse.FromCloudFormation.getNumber(properties.MaxAge) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CorsConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`CorsConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnBucketCorsConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("corsRules", cdk.requiredValidator)(properties.corsRules));
  errors.collect(cdk.propertyValidator("corsRules", cdk.listValidator(CfnBucketCorsRulePropertyValidator))(properties.corsRules));
  return errors.wrap("supplied properties not correct for \\"CorsConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnBucketCorsConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnBucketCorsConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "CorsRules": cdk.listMapper(convertCfnBucketCorsRulePropertyToCloudFormation)(properties.corsRules)
  };
}

// @ts-ignore TS6133
function CfnBucketCorsConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnBucket.CorsConfigurationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnBucket.CorsConfigurationProperty>();
  ret.addPropertyResult("corsRules", "CorsRules", (properties.CorsRules != null ? cfn_parse.FromCloudFormation.getArray(CfnBucketCorsRulePropertyFromCloudFormation)(properties.CorsRules) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`TieringProperty\`
 *
 * @param properties - the TypeScript properties of a \`TieringProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnBucketTieringPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("accessTier", cdk.requiredValidator)(properties.accessTier));
  errors.collect(cdk.propertyValidator("accessTier", cdk.validateString)(properties.accessTier));
  errors.collect(cdk.propertyValidator("days", cdk.requiredValidator)(properties.days));
  errors.collect(cdk.propertyValidator("days", cdk.validateNumber)(properties.days));
  return errors.wrap("supplied properties not correct for \\"TieringProperty\\"");
}

// @ts-ignore TS6133
function convertCfnBucketTieringPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnBucketTieringPropertyValidator(properties).assertSuccess();
  return {
    "AccessTier": cdk.stringToCloudFormation(properties.accessTier),
    "Days": cdk.numberToCloudFormation(properties.days)
  };
}

// @ts-ignore TS6133
function CfnBucketTieringPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnBucket.TieringProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnBucket.TieringProperty>();
  ret.addPropertyResult("accessTier", "AccessTier", (properties.AccessTier != null ? cfn_parse.FromCloudFormation.getString(properties.AccessTier) : undefined));
  ret.addPropertyResult("days", "Days", (properties.Days != null ? cfn_parse.FromCloudFormation.getNumber(properties.Days) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`IntelligentTieringConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`IntelligentTieringConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnBucketIntelligentTieringConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("id", cdk.requiredValidator)(properties.id));
  errors.collect(cdk.propertyValidator("id", cdk.validateString)(properties.id));
  errors.collect(cdk.propertyValidator("prefix", cdk.validateString)(properties.prefix));
  errors.collect(cdk.propertyValidator("status", cdk.requiredValidator)(properties.status));
  errors.collect(cdk.propertyValidator("status", cdk.validateString)(properties.status));
  errors.collect(cdk.propertyValidator("tagFilters", cdk.listValidator(CfnBucketTagFilterPropertyValidator))(properties.tagFilters));
  errors.collect(cdk.propertyValidator("tierings", cdk.requiredValidator)(properties.tierings));
  errors.collect(cdk.propertyValidator("tierings", cdk.listValidator(CfnBucketTieringPropertyValidator))(properties.tierings));
  return errors.wrap("supplied properties not correct for \\"IntelligentTieringConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnBucketIntelligentTieringConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnBucketIntelligentTieringConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "Id": cdk.stringToCloudFormation(properties.id),
    "Prefix": cdk.stringToCloudFormation(properties.prefix),
    "Status": cdk.stringToCloudFormation(properties.status),
    "TagFilters": cdk.listMapper(convertCfnBucketTagFilterPropertyToCloudFormation)(properties.tagFilters),
    "Tierings": cdk.listMapper(convertCfnBucketTieringPropertyToCloudFormation)(properties.tierings)
  };
}

// @ts-ignore TS6133
function CfnBucketIntelligentTieringConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnBucket.IntelligentTieringConfigurationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnBucket.IntelligentTieringConfigurationProperty>();
  ret.addPropertyResult("id", "Id", (properties.Id != null ? cfn_parse.FromCloudFormation.getString(properties.Id) : undefined));
  ret.addPropertyResult("prefix", "Prefix", (properties.Prefix != null ? cfn_parse.FromCloudFormation.getString(properties.Prefix) : undefined));
  ret.addPropertyResult("status", "Status", (properties.Status != null ? cfn_parse.FromCloudFormation.getString(properties.Status) : undefined));
  ret.addPropertyResult("tagFilters", "TagFilters", (properties.TagFilters != null ? cfn_parse.FromCloudFormation.getArray(CfnBucketTagFilterPropertyFromCloudFormation)(properties.TagFilters) : undefined));
  ret.addPropertyResult("tierings", "Tierings", (properties.Tierings != null ? cfn_parse.FromCloudFormation.getArray(CfnBucketTieringPropertyFromCloudFormation)(properties.Tierings) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`InventoryConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`InventoryConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnBucketInventoryConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("destination", cdk.requiredValidator)(properties.destination));
  errors.collect(cdk.propertyValidator("destination", CfnBucketDestinationPropertyValidator)(properties.destination));
  errors.collect(cdk.propertyValidator("enabled", cdk.requiredValidator)(properties.enabled));
  errors.collect(cdk.propertyValidator("enabled", cdk.validateBoolean)(properties.enabled));
  errors.collect(cdk.propertyValidator("id", cdk.requiredValidator)(properties.id));
  errors.collect(cdk.propertyValidator("id", cdk.validateString)(properties.id));
  errors.collect(cdk.propertyValidator("includedObjectVersions", cdk.requiredValidator)(properties.includedObjectVersions));
  errors.collect(cdk.propertyValidator("includedObjectVersions", cdk.validateString)(properties.includedObjectVersions));
  errors.collect(cdk.propertyValidator("optionalFields", cdk.listValidator(cdk.validateString))(properties.optionalFields));
  errors.collect(cdk.propertyValidator("prefix", cdk.validateString)(properties.prefix));
  errors.collect(cdk.propertyValidator("scheduleFrequency", cdk.requiredValidator)(properties.scheduleFrequency));
  errors.collect(cdk.propertyValidator("scheduleFrequency", cdk.validateString)(properties.scheduleFrequency));
  return errors.wrap("supplied properties not correct for \\"InventoryConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnBucketInventoryConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnBucketInventoryConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "Destination": convertCfnBucketDestinationPropertyToCloudFormation(properties.destination),
    "Enabled": cdk.booleanToCloudFormation(properties.enabled),
    "Id": cdk.stringToCloudFormation(properties.id),
    "IncludedObjectVersions": cdk.stringToCloudFormation(properties.includedObjectVersions),
    "OptionalFields": cdk.listMapper(cdk.stringToCloudFormation)(properties.optionalFields),
    "Prefix": cdk.stringToCloudFormation(properties.prefix),
    "ScheduleFrequency": cdk.stringToCloudFormation(properties.scheduleFrequency)
  };
}

// @ts-ignore TS6133
function CfnBucketInventoryConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnBucket.InventoryConfigurationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnBucket.InventoryConfigurationProperty>();
  ret.addPropertyResult("destination", "Destination", (properties.Destination != null ? CfnBucketDestinationPropertyFromCloudFormation(properties.Destination) : undefined));
  ret.addPropertyResult("enabled", "Enabled", (properties.Enabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Enabled) : undefined));
  ret.addPropertyResult("id", "Id", (properties.Id != null ? cfn_parse.FromCloudFormation.getString(properties.Id) : undefined));
  ret.addPropertyResult("includedObjectVersions", "IncludedObjectVersions", (properties.IncludedObjectVersions != null ? cfn_parse.FromCloudFormation.getString(properties.IncludedObjectVersions) : undefined));
  ret.addPropertyResult("optionalFields", "OptionalFields", (properties.OptionalFields != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.OptionalFields) : undefined));
  ret.addPropertyResult("prefix", "Prefix", (properties.Prefix != null ? cfn_parse.FromCloudFormation.getString(properties.Prefix) : undefined));
  ret.addPropertyResult("scheduleFrequency", "ScheduleFrequency", (properties.ScheduleFrequency != null ? cfn_parse.FromCloudFormation.getString(properties.ScheduleFrequency) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`AbortIncompleteMultipartUploadProperty\`
 *
 * @param properties - the TypeScript properties of a \`AbortIncompleteMultipartUploadProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnBucketAbortIncompleteMultipartUploadPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("daysAfterInitiation", cdk.requiredValidator)(properties.daysAfterInitiation));
  errors.collect(cdk.propertyValidator("daysAfterInitiation", cdk.validateNumber)(properties.daysAfterInitiation));
  return errors.wrap("supplied properties not correct for \\"AbortIncompleteMultipartUploadProperty\\"");
}

// @ts-ignore TS6133
function convertCfnBucketAbortIncompleteMultipartUploadPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnBucketAbortIncompleteMultipartUploadPropertyValidator(properties).assertSuccess();
  return {
    "DaysAfterInitiation": cdk.numberToCloudFormation(properties.daysAfterInitiation)
  };
}

// @ts-ignore TS6133
function CfnBucketAbortIncompleteMultipartUploadPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnBucket.AbortIncompleteMultipartUploadProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnBucket.AbortIncompleteMultipartUploadProperty>();
  ret.addPropertyResult("daysAfterInitiation", "DaysAfterInitiation", (properties.DaysAfterInitiation != null ? cfn_parse.FromCloudFormation.getNumber(properties.DaysAfterInitiation) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`NoncurrentVersionExpirationProperty\`
 *
 * @param properties - the TypeScript properties of a \`NoncurrentVersionExpirationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnBucketNoncurrentVersionExpirationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("newerNoncurrentVersions", cdk.validateNumber)(properties.newerNoncurrentVersions));
  errors.collect(cdk.propertyValidator("noncurrentDays", cdk.requiredValidator)(properties.noncurrentDays));
  errors.collect(cdk.propertyValidator("noncurrentDays", cdk.validateNumber)(properties.noncurrentDays));
  return errors.wrap("supplied properties not correct for \\"NoncurrentVersionExpirationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnBucketNoncurrentVersionExpirationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnBucketNoncurrentVersionExpirationPropertyValidator(properties).assertSuccess();
  return {
    "NewerNoncurrentVersions": cdk.numberToCloudFormation(properties.newerNoncurrentVersions),
    "NoncurrentDays": cdk.numberToCloudFormation(properties.noncurrentDays)
  };
}

// @ts-ignore TS6133
function CfnBucketNoncurrentVersionExpirationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnBucket.NoncurrentVersionExpirationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnBucket.NoncurrentVersionExpirationProperty>();
  ret.addPropertyResult("newerNoncurrentVersions", "NewerNoncurrentVersions", (properties.NewerNoncurrentVersions != null ? cfn_parse.FromCloudFormation.getNumber(properties.NewerNoncurrentVersions) : undefined));
  ret.addPropertyResult("noncurrentDays", "NoncurrentDays", (properties.NoncurrentDays != null ? cfn_parse.FromCloudFormation.getNumber(properties.NoncurrentDays) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`NoncurrentVersionTransitionProperty\`
 *
 * @param properties - the TypeScript properties of a \`NoncurrentVersionTransitionProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnBucketNoncurrentVersionTransitionPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("newerNoncurrentVersions", cdk.validateNumber)(properties.newerNoncurrentVersions));
  errors.collect(cdk.propertyValidator("storageClass", cdk.requiredValidator)(properties.storageClass));
  errors.collect(cdk.propertyValidator("storageClass", cdk.validateString)(properties.storageClass));
  errors.collect(cdk.propertyValidator("transitionInDays", cdk.requiredValidator)(properties.transitionInDays));
  errors.collect(cdk.propertyValidator("transitionInDays", cdk.validateNumber)(properties.transitionInDays));
  return errors.wrap("supplied properties not correct for \\"NoncurrentVersionTransitionProperty\\"");
}

// @ts-ignore TS6133
function convertCfnBucketNoncurrentVersionTransitionPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnBucketNoncurrentVersionTransitionPropertyValidator(properties).assertSuccess();
  return {
    "NewerNoncurrentVersions": cdk.numberToCloudFormation(properties.newerNoncurrentVersions),
    "StorageClass": cdk.stringToCloudFormation(properties.storageClass),
    "TransitionInDays": cdk.numberToCloudFormation(properties.transitionInDays)
  };
}

// @ts-ignore TS6133
function CfnBucketNoncurrentVersionTransitionPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnBucket.NoncurrentVersionTransitionProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnBucket.NoncurrentVersionTransitionProperty>();
  ret.addPropertyResult("newerNoncurrentVersions", "NewerNoncurrentVersions", (properties.NewerNoncurrentVersions != null ? cfn_parse.FromCloudFormation.getNumber(properties.NewerNoncurrentVersions) : undefined));
  ret.addPropertyResult("storageClass", "StorageClass", (properties.StorageClass != null ? cfn_parse.FromCloudFormation.getString(properties.StorageClass) : undefined));
  ret.addPropertyResult("transitionInDays", "TransitionInDays", (properties.TransitionInDays != null ? cfn_parse.FromCloudFormation.getNumber(properties.TransitionInDays) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`TransitionProperty\`
 *
 * @param properties - the TypeScript properties of a \`TransitionProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnBucketTransitionPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("storageClass", cdk.requiredValidator)(properties.storageClass));
  errors.collect(cdk.propertyValidator("storageClass", cdk.validateString)(properties.storageClass));
  errors.collect(cdk.propertyValidator("transitionDate", cdk.validateDate)(properties.transitionDate));
  errors.collect(cdk.propertyValidator("transitionInDays", cdk.validateNumber)(properties.transitionInDays));
  return errors.wrap("supplied properties not correct for \\"TransitionProperty\\"");
}

// @ts-ignore TS6133
function convertCfnBucketTransitionPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnBucketTransitionPropertyValidator(properties).assertSuccess();
  return {
    "StorageClass": cdk.stringToCloudFormation(properties.storageClass),
    "TransitionDate": cdk.dateToCloudFormation(properties.transitionDate),
    "TransitionInDays": cdk.numberToCloudFormation(properties.transitionInDays)
  };
}

// @ts-ignore TS6133
function CfnBucketTransitionPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnBucket.TransitionProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnBucket.TransitionProperty>();
  ret.addPropertyResult("storageClass", "StorageClass", (properties.StorageClass != null ? cfn_parse.FromCloudFormation.getString(properties.StorageClass) : undefined));
  ret.addPropertyResult("transitionDate", "TransitionDate", (properties.TransitionDate != null ? cfn_parse.FromCloudFormation.getDate(properties.TransitionDate) : undefined));
  ret.addPropertyResult("transitionInDays", "TransitionInDays", (properties.TransitionInDays != null ? cfn_parse.FromCloudFormation.getNumber(properties.TransitionInDays) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`RuleProperty\`
 *
 * @param properties - the TypeScript properties of a \`RuleProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnBucketRulePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("abortIncompleteMultipartUpload", CfnBucketAbortIncompleteMultipartUploadPropertyValidator)(properties.abortIncompleteMultipartUpload));
  errors.collect(cdk.propertyValidator("expirationDate", cdk.validateDate)(properties.expirationDate));
  errors.collect(cdk.propertyValidator("expirationInDays", cdk.validateNumber)(properties.expirationInDays));
  errors.collect(cdk.propertyValidator("expiredObjectDeleteMarker", cdk.validateBoolean)(properties.expiredObjectDeleteMarker));
  errors.collect(cdk.propertyValidator("id", cdk.validateString)(properties.id));
  errors.collect(cdk.propertyValidator("noncurrentVersionExpiration", CfnBucketNoncurrentVersionExpirationPropertyValidator)(properties.noncurrentVersionExpiration));
  errors.collect(cdk.propertyValidator("noncurrentVersionExpirationInDays", cdk.validateNumber)(properties.noncurrentVersionExpirationInDays));
  errors.collect(cdk.propertyValidator("noncurrentVersionTransition", CfnBucketNoncurrentVersionTransitionPropertyValidator)(properties.noncurrentVersionTransition));
  errors.collect(cdk.propertyValidator("noncurrentVersionTransitions", cdk.listValidator(CfnBucketNoncurrentVersionTransitionPropertyValidator))(properties.noncurrentVersionTransitions));
  errors.collect(cdk.propertyValidator("objectSizeGreaterThan", cdk.validateNumber)(properties.objectSizeGreaterThan));
  errors.collect(cdk.propertyValidator("objectSizeLessThan", cdk.validateNumber)(properties.objectSizeLessThan));
  errors.collect(cdk.propertyValidator("prefix", cdk.validateString)(properties.prefix));
  errors.collect(cdk.propertyValidator("status", cdk.requiredValidator)(properties.status));
  errors.collect(cdk.propertyValidator("status", cdk.validateString)(properties.status));
  errors.collect(cdk.propertyValidator("tagFilters", cdk.listValidator(CfnBucketTagFilterPropertyValidator))(properties.tagFilters));
  errors.collect(cdk.propertyValidator("transition", CfnBucketTransitionPropertyValidator)(properties.transition));
  errors.collect(cdk.propertyValidator("transitions", cdk.listValidator(CfnBucketTransitionPropertyValidator))(properties.transitions));
  return errors.wrap("supplied properties not correct for \\"RuleProperty\\"");
}

// @ts-ignore TS6133
function convertCfnBucketRulePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnBucketRulePropertyValidator(properties).assertSuccess();
  return {
    "AbortIncompleteMultipartUpload": convertCfnBucketAbortIncompleteMultipartUploadPropertyToCloudFormation(properties.abortIncompleteMultipartUpload),
    "ExpirationDate": cdk.dateToCloudFormation(properties.expirationDate),
    "ExpirationInDays": cdk.numberToCloudFormation(properties.expirationInDays),
    "ExpiredObjectDeleteMarker": cdk.booleanToCloudFormation(properties.expiredObjectDeleteMarker),
    "Id": cdk.stringToCloudFormation(properties.id),
    "NoncurrentVersionExpiration": convertCfnBucketNoncurrentVersionExpirationPropertyToCloudFormation(properties.noncurrentVersionExpiration),
    "NoncurrentVersionExpirationInDays": cdk.numberToCloudFormation(properties.noncurrentVersionExpirationInDays),
    "NoncurrentVersionTransition": convertCfnBucketNoncurrentVersionTransitionPropertyToCloudFormation(properties.noncurrentVersionTransition),
    "NoncurrentVersionTransitions": cdk.listMapper(convertCfnBucketNoncurrentVersionTransitionPropertyToCloudFormation)(properties.noncurrentVersionTransitions),
    "ObjectSizeGreaterThan": cdk.numberToCloudFormation(properties.objectSizeGreaterThan),
    "ObjectSizeLessThan": cdk.numberToCloudFormation(properties.objectSizeLessThan),
    "Prefix": cdk.stringToCloudFormation(properties.prefix),
    "Status": cdk.stringToCloudFormation(properties.status),
    "TagFilters": cdk.listMapper(convertCfnBucketTagFilterPropertyToCloudFormation)(properties.tagFilters),
    "Transition": convertCfnBucketTransitionPropertyToCloudFormation(properties.transition),
    "Transitions": cdk.listMapper(convertCfnBucketTransitionPropertyToCloudFormation)(properties.transitions)
  };
}

// @ts-ignore TS6133
function CfnBucketRulePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnBucket.RuleProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnBucket.RuleProperty>();
  ret.addPropertyResult("abortIncompleteMultipartUpload", "AbortIncompleteMultipartUpload", (properties.AbortIncompleteMultipartUpload != null ? CfnBucketAbortIncompleteMultipartUploadPropertyFromCloudFormation(properties.AbortIncompleteMultipartUpload) : undefined));
  ret.addPropertyResult("expirationDate", "ExpirationDate", (properties.ExpirationDate != null ? cfn_parse.FromCloudFormation.getDate(properties.ExpirationDate) : undefined));
  ret.addPropertyResult("expirationInDays", "ExpirationInDays", (properties.ExpirationInDays != null ? cfn_parse.FromCloudFormation.getNumber(properties.ExpirationInDays) : undefined));
  ret.addPropertyResult("expiredObjectDeleteMarker", "ExpiredObjectDeleteMarker", (properties.ExpiredObjectDeleteMarker != null ? cfn_parse.FromCloudFormation.getBoolean(properties.ExpiredObjectDeleteMarker) : undefined));
  ret.addPropertyResult("id", "Id", (properties.Id != null ? cfn_parse.FromCloudFormation.getString(properties.Id) : undefined));
  ret.addPropertyResult("noncurrentVersionExpiration", "NoncurrentVersionExpiration", (properties.NoncurrentVersionExpiration != null ? CfnBucketNoncurrentVersionExpirationPropertyFromCloudFormation(properties.NoncurrentVersionExpiration) : undefined));
  ret.addPropertyResult("noncurrentVersionExpirationInDays", "NoncurrentVersionExpirationInDays", (properties.NoncurrentVersionExpirationInDays != null ? cfn_parse.FromCloudFormation.getNumber(properties.NoncurrentVersionExpirationInDays) : undefined));
  ret.addPropertyResult("noncurrentVersionTransition", "NoncurrentVersionTransition", (properties.NoncurrentVersionTransition != null ? CfnBucketNoncurrentVersionTransitionPropertyFromCloudFormation(properties.NoncurrentVersionTransition) : undefined));
  ret.addPropertyResult("noncurrentVersionTransitions", "NoncurrentVersionTransitions", (properties.NoncurrentVersionTransitions != null ? cfn_parse.FromCloudFormation.getArray(CfnBucketNoncurrentVersionTransitionPropertyFromCloudFormation)(properties.NoncurrentVersionTransitions) : undefined));
  ret.addPropertyResult("objectSizeGreaterThan", "ObjectSizeGreaterThan", (properties.ObjectSizeGreaterThan != null ? cfn_parse.FromCloudFormation.getNumber(properties.ObjectSizeGreaterThan) : undefined));
  ret.addPropertyResult("objectSizeLessThan", "ObjectSizeLessThan", (properties.ObjectSizeLessThan != null ? cfn_parse.FromCloudFormation.getNumber(properties.ObjectSizeLessThan) : undefined));
  ret.addPropertyResult("prefix", "Prefix", (properties.Prefix != null ? cfn_parse.FromCloudFormation.getString(properties.Prefix) : undefined));
  ret.addPropertyResult("status", "Status", (properties.Status != null ? cfn_parse.FromCloudFormation.getString(properties.Status) : undefined));
  ret.addPropertyResult("tagFilters", "TagFilters", (properties.TagFilters != null ? cfn_parse.FromCloudFormation.getArray(CfnBucketTagFilterPropertyFromCloudFormation)(properties.TagFilters) : undefined));
  ret.addPropertyResult("transition", "Transition", (properties.Transition != null ? CfnBucketTransitionPropertyFromCloudFormation(properties.Transition) : undefined));
  ret.addPropertyResult("transitions", "Transitions", (properties.Transitions != null ? cfn_parse.FromCloudFormation.getArray(CfnBucketTransitionPropertyFromCloudFormation)(properties.Transitions) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`LifecycleConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`LifecycleConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnBucketLifecycleConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("rules", cdk.requiredValidator)(properties.rules));
  errors.collect(cdk.propertyValidator("rules", cdk.listValidator(CfnBucketRulePropertyValidator))(properties.rules));
  return errors.wrap("supplied properties not correct for \\"LifecycleConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnBucketLifecycleConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnBucketLifecycleConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "Rules": cdk.listMapper(convertCfnBucketRulePropertyToCloudFormation)(properties.rules)
  };
}

// @ts-ignore TS6133
function CfnBucketLifecycleConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnBucket.LifecycleConfigurationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnBucket.LifecycleConfigurationProperty>();
  ret.addPropertyResult("rules", "Rules", (properties.Rules != null ? cfn_parse.FromCloudFormation.getArray(CfnBucketRulePropertyFromCloudFormation)(properties.Rules) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`LoggingConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`LoggingConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnBucketLoggingConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("destinationBucketName", cdk.validateString)(properties.destinationBucketName));
  errors.collect(cdk.propertyValidator("logFilePrefix", cdk.validateString)(properties.logFilePrefix));
  return errors.wrap("supplied properties not correct for \\"LoggingConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnBucketLoggingConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnBucketLoggingConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "DestinationBucketName": cdk.stringToCloudFormation(properties.destinationBucketName),
    "LogFilePrefix": cdk.stringToCloudFormation(properties.logFilePrefix)
  };
}

// @ts-ignore TS6133
function CfnBucketLoggingConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnBucket.LoggingConfigurationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnBucket.LoggingConfigurationProperty>();
  ret.addPropertyResult("destinationBucketName", "DestinationBucketName", (properties.DestinationBucketName != null ? cfn_parse.FromCloudFormation.getString(properties.DestinationBucketName) : undefined));
  ret.addPropertyResult("logFilePrefix", "LogFilePrefix", (properties.LogFilePrefix != null ? cfn_parse.FromCloudFormation.getString(properties.LogFilePrefix) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`MetricsConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`MetricsConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnBucketMetricsConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("accessPointArn", cdk.validateString)(properties.accessPointArn));
  errors.collect(cdk.propertyValidator("id", cdk.requiredValidator)(properties.id));
  errors.collect(cdk.propertyValidator("id", cdk.validateString)(properties.id));
  errors.collect(cdk.propertyValidator("prefix", cdk.validateString)(properties.prefix));
  errors.collect(cdk.propertyValidator("tagFilters", cdk.listValidator(CfnBucketTagFilterPropertyValidator))(properties.tagFilters));
  return errors.wrap("supplied properties not correct for \\"MetricsConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnBucketMetricsConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnBucketMetricsConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "AccessPointArn": cdk.stringToCloudFormation(properties.accessPointArn),
    "Id": cdk.stringToCloudFormation(properties.id),
    "Prefix": cdk.stringToCloudFormation(properties.prefix),
    "TagFilters": cdk.listMapper(convertCfnBucketTagFilterPropertyToCloudFormation)(properties.tagFilters)
  };
}

// @ts-ignore TS6133
function CfnBucketMetricsConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnBucket.MetricsConfigurationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnBucket.MetricsConfigurationProperty>();
  ret.addPropertyResult("accessPointArn", "AccessPointArn", (properties.AccessPointArn != null ? cfn_parse.FromCloudFormation.getString(properties.AccessPointArn) : undefined));
  ret.addPropertyResult("id", "Id", (properties.Id != null ? cfn_parse.FromCloudFormation.getString(properties.Id) : undefined));
  ret.addPropertyResult("prefix", "Prefix", (properties.Prefix != null ? cfn_parse.FromCloudFormation.getString(properties.Prefix) : undefined));
  ret.addPropertyResult("tagFilters", "TagFilters", (properties.TagFilters != null ? cfn_parse.FromCloudFormation.getArray(CfnBucketTagFilterPropertyFromCloudFormation)(properties.TagFilters) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`EventBridgeConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`EventBridgeConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnBucketEventBridgeConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("eventBridgeEnabled", cdk.requiredValidator)(properties.eventBridgeEnabled));
  errors.collect(cdk.propertyValidator("eventBridgeEnabled", cdk.validateBoolean)(properties.eventBridgeEnabled));
  return errors.wrap("supplied properties not correct for \\"EventBridgeConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnBucketEventBridgeConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnBucketEventBridgeConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "EventBridgeEnabled": cdk.booleanToCloudFormation(properties.eventBridgeEnabled)
  };
}

// @ts-ignore TS6133
function CfnBucketEventBridgeConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnBucket.EventBridgeConfigurationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnBucket.EventBridgeConfigurationProperty>();
  ret.addPropertyResult("eventBridgeEnabled", "EventBridgeEnabled", (properties.EventBridgeEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EventBridgeEnabled) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`FilterRuleProperty\`
 *
 * @param properties - the TypeScript properties of a \`FilterRuleProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnBucketFilterRulePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("name", cdk.requiredValidator)(properties.name));
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  errors.collect(cdk.propertyValidator("value", cdk.requiredValidator)(properties.value));
  errors.collect(cdk.propertyValidator("value", cdk.validateString)(properties.value));
  return errors.wrap("supplied properties not correct for \\"FilterRuleProperty\\"");
}

// @ts-ignore TS6133
function convertCfnBucketFilterRulePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnBucketFilterRulePropertyValidator(properties).assertSuccess();
  return {
    "Name": cdk.stringToCloudFormation(properties.name),
    "Value": cdk.stringToCloudFormation(properties.value)
  };
}

// @ts-ignore TS6133
function CfnBucketFilterRulePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnBucket.FilterRuleProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnBucket.FilterRuleProperty>();
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addPropertyResult("value", "Value", (properties.Value != null ? cfn_parse.FromCloudFormation.getString(properties.Value) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`S3KeyFilterProperty\`
 *
 * @param properties - the TypeScript properties of a \`S3KeyFilterProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnBucketS3KeyFilterPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("rules", cdk.requiredValidator)(properties.rules));
  errors.collect(cdk.propertyValidator("rules", cdk.listValidator(CfnBucketFilterRulePropertyValidator))(properties.rules));
  return errors.wrap("supplied properties not correct for \\"S3KeyFilterProperty\\"");
}

// @ts-ignore TS6133
function convertCfnBucketS3KeyFilterPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnBucketS3KeyFilterPropertyValidator(properties).assertSuccess();
  return {
    "Rules": cdk.listMapper(convertCfnBucketFilterRulePropertyToCloudFormation)(properties.rules)
  };
}

// @ts-ignore TS6133
function CfnBucketS3KeyFilterPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnBucket.S3KeyFilterProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnBucket.S3KeyFilterProperty>();
  ret.addPropertyResult("rules", "Rules", (properties.Rules != null ? cfn_parse.FromCloudFormation.getArray(CfnBucketFilterRulePropertyFromCloudFormation)(properties.Rules) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`NotificationFilterProperty\`
 *
 * @param properties - the TypeScript properties of a \`NotificationFilterProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnBucketNotificationFilterPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("s3Key", cdk.requiredValidator)(properties.s3Key));
  errors.collect(cdk.propertyValidator("s3Key", CfnBucketS3KeyFilterPropertyValidator)(properties.s3Key));
  return errors.wrap("supplied properties not correct for \\"NotificationFilterProperty\\"");
}

// @ts-ignore TS6133
function convertCfnBucketNotificationFilterPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnBucketNotificationFilterPropertyValidator(properties).assertSuccess();
  return {
    "S3Key": convertCfnBucketS3KeyFilterPropertyToCloudFormation(properties.s3Key)
  };
}

// @ts-ignore TS6133
function CfnBucketNotificationFilterPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnBucket.NotificationFilterProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnBucket.NotificationFilterProperty>();
  ret.addPropertyResult("s3Key", "S3Key", (properties.S3Key != null ? CfnBucketS3KeyFilterPropertyFromCloudFormation(properties.S3Key) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`LambdaConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`LambdaConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnBucketLambdaConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("event", cdk.requiredValidator)(properties.event));
  errors.collect(cdk.propertyValidator("event", cdk.validateString)(properties.event));
  errors.collect(cdk.propertyValidator("filter", CfnBucketNotificationFilterPropertyValidator)(properties.filter));
  errors.collect(cdk.propertyValidator("function", cdk.requiredValidator)(properties.function));
  errors.collect(cdk.propertyValidator("function", cdk.validateString)(properties.function));
  return errors.wrap("supplied properties not correct for \\"LambdaConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnBucketLambdaConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnBucketLambdaConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "Event": cdk.stringToCloudFormation(properties.event),
    "Filter": convertCfnBucketNotificationFilterPropertyToCloudFormation(properties.filter),
    "Function": cdk.stringToCloudFormation(properties.function)
  };
}

// @ts-ignore TS6133
function CfnBucketLambdaConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnBucket.LambdaConfigurationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnBucket.LambdaConfigurationProperty>();
  ret.addPropertyResult("event", "Event", (properties.Event != null ? cfn_parse.FromCloudFormation.getString(properties.Event) : undefined));
  ret.addPropertyResult("filter", "Filter", (properties.Filter != null ? CfnBucketNotificationFilterPropertyFromCloudFormation(properties.Filter) : undefined));
  ret.addPropertyResult("function", "Function", (properties.Function != null ? cfn_parse.FromCloudFormation.getString(properties.Function) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`QueueConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`QueueConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnBucketQueueConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("event", cdk.requiredValidator)(properties.event));
  errors.collect(cdk.propertyValidator("event", cdk.validateString)(properties.event));
  errors.collect(cdk.propertyValidator("filter", CfnBucketNotificationFilterPropertyValidator)(properties.filter));
  errors.collect(cdk.propertyValidator("queue", cdk.requiredValidator)(properties.queue));
  errors.collect(cdk.propertyValidator("queue", cdk.validateString)(properties.queue));
  return errors.wrap("supplied properties not correct for \\"QueueConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnBucketQueueConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnBucketQueueConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "Event": cdk.stringToCloudFormation(properties.event),
    "Filter": convertCfnBucketNotificationFilterPropertyToCloudFormation(properties.filter),
    "Queue": cdk.stringToCloudFormation(properties.queue)
  };
}

// @ts-ignore TS6133
function CfnBucketQueueConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnBucket.QueueConfigurationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnBucket.QueueConfigurationProperty>();
  ret.addPropertyResult("event", "Event", (properties.Event != null ? cfn_parse.FromCloudFormation.getString(properties.Event) : undefined));
  ret.addPropertyResult("filter", "Filter", (properties.Filter != null ? CfnBucketNotificationFilterPropertyFromCloudFormation(properties.Filter) : undefined));
  ret.addPropertyResult("queue", "Queue", (properties.Queue != null ? cfn_parse.FromCloudFormation.getString(properties.Queue) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`TopicConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`TopicConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnBucketTopicConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("event", cdk.requiredValidator)(properties.event));
  errors.collect(cdk.propertyValidator("event", cdk.validateString)(properties.event));
  errors.collect(cdk.propertyValidator("filter", CfnBucketNotificationFilterPropertyValidator)(properties.filter));
  errors.collect(cdk.propertyValidator("topic", cdk.requiredValidator)(properties.topic));
  errors.collect(cdk.propertyValidator("topic", cdk.validateString)(properties.topic));
  return errors.wrap("supplied properties not correct for \\"TopicConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnBucketTopicConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnBucketTopicConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "Event": cdk.stringToCloudFormation(properties.event),
    "Filter": convertCfnBucketNotificationFilterPropertyToCloudFormation(properties.filter),
    "Topic": cdk.stringToCloudFormation(properties.topic)
  };
}

// @ts-ignore TS6133
function CfnBucketTopicConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnBucket.TopicConfigurationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnBucket.TopicConfigurationProperty>();
  ret.addPropertyResult("event", "Event", (properties.Event != null ? cfn_parse.FromCloudFormation.getString(properties.Event) : undefined));
  ret.addPropertyResult("filter", "Filter", (properties.Filter != null ? CfnBucketNotificationFilterPropertyFromCloudFormation(properties.Filter) : undefined));
  ret.addPropertyResult("topic", "Topic", (properties.Topic != null ? cfn_parse.FromCloudFormation.getString(properties.Topic) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`NotificationConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`NotificationConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnBucketNotificationConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("eventBridgeConfiguration", CfnBucketEventBridgeConfigurationPropertyValidator)(properties.eventBridgeConfiguration));
  errors.collect(cdk.propertyValidator("lambdaConfigurations", cdk.listValidator(CfnBucketLambdaConfigurationPropertyValidator))(properties.lambdaConfigurations));
  errors.collect(cdk.propertyValidator("queueConfigurations", cdk.listValidator(CfnBucketQueueConfigurationPropertyValidator))(properties.queueConfigurations));
  errors.collect(cdk.propertyValidator("topicConfigurations", cdk.listValidator(CfnBucketTopicConfigurationPropertyValidator))(properties.topicConfigurations));
  return errors.wrap("supplied properties not correct for \\"NotificationConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnBucketNotificationConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnBucketNotificationConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "EventBridgeConfiguration": convertCfnBucketEventBridgeConfigurationPropertyToCloudFormation(properties.eventBridgeConfiguration),
    "LambdaConfigurations": cdk.listMapper(convertCfnBucketLambdaConfigurationPropertyToCloudFormation)(properties.lambdaConfigurations),
    "QueueConfigurations": cdk.listMapper(convertCfnBucketQueueConfigurationPropertyToCloudFormation)(properties.queueConfigurations),
    "TopicConfigurations": cdk.listMapper(convertCfnBucketTopicConfigurationPropertyToCloudFormation)(properties.topicConfigurations)
  };
}

// @ts-ignore TS6133
function CfnBucketNotificationConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnBucket.NotificationConfigurationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnBucket.NotificationConfigurationProperty>();
  ret.addPropertyResult("eventBridgeConfiguration", "EventBridgeConfiguration", (properties.EventBridgeConfiguration != null ? CfnBucketEventBridgeConfigurationPropertyFromCloudFormation(properties.EventBridgeConfiguration) : undefined));
  ret.addPropertyResult("lambdaConfigurations", "LambdaConfigurations", (properties.LambdaConfigurations != null ? cfn_parse.FromCloudFormation.getArray(CfnBucketLambdaConfigurationPropertyFromCloudFormation)(properties.LambdaConfigurations) : undefined));
  ret.addPropertyResult("queueConfigurations", "QueueConfigurations", (properties.QueueConfigurations != null ? cfn_parse.FromCloudFormation.getArray(CfnBucketQueueConfigurationPropertyFromCloudFormation)(properties.QueueConfigurations) : undefined));
  ret.addPropertyResult("topicConfigurations", "TopicConfigurations", (properties.TopicConfigurations != null ? cfn_parse.FromCloudFormation.getArray(CfnBucketTopicConfigurationPropertyFromCloudFormation)(properties.TopicConfigurations) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`DefaultRetentionProperty\`
 *
 * @param properties - the TypeScript properties of a \`DefaultRetentionProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnBucketDefaultRetentionPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("days", cdk.validateNumber)(properties.days));
  errors.collect(cdk.propertyValidator("mode", cdk.validateString)(properties.mode));
  errors.collect(cdk.propertyValidator("years", cdk.validateNumber)(properties.years));
  return errors.wrap("supplied properties not correct for \\"DefaultRetentionProperty\\"");
}

// @ts-ignore TS6133
function convertCfnBucketDefaultRetentionPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnBucketDefaultRetentionPropertyValidator(properties).assertSuccess();
  return {
    "Days": cdk.numberToCloudFormation(properties.days),
    "Mode": cdk.stringToCloudFormation(properties.mode),
    "Years": cdk.numberToCloudFormation(properties.years)
  };
}

// @ts-ignore TS6133
function CfnBucketDefaultRetentionPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnBucket.DefaultRetentionProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnBucket.DefaultRetentionProperty>();
  ret.addPropertyResult("days", "Days", (properties.Days != null ? cfn_parse.FromCloudFormation.getNumber(properties.Days) : undefined));
  ret.addPropertyResult("mode", "Mode", (properties.Mode != null ? cfn_parse.FromCloudFormation.getString(properties.Mode) : undefined));
  ret.addPropertyResult("years", "Years", (properties.Years != null ? cfn_parse.FromCloudFormation.getNumber(properties.Years) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ObjectLockRuleProperty\`
 *
 * @param properties - the TypeScript properties of a \`ObjectLockRuleProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnBucketObjectLockRulePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("defaultRetention", CfnBucketDefaultRetentionPropertyValidator)(properties.defaultRetention));
  return errors.wrap("supplied properties not correct for \\"ObjectLockRuleProperty\\"");
}

// @ts-ignore TS6133
function convertCfnBucketObjectLockRulePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnBucketObjectLockRulePropertyValidator(properties).assertSuccess();
  return {
    "DefaultRetention": convertCfnBucketDefaultRetentionPropertyToCloudFormation(properties.defaultRetention)
  };
}

// @ts-ignore TS6133
function CfnBucketObjectLockRulePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnBucket.ObjectLockRuleProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnBucket.ObjectLockRuleProperty>();
  ret.addPropertyResult("defaultRetention", "DefaultRetention", (properties.DefaultRetention != null ? CfnBucketDefaultRetentionPropertyFromCloudFormation(properties.DefaultRetention) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ObjectLockConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`ObjectLockConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnBucketObjectLockConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("objectLockEnabled", cdk.validateString)(properties.objectLockEnabled));
  errors.collect(cdk.propertyValidator("rule", CfnBucketObjectLockRulePropertyValidator)(properties.rule));
  return errors.wrap("supplied properties not correct for \\"ObjectLockConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnBucketObjectLockConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnBucketObjectLockConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "ObjectLockEnabled": cdk.stringToCloudFormation(properties.objectLockEnabled),
    "Rule": convertCfnBucketObjectLockRulePropertyToCloudFormation(properties.rule)
  };
}

// @ts-ignore TS6133
function CfnBucketObjectLockConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnBucket.ObjectLockConfigurationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnBucket.ObjectLockConfigurationProperty>();
  ret.addPropertyResult("objectLockEnabled", "ObjectLockEnabled", (properties.ObjectLockEnabled != null ? cfn_parse.FromCloudFormation.getString(properties.ObjectLockEnabled) : undefined));
  ret.addPropertyResult("rule", "Rule", (properties.Rule != null ? CfnBucketObjectLockRulePropertyFromCloudFormation(properties.Rule) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`OwnershipControlsRuleProperty\`
 *
 * @param properties - the TypeScript properties of a \`OwnershipControlsRuleProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnBucketOwnershipControlsRulePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("objectOwnership", cdk.validateString)(properties.objectOwnership));
  return errors.wrap("supplied properties not correct for \\"OwnershipControlsRuleProperty\\"");
}

// @ts-ignore TS6133
function convertCfnBucketOwnershipControlsRulePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnBucketOwnershipControlsRulePropertyValidator(properties).assertSuccess();
  return {
    "ObjectOwnership": cdk.stringToCloudFormation(properties.objectOwnership)
  };
}

// @ts-ignore TS6133
function CfnBucketOwnershipControlsRulePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnBucket.OwnershipControlsRuleProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnBucket.OwnershipControlsRuleProperty>();
  ret.addPropertyResult("objectOwnership", "ObjectOwnership", (properties.ObjectOwnership != null ? cfn_parse.FromCloudFormation.getString(properties.ObjectOwnership) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`OwnershipControlsProperty\`
 *
 * @param properties - the TypeScript properties of a \`OwnershipControlsProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnBucketOwnershipControlsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("rules", cdk.requiredValidator)(properties.rules));
  errors.collect(cdk.propertyValidator("rules", cdk.listValidator(CfnBucketOwnershipControlsRulePropertyValidator))(properties.rules));
  return errors.wrap("supplied properties not correct for \\"OwnershipControlsProperty\\"");
}

// @ts-ignore TS6133
function convertCfnBucketOwnershipControlsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnBucketOwnershipControlsPropertyValidator(properties).assertSuccess();
  return {
    "Rules": cdk.listMapper(convertCfnBucketOwnershipControlsRulePropertyToCloudFormation)(properties.rules)
  };
}

// @ts-ignore TS6133
function CfnBucketOwnershipControlsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnBucket.OwnershipControlsProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnBucket.OwnershipControlsProperty>();
  ret.addPropertyResult("rules", "Rules", (properties.Rules != null ? cfn_parse.FromCloudFormation.getArray(CfnBucketOwnershipControlsRulePropertyFromCloudFormation)(properties.Rules) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`PublicAccessBlockConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`PublicAccessBlockConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnBucketPublicAccessBlockConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("blockPublicAcls", cdk.validateBoolean)(properties.blockPublicAcls));
  errors.collect(cdk.propertyValidator("blockPublicPolicy", cdk.validateBoolean)(properties.blockPublicPolicy));
  errors.collect(cdk.propertyValidator("ignorePublicAcls", cdk.validateBoolean)(properties.ignorePublicAcls));
  errors.collect(cdk.propertyValidator("restrictPublicBuckets", cdk.validateBoolean)(properties.restrictPublicBuckets));
  return errors.wrap("supplied properties not correct for \\"PublicAccessBlockConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnBucketPublicAccessBlockConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnBucketPublicAccessBlockConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "BlockPublicAcls": cdk.booleanToCloudFormation(properties.blockPublicAcls),
    "BlockPublicPolicy": cdk.booleanToCloudFormation(properties.blockPublicPolicy),
    "IgnorePublicAcls": cdk.booleanToCloudFormation(properties.ignorePublicAcls),
    "RestrictPublicBuckets": cdk.booleanToCloudFormation(properties.restrictPublicBuckets)
  };
}

// @ts-ignore TS6133
function CfnBucketPublicAccessBlockConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnBucket.PublicAccessBlockConfigurationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnBucket.PublicAccessBlockConfigurationProperty>();
  ret.addPropertyResult("blockPublicAcls", "BlockPublicAcls", (properties.BlockPublicAcls != null ? cfn_parse.FromCloudFormation.getBoolean(properties.BlockPublicAcls) : undefined));
  ret.addPropertyResult("blockPublicPolicy", "BlockPublicPolicy", (properties.BlockPublicPolicy != null ? cfn_parse.FromCloudFormation.getBoolean(properties.BlockPublicPolicy) : undefined));
  ret.addPropertyResult("ignorePublicAcls", "IgnorePublicAcls", (properties.IgnorePublicAcls != null ? cfn_parse.FromCloudFormation.getBoolean(properties.IgnorePublicAcls) : undefined));
  ret.addPropertyResult("restrictPublicBuckets", "RestrictPublicBuckets", (properties.RestrictPublicBuckets != null ? cfn_parse.FromCloudFormation.getBoolean(properties.RestrictPublicBuckets) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`DeleteMarkerReplicationProperty\`
 *
 * @param properties - the TypeScript properties of a \`DeleteMarkerReplicationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnBucketDeleteMarkerReplicationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("status", cdk.validateString)(properties.status));
  return errors.wrap("supplied properties not correct for \\"DeleteMarkerReplicationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnBucketDeleteMarkerReplicationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnBucketDeleteMarkerReplicationPropertyValidator(properties).assertSuccess();
  return {
    "Status": cdk.stringToCloudFormation(properties.status)
  };
}

// @ts-ignore TS6133
function CfnBucketDeleteMarkerReplicationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnBucket.DeleteMarkerReplicationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnBucket.DeleteMarkerReplicationProperty>();
  ret.addPropertyResult("status", "Status", (properties.Status != null ? cfn_parse.FromCloudFormation.getString(properties.Status) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`AccessControlTranslationProperty\`
 *
 * @param properties - the TypeScript properties of a \`AccessControlTranslationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnBucketAccessControlTranslationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("owner", cdk.requiredValidator)(properties.owner));
  errors.collect(cdk.propertyValidator("owner", cdk.validateString)(properties.owner));
  return errors.wrap("supplied properties not correct for \\"AccessControlTranslationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnBucketAccessControlTranslationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnBucketAccessControlTranslationPropertyValidator(properties).assertSuccess();
  return {
    "Owner": cdk.stringToCloudFormation(properties.owner)
  };
}

// @ts-ignore TS6133
function CfnBucketAccessControlTranslationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnBucket.AccessControlTranslationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnBucket.AccessControlTranslationProperty>();
  ret.addPropertyResult("owner", "Owner", (properties.Owner != null ? cfn_parse.FromCloudFormation.getString(properties.Owner) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`EncryptionConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`EncryptionConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnBucketEncryptionConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("replicaKmsKeyId", cdk.requiredValidator)(properties.replicaKmsKeyId));
  errors.collect(cdk.propertyValidator("replicaKmsKeyId", cdk.validateString)(properties.replicaKmsKeyId));
  return errors.wrap("supplied properties not correct for \\"EncryptionConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnBucketEncryptionConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnBucketEncryptionConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "ReplicaKmsKeyID": cdk.stringToCloudFormation(properties.replicaKmsKeyId)
  };
}

// @ts-ignore TS6133
function CfnBucketEncryptionConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnBucket.EncryptionConfigurationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnBucket.EncryptionConfigurationProperty>();
  ret.addPropertyResult("replicaKmsKeyId", "ReplicaKmsKeyID", (properties.ReplicaKmsKeyID != null ? cfn_parse.FromCloudFormation.getString(properties.ReplicaKmsKeyID) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ReplicationTimeValueProperty\`
 *
 * @param properties - the TypeScript properties of a \`ReplicationTimeValueProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnBucketReplicationTimeValuePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("minutes", cdk.requiredValidator)(properties.minutes));
  errors.collect(cdk.propertyValidator("minutes", cdk.validateNumber)(properties.minutes));
  return errors.wrap("supplied properties not correct for \\"ReplicationTimeValueProperty\\"");
}

// @ts-ignore TS6133
function convertCfnBucketReplicationTimeValuePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnBucketReplicationTimeValuePropertyValidator(properties).assertSuccess();
  return {
    "Minutes": cdk.numberToCloudFormation(properties.minutes)
  };
}

// @ts-ignore TS6133
function CfnBucketReplicationTimeValuePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnBucket.ReplicationTimeValueProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnBucket.ReplicationTimeValueProperty>();
  ret.addPropertyResult("minutes", "Minutes", (properties.Minutes != null ? cfn_parse.FromCloudFormation.getNumber(properties.Minutes) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`MetricsProperty\`
 *
 * @param properties - the TypeScript properties of a \`MetricsProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnBucketMetricsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("eventThreshold", CfnBucketReplicationTimeValuePropertyValidator)(properties.eventThreshold));
  errors.collect(cdk.propertyValidator("status", cdk.requiredValidator)(properties.status));
  errors.collect(cdk.propertyValidator("status", cdk.validateString)(properties.status));
  return errors.wrap("supplied properties not correct for \\"MetricsProperty\\"");
}

// @ts-ignore TS6133
function convertCfnBucketMetricsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnBucketMetricsPropertyValidator(properties).assertSuccess();
  return {
    "EventThreshold": convertCfnBucketReplicationTimeValuePropertyToCloudFormation(properties.eventThreshold),
    "Status": cdk.stringToCloudFormation(properties.status)
  };
}

// @ts-ignore TS6133
function CfnBucketMetricsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnBucket.MetricsProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnBucket.MetricsProperty>();
  ret.addPropertyResult("eventThreshold", "EventThreshold", (properties.EventThreshold != null ? CfnBucketReplicationTimeValuePropertyFromCloudFormation(properties.EventThreshold) : undefined));
  ret.addPropertyResult("status", "Status", (properties.Status != null ? cfn_parse.FromCloudFormation.getString(properties.Status) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ReplicationTimeProperty\`
 *
 * @param properties - the TypeScript properties of a \`ReplicationTimeProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnBucketReplicationTimePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("status", cdk.requiredValidator)(properties.status));
  errors.collect(cdk.propertyValidator("status", cdk.validateString)(properties.status));
  errors.collect(cdk.propertyValidator("time", cdk.requiredValidator)(properties.time));
  errors.collect(cdk.propertyValidator("time", CfnBucketReplicationTimeValuePropertyValidator)(properties.time));
  return errors.wrap("supplied properties not correct for \\"ReplicationTimeProperty\\"");
}

// @ts-ignore TS6133
function convertCfnBucketReplicationTimePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnBucketReplicationTimePropertyValidator(properties).assertSuccess();
  return {
    "Status": cdk.stringToCloudFormation(properties.status),
    "Time": convertCfnBucketReplicationTimeValuePropertyToCloudFormation(properties.time)
  };
}

// @ts-ignore TS6133
function CfnBucketReplicationTimePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnBucket.ReplicationTimeProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnBucket.ReplicationTimeProperty>();
  ret.addPropertyResult("status", "Status", (properties.Status != null ? cfn_parse.FromCloudFormation.getString(properties.Status) : undefined));
  ret.addPropertyResult("time", "Time", (properties.Time != null ? CfnBucketReplicationTimeValuePropertyFromCloudFormation(properties.Time) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ReplicationDestinationProperty\`
 *
 * @param properties - the TypeScript properties of a \`ReplicationDestinationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnBucketReplicationDestinationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("accessControlTranslation", CfnBucketAccessControlTranslationPropertyValidator)(properties.accessControlTranslation));
  errors.collect(cdk.propertyValidator("account", cdk.validateString)(properties.account));
  errors.collect(cdk.propertyValidator("bucket", cdk.requiredValidator)(properties.bucket));
  errors.collect(cdk.propertyValidator("bucket", cdk.validateString)(properties.bucket));
  errors.collect(cdk.propertyValidator("encryptionConfiguration", CfnBucketEncryptionConfigurationPropertyValidator)(properties.encryptionConfiguration));
  errors.collect(cdk.propertyValidator("metrics", CfnBucketMetricsPropertyValidator)(properties.metrics));
  errors.collect(cdk.propertyValidator("replicationTime", CfnBucketReplicationTimePropertyValidator)(properties.replicationTime));
  errors.collect(cdk.propertyValidator("storageClass", cdk.validateString)(properties.storageClass));
  return errors.wrap("supplied properties not correct for \\"ReplicationDestinationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnBucketReplicationDestinationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnBucketReplicationDestinationPropertyValidator(properties).assertSuccess();
  return {
    "AccessControlTranslation": convertCfnBucketAccessControlTranslationPropertyToCloudFormation(properties.accessControlTranslation),
    "Account": cdk.stringToCloudFormation(properties.account),
    "Bucket": cdk.stringToCloudFormation(properties.bucket),
    "EncryptionConfiguration": convertCfnBucketEncryptionConfigurationPropertyToCloudFormation(properties.encryptionConfiguration),
    "Metrics": convertCfnBucketMetricsPropertyToCloudFormation(properties.metrics),
    "ReplicationTime": convertCfnBucketReplicationTimePropertyToCloudFormation(properties.replicationTime),
    "StorageClass": cdk.stringToCloudFormation(properties.storageClass)
  };
}

// @ts-ignore TS6133
function CfnBucketReplicationDestinationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnBucket.ReplicationDestinationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnBucket.ReplicationDestinationProperty>();
  ret.addPropertyResult("accessControlTranslation", "AccessControlTranslation", (properties.AccessControlTranslation != null ? CfnBucketAccessControlTranslationPropertyFromCloudFormation(properties.AccessControlTranslation) : undefined));
  ret.addPropertyResult("account", "Account", (properties.Account != null ? cfn_parse.FromCloudFormation.getString(properties.Account) : undefined));
  ret.addPropertyResult("bucket", "Bucket", (properties.Bucket != null ? cfn_parse.FromCloudFormation.getString(properties.Bucket) : undefined));
  ret.addPropertyResult("encryptionConfiguration", "EncryptionConfiguration", (properties.EncryptionConfiguration != null ? CfnBucketEncryptionConfigurationPropertyFromCloudFormation(properties.EncryptionConfiguration) : undefined));
  ret.addPropertyResult("metrics", "Metrics", (properties.Metrics != null ? CfnBucketMetricsPropertyFromCloudFormation(properties.Metrics) : undefined));
  ret.addPropertyResult("replicationTime", "ReplicationTime", (properties.ReplicationTime != null ? CfnBucketReplicationTimePropertyFromCloudFormation(properties.ReplicationTime) : undefined));
  ret.addPropertyResult("storageClass", "StorageClass", (properties.StorageClass != null ? cfn_parse.FromCloudFormation.getString(properties.StorageClass) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ReplicationRuleAndOperatorProperty\`
 *
 * @param properties - the TypeScript properties of a \`ReplicationRuleAndOperatorProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnBucketReplicationRuleAndOperatorPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("prefix", cdk.validateString)(properties.prefix));
  errors.collect(cdk.propertyValidator("tagFilters", cdk.listValidator(CfnBucketTagFilterPropertyValidator))(properties.tagFilters));
  return errors.wrap("supplied properties not correct for \\"ReplicationRuleAndOperatorProperty\\"");
}

// @ts-ignore TS6133
function convertCfnBucketReplicationRuleAndOperatorPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnBucketReplicationRuleAndOperatorPropertyValidator(properties).assertSuccess();
  return {
    "Prefix": cdk.stringToCloudFormation(properties.prefix),
    "TagFilters": cdk.listMapper(convertCfnBucketTagFilterPropertyToCloudFormation)(properties.tagFilters)
  };
}

// @ts-ignore TS6133
function CfnBucketReplicationRuleAndOperatorPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnBucket.ReplicationRuleAndOperatorProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnBucket.ReplicationRuleAndOperatorProperty>();
  ret.addPropertyResult("prefix", "Prefix", (properties.Prefix != null ? cfn_parse.FromCloudFormation.getString(properties.Prefix) : undefined));
  ret.addPropertyResult("tagFilters", "TagFilters", (properties.TagFilters != null ? cfn_parse.FromCloudFormation.getArray(CfnBucketTagFilterPropertyFromCloudFormation)(properties.TagFilters) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ReplicationRuleFilterProperty\`
 *
 * @param properties - the TypeScript properties of a \`ReplicationRuleFilterProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnBucketReplicationRuleFilterPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("and", CfnBucketReplicationRuleAndOperatorPropertyValidator)(properties.and));
  errors.collect(cdk.propertyValidator("prefix", cdk.validateString)(properties.prefix));
  errors.collect(cdk.propertyValidator("tagFilter", CfnBucketTagFilterPropertyValidator)(properties.tagFilter));
  return errors.wrap("supplied properties not correct for \\"ReplicationRuleFilterProperty\\"");
}

// @ts-ignore TS6133
function convertCfnBucketReplicationRuleFilterPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnBucketReplicationRuleFilterPropertyValidator(properties).assertSuccess();
  return {
    "And": convertCfnBucketReplicationRuleAndOperatorPropertyToCloudFormation(properties.and),
    "Prefix": cdk.stringToCloudFormation(properties.prefix),
    "TagFilter": convertCfnBucketTagFilterPropertyToCloudFormation(properties.tagFilter)
  };
}

// @ts-ignore TS6133
function CfnBucketReplicationRuleFilterPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnBucket.ReplicationRuleFilterProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnBucket.ReplicationRuleFilterProperty>();
  ret.addPropertyResult("and", "And", (properties.And != null ? CfnBucketReplicationRuleAndOperatorPropertyFromCloudFormation(properties.And) : undefined));
  ret.addPropertyResult("prefix", "Prefix", (properties.Prefix != null ? cfn_parse.FromCloudFormation.getString(properties.Prefix) : undefined));
  ret.addPropertyResult("tagFilter", "TagFilter", (properties.TagFilter != null ? CfnBucketTagFilterPropertyFromCloudFormation(properties.TagFilter) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ReplicaModificationsProperty\`
 *
 * @param properties - the TypeScript properties of a \`ReplicaModificationsProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnBucketReplicaModificationsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("status", cdk.requiredValidator)(properties.status));
  errors.collect(cdk.propertyValidator("status", cdk.validateString)(properties.status));
  return errors.wrap("supplied properties not correct for \\"ReplicaModificationsProperty\\"");
}

// @ts-ignore TS6133
function convertCfnBucketReplicaModificationsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnBucketReplicaModificationsPropertyValidator(properties).assertSuccess();
  return {
    "Status": cdk.stringToCloudFormation(properties.status)
  };
}

// @ts-ignore TS6133
function CfnBucketReplicaModificationsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnBucket.ReplicaModificationsProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnBucket.ReplicaModificationsProperty>();
  ret.addPropertyResult("status", "Status", (properties.Status != null ? cfn_parse.FromCloudFormation.getString(properties.Status) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`SseKmsEncryptedObjectsProperty\`
 *
 * @param properties - the TypeScript properties of a \`SseKmsEncryptedObjectsProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnBucketSseKmsEncryptedObjectsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("status", cdk.requiredValidator)(properties.status));
  errors.collect(cdk.propertyValidator("status", cdk.validateString)(properties.status));
  return errors.wrap("supplied properties not correct for \\"SseKmsEncryptedObjectsProperty\\"");
}

// @ts-ignore TS6133
function convertCfnBucketSseKmsEncryptedObjectsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnBucketSseKmsEncryptedObjectsPropertyValidator(properties).assertSuccess();
  return {
    "Status": cdk.stringToCloudFormation(properties.status)
  };
}

// @ts-ignore TS6133
function CfnBucketSseKmsEncryptedObjectsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnBucket.SseKmsEncryptedObjectsProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnBucket.SseKmsEncryptedObjectsProperty>();
  ret.addPropertyResult("status", "Status", (properties.Status != null ? cfn_parse.FromCloudFormation.getString(properties.Status) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`SourceSelectionCriteriaProperty\`
 *
 * @param properties - the TypeScript properties of a \`SourceSelectionCriteriaProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnBucketSourceSelectionCriteriaPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("replicaModifications", CfnBucketReplicaModificationsPropertyValidator)(properties.replicaModifications));
  errors.collect(cdk.propertyValidator("sseKmsEncryptedObjects", CfnBucketSseKmsEncryptedObjectsPropertyValidator)(properties.sseKmsEncryptedObjects));
  return errors.wrap("supplied properties not correct for \\"SourceSelectionCriteriaProperty\\"");
}

// @ts-ignore TS6133
function convertCfnBucketSourceSelectionCriteriaPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnBucketSourceSelectionCriteriaPropertyValidator(properties).assertSuccess();
  return {
    "ReplicaModifications": convertCfnBucketReplicaModificationsPropertyToCloudFormation(properties.replicaModifications),
    "SseKmsEncryptedObjects": convertCfnBucketSseKmsEncryptedObjectsPropertyToCloudFormation(properties.sseKmsEncryptedObjects)
  };
}

// @ts-ignore TS6133
function CfnBucketSourceSelectionCriteriaPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnBucket.SourceSelectionCriteriaProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnBucket.SourceSelectionCriteriaProperty>();
  ret.addPropertyResult("replicaModifications", "ReplicaModifications", (properties.ReplicaModifications != null ? CfnBucketReplicaModificationsPropertyFromCloudFormation(properties.ReplicaModifications) : undefined));
  ret.addPropertyResult("sseKmsEncryptedObjects", "SseKmsEncryptedObjects", (properties.SseKmsEncryptedObjects != null ? CfnBucketSseKmsEncryptedObjectsPropertyFromCloudFormation(properties.SseKmsEncryptedObjects) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ReplicationRuleProperty\`
 *
 * @param properties - the TypeScript properties of a \`ReplicationRuleProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnBucketReplicationRulePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("deleteMarkerReplication", CfnBucketDeleteMarkerReplicationPropertyValidator)(properties.deleteMarkerReplication));
  errors.collect(cdk.propertyValidator("destination", cdk.requiredValidator)(properties.destination));
  errors.collect(cdk.propertyValidator("destination", CfnBucketReplicationDestinationPropertyValidator)(properties.destination));
  errors.collect(cdk.propertyValidator("filter", CfnBucketReplicationRuleFilterPropertyValidator)(properties.filter));
  errors.collect(cdk.propertyValidator("id", cdk.validateString)(properties.id));
  errors.collect(cdk.propertyValidator("prefix", cdk.validateString)(properties.prefix));
  errors.collect(cdk.propertyValidator("priority", cdk.validateNumber)(properties.priority));
  errors.collect(cdk.propertyValidator("sourceSelectionCriteria", CfnBucketSourceSelectionCriteriaPropertyValidator)(properties.sourceSelectionCriteria));
  errors.collect(cdk.propertyValidator("status", cdk.requiredValidator)(properties.status));
  errors.collect(cdk.propertyValidator("status", cdk.validateString)(properties.status));
  return errors.wrap("supplied properties not correct for \\"ReplicationRuleProperty\\"");
}

// @ts-ignore TS6133
function convertCfnBucketReplicationRulePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnBucketReplicationRulePropertyValidator(properties).assertSuccess();
  return {
    "DeleteMarkerReplication": convertCfnBucketDeleteMarkerReplicationPropertyToCloudFormation(properties.deleteMarkerReplication),
    "Destination": convertCfnBucketReplicationDestinationPropertyToCloudFormation(properties.destination),
    "Filter": convertCfnBucketReplicationRuleFilterPropertyToCloudFormation(properties.filter),
    "Id": cdk.stringToCloudFormation(properties.id),
    "Prefix": cdk.stringToCloudFormation(properties.prefix),
    "Priority": cdk.numberToCloudFormation(properties.priority),
    "SourceSelectionCriteria": convertCfnBucketSourceSelectionCriteriaPropertyToCloudFormation(properties.sourceSelectionCriteria),
    "Status": cdk.stringToCloudFormation(properties.status)
  };
}

// @ts-ignore TS6133
function CfnBucketReplicationRulePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnBucket.ReplicationRuleProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnBucket.ReplicationRuleProperty>();
  ret.addPropertyResult("deleteMarkerReplication", "DeleteMarkerReplication", (properties.DeleteMarkerReplication != null ? CfnBucketDeleteMarkerReplicationPropertyFromCloudFormation(properties.DeleteMarkerReplication) : undefined));
  ret.addPropertyResult("destination", "Destination", (properties.Destination != null ? CfnBucketReplicationDestinationPropertyFromCloudFormation(properties.Destination) : undefined));
  ret.addPropertyResult("filter", "Filter", (properties.Filter != null ? CfnBucketReplicationRuleFilterPropertyFromCloudFormation(properties.Filter) : undefined));
  ret.addPropertyResult("id", "Id", (properties.Id != null ? cfn_parse.FromCloudFormation.getString(properties.Id) : undefined));
  ret.addPropertyResult("prefix", "Prefix", (properties.Prefix != null ? cfn_parse.FromCloudFormation.getString(properties.Prefix) : undefined));
  ret.addPropertyResult("priority", "Priority", (properties.Priority != null ? cfn_parse.FromCloudFormation.getNumber(properties.Priority) : undefined));
  ret.addPropertyResult("sourceSelectionCriteria", "SourceSelectionCriteria", (properties.SourceSelectionCriteria != null ? CfnBucketSourceSelectionCriteriaPropertyFromCloudFormation(properties.SourceSelectionCriteria) : undefined));
  ret.addPropertyResult("status", "Status", (properties.Status != null ? cfn_parse.FromCloudFormation.getString(properties.Status) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ReplicationConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`ReplicationConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnBucketReplicationConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("role", cdk.requiredValidator)(properties.role));
  errors.collect(cdk.propertyValidator("role", cdk.validateString)(properties.role));
  errors.collect(cdk.propertyValidator("rules", cdk.requiredValidator)(properties.rules));
  errors.collect(cdk.propertyValidator("rules", cdk.listValidator(CfnBucketReplicationRulePropertyValidator))(properties.rules));
  return errors.wrap("supplied properties not correct for \\"ReplicationConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnBucketReplicationConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnBucketReplicationConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "Role": cdk.stringToCloudFormation(properties.role),
    "Rules": cdk.listMapper(convertCfnBucketReplicationRulePropertyToCloudFormation)(properties.rules)
  };
}

// @ts-ignore TS6133
function CfnBucketReplicationConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnBucket.ReplicationConfigurationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnBucket.ReplicationConfigurationProperty>();
  ret.addPropertyResult("role", "Role", (properties.Role != null ? cfn_parse.FromCloudFormation.getString(properties.Role) : undefined));
  ret.addPropertyResult("rules", "Rules", (properties.Rules != null ? cfn_parse.FromCloudFormation.getArray(CfnBucketReplicationRulePropertyFromCloudFormation)(properties.Rules) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`VersioningConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`VersioningConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnBucketVersioningConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("status", cdk.requiredValidator)(properties.status));
  errors.collect(cdk.propertyValidator("status", cdk.validateString)(properties.status));
  return errors.wrap("supplied properties not correct for \\"VersioningConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnBucketVersioningConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnBucketVersioningConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "Status": cdk.stringToCloudFormation(properties.status)
  };
}

// @ts-ignore TS6133
function CfnBucketVersioningConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnBucket.VersioningConfigurationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnBucket.VersioningConfigurationProperty>();
  ret.addPropertyResult("status", "Status", (properties.Status != null ? cfn_parse.FromCloudFormation.getString(properties.Status) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`RedirectRuleProperty\`
 *
 * @param properties - the TypeScript properties of a \`RedirectRuleProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnBucketRedirectRulePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("hostName", cdk.validateString)(properties.hostName));
  errors.collect(cdk.propertyValidator("httpRedirectCode", cdk.validateString)(properties.httpRedirectCode));
  errors.collect(cdk.propertyValidator("protocol", cdk.validateString)(properties.protocol));
  errors.collect(cdk.propertyValidator("replaceKeyPrefixWith", cdk.validateString)(properties.replaceKeyPrefixWith));
  errors.collect(cdk.propertyValidator("replaceKeyWith", cdk.validateString)(properties.replaceKeyWith));
  return errors.wrap("supplied properties not correct for \\"RedirectRuleProperty\\"");
}

// @ts-ignore TS6133
function convertCfnBucketRedirectRulePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnBucketRedirectRulePropertyValidator(properties).assertSuccess();
  return {
    "HostName": cdk.stringToCloudFormation(properties.hostName),
    "HttpRedirectCode": cdk.stringToCloudFormation(properties.httpRedirectCode),
    "Protocol": cdk.stringToCloudFormation(properties.protocol),
    "ReplaceKeyPrefixWith": cdk.stringToCloudFormation(properties.replaceKeyPrefixWith),
    "ReplaceKeyWith": cdk.stringToCloudFormation(properties.replaceKeyWith)
  };
}

// @ts-ignore TS6133
function CfnBucketRedirectRulePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnBucket.RedirectRuleProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnBucket.RedirectRuleProperty>();
  ret.addPropertyResult("hostName", "HostName", (properties.HostName != null ? cfn_parse.FromCloudFormation.getString(properties.HostName) : undefined));
  ret.addPropertyResult("httpRedirectCode", "HttpRedirectCode", (properties.HttpRedirectCode != null ? cfn_parse.FromCloudFormation.getString(properties.HttpRedirectCode) : undefined));
  ret.addPropertyResult("protocol", "Protocol", (properties.Protocol != null ? cfn_parse.FromCloudFormation.getString(properties.Protocol) : undefined));
  ret.addPropertyResult("replaceKeyPrefixWith", "ReplaceKeyPrefixWith", (properties.ReplaceKeyPrefixWith != null ? cfn_parse.FromCloudFormation.getString(properties.ReplaceKeyPrefixWith) : undefined));
  ret.addPropertyResult("replaceKeyWith", "ReplaceKeyWith", (properties.ReplaceKeyWith != null ? cfn_parse.FromCloudFormation.getString(properties.ReplaceKeyWith) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`RoutingRuleConditionProperty\`
 *
 * @param properties - the TypeScript properties of a \`RoutingRuleConditionProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnBucketRoutingRuleConditionPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("httpErrorCodeReturnedEquals", cdk.validateString)(properties.httpErrorCodeReturnedEquals));
  errors.collect(cdk.propertyValidator("keyPrefixEquals", cdk.validateString)(properties.keyPrefixEquals));
  return errors.wrap("supplied properties not correct for \\"RoutingRuleConditionProperty\\"");
}

// @ts-ignore TS6133
function convertCfnBucketRoutingRuleConditionPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnBucketRoutingRuleConditionPropertyValidator(properties).assertSuccess();
  return {
    "HttpErrorCodeReturnedEquals": cdk.stringToCloudFormation(properties.httpErrorCodeReturnedEquals),
    "KeyPrefixEquals": cdk.stringToCloudFormation(properties.keyPrefixEquals)
  };
}

// @ts-ignore TS6133
function CfnBucketRoutingRuleConditionPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnBucket.RoutingRuleConditionProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnBucket.RoutingRuleConditionProperty>();
  ret.addPropertyResult("httpErrorCodeReturnedEquals", "HttpErrorCodeReturnedEquals", (properties.HttpErrorCodeReturnedEquals != null ? cfn_parse.FromCloudFormation.getString(properties.HttpErrorCodeReturnedEquals) : undefined));
  ret.addPropertyResult("keyPrefixEquals", "KeyPrefixEquals", (properties.KeyPrefixEquals != null ? cfn_parse.FromCloudFormation.getString(properties.KeyPrefixEquals) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`RoutingRuleProperty\`
 *
 * @param properties - the TypeScript properties of a \`RoutingRuleProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnBucketRoutingRulePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("redirectRule", cdk.requiredValidator)(properties.redirectRule));
  errors.collect(cdk.propertyValidator("redirectRule", CfnBucketRedirectRulePropertyValidator)(properties.redirectRule));
  errors.collect(cdk.propertyValidator("routingRuleCondition", CfnBucketRoutingRuleConditionPropertyValidator)(properties.routingRuleCondition));
  return errors.wrap("supplied properties not correct for \\"RoutingRuleProperty\\"");
}

// @ts-ignore TS6133
function convertCfnBucketRoutingRulePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnBucketRoutingRulePropertyValidator(properties).assertSuccess();
  return {
    "RedirectRule": convertCfnBucketRedirectRulePropertyToCloudFormation(properties.redirectRule),
    "RoutingRuleCondition": convertCfnBucketRoutingRuleConditionPropertyToCloudFormation(properties.routingRuleCondition)
  };
}

// @ts-ignore TS6133
function CfnBucketRoutingRulePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnBucket.RoutingRuleProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnBucket.RoutingRuleProperty>();
  ret.addPropertyResult("redirectRule", "RedirectRule", (properties.RedirectRule != null ? CfnBucketRedirectRulePropertyFromCloudFormation(properties.RedirectRule) : undefined));
  ret.addPropertyResult("routingRuleCondition", "RoutingRuleCondition", (properties.RoutingRuleCondition != null ? CfnBucketRoutingRuleConditionPropertyFromCloudFormation(properties.RoutingRuleCondition) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`RedirectAllRequestsToProperty\`
 *
 * @param properties - the TypeScript properties of a \`RedirectAllRequestsToProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnBucketRedirectAllRequestsToPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("hostName", cdk.requiredValidator)(properties.hostName));
  errors.collect(cdk.propertyValidator("hostName", cdk.validateString)(properties.hostName));
  errors.collect(cdk.propertyValidator("protocol", cdk.validateString)(properties.protocol));
  return errors.wrap("supplied properties not correct for \\"RedirectAllRequestsToProperty\\"");
}

// @ts-ignore TS6133
function convertCfnBucketRedirectAllRequestsToPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnBucketRedirectAllRequestsToPropertyValidator(properties).assertSuccess();
  return {
    "HostName": cdk.stringToCloudFormation(properties.hostName),
    "Protocol": cdk.stringToCloudFormation(properties.protocol)
  };
}

// @ts-ignore TS6133
function CfnBucketRedirectAllRequestsToPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnBucket.RedirectAllRequestsToProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnBucket.RedirectAllRequestsToProperty>();
  ret.addPropertyResult("hostName", "HostName", (properties.HostName != null ? cfn_parse.FromCloudFormation.getString(properties.HostName) : undefined));
  ret.addPropertyResult("protocol", "Protocol", (properties.Protocol != null ? cfn_parse.FromCloudFormation.getString(properties.Protocol) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`WebsiteConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`WebsiteConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnBucketWebsiteConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("errorDocument", cdk.validateString)(properties.errorDocument));
  errors.collect(cdk.propertyValidator("indexDocument", cdk.validateString)(properties.indexDocument));
  errors.collect(cdk.propertyValidator("redirectAllRequestsTo", CfnBucketRedirectAllRequestsToPropertyValidator)(properties.redirectAllRequestsTo));
  errors.collect(cdk.propertyValidator("routingRules", cdk.listValidator(CfnBucketRoutingRulePropertyValidator))(properties.routingRules));
  return errors.wrap("supplied properties not correct for \\"WebsiteConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnBucketWebsiteConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnBucketWebsiteConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "ErrorDocument": cdk.stringToCloudFormation(properties.errorDocument),
    "IndexDocument": cdk.stringToCloudFormation(properties.indexDocument),
    "RedirectAllRequestsTo": convertCfnBucketRedirectAllRequestsToPropertyToCloudFormation(properties.redirectAllRequestsTo),
    "RoutingRules": cdk.listMapper(convertCfnBucketRoutingRulePropertyToCloudFormation)(properties.routingRules)
  };
}

// @ts-ignore TS6133
function CfnBucketWebsiteConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnBucket.WebsiteConfigurationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnBucket.WebsiteConfigurationProperty>();
  ret.addPropertyResult("errorDocument", "ErrorDocument", (properties.ErrorDocument != null ? cfn_parse.FromCloudFormation.getString(properties.ErrorDocument) : undefined));
  ret.addPropertyResult("indexDocument", "IndexDocument", (properties.IndexDocument != null ? cfn_parse.FromCloudFormation.getString(properties.IndexDocument) : undefined));
  ret.addPropertyResult("redirectAllRequestsTo", "RedirectAllRequestsTo", (properties.RedirectAllRequestsTo != null ? CfnBucketRedirectAllRequestsToPropertyFromCloudFormation(properties.RedirectAllRequestsTo) : undefined));
  ret.addPropertyResult("routingRules", "RoutingRules", (properties.RoutingRules != null ? cfn_parse.FromCloudFormation.getArray(CfnBucketRoutingRulePropertyFromCloudFormation)(properties.RoutingRules) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnBucketProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnBucketProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnBucketPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("accelerateConfiguration", CfnBucketAccelerateConfigurationPropertyValidator)(properties.accelerateConfiguration));
  errors.collect(cdk.propertyValidator("accessControl", cdk.validateString)(properties.accessControl));
  errors.collect(cdk.propertyValidator("analyticsConfigurations", cdk.listValidator(CfnBucketAnalyticsConfigurationPropertyValidator))(properties.analyticsConfigurations));
  errors.collect(cdk.propertyValidator("bucketEncryption", CfnBucketBucketEncryptionPropertyValidator)(properties.bucketEncryption));
  errors.collect(cdk.propertyValidator("bucketName", cdk.validateString)(properties.bucketName));
  errors.collect(cdk.propertyValidator("corsConfiguration", CfnBucketCorsConfigurationPropertyValidator)(properties.corsConfiguration));
  errors.collect(cdk.propertyValidator("intelligentTieringConfigurations", cdk.listValidator(CfnBucketIntelligentTieringConfigurationPropertyValidator))(properties.intelligentTieringConfigurations));
  errors.collect(cdk.propertyValidator("inventoryConfigurations", cdk.listValidator(CfnBucketInventoryConfigurationPropertyValidator))(properties.inventoryConfigurations));
  errors.collect(cdk.propertyValidator("lifecycleConfiguration", CfnBucketLifecycleConfigurationPropertyValidator)(properties.lifecycleConfiguration));
  errors.collect(cdk.propertyValidator("loggingConfiguration", CfnBucketLoggingConfigurationPropertyValidator)(properties.loggingConfiguration));
  errors.collect(cdk.propertyValidator("metricsConfigurations", cdk.listValidator(CfnBucketMetricsConfigurationPropertyValidator))(properties.metricsConfigurations));
  errors.collect(cdk.propertyValidator("notificationConfiguration", CfnBucketNotificationConfigurationPropertyValidator)(properties.notificationConfiguration));
  errors.collect(cdk.propertyValidator("objectLockConfiguration", CfnBucketObjectLockConfigurationPropertyValidator)(properties.objectLockConfiguration));
  errors.collect(cdk.propertyValidator("objectLockEnabled", cdk.validateBoolean)(properties.objectLockEnabled));
  errors.collect(cdk.propertyValidator("ownershipControls", CfnBucketOwnershipControlsPropertyValidator)(properties.ownershipControls));
  errors.collect(cdk.propertyValidator("publicAccessBlockConfiguration", CfnBucketPublicAccessBlockConfigurationPropertyValidator)(properties.publicAccessBlockConfiguration));
  errors.collect(cdk.propertyValidator("replicationConfiguration", CfnBucketReplicationConfigurationPropertyValidator)(properties.replicationConfiguration));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("versioningConfiguration", CfnBucketVersioningConfigurationPropertyValidator)(properties.versioningConfiguration));
  errors.collect(cdk.propertyValidator("websiteConfiguration", CfnBucketWebsiteConfigurationPropertyValidator)(properties.websiteConfiguration));
  return errors.wrap("supplied properties not correct for \\"CfnBucketProps\\"");
}

// @ts-ignore TS6133
function convertCfnBucketPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnBucketPropsValidator(properties).assertSuccess();
  return {
    "AccelerateConfiguration": convertCfnBucketAccelerateConfigurationPropertyToCloudFormation(properties.accelerateConfiguration),
    "AccessControl": cdk.stringToCloudFormation(properties.accessControl),
    "AnalyticsConfigurations": cdk.listMapper(convertCfnBucketAnalyticsConfigurationPropertyToCloudFormation)(properties.analyticsConfigurations),
    "BucketEncryption": convertCfnBucketBucketEncryptionPropertyToCloudFormation(properties.bucketEncryption),
    "BucketName": cdk.stringToCloudFormation(properties.bucketName),
    "CorsConfiguration": convertCfnBucketCorsConfigurationPropertyToCloudFormation(properties.corsConfiguration),
    "IntelligentTieringConfigurations": cdk.listMapper(convertCfnBucketIntelligentTieringConfigurationPropertyToCloudFormation)(properties.intelligentTieringConfigurations),
    "InventoryConfigurations": cdk.listMapper(convertCfnBucketInventoryConfigurationPropertyToCloudFormation)(properties.inventoryConfigurations),
    "LifecycleConfiguration": convertCfnBucketLifecycleConfigurationPropertyToCloudFormation(properties.lifecycleConfiguration),
    "LoggingConfiguration": convertCfnBucketLoggingConfigurationPropertyToCloudFormation(properties.loggingConfiguration),
    "MetricsConfigurations": cdk.listMapper(convertCfnBucketMetricsConfigurationPropertyToCloudFormation)(properties.metricsConfigurations),
    "NotificationConfiguration": convertCfnBucketNotificationConfigurationPropertyToCloudFormation(properties.notificationConfiguration),
    "ObjectLockConfiguration": convertCfnBucketObjectLockConfigurationPropertyToCloudFormation(properties.objectLockConfiguration),
    "ObjectLockEnabled": cdk.booleanToCloudFormation(properties.objectLockEnabled),
    "OwnershipControls": convertCfnBucketOwnershipControlsPropertyToCloudFormation(properties.ownershipControls),
    "PublicAccessBlockConfiguration": convertCfnBucketPublicAccessBlockConfigurationPropertyToCloudFormation(properties.publicAccessBlockConfiguration),
    "ReplicationConfiguration": convertCfnBucketReplicationConfigurationPropertyToCloudFormation(properties.replicationConfiguration),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "VersioningConfiguration": convertCfnBucketVersioningConfigurationPropertyToCloudFormation(properties.versioningConfiguration),
    "WebsiteConfiguration": convertCfnBucketWebsiteConfigurationPropertyToCloudFormation(properties.websiteConfiguration)
  };
}

// @ts-ignore TS6133
function CfnBucketPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnBucketProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnBucketProps>();
  ret.addPropertyResult("accelerateConfiguration", "AccelerateConfiguration", (properties.AccelerateConfiguration != null ? CfnBucketAccelerateConfigurationPropertyFromCloudFormation(properties.AccelerateConfiguration) : undefined));
  ret.addPropertyResult("accessControl", "AccessControl", (properties.AccessControl != null ? cfn_parse.FromCloudFormation.getString(properties.AccessControl) : undefined));
  ret.addPropertyResult("analyticsConfigurations", "AnalyticsConfigurations", (properties.AnalyticsConfigurations != null ? cfn_parse.FromCloudFormation.getArray(CfnBucketAnalyticsConfigurationPropertyFromCloudFormation)(properties.AnalyticsConfigurations) : undefined));
  ret.addPropertyResult("bucketEncryption", "BucketEncryption", (properties.BucketEncryption != null ? CfnBucketBucketEncryptionPropertyFromCloudFormation(properties.BucketEncryption) : undefined));
  ret.addPropertyResult("bucketName", "BucketName", (properties.BucketName != null ? cfn_parse.FromCloudFormation.getString(properties.BucketName) : undefined));
  ret.addPropertyResult("corsConfiguration", "CorsConfiguration", (properties.CorsConfiguration != null ? CfnBucketCorsConfigurationPropertyFromCloudFormation(properties.CorsConfiguration) : undefined));
  ret.addPropertyResult("intelligentTieringConfigurations", "IntelligentTieringConfigurations", (properties.IntelligentTieringConfigurations != null ? cfn_parse.FromCloudFormation.getArray(CfnBucketIntelligentTieringConfigurationPropertyFromCloudFormation)(properties.IntelligentTieringConfigurations) : undefined));
  ret.addPropertyResult("inventoryConfigurations", "InventoryConfigurations", (properties.InventoryConfigurations != null ? cfn_parse.FromCloudFormation.getArray(CfnBucketInventoryConfigurationPropertyFromCloudFormation)(properties.InventoryConfigurations) : undefined));
  ret.addPropertyResult("lifecycleConfiguration", "LifecycleConfiguration", (properties.LifecycleConfiguration != null ? CfnBucketLifecycleConfigurationPropertyFromCloudFormation(properties.LifecycleConfiguration) : undefined));
  ret.addPropertyResult("loggingConfiguration", "LoggingConfiguration", (properties.LoggingConfiguration != null ? CfnBucketLoggingConfigurationPropertyFromCloudFormation(properties.LoggingConfiguration) : undefined));
  ret.addPropertyResult("metricsConfigurations", "MetricsConfigurations", (properties.MetricsConfigurations != null ? cfn_parse.FromCloudFormation.getArray(CfnBucketMetricsConfigurationPropertyFromCloudFormation)(properties.MetricsConfigurations) : undefined));
  ret.addPropertyResult("notificationConfiguration", "NotificationConfiguration", (properties.NotificationConfiguration != null ? CfnBucketNotificationConfigurationPropertyFromCloudFormation(properties.NotificationConfiguration) : undefined));
  ret.addPropertyResult("objectLockConfiguration", "ObjectLockConfiguration", (properties.ObjectLockConfiguration != null ? CfnBucketObjectLockConfigurationPropertyFromCloudFormation(properties.ObjectLockConfiguration) : undefined));
  ret.addPropertyResult("objectLockEnabled", "ObjectLockEnabled", (properties.ObjectLockEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.ObjectLockEnabled) : undefined));
  ret.addPropertyResult("ownershipControls", "OwnershipControls", (properties.OwnershipControls != null ? CfnBucketOwnershipControlsPropertyFromCloudFormation(properties.OwnershipControls) : undefined));
  ret.addPropertyResult("publicAccessBlockConfiguration", "PublicAccessBlockConfiguration", (properties.PublicAccessBlockConfiguration != null ? CfnBucketPublicAccessBlockConfigurationPropertyFromCloudFormation(properties.PublicAccessBlockConfiguration) : undefined));
  ret.addPropertyResult("replicationConfiguration", "ReplicationConfiguration", (properties.ReplicationConfiguration != null ? CfnBucketReplicationConfigurationPropertyFromCloudFormation(properties.ReplicationConfiguration) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("versioningConfiguration", "VersioningConfiguration", (properties.VersioningConfiguration != null ? CfnBucketVersioningConfigurationPropertyFromCloudFormation(properties.VersioningConfiguration) : undefined));
  ret.addPropertyResult("websiteConfiguration", "WebsiteConfiguration", (properties.WebsiteConfiguration != null ? CfnBucketWebsiteConfigurationPropertyFromCloudFormation(properties.WebsiteConfiguration) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}",
}
`;

exports[`AWS::SQS::Queue 1`] = `
{
  "augmentations": "// Copyright 2012-2023 Amazon.com, Inc. or its affiliates. All Rights Reserved.
/* eslint-disable prettier/prettier,max-len */
import * as cw from "aws-cdk-lib/aws-cloudwatch";
import { QueueBase } from "./queue-base";

declare module "./queue-base" {
  interface IQueue {
    /**
     * Return the given named metric for this Queue
     */
    metric(metricName: string, props?: cw.MetricOptions): cw.Metric;

    /**
     * The approximate age of the oldest non-deleted message in the queue.
     *
     * Maximum over 5 minutes
     */
    metricApproximateAgeOfOldestMessage(props?: cw.MetricOptions): cw.Metric;

    /**
     * The number of messages in the queue that are delayed and not available for reading immediately.
     *
     * Maximum over 5 minutes
     */
    metricApproximateNumberOfMessagesDelayed(props?: cw.MetricOptions): cw.Metric;

    /**
     * The number of messages that are in flight.
     *
     * Maximum over 5 minutes
     */
    metricApproximateNumberOfMessagesNotVisible(props?: cw.MetricOptions): cw.Metric;

    /**
     * The number of messages available for retrieval from the queue.
     *
     * Maximum over 5 minutes
     */
    metricApproximateNumberOfMessagesVisible(props?: cw.MetricOptions): cw.Metric;

    /**
     * The number of ReceiveMessage API calls that did not return a message.
     *
     * Sum over 5 minutes
     */
    metricNumberOfEmptyReceives(props?: cw.MetricOptions): cw.Metric;

    /**
     * The number of messages deleted from the queue.
     *
     * Sum over 5 minutes
     */
    metricNumberOfMessagesDeleted(props?: cw.MetricOptions): cw.Metric;

    /**
     * The number of messages returned by calls to the ReceiveMessage action.
     *
     * Sum over 5 minutes
     */
    metricNumberOfMessagesReceived(props?: cw.MetricOptions): cw.Metric;

    /**
     * The number of messages added to a queue.
     *
     * Sum over 5 minutes
     */
    metricNumberOfMessagesSent(props?: cw.MetricOptions): cw.Metric;

    /**
     * The size of messages added to a queue.
     *
     * Average over 5 minutes
     */
    metricSentMessageSize(props?: cw.MetricOptions): cw.Metric;
  }
}



declare module "./queue-base" {
  interface QueueBase {
    /**
     * Return the given named metric for this Queue
     */
    metric(metricName: string, props?: cw.MetricOptions): cw.Metric;

    /**
     * The approximate age of the oldest non-deleted message in the queue.
     *
     * Maximum over 5 minutes
     */
    metricApproximateAgeOfOldestMessage(props?: cw.MetricOptions): cw.Metric;

    /**
     * The number of messages in the queue that are delayed and not available for reading immediately.
     *
     * Maximum over 5 minutes
     */
    metricApproximateNumberOfMessagesDelayed(props?: cw.MetricOptions): cw.Metric;

    /**
     * The number of messages that are in flight.
     *
     * Maximum over 5 minutes
     */
    metricApproximateNumberOfMessagesNotVisible(props?: cw.MetricOptions): cw.Metric;

    /**
     * The number of messages available for retrieval from the queue.
     *
     * Maximum over 5 minutes
     */
    metricApproximateNumberOfMessagesVisible(props?: cw.MetricOptions): cw.Metric;

    /**
     * The number of ReceiveMessage API calls that did not return a message.
     *
     * Sum over 5 minutes
     */
    metricNumberOfEmptyReceives(props?: cw.MetricOptions): cw.Metric;

    /**
     * The number of messages deleted from the queue.
     *
     * Sum over 5 minutes
     */
    metricNumberOfMessagesDeleted(props?: cw.MetricOptions): cw.Metric;

    /**
     * The number of messages returned by calls to the ReceiveMessage action.
     *
     * Sum over 5 minutes
     */
    metricNumberOfMessagesReceived(props?: cw.MetricOptions): cw.Metric;

    /**
     * The number of messages added to a queue.
     *
     * Sum over 5 minutes
     */
    metricNumberOfMessagesSent(props?: cw.MetricOptions): cw.Metric;

    /**
     * The size of messages added to a queue.
     *
     * Average over 5 minutes
     */
    metricSentMessageSize(props?: cw.MetricOptions): cw.Metric;
  }
}

QueueBase.prototype.metric = function(metricName: string, props?: cw.MetricOptions) {
  return new cw.Metric({
    "namespace": "AWS/SQS",
    "metricName": metricName,
    "dimensionsMap": {
      "QueueName": this.queueName
    },
    ...props
  }).attachTo(this);
};
QueueBase.prototype.metricApproximateAgeOfOldestMessage = function(props?: cw.MetricOptions) {
  return this.metric("ApproximateAgeOfOldestMessage", {
    "statistic": "Maximum",
    ...props
  });
};
QueueBase.prototype.metricApproximateNumberOfMessagesDelayed = function(props?: cw.MetricOptions) {
  return this.metric("ApproximateNumberOfMessagesDelayed", {
    "statistic": "Maximum",
    ...props
  });
};
QueueBase.prototype.metricApproximateNumberOfMessagesNotVisible = function(props?: cw.MetricOptions) {
  return this.metric("ApproximateNumberOfMessagesNotVisible", {
    "statistic": "Maximum",
    ...props
  });
};
QueueBase.prototype.metricApproximateNumberOfMessagesVisible = function(props?: cw.MetricOptions) {
  return this.metric("ApproximateNumberOfMessagesVisible", {
    "statistic": "Maximum",
    ...props
  });
};
QueueBase.prototype.metricNumberOfEmptyReceives = function(props?: cw.MetricOptions) {
  return this.metric("NumberOfEmptyReceives", {
    "statistic": "Sum",
    ...props
  });
};
QueueBase.prototype.metricNumberOfMessagesDeleted = function(props?: cw.MetricOptions) {
  return this.metric("NumberOfMessagesDeleted", {
    "statistic": "Sum",
    ...props
  });
};
QueueBase.prototype.metricNumberOfMessagesReceived = function(props?: cw.MetricOptions) {
  return this.metric("NumberOfMessagesReceived", {
    "statistic": "Sum",
    ...props
  });
};
QueueBase.prototype.metricNumberOfMessagesSent = function(props?: cw.MetricOptions) {
  return this.metric("NumberOfMessagesSent", {
    "statistic": "Sum",
    ...props
  });
};
QueueBase.prototype.metricSentMessageSize = function(props?: cw.MetricOptions) {
  return this.metric("SentMessageSize", {
    "statistic": "Average",
    ...props
  });
};",
  "metrics": "/* eslint-disable prettier/prettier,max-len */
export interface MetricWithDims<D> {
  readonly namespace: string;

  readonly metricName: string;

  readonly statistic: string;

  readonly dimensionsMap: D;
}

export class SQSMetrics {
  public static numberOfMessagesSentAverage(dimensions: { QueueName: string; }): MetricWithDims<{ QueueName: string; }> {
    return {
      "namespace": "AWS/SQS",
      "metricName": "NumberOfMessagesSent",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static approximateNumberOfMessagesDelayedAverage(dimensions: { QueueName: string; }): MetricWithDims<{ QueueName: string; }> {
    return {
      "namespace": "AWS/SQS",
      "metricName": "ApproximateNumberOfMessagesDelayed",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static numberOfMessagesReceivedAverage(dimensions: { QueueName: string; }): MetricWithDims<{ QueueName: string; }> {
    return {
      "namespace": "AWS/SQS",
      "metricName": "NumberOfMessagesReceived",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static numberOfMessagesDeletedAverage(dimensions: { QueueName: string; }): MetricWithDims<{ QueueName: string; }> {
    return {
      "namespace": "AWS/SQS",
      "metricName": "NumberOfMessagesDeleted",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static approximateNumberOfMessagesNotVisibleAverage(dimensions: { QueueName: string; }): MetricWithDims<{ QueueName: string; }> {
    return {
      "namespace": "AWS/SQS",
      "metricName": "ApproximateNumberOfMessagesNotVisible",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static approximateNumberOfMessagesVisibleAverage(dimensions: { QueueName: string; }): MetricWithDims<{ QueueName: string; }> {
    return {
      "namespace": "AWS/SQS",
      "metricName": "ApproximateNumberOfMessagesVisible",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static approximateAgeOfOldestMessageAverage(dimensions: { QueueName: string; }): MetricWithDims<{ QueueName: string; }> {
    return {
      "namespace": "AWS/SQS",
      "metricName": "ApproximateAgeOfOldestMessage",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static numberOfEmptyReceivesAverage(dimensions: { QueueName: string; }): MetricWithDims<{ QueueName: string; }> {
    return {
      "namespace": "AWS/SQS",
      "metricName": "NumberOfEmptyReceives",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static sentMessageSizeAverage(dimensions: { QueueName: string; }): MetricWithDims<{ QueueName: string; }> {
    return {
      "namespace": "AWS/SQS",
      "metricName": "SentMessageSize",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }
}",
  "module": "/* eslint-disable prettier/prettier,max-len */
import * as cdk from "aws-cdk-lib";
import * as constructs from "constructs";
import * as cfn_parse from "aws-cdk-lib/core/lib/helpers-internal";

/**
 * The \`AWS::SQS::Queue\` resource creates an Amazon SQS standard or FIFO queue.
 *
 * Keep the following caveats in mind:
 *
 * - If you don't specify the \`FifoQueue\` property, Amazon SQS creates a standard queue.
 *
 * > You can't change the queue type after you create it and you can't convert an existing standard queue into a FIFO queue. You must either create a new FIFO queue for your application or delete your existing standard queue and recreate it as a FIFO queue. For more information, see [Moving from a standard queue to a FIFO queue](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/FIFO-queues-moving.html) in the *Amazon SQS Developer Guide* .
 * - If you don't provide a value for a property, the queue is created with the default value for the property.
 * - If you delete a queue, you must wait at least 60 seconds before creating a queue with the same name.
 * - To successfully create a new queue, you must provide a queue name that adheres to the [limits related to queues](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/limits-queues.html) and is unique within the scope of your queues.
 *
 * For more information about creating FIFO (first-in-first-out) queues, see [Creating an Amazon SQS queue ( AWS CloudFormation )](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/screate-queue-cloudformation.html) in the *Amazon SQS Developer Guide* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html
 */
export class CfnQueue extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::SQS::Queue";

  /**
   * Build a CfnQueue from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnQueue {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnQueuePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnQueue(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * Returns the Amazon Resource Name (ARN) of the queue. For example: \`arn:aws:sqs:us-east-2:123456789012:mystack-myqueue-15PG5C2FC1CW8\` .
   *
   * @cloudformationAttribute Arn
   */
  public readonly attrArn: string;

  /**
   * Returns the queue name. For example: \`mystack-myqueue-1VF9BKQH5BJVI\` .
   *
   * @cloudformationAttribute QueueName
   */
  public readonly attrQueueName: string;

  /**
   * Returns the URLs of the queues from the policy.
   *
   * @cloudformationAttribute QueueUrl
   */
  public readonly attrQueueUrl: string;

  /**
   * For first-in-first-out (FIFO) queues, specifies whether to enable content-based deduplication.
   */
  public contentBasedDeduplication?: boolean | cdk.IResolvable;

  /**
   * For high throughput for FIFO queues, specifies whether message deduplication occurs at the message group or queue level.
   */
  public deduplicationScope?: string;

  /**
   * The time in seconds for which the delivery of all messages in the queue is delayed.
   */
  public delaySeconds?: number;

  /**
   * If set to true, creates a FIFO queue.
   */
  public fifoQueue?: boolean | cdk.IResolvable;

  /**
   * For high throughput for FIFO queues, specifies whether the FIFO queue throughput quota applies to the entire queue or per message group.
   */
  public fifoThroughputLimit?: string;

  /**
   * The length of time in seconds for which Amazon SQS can reuse a data key to encrypt or decrypt messages before calling AWS KMS again.
   */
  public kmsDataKeyReusePeriodSeconds?: number;

  /**
   * The ID of an AWS Key Management Service (KMS) for Amazon SQS , or a custom KMS.
   */
  public kmsMasterKeyId?: string;

  /**
   * The limit of how many bytes that a message can contain before Amazon SQS rejects it.
   */
  public maximumMessageSize?: number;

  /**
   * The number of seconds that Amazon SQS retains a message.
   */
  public messageRetentionPeriod?: number;

  /**
   * A name for the queue.
   */
  public queueName?: string;

  /**
   * Specifies the duration, in seconds, that the ReceiveMessage action call waits until a message is in the queue in order to include it in the response, rather than returning an empty response if a message isn't yet available.
   */
  public receiveMessageWaitTimeSeconds?: number;

  /**
   * The string that includes the parameters for the permissions for the dead-letter queue redrive permission and which source queues can specify dead-letter queues as a JSON object.
   */
  public redriveAllowPolicy?: any | cdk.IResolvable;

  /**
   * The string that includes the parameters for the dead-letter queue functionality of the source queue as a JSON object.
   */
  public redrivePolicy?: any | cdk.IResolvable;

  /**
   * Enables server-side queue encryption using SQS owned encryption keys.
   */
  public sqsManagedSseEnabled?: boolean | cdk.IResolvable;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags that you attach to this queue.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The length of time during which a message will be unavailable after a message is delivered from the queue.
   */
  public visibilityTimeout?: number;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnQueueProps = {}) {
    super(scope, id, {
      "type": CfnQueue.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.attrArn = cdk.Token.asString(this.getAtt("Arn", cdk.ResolutionTypeHint.STRING));
    this.attrQueueName = cdk.Token.asString(this.getAtt("QueueName", cdk.ResolutionTypeHint.STRING));
    this.attrQueueUrl = cdk.Token.asString(this.getAtt("QueueUrl", cdk.ResolutionTypeHint.STRING));
    this.contentBasedDeduplication = props.contentBasedDeduplication;
    this.deduplicationScope = props.deduplicationScope;
    this.delaySeconds = props.delaySeconds;
    this.fifoQueue = props.fifoQueue;
    this.fifoThroughputLimit = props.fifoThroughputLimit;
    this.kmsDataKeyReusePeriodSeconds = props.kmsDataKeyReusePeriodSeconds;
    this.kmsMasterKeyId = props.kmsMasterKeyId;
    this.maximumMessageSize = props.maximumMessageSize;
    this.messageRetentionPeriod = props.messageRetentionPeriod;
    this.queueName = props.queueName;
    this.receiveMessageWaitTimeSeconds = props.receiveMessageWaitTimeSeconds;
    this.redriveAllowPolicy = props.redriveAllowPolicy;
    this.redrivePolicy = props.redrivePolicy;
    this.sqsManagedSseEnabled = props.sqsManagedSseEnabled;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::SQS::Queue", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.visibilityTimeout = props.visibilityTimeout;
    if ((this.node.scope != null && cdk.Resource.isResource(this.node.scope))) {
      this.node.addValidation({
        "validate": () => ((this.cfnOptions.deletionPolicy === undefined) ? ["'AWS::SQS::Queue' is a stateful resource type, and you must specify a Removal Policy for it. Call 'resource.applyRemovalPolicy()'."] : [])
      });
    }
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "contentBasedDeduplication": this.contentBasedDeduplication,
      "deduplicationScope": this.deduplicationScope,
      "delaySeconds": this.delaySeconds,
      "fifoQueue": this.fifoQueue,
      "fifoThroughputLimit": this.fifoThroughputLimit,
      "kmsDataKeyReusePeriodSeconds": this.kmsDataKeyReusePeriodSeconds,
      "kmsMasterKeyId": this.kmsMasterKeyId,
      "maximumMessageSize": this.maximumMessageSize,
      "messageRetentionPeriod": this.messageRetentionPeriod,
      "queueName": this.queueName,
      "receiveMessageWaitTimeSeconds": this.receiveMessageWaitTimeSeconds,
      "redriveAllowPolicy": this.redriveAllowPolicy,
      "redrivePolicy": this.redrivePolicy,
      "sqsManagedSseEnabled": this.sqsManagedSseEnabled,
      "tags": this.tags.renderTags(),
      "visibilityTimeout": this.visibilityTimeout
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnQueue.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnQueuePropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnQueue\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html
 */
export interface CfnQueueProps {
  /**
   * For first-in-first-out (FIFO) queues, specifies whether to enable content-based deduplication.
   *
   * During the deduplication interval, Amazon SQS treats messages that are sent with identical content as duplicates and delivers only one copy of the message. For more information, see the \`ContentBasedDeduplication\` attribute for the \`[CreateQueue](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/APIReference/API_CreateQueue.html)\` action in the *Amazon SQS API Reference* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-contentbaseddeduplication
   */
  readonly contentBasedDeduplication?: boolean | cdk.IResolvable;

  /**
   * For high throughput for FIFO queues, specifies whether message deduplication occurs at the message group or queue level.
   *
   * Valid values are \`messageGroup\` and \`queue\` .
   *
   * To enable high throughput for a FIFO queue, set this attribute to \`messageGroup\` *and* set the \`FifoThroughputLimit\` attribute to \`perMessageGroupId\` . If you set these attributes to anything other than these values, normal throughput is in effect and deduplication occurs as specified. For more information, see [High throughput for FIFO queues](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/high-throughput-fifo.html) and [Quotas related to messages](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/quotas-messages.html) in the *Amazon SQS Developer Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-deduplicationscope
   */
  readonly deduplicationScope?: string;

  /**
   * The time in seconds for which the delivery of all messages in the queue is delayed.
   *
   * You can specify an integer value of \`0\` to \`900\` (15 minutes). The default value is \`0\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-delayseconds
   */
  readonly delaySeconds?: number;

  /**
   * If set to true, creates a FIFO queue.
   *
   * If you don't specify this property, Amazon SQS creates a standard queue. For more information, see [FIFO queues](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/FIFO-queues.html) in the *Amazon SQS Developer Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-fifoqueue
   */
  readonly fifoQueue?: boolean | cdk.IResolvable;

  /**
   * For high throughput for FIFO queues, specifies whether the FIFO queue throughput quota applies to the entire queue or per message group.
   *
   * Valid values are \`perQueue\` and \`perMessageGroupId\` .
   *
   * To enable high throughput for a FIFO queue, set this attribute to \`perMessageGroupId\` *and* set the \`DeduplicationScope\` attribute to \`messageGroup\` . If you set these attributes to anything other than these values, normal throughput is in effect and deduplication occurs as specified. For more information, see [High throughput for FIFO queues](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/high-throughput-fifo.html) and [Quotas related to messages](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/quotas-messages.html) in the *Amazon SQS Developer Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-fifothroughputlimit
   */
  readonly fifoThroughputLimit?: string;

  /**
   * The length of time in seconds for which Amazon SQS can reuse a data key to encrypt or decrypt messages before calling AWS KMS again.
   *
   * The value must be an integer between 60 (1 minute) and 86,400 (24 hours). The default is 300 (5 minutes).
   *
   * > A shorter time period provides better security, but results in more calls to AWS KMS , which might incur charges after Free Tier. For more information, see [Encryption at rest](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-server-side-encryption.html#sqs-how-does-the-data-key-reuse-period-work) in the *Amazon SQS Developer Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-kmsdatakeyreuseperiodseconds
   */
  readonly kmsDataKeyReusePeriodSeconds?: number;

  /**
   * The ID of an AWS Key Management Service (KMS) for Amazon SQS , or a custom KMS.
   *
   * To use the AWS managed KMS for Amazon SQS , specify a (default) alias ARN, alias name (e.g. \`alias/aws/sqs\` ), key ARN, or key ID. For more information, see the following:
   *
   * - [Encryption at rest](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-server-side-encryption.html) in the *Amazon SQS Developer Guide*
   * - [CreateQueue](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/APIReference/API_CreateQueue.html) in the *Amazon SQS API Reference*
   * - [Request Parameters](https://docs.aws.amazon.com/kms/latest/APIReference/API_DescribeKey.html#API_DescribeKey_RequestParameters) in the *AWS Key Management Service API Reference*
   * - The Key Management Service (KMS) section of the [AWS Key Management Service Best Practices](https://docs.aws.amazon.com/https://d0.awsstatic.com/whitepapers/aws-kms-best-practices.pdf) whitepaper
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-kmsmasterkeyid
   */
  readonly kmsMasterKeyId?: string;

  /**
   * The limit of how many bytes that a message can contain before Amazon SQS rejects it.
   *
   * You can specify an integer value from \`1,024\` bytes (1 KiB) to \`262,144\` bytes (256 KiB). The default value is \`262,144\` (256 KiB).
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-maximummessagesize
   */
  readonly maximumMessageSize?: number;

  /**
   * The number of seconds that Amazon SQS retains a message.
   *
   * You can specify an integer value from \`60\` seconds (1 minute) to \`1,209,600\` seconds (14 days). The default value is \`345,600\` seconds (4 days).
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-messageretentionperiod
   */
  readonly messageRetentionPeriod?: number;

  /**
   * A name for the queue.
   *
   * To create a FIFO queue, the name of your FIFO queue must end with the \`.fifo\` suffix. For more information, see [FIFO queues](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/FIFO-queues.html) in the *Amazon SQS Developer Guide* .
   *
   * If you don't specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the queue name. For more information, see [Name type](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-name.html) in the *AWS CloudFormation User Guide* .
   *
   * > If you specify a name, you can't perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you must replace the resource, specify a new name.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-queuename
   */
  readonly queueName?: string;

  /**
   * Specifies the duration, in seconds, that the ReceiveMessage action call waits until a message is in the queue in order to include it in the response, rather than returning an empty response if a message isn't yet available.
   *
   * You can specify an integer from 1 to 20. Short polling is used as the default or when you specify 0 for this property. For more information, see [Consuming messages using long polling](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-short-and-long-polling.html#sqs-long-polling) in the *Amazon SQS Developer Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-receivemessagewaittimeseconds
   */
  readonly receiveMessageWaitTimeSeconds?: number;

  /**
   * The string that includes the parameters for the permissions for the dead-letter queue redrive permission and which source queues can specify dead-letter queues as a JSON object.
   *
   * The parameters are as follows:
   *
   * - \`redrivePermission\` : The permission type that defines which source queues can specify the current queue as the dead-letter queue. Valid values are:
   *
   * - \`allowAll\` : (Default) Any source queues in this AWS account in the same Region can specify this queue as the dead-letter queue.
   * - \`denyAll\` : No source queues can specify this queue as the dead-letter queue.
   * - \`byQueue\` : Only queues specified by the \`sourceQueueArns\` parameter can specify this queue as the dead-letter queue.
   * - \`sourceQueueArns\` : The Amazon Resource Names (ARN)s of the source queues that can specify this queue as the dead-letter queue and redrive messages. You can specify this parameter only when the \`redrivePermission\` parameter is set to \`byQueue\` . You can specify up to 10 source queue ARNs. To allow more than 10 source queues to specify dead-letter queues, set the \`redrivePermission\` parameter to \`allowAll\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-redriveallowpolicy
   */
  readonly redriveAllowPolicy?: any | cdk.IResolvable;

  /**
   * The string that includes the parameters for the dead-letter queue functionality of the source queue as a JSON object.
   *
   * The parameters are as follows:
   *
   * - \`deadLetterTargetArn\` : The Amazon Resource Name (ARN) of the dead-letter queue to which Amazon SQS moves messages after the value of \`maxReceiveCount\` is exceeded.
   * - \`maxReceiveCount\` : The number of times a message is delivered to the source queue before being moved to the dead-letter queue. When the \`ReceiveCount\` for a message exceeds the \`maxReceiveCount\` for a queue, Amazon SQS moves the message to the dead-letter-queue.
   *
   * > The dead-letter queue of a FIFO queue must also be a FIFO queue. Similarly, the dead-letter queue of a standard queue must also be a standard queue.
   *
   * *JSON*
   *
   * \`{ "deadLetterTargetArn" : *String* , "maxReceiveCount" : *Integer* }\`
   *
   * *YAML*
   *
   * \`deadLetterTargetArn : *String*\`
   *
   * \`maxReceiveCount : *Integer*\`
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-redrivepolicy
   */
  readonly redrivePolicy?: any | cdk.IResolvable;

  /**
   * Enables server-side queue encryption using SQS owned encryption keys.
   *
   * Only one server-side encryption option is supported per queue (for example, [SSE-KMS](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-configure-sse-existing-queue.html) or [SSE-SQS](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-configure-sqs-sse-queue.html) ).
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-sqsmanagedsseenabled
   */
  readonly sqsManagedSseEnabled?: boolean | cdk.IResolvable;

  /**
   * The tags that you attach to this queue.
   *
   * For more information, see [Resource tag](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html) in the *AWS CloudFormation User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The length of time during which a message will be unavailable after a message is delivered from the queue.
   *
   * This blocks other components from receiving the same message and gives the initial component time to process and delete the message from the queue.
   *
   * Values must be from 0 to 43,200 seconds (12 hours). If you don't specify a value, AWS CloudFormation uses the default value of 30 seconds.
   *
   * For more information about Amazon SQS queue visibility timeouts, see [Visibility timeout](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-visibility-timeout.html) in the *Amazon SQS Developer Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-visibilitytimeout
   */
  readonly visibilityTimeout?: number;
}

/**
 * Determine whether the given properties match those of a \`CfnQueueProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnQueueProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnQueuePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("contentBasedDeduplication", cdk.validateBoolean)(properties.contentBasedDeduplication));
  errors.collect(cdk.propertyValidator("deduplicationScope", cdk.validateString)(properties.deduplicationScope));
  errors.collect(cdk.propertyValidator("delaySeconds", cdk.validateNumber)(properties.delaySeconds));
  errors.collect(cdk.propertyValidator("fifoQueue", cdk.validateBoolean)(properties.fifoQueue));
  errors.collect(cdk.propertyValidator("fifoThroughputLimit", cdk.validateString)(properties.fifoThroughputLimit));
  errors.collect(cdk.propertyValidator("kmsDataKeyReusePeriodSeconds", cdk.validateNumber)(properties.kmsDataKeyReusePeriodSeconds));
  errors.collect(cdk.propertyValidator("kmsMasterKeyId", cdk.validateString)(properties.kmsMasterKeyId));
  errors.collect(cdk.propertyValidator("maximumMessageSize", cdk.validateNumber)(properties.maximumMessageSize));
  errors.collect(cdk.propertyValidator("messageRetentionPeriod", cdk.validateNumber)(properties.messageRetentionPeriod));
  errors.collect(cdk.propertyValidator("queueName", cdk.validateString)(properties.queueName));
  errors.collect(cdk.propertyValidator("receiveMessageWaitTimeSeconds", cdk.validateNumber)(properties.receiveMessageWaitTimeSeconds));
  errors.collect(cdk.propertyValidator("redriveAllowPolicy", cdk.validateObject)(properties.redriveAllowPolicy));
  errors.collect(cdk.propertyValidator("redrivePolicy", cdk.validateObject)(properties.redrivePolicy));
  errors.collect(cdk.propertyValidator("sqsManagedSseEnabled", cdk.validateBoolean)(properties.sqsManagedSseEnabled));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("visibilityTimeout", cdk.validateNumber)(properties.visibilityTimeout));
  return errors.wrap("supplied properties not correct for \\"CfnQueueProps\\"");
}

// @ts-ignore TS6133
function convertCfnQueuePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnQueuePropsValidator(properties).assertSuccess();
  return {
    "ContentBasedDeduplication": cdk.booleanToCloudFormation(properties.contentBasedDeduplication),
    "DeduplicationScope": cdk.stringToCloudFormation(properties.deduplicationScope),
    "DelaySeconds": cdk.numberToCloudFormation(properties.delaySeconds),
    "FifoQueue": cdk.booleanToCloudFormation(properties.fifoQueue),
    "FifoThroughputLimit": cdk.stringToCloudFormation(properties.fifoThroughputLimit),
    "KmsDataKeyReusePeriodSeconds": cdk.numberToCloudFormation(properties.kmsDataKeyReusePeriodSeconds),
    "KmsMasterKeyId": cdk.stringToCloudFormation(properties.kmsMasterKeyId),
    "MaximumMessageSize": cdk.numberToCloudFormation(properties.maximumMessageSize),
    "MessageRetentionPeriod": cdk.numberToCloudFormation(properties.messageRetentionPeriod),
    "QueueName": cdk.stringToCloudFormation(properties.queueName),
    "ReceiveMessageWaitTimeSeconds": cdk.numberToCloudFormation(properties.receiveMessageWaitTimeSeconds),
    "RedriveAllowPolicy": cdk.objectToCloudFormation(properties.redriveAllowPolicy),
    "RedrivePolicy": cdk.objectToCloudFormation(properties.redrivePolicy),
    "SqsManagedSseEnabled": cdk.booleanToCloudFormation(properties.sqsManagedSseEnabled),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "VisibilityTimeout": cdk.numberToCloudFormation(properties.visibilityTimeout)
  };
}

// @ts-ignore TS6133
function CfnQueuePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnQueueProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnQueueProps>();
  ret.addPropertyResult("contentBasedDeduplication", "ContentBasedDeduplication", (properties.ContentBasedDeduplication != null ? cfn_parse.FromCloudFormation.getBoolean(properties.ContentBasedDeduplication) : undefined));
  ret.addPropertyResult("deduplicationScope", "DeduplicationScope", (properties.DeduplicationScope != null ? cfn_parse.FromCloudFormation.getString(properties.DeduplicationScope) : undefined));
  ret.addPropertyResult("delaySeconds", "DelaySeconds", (properties.DelaySeconds != null ? cfn_parse.FromCloudFormation.getNumber(properties.DelaySeconds) : undefined));
  ret.addPropertyResult("fifoQueue", "FifoQueue", (properties.FifoQueue != null ? cfn_parse.FromCloudFormation.getBoolean(properties.FifoQueue) : undefined));
  ret.addPropertyResult("fifoThroughputLimit", "FifoThroughputLimit", (properties.FifoThroughputLimit != null ? cfn_parse.FromCloudFormation.getString(properties.FifoThroughputLimit) : undefined));
  ret.addPropertyResult("kmsDataKeyReusePeriodSeconds", "KmsDataKeyReusePeriodSeconds", (properties.KmsDataKeyReusePeriodSeconds != null ? cfn_parse.FromCloudFormation.getNumber(properties.KmsDataKeyReusePeriodSeconds) : undefined));
  ret.addPropertyResult("kmsMasterKeyId", "KmsMasterKeyId", (properties.KmsMasterKeyId != null ? cfn_parse.FromCloudFormation.getString(properties.KmsMasterKeyId) : undefined));
  ret.addPropertyResult("maximumMessageSize", "MaximumMessageSize", (properties.MaximumMessageSize != null ? cfn_parse.FromCloudFormation.getNumber(properties.MaximumMessageSize) : undefined));
  ret.addPropertyResult("messageRetentionPeriod", "MessageRetentionPeriod", (properties.MessageRetentionPeriod != null ? cfn_parse.FromCloudFormation.getNumber(properties.MessageRetentionPeriod) : undefined));
  ret.addPropertyResult("queueName", "QueueName", (properties.QueueName != null ? cfn_parse.FromCloudFormation.getString(properties.QueueName) : undefined));
  ret.addPropertyResult("receiveMessageWaitTimeSeconds", "ReceiveMessageWaitTimeSeconds", (properties.ReceiveMessageWaitTimeSeconds != null ? cfn_parse.FromCloudFormation.getNumber(properties.ReceiveMessageWaitTimeSeconds) : undefined));
  ret.addPropertyResult("redriveAllowPolicy", "RedriveAllowPolicy", (properties.RedriveAllowPolicy != null ? cfn_parse.FromCloudFormation.getAny(properties.RedriveAllowPolicy) : undefined));
  ret.addPropertyResult("redrivePolicy", "RedrivePolicy", (properties.RedrivePolicy != null ? cfn_parse.FromCloudFormation.getAny(properties.RedrivePolicy) : undefined));
  ret.addPropertyResult("sqsManagedSseEnabled", "SqsManagedSseEnabled", (properties.SqsManagedSseEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.SqsManagedSseEnabled) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("visibilityTimeout", "VisibilityTimeout", (properties.VisibilityTimeout != null ? cfn_parse.FromCloudFormation.getNumber(properties.VisibilityTimeout) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}",
}
`;

exports[`Alexa::ASK::Skill 1`] = `
{
  "augmentations": undefined,
  "metrics": undefined,
  "module": "/* eslint-disable prettier/prettier,max-len */
import * as cdk from "aws-cdk-lib";
import * as constructs from "constructs";
import * as cfn_parse from "aws-cdk-lib/core/lib/helpers-internal";

/**
 * The \`Alexa::ASK::Skill\` resource creates an Alexa skill that enables customers to access new abilities.
 *
 * For more information about developing a skill, see the  .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ask-skill.html
 */
export class CfnSkill extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "Alexa::ASK::Skill";

  /**
   * Build a CfnSkill from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnSkill {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnSkillPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnSkill(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * Login with Amazon (LWA) configuration used to authenticate with the Alexa service.
   */
  public authenticationConfiguration: CfnSkill.AuthenticationConfigurationProperty | cdk.IResolvable;

  /**
   * Configuration for the skill package that contains the components of the Alexa skill.
   */
  public skillPackage: cdk.IResolvable | CfnSkill.SkillPackageProperty;

  /**
   * The vendor ID associated with the Amazon developer account that will host the skill.
   */
  public vendorId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnSkillProps) {
    super(scope, id, {
      "type": CfnSkill.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "authenticationConfiguration", this);
    cdk.requireProperty(props, "skillPackage", this);
    cdk.requireProperty(props, "vendorId", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.authenticationConfiguration = props.authenticationConfiguration;
    this.skillPackage = props.skillPackage;
    this.vendorId = props.vendorId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "authenticationConfiguration": this.authenticationConfiguration,
      "skillPackage": this.skillPackage,
      "vendorId": this.vendorId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnSkill.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnSkillPropsToCloudFormation(props);
  }
}

export namespace CfnSkill {
  /**
   * The \`AuthenticationConfiguration\` property type specifies the Login with Amazon (LWA) configuration used to authenticate with the Alexa service.
   *
   * Only Login with Amazon security profiles created through the  are supported for authentication. A client ID, client secret, and refresh token are required. You can generate a client ID and client secret by creating a new  on the Amazon Developer Portal or you can retrieve them from an existing profile. You can then retrieve the refresh token using the Alexa Skills Kit CLI. For instructions, see  in the  .
   *
   * \`AuthenticationConfiguration\` is a property of the \`Alexa::ASK::Skill\` resource.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ask-skill-authenticationconfiguration.html
   */
  export interface AuthenticationConfigurationProperty {
    /**
     * Client ID from Login with Amazon (LWA).
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ask-skill-authenticationconfiguration.html#cfn-ask-skill-authenticationconfiguration-clientid
     */
    readonly clientId: string;

    /**
     * Client secret from Login with Amazon (LWA).
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ask-skill-authenticationconfiguration.html#cfn-ask-skill-authenticationconfiguration-clientsecret
     */
    readonly clientSecret: string;

    /**
     * Refresh token from Login with Amazon (LWA).
     *
     * This token is secret.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ask-skill-authenticationconfiguration.html#cfn-ask-skill-authenticationconfiguration-refreshtoken
     */
    readonly refreshToken: string;
  }

  /**
   * The \`SkillPackage\` property type contains configuration details for the skill package that contains the components of the Alexa skill.
   *
   * Skill packages are retrieved from an Amazon S3 bucket and key and used to create and update the skill. More details about the skill package format are located in the  .
   *
   * \`SkillPackage\` is a property of the \`Alexa::ASK::Skill\` resource.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ask-skill-skillpackage.html
   */
  export interface SkillPackageProperty {
    /**
     * Overrides to the skill package to apply when creating or updating the skill.
     *
     * Values provided here do not modify the contents of the original skill package. Currently, only overriding values inside of the skill manifest component of the package is supported.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ask-skill-skillpackage.html#cfn-ask-skill-skillpackage-overrides
     */
    readonly overrides?: cdk.IResolvable | CfnSkill.OverridesProperty;

    /**
     * The name of the Amazon S3 bucket where the .zip file that contains the skill package is stored.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ask-skill-skillpackage.html#cfn-ask-skill-skillpackage-s3bucket
     */
    readonly s3Bucket: string;

    /**
     * ARN of the IAM role that grants the Alexa service ( \`alexa-appkit.amazon.com\` ) permission to access the bucket and retrieve the skill package. This property is optional. If you do not provide it, the bucket must be publicly accessible or configured with a policy that allows this access. Otherwise, AWS CloudFormation cannot create the skill.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ask-skill-skillpackage.html#cfn-ask-skill-skillpackage-s3bucketrole
     */
    readonly s3BucketRole?: string;

    /**
     * The location and name of the skill package .zip file.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ask-skill-skillpackage.html#cfn-ask-skill-skillpackage-s3key
     */
    readonly s3Key: string;

    /**
     * If you have S3 versioning enabled, the version ID of the skill package.zip file.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ask-skill-skillpackage.html#cfn-ask-skill-skillpackage-s3objectversion
     */
    readonly s3ObjectVersion?: string;
  }

  /**
   * The \`Overrides\` property type provides overrides to the skill package to apply when creating or updating the skill.
   *
   * Values provided here do not modify the contents of the original skill package. Currently, only overriding values inside of the skill manifest component of the package is supported.
   *
   * \`Overrides\` is a property of the \`Alexa::ASK::Skill SkillPackage\` property type.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ask-skill-overrides.html
   */
  export interface OverridesProperty {
    /**
     * Overrides to apply to the skill manifest inside of the skill package.
     *
     * The skill manifest contains metadata about the skill. For more information, see  .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ask-skill-overrides.html#cfn-ask-skill-overrides-manifest
     */
    readonly manifest?: any | cdk.IResolvable;
  }
}

/**
 * Properties for defining a \`CfnSkill\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ask-skill.html
 */
export interface CfnSkillProps {
  /**
   * Login with Amazon (LWA) configuration used to authenticate with the Alexa service.
   *
   * Only Login with Amazon clients created through the  are supported. The client ID, client secret, and refresh token are required.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ask-skill.html#cfn-ask-skill-authenticationconfiguration
   */
  readonly authenticationConfiguration: CfnSkill.AuthenticationConfigurationProperty | cdk.IResolvable;

  /**
   * Configuration for the skill package that contains the components of the Alexa skill.
   *
   * Skill packages are retrieved from an Amazon S3 bucket and key and used to create and update the skill. For more information about the skill package format, see the  .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ask-skill.html#cfn-ask-skill-skillpackage
   */
  readonly skillPackage: cdk.IResolvable | CfnSkill.SkillPackageProperty;

  /**
   * The vendor ID associated with the Amazon developer account that will host the skill.
   *
   * Details for retrieving the vendor ID are in  . The provided LWA credentials must be linked to the developer account associated with this vendor ID.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ask-skill.html#cfn-ask-skill-vendorid
   */
  readonly vendorId: string;
}

/**
 * Determine whether the given properties match those of a \`AuthenticationConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`AuthenticationConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSkillAuthenticationConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("clientId", cdk.requiredValidator)(properties.clientId));
  errors.collect(cdk.propertyValidator("clientId", cdk.validateString)(properties.clientId));
  errors.collect(cdk.propertyValidator("clientSecret", cdk.requiredValidator)(properties.clientSecret));
  errors.collect(cdk.propertyValidator("clientSecret", cdk.validateString)(properties.clientSecret));
  errors.collect(cdk.propertyValidator("refreshToken", cdk.requiredValidator)(properties.refreshToken));
  errors.collect(cdk.propertyValidator("refreshToken", cdk.validateString)(properties.refreshToken));
  return errors.wrap("supplied properties not correct for \\"AuthenticationConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnSkillAuthenticationConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSkillAuthenticationConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "ClientId": cdk.stringToCloudFormation(properties.clientId),
    "ClientSecret": cdk.stringToCloudFormation(properties.clientSecret),
    "RefreshToken": cdk.stringToCloudFormation(properties.refreshToken)
  };
}

// @ts-ignore TS6133
function CfnSkillAuthenticationConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSkill.AuthenticationConfigurationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSkill.AuthenticationConfigurationProperty>();
  ret.addPropertyResult("clientId", "ClientId", (properties.ClientId != null ? cfn_parse.FromCloudFormation.getString(properties.ClientId) : undefined));
  ret.addPropertyResult("clientSecret", "ClientSecret", (properties.ClientSecret != null ? cfn_parse.FromCloudFormation.getString(properties.ClientSecret) : undefined));
  ret.addPropertyResult("refreshToken", "RefreshToken", (properties.RefreshToken != null ? cfn_parse.FromCloudFormation.getString(properties.RefreshToken) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`OverridesProperty\`
 *
 * @param properties - the TypeScript properties of a \`OverridesProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSkillOverridesPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("manifest", cdk.validateObject)(properties.manifest));
  return errors.wrap("supplied properties not correct for \\"OverridesProperty\\"");
}

// @ts-ignore TS6133
function convertCfnSkillOverridesPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSkillOverridesPropertyValidator(properties).assertSuccess();
  return {
    "Manifest": cdk.objectToCloudFormation(properties.manifest)
  };
}

// @ts-ignore TS6133
function CfnSkillOverridesPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSkill.OverridesProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSkill.OverridesProperty>();
  ret.addPropertyResult("manifest", "Manifest", (properties.Manifest != null ? cfn_parse.FromCloudFormation.getAny(properties.Manifest) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`SkillPackageProperty\`
 *
 * @param properties - the TypeScript properties of a \`SkillPackageProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSkillSkillPackagePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("overrides", CfnSkillOverridesPropertyValidator)(properties.overrides));
  errors.collect(cdk.propertyValidator("s3Bucket", cdk.requiredValidator)(properties.s3Bucket));
  errors.collect(cdk.propertyValidator("s3Bucket", cdk.validateString)(properties.s3Bucket));
  errors.collect(cdk.propertyValidator("s3BucketRole", cdk.validateString)(properties.s3BucketRole));
  errors.collect(cdk.propertyValidator("s3Key", cdk.requiredValidator)(properties.s3Key));
  errors.collect(cdk.propertyValidator("s3Key", cdk.validateString)(properties.s3Key));
  errors.collect(cdk.propertyValidator("s3ObjectVersion", cdk.validateString)(properties.s3ObjectVersion));
  return errors.wrap("supplied properties not correct for \\"SkillPackageProperty\\"");
}

// @ts-ignore TS6133
function convertCfnSkillSkillPackagePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSkillSkillPackagePropertyValidator(properties).assertSuccess();
  return {
    "Overrides": convertCfnSkillOverridesPropertyToCloudFormation(properties.overrides),
    "S3Bucket": cdk.stringToCloudFormation(properties.s3Bucket),
    "S3BucketRole": cdk.stringToCloudFormation(properties.s3BucketRole),
    "S3Key": cdk.stringToCloudFormation(properties.s3Key),
    "S3ObjectVersion": cdk.stringToCloudFormation(properties.s3ObjectVersion)
  };
}

// @ts-ignore TS6133
function CfnSkillSkillPackagePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSkill.SkillPackageProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSkill.SkillPackageProperty>();
  ret.addPropertyResult("overrides", "Overrides", (properties.Overrides != null ? CfnSkillOverridesPropertyFromCloudFormation(properties.Overrides) : undefined));
  ret.addPropertyResult("s3Bucket", "S3Bucket", (properties.S3Bucket != null ? cfn_parse.FromCloudFormation.getString(properties.S3Bucket) : undefined));
  ret.addPropertyResult("s3BucketRole", "S3BucketRole", (properties.S3BucketRole != null ? cfn_parse.FromCloudFormation.getString(properties.S3BucketRole) : undefined));
  ret.addPropertyResult("s3Key", "S3Key", (properties.S3Key != null ? cfn_parse.FromCloudFormation.getString(properties.S3Key) : undefined));
  ret.addPropertyResult("s3ObjectVersion", "S3ObjectVersion", (properties.S3ObjectVersion != null ? cfn_parse.FromCloudFormation.getString(properties.S3ObjectVersion) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnSkillProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnSkillProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSkillPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("authenticationConfiguration", cdk.requiredValidator)(properties.authenticationConfiguration));
  errors.collect(cdk.propertyValidator("authenticationConfiguration", CfnSkillAuthenticationConfigurationPropertyValidator)(properties.authenticationConfiguration));
  errors.collect(cdk.propertyValidator("skillPackage", cdk.requiredValidator)(properties.skillPackage));
  errors.collect(cdk.propertyValidator("skillPackage", CfnSkillSkillPackagePropertyValidator)(properties.skillPackage));
  errors.collect(cdk.propertyValidator("vendorId", cdk.requiredValidator)(properties.vendorId));
  errors.collect(cdk.propertyValidator("vendorId", cdk.validateString)(properties.vendorId));
  return errors.wrap("supplied properties not correct for \\"CfnSkillProps\\"");
}

// @ts-ignore TS6133
function convertCfnSkillPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSkillPropsValidator(properties).assertSuccess();
  return {
    "AuthenticationConfiguration": convertCfnSkillAuthenticationConfigurationPropertyToCloudFormation(properties.authenticationConfiguration),
    "SkillPackage": convertCfnSkillSkillPackagePropertyToCloudFormation(properties.skillPackage),
    "VendorId": cdk.stringToCloudFormation(properties.vendorId)
  };
}

// @ts-ignore TS6133
function CfnSkillPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSkillProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSkillProps>();
  ret.addPropertyResult("authenticationConfiguration", "AuthenticationConfiguration", (properties.AuthenticationConfiguration != null ? CfnSkillAuthenticationConfigurationPropertyFromCloudFormation(properties.AuthenticationConfiguration) : undefined));
  ret.addPropertyResult("skillPackage", "SkillPackage", (properties.SkillPackage != null ? CfnSkillSkillPackagePropertyFromCloudFormation(properties.SkillPackage) : undefined));
  ret.addPropertyResult("vendorId", "VendorId", (properties.VendorId != null ? cfn_parse.FromCloudFormation.getString(properties.VendorId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}",
}
`;
