"use strict";var C=Object.create;var c=Object.defineProperty;var S=Object.getOwnPropertyDescriptor;var w=Object.getOwnPropertyNames;var A=Object.getPrototypeOf,P=Object.prototype.hasOwnProperty;var L=(e,o)=>{for(var t in o)c(e,t,{get:o[t],enumerable:!0})},d=(e,o,t,s)=>{if(o&&typeof o=="object"||typeof o=="function")for(let r of w(o))!P.call(e,r)&&r!==t&&c(e,r,{get:()=>o[r],enumerable:!(s=S(o,r))||s.enumerable});return e};var p=(e,o,t)=>(t=e!=null?C(A(e)):{},d(o||!e||!e.__esModule?c(t,"default",{value:e,enumerable:!0}):t,e)),D=e=>d(c({},"__esModule",{value:!0}),e);var W={};L(W,{autoDeleteHandler:()=>E,handler:()=>k});module.exports=D(W);var h=require("aws-sdk");var m=p(require("https")),R=p(require("url")),n={sendHttpRequest:x,log:N,includeStackTraces:!0,userHandlerIndex:"./index"},l="AWSCDK::CustomResourceProviderFramework::CREATE_FAILED",b="AWSCDK::CustomResourceProviderFramework::MISSING_PHYSICAL_ID";function y(e){return async(o,t)=>{let s={...o,ResponseURL:"..."};if(n.log(JSON.stringify(s,void 0,2)),o.RequestType==="Delete"&&o.PhysicalResourceId===l){n.log("ignoring DELETE event caused by a failed CREATE event"),await u("SUCCESS",o);return}try{let r=await e(s,t),a=T(o,r);await u("SUCCESS",a)}catch(r){let a={...o,Reason:n.includeStackTraces?r.stack:r.message};a.PhysicalResourceId||(o.RequestType==="Create"?(n.log("CREATE failed, responding with a marker physical resource id so that the subsequent DELETE will be ignored"),a.PhysicalResourceId=l):n.log(`ERROR: Malformed event. "PhysicalResourceId" is required: ${JSON.stringify(o)}`)),await u("FAILED",a)}}}function T(e,o={}){let t=o.PhysicalResourceId??e.PhysicalResourceId??e.RequestId;if(e.RequestType==="Delete"&&t!==e.PhysicalResourceId)throw new Error(`DELETE: cannot change the physical resource ID from "${e.PhysicalResourceId}" to "${o.PhysicalResourceId}" during deletion`);return{...e,...o,PhysicalResourceId:t}}async function u(e,o){let t={Status:e,Reason:o.Reason??e,StackId:o.StackId,RequestId:o.RequestId,PhysicalResourceId:o.PhysicalResourceId||b,LogicalResourceId:o.LogicalResourceId,NoEcho:o.NoEcho,Data:o.Data};n.log("submit response to cloudformation",t);let s=JSON.stringify(t),r=R.parse(o.ResponseURL),a={hostname:r.hostname,path:r.path,method:"PUT",headers:{"content-type":"","content-length":Buffer.byteLength(s,"utf8")}};await H({attempts:5,sleep:1e3},n.sendHttpRequest)(a,s)}async function x(e,o){return new Promise((t,s)=>{try{let r=m.request(e,a=>t());r.on("error",s),r.write(o),r.end()}catch(r){s(r)}})}function N(e,...o){console.log(e,...o)}function H(e,o){return async(...t)=>{let s=e.attempts,r=e.sleep;for(;;)try{return await o(...t)}catch(a){if(s--<=0)throw a;await F(Math.floor(Math.random()*r)),r*=2}}}async function F(e){return new Promise(o=>setTimeout(o,e))}var g="aws-cdk:auto-delete-images",i=new h.ECR,k=y(E);async function E(e){switch(e.RequestType){case"Create":break;case"Update":return _(e);case"Delete":return f(e.ResourceProperties?.RepositoryName)}}async function _(e){let o=e,t=o.OldResourceProperties?.RepositoryName,s=o.ResourceProperties?.RepositoryName;if(s&&t&&s!==t)return f(t)}async function I(e){let o=await i.listImages(e).promise(),t=[],s=[];(o.imageIds??[]).forEach(a=>{"imageTag"in a?s.push(a):t.push(a)});let r=o.nextToken??null;t.length===0&&s.length===0||(s.length!==0&&await i.batchDeleteImage({repositoryName:e.repositoryName,imageIds:s}).promise(),t.length!==0&&await i.batchDeleteImage({repositoryName:e.repositoryName,imageIds:t}).promise(),r&&await I({...e,nextToken:r}))}async function f(e){if(!e)throw new Error("No RepositoryName was provided.");let t=(await i.describeRepositories({repositoryNames:[e]}).promise()).repositories?.find(s=>s.repositoryName===e);if(!await q(t?.repositoryArn)){process.stdout.write(`Repository does not have '${g}' tag, skipping cleaning.
`);return}try{await I({repositoryName:e})}catch(s){if(s.name!=="RepositoryNotFoundException")throw s}}async function q(e){return(await i.listTagsForResource({resourceArn:e}).promise()).tags?.some(t=>t.Key===g&&t.Value==="true")}0&&(module.exports={autoDeleteHandler,handler});
