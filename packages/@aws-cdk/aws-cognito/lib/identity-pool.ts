import {
  randomBytes
} from 'crypto';
import {
  IOpenIdConnectProvider,
  ISamlProvider,
  IRole
} from '@aws-cdk/aws-iam';
import {
  IFunction
} from '@aws-cdk/aws-lambda';
import {
  Resource,
  IResource,
  Stack,
  ArnFormat,
  Lazy,
  Names
} from '@aws-cdk/core';
import {
  Construct
} from 'constructs';
import {
  CfnIdentityPool,
  CfnIdentityPoolRoleAttachment
} from './cognito.generated';
import {
  IUserPool
} from './user-pool';
import {
  IUserPoolClient,
  UserPoolClient,
  UserPoolClientOptions,
  UserPoolClientProps
} from './user-pool-client';

/**
 * Represents a Cognito IdentityPool
 */
export interface IIdentityPool extends IResource {
  /**
   * The id of the Identity Pool in the format REGION:GUID
   * @attribute
   */
  readonly identityPoolId: string;

  /**
   * The ARN of the Identity Pool
   * @attribute
   */
  readonly identityPoolArn: string;

  /**
   * Name of the Identity Pool
   * @attribute
   */
  readonly identityPoolName: string
}

/**
 * Props for the IdentityPool construct
 */
export interface IdentityPoolProps {

  /**
   * The name of the Identity Pool
   * @default - automatically generated name by CloudFormation at deploy time
   */
  readonly identityPoolName?: string;

  /**
   * The Default Role to be assumed by Authenticated Users
   */
  readonly authenticatedRole: IRole;

  /**
   * The Default Role to be assumed by Unauthenticated Users
   */
  readonly unauthenticatedRole: IRole;

  /**
   * The Default Role to be assumed by Authenticated Users
   * @default - no Role Mappings
   */
  readonly roleMappings?: IdentityPoolRoleMapping[];

  /**
   * Whether to allow unauthenticated identities access to identity pool
   * @default false
   */
  readonly allowUnauthenticatedIdentities?: boolean;

  /**
   * Enables the Basic (Classic) authentication flow
   * @default - Classic Flow not allowed
   */
  readonly allowClassicFlow?: boolean;

  /**
   * The configuration options to be applied to the identity pool.
   * @default - No push sync config
   */
  readonly pushSyncConfig?: PushSyncConfig;

  /**
   * The configuration options for Amazon Cognito streams.
   * @default - No Cognito stream options
   */
  readonly streamOptions?: CognitoStreamOptions;

  /**
   * Set a lambda function to respond to events in Amazon Cognito
   *  @see https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-events.html
   * @default - No Sync Triggers
   */
  readonly syncTrigger?: IFunction;

  /**
   * Supported login providers for using directly in identity pool without using OpnIdConnect or a user pool.
   * @default - No Supported Login Providers passed directly to Identity Pool
   */
  readonly authenticationProviders?: AuthenticationProviders
}

/**
 * The configuration options for Amazon Cognito streams.
 */
export interface CognitoStreamOptions {

  /**
   * The name of the Amazon Cognito stream to receive updates
   * @default - Automatically generated by CloudFormation
   */
  readonly streamName?: string;
  /**
   * Whether the Amazon Cognito Streams are enabled
   * @default false
   */
  readonly enableStreamingStatus?: boolean;

  /**
   * The role Amazon Cognito can assume to publish to the stream. This role must grant access to Amazon Cognito (cognito-sync) to invoke PutRecord on your Amazon Cognito stream.
   * @default - No role set for Cognito Streams
   */
  readonly role?: IRole;
}

/**
 * The configuration options to be applied to the identity pool.
 */
export interface PushSyncConfig {
  /**
   * The ARNs of the Amazon SNS platform applications that could be used by clients.
   * @default []
   */
  readonly applicationArns?: string[]

  /**
   * An IAM role configured to allow Amazon Cognito to call Amazon SNS on behalf of the developer.
   * @default - No role set for Push Sync
   */
  readonly role?: IRole
}

/**
 * Map roles to users in the identity pool based on claims from the Identity Provider
 *  @see https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-cognito-identitypoolroleattachment.html
 */
export interface IdentityPoolRoleMapping {
  /**
   * The url of the provider of for which the role is mapped
   */
  readonly providerUrl: AuthenticationProviderType | string;

  /**
   *  If true then mapped roles must be passed through the cognito:roles or cognito:preferred_role claims from identity provider.
   * @see https://docs.aws.amazon.com/cognito/latest/developerguide/role-based-access-control.html#using-tokens-to-assign-roles-to-users
   *
   * @default false
   */
  readonly useToken?: boolean;

  /**
   * Allow for role assumption when results of role mapping are ambiguous
   * @default false - Ambiguous role resolutions will lead to requester being denied
   */
  readonly resolveAmbiguousRoles?: boolean;

  /**
   * The claim and value that must be matched in order to assume the role. Required if useToken is false
   * @default - No Rule Mapping Rule
   */
  readonly rules?: RoleMappingRule[];

}

/**
 * Types of matches allowed for Role Mapping
 */
export enum RoleMappingMatchType {
  /**
   * The Claim from the token must equal the given value in order for a match
   */
  EQUALS = 'Equals',

  /**
   * The Claim from the token must contain the given value in order for a match
   */
  CONTAINS = 'Contains',

  /**
   * The Claim from the token must start with the given value in order for a match
   */
  STARTS_WITH = 'StartsWith',

  /**
   * The Claim from the token must not equal the given value in order for a match
   */
  NOTEQUAL = 'NotEqual',
}

/**
 * Represents an Identity Pool Role Attachment Role Mapping Rule
 */
export interface RoleMappingRule {
  /**
   * The key sent in the token by the federated identity provider.
   */
  readonly claim: string;

  /**
    * The Role to be assumed when Claim Value is matched.
    */
  readonly mappedRole: IRole;

  /**
    * The value of the claim that must be matched
    */
  readonly claimValue: string;

  /**
   * How to match with the Claim value
   * @default RoleMappingMatchType.EQUALS
   */
  readonly matchType?: RoleMappingMatchType
}

/**
 * Keys for SupportedLoginProvider - correspond to client id's of respective federation identity providers
 */
export enum AuthenticationProviderType {
  /** Facebook Provider type */
  FACEBOOK = 'graph.facebook.com',
  /** Google Provider Type */
  GOOGLE = 'accounts.google.com',
  /** Amazon Provider Type */
  AMAZON = 'www.amazon.com',
  /** Apple Provider Type */
  APPLE = 'appleid.apple.com',
  /** Twitter Provider Type */
  TWITTER = 'api.twitter.com'
}

/**
 * Id for Amazon Identity Federation
*/
export interface IdentityPoolIdentityProviderProps {
  /**
   * App Id for External Identity Provider
  */
  readonly appId: string

  /**
   * App Secret for External Identity Provider (currently only needed for Twitter)
   * @default - No app secret
  */
  readonly appSecret?: string
}

/**
 * Props for User Pools and User Pool Clients to be attached to identity pool
*/
export interface UserPoolAuthenticationProviderProps extends UserPoolClientProps {
  /**
   * Setting this to true turns off identity pool checks for this user pool to make sure the user has not been globally signed out or deleted before the identity pool provides an OIDC token or AWS credentials for the user
   * @see https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cognito-identitypool-cognitoidentityprovider.html
   * @default false
  */
  readonly disableServerSideTokenCheck?: boolean;
}

/**
 * Supported login providers for using directly in identity pool without using OpenIdConnect or a user pool. String values are id's associated with provider. Separate multiple fields with a semicolon
 * @see https://docs.aws.amazon.com/cognito/latest/developerguide/external-identity-providers.html
 */
export interface AuthenticationProviders {

  /**
   * The User Pools associated with this Identity Pool
   * @default - no User Pools Associated
  */
  readonly userPools?: UserPoolAuthenticationProviderProps[];

  /** App Id for Facebook Identity Federation
   * @default - No Facebook Login Provider used without OpenIdConnect or a User Pool
  */
  readonly facebook?: IdentityPoolIdentityProviderProps

  /** Client Id for Google Identity Federation
   * @default - No Google Login Provider used without OpenIdConnect or a User Pool
  */
  readonly google?: IdentityPoolIdentityProviderProps

  /** App Id for Amazon Identity Federation
   * @default -  No Amazon Login Provider used without OpenIdConnect or a User Pool
  */
  readonly amazon?: IdentityPoolIdentityProviderProps

  /** Services Id for Apple Identity Federation
   * @default - No Apple Login Provider used without OpenIdConnect or a User Pool
  */
  readonly apple?: IdentityPoolIdentityProviderProps

  /** Consumer Key and Secret for Twitter Identity Federation
   * @default - No Twitter Login Provider used without OpenIdConnect or a User Pool
  */
  readonly twitter?: IdentityPoolIdentityProviderProps

  /**
   * The OpenIdConnect Provider associated with this Identity Pool
   * @default - no OpenIdConnectProvider
  */
  readonly openIdConnectProvider?: IOpenIdConnectProvider;

  /**
   * The Security Assertion Markup Language Provider associated with this Identity Pool
   * @default - no SamlProvider
  */
  readonly samlProvider?: ISamlProvider;

  /**
   * The Developer Provider Name to associate with this Identity Pool
   * @default - no Custom Provider
  */
  readonly customProvider?: string;
}

/**
 * Define a Cognito Identity Pool
 */
export class IdentityPool extends Resource implements IIdentityPool {

  /**
   * Import an existing Identity Pool from its id
   */
  public static fromIdentityPoolId(scope: Construct, id: string, identityPoolId: string): IIdentityPool {
    const identityPoolArn = Stack.of(scope).formatArn({
      service: 'cognito-identity',
      resource: 'identitypool',
      resourceName: identityPoolId,
      arnFormat: ArnFormat.SLASH_RESOURCE_NAME,
    });

    return IdentityPool.fromIdentityPoolArn(scope, id, identityPoolArn);
  }

  /**
   * Import an existing Identity Pool from its Arn
   */
  public static fromIdentityPoolArn(scope: Construct, id: string, identityPoolArn: string): IIdentityPool {
    const pool = Stack.of(scope).splitArn(identityPoolArn, ArnFormat.SLASH_RESOURCE_NAME);
    const res = pool.resourceName || '';
    if (!res) {
      throw new Error('Invalid Identity Pool ARN');
    }
    const idParts = res.split(':');
    if (!(idParts.length === 2)) throw new Error('Invalid Identity Pool Id: Identity Pool Ids must follow the format <region>:<id>');
    if (idParts[0] !== pool.region) throw new Error('Invalid Identity Pool Id: Region in Identity Pool Id must match stack region');
    class ImportedIdentityPool extends Resource implements IIdentityPool {
      public readonly identityPoolId = res;
      public readonly identityPoolArn = identityPoolArn;
      public readonly identityPoolName: string
      constructor() {
        super(scope, id, {
          account: pool.account,
          region: pool.region,
        });
        this.identityPoolName = this.physicalName;
      }
    }
    return new ImportedIdentityPool();
  }

  /**
   * The id of the Identity Pool in the format REGION:GUID
   * @attribute
   */
  public readonly identityPoolId: string;

  /**
   * The ARN of the Identity Pool
   * @attribute
   */
  public readonly identityPoolArn: string;

  /**
   * The ARN of the Identity Pool
   * @attribute
   */
  public readonly identityPoolName: string;

  /**
   * The Identity Pool Cloud Formation Construct
   */
  private cfnIdentityPool: CfnIdentityPool;

  /**
   * List of Identity Providers added in constructor for use with property overrides
   */
  private cognitoIdentityProviders: CfnIdentityPool.CognitoIdentityProviderProperty[] = [];

  constructor(scope: Construct, private id: string, props:IdentityPoolProps) {
    super(scope, id, {
      physicalName: props.identityPoolName || Lazy.string({ produce: () => this.generateUniqueId() }),
    });
    this.identityPoolName = this.physicalName;
    const authProviders: AuthenticationProviders = props.authenticationProviders || {};
    const providers = this.configureUserPools(authProviders.userPools);
    if (providers && providers.length) this.cognitoIdentityProviders = providers;
    this.cfnIdentityPool = new CfnIdentityPool(this, id, {
      allowUnauthenticatedIdentities: props.allowUnauthenticatedIdentities ? true : false,
      allowClassicFlow: props.allowClassicFlow,
      identityPoolName: props.identityPoolName,
      developerProviderName:  authProviders.customProvider,
      openIdConnectProviderArns: this.configureOpenIdConnectProviderArns(authProviders.openIdConnectProvider),
      samlProviderArns: this.configureSamlProviderArns(authProviders.samlProvider),
      cognitoEvents: this.configureCognitoEvents(props.syncTrigger),
      cognitoStreams: this.configureCognitoStreamOptions(props.streamOptions),
      pushSync: this.configurePushSyncConfig(props.pushSyncConfig),
      authenticationProviders: this.configureAuthenticationProviders(props.authenticationProviders),
      cognitoIdentityProviders: providers,
    });
    this.identityPoolId = this.cfnIdentityPool.ref;
    this.identityPoolArn = Stack.of(scope).formatArn({
      service: 'cognito-identity',
      resource: 'identitypool',
      resourceName: this.identityPoolId,
      arnFormat: ArnFormat.SLASH_RESOURCE_NAME,
    });

    this.configureRoleAttachment(props.authenticatedRole, props.unauthenticatedRole, ...(props.roleMappings || []));
  }

  /**
   * Add a User Pool to the IdentityPool and configures User Pool Client to handle identities
   */
  public addUserPool(userPool: IUserPool, options?: UserPoolClientOptions, disableServerSideTokenCheck?: boolean): UserPoolClient {
    const client = this.configureUserPoolClient(userPool, options);
    this.cognitoIdentityProviders = this.cognitoIdentityProviders
      .concat(this.configureIdentityProviders(userPool, client, disableServerSideTokenCheck));
    const providers = this.cognitoIdentityProviders.map(provider => {
      return {
        ClientId: provider.clientId,
        ProviderName: provider.providerName,
        ServerSideTokenCheck: provider.serverSideTokenCheck,
      };
    }, this);
    this.cfnIdentityPool.addPropertyOverride('CognitoIdentityProviders', providers);
    return client;
  }

  /**
   * Adds Role Mappings to Identity Pool
  */
  public addRoleMappings(...mappings: IdentityPoolRoleMapping[]): void {
    if (!mappings || !mappings.length) return;
    const name = this.id + 'RoleMappingAttachment';
    const roleMappings = this.configureRoleMappings(...mappings);

    const attachment = new CfnIdentityPoolRoleAttachment(this, name, {
      identityPoolId: this.identityPoolId,
      roles: {},
      roleMappings,
    });
    attachment.node.addDependency(this.cfnIdentityPool);
  }

  /**
   * Configure Role Attachments For Identity Pool
   */
  private configureRoleAttachment(
    authenticatedRole?: IRole,
    unauthenticatedRole?: IRole,
    ...mappings: IdentityPoolRoleMapping[]
  ): void {
    const name = this.id + 'RoleAttachment';
    let roles: any = undefined, roleMappings: any = undefined;
    if (authenticatedRole || unauthenticatedRole) {
      roles = {};
      if (authenticatedRole) roles.authenticated = authenticatedRole.roleArn;
      if (unauthenticatedRole) roles.unauthenticated = unauthenticatedRole.roleArn;
    }
    if (mappings) {
      roleMappings = this.configureRoleMappings(...mappings);
    }
    const attachment = new CfnIdentityPoolRoleAttachment(this, name, {
      identityPoolId: this.identityPoolId,
      roles,
      roleMappings,
    });
    attachment.node.addDependency(this.cfnIdentityPool);
  }

  /**
   * Configure CognitoIdentityProviders for a User Pools
   */
  private configureIdentityProviders(
    userPool: IUserPool,
    client: IUserPoolClient,
    disableServerSideTokenCheck?: boolean,
  ): CfnIdentityPool.CognitoIdentityProviderProperty[] {
    return userPool.identityProviders.map(provider => {
      return {
        clientId: client.userPoolClientId,
        providerName: provider.providerName,
        serverSideTokenCheck: disableServerSideTokenCheck ? false : true,
      };
    });
  }

  /**
   * Configures and returns new User Pool Client that will implement Identity Providers in Identity Pool
   */
  private configureUserPoolClient(userPool: IUserPool, options?: UserPoolClientOptions): UserPoolClient {
    return userPool.addClient('UserPoolClientFor' + options?.userPoolClientName || this.generateRandomName(), options);
  }

  /**
   * Configure CognitoIdentityProviders from list of User Pools
   */
  private configureUserPools(userPoolProps: UserPoolAuthenticationProviderProps[]): CfnIdentityPool.CognitoIdentityProviderProperty[] | undefined {
    if (!userPoolProps || !userPoolProps.length) return undefined;
    let providers: CfnIdentityPool.CognitoIdentityProviderProperty[] = [];
    userPoolProps.forEach(props => {
      const pool = props.userPool;
      const client = this.configureUserPoolClient(pool, props);
      providers = [...providers, ...this.configureIdentityProviders(pool, client, props.disableServerSideTokenCheck)];
    }, this);
    return providers;
  }

  /**
   * Converts OpenIdConnectProvider constructs to an array of Arns
   */
  private configureOpenIdConnectProviderArns(arns: IOpenIdConnectProvider[] = []): string[] | undefined {
    let arnList = arns.map(openId => openId.openIdConnectProviderArn);
    if (!arnList.length) return undefined;
    return arnList;
  }

  /**
   * Converts SamlProvider constructs to an array of Arns
   */
  private configureSamlProviderArns(arns: ISamlProvider[] = []): string[] | undefined {
    let arnList = arns.map(saml => saml.samlProviderArn);
    if (!arnList.length) return undefined;
    return arnList;
  }

  /**
   * Converts SyncTrigger lambda into a Cognito Event
   */
  private configureCognitoEvents(syncTrigger?: IFunction): any {
    if (!syncTrigger) return undefined;
    return {
      SyncTrigger: syncTrigger.functionArn,
    };
  }

  /**
   * Converts CognitoStreamOptions into CfnIdentityPool.CognitoStreamProperty
   */
  private configureCognitoStreamOptions(options?: CognitoStreamOptions): CfnIdentityPool.CognitoStreamsProperty | undefined {
    if (!options) return undefined;
    const property: any = {
      roleArn: options.role ? options.role.roleArn : undefined,
      streamName: options.streamName,
    };

    if (options.hasOwnProperty('enableStreamingStatus')) {
      property.streamingStatus = options.enableStreamingStatus ? 'ENABLED' : 'DISABLED';
    }
    return property as CfnIdentityPool.CognitoStreamsProperty;
  }

  /**
   * Converts PushSyncConfig into CfnIdentityPool.PushSyncProperty
   */
  private configurePushSyncConfig(config?: PushSyncConfig): CfnIdentityPool.PushSyncProperty | undefined {
    if (!config) return undefined;
    return {
      roleArn: config.role ? config.role.roleArn : undefined,
      applicationArns: config.applicationArns,
    };
  }

  /**
   * Formats supported login providers
   */
  private configureAuthenticationProviders(providers?: AuthenticationProviders): any {
    if (!providers) return undefined;
    const supportedProviders:any = {};
    if (providers.amazon) supportedProviders[AuthenticationProviderType.AMAZON] = providers.amazon;
    if (providers.facebook) supportedProviders[AuthenticationProviderType.FACEBOOK] = providers.facebook;
    if (providers.google) supportedProviders[AuthenticationProviderType.GOOGLE] = providers.google;
    if (providers.apple) supportedProviders[AuthenticationProviderType.APPLE] = providers.apple;
    if (providers.twitter) supportedProviders[AuthenticationProviderType.TWITTER] = providers.twitter;
    return supportedProviders;
  }

  /**
   * Configures Role Mappings for Identity Pool Role Attachment
   */
  private configureRoleMappings(
    ...props: IdentityPoolRoleMapping[]
  ): { [name:string]: CfnIdentityPoolRoleAttachment.RoleMappingProperty } | undefined {
    if (!props || !props.length) return undefined;
    return props.reduce((acc, prop) => {
      let roleMapping: any = {
        ambiguousRoleResolution: prop.resolveAmbiguousRoles ? 'AuthenticatedRole' : 'Deny',
        type: prop.useToken ? 'Token' : 'Rules',
        identityProvider: prop.providerUrl,
      };
      if (roleMapping.type === 'Rules') {
        if (!prop.rules) {
          throw new Error('IdentityPoolRoleMapping.rules is required when useToken is false');
        }

        roleMapping.rulesConfiguration = {
          rules: prop.rules.map(rule => {
            return {
              claim: rule.claim,
              value: rule.claimValue,
              matchType: rule.matchType || RoleMappingMatchType.EQUALS,
              roleArn: rule.mappedRole.roleArn,
            };
          }),
        };
      };
      acc[prop.providerUrl] = roleMapping;
      return acc;
    }, {} as { [name:string]: CfnIdentityPoolRoleAttachment.RoleMappingProperty });
  }

  /** Generate random name when construct name is not present */
  private generateUniqueId(): string {
    const name = Names.uniqueId(this);
    if (name.length > 20) {
      return name.substring(0, 20);
    }
    return name;
  }

  private generateRandomName(bytes: number = 5): string {
    return randomBytes(bytes).toString('hex');
  }
}