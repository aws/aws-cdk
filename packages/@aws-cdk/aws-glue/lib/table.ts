import iam = require('@aws-cdk/aws-iam');
import s3 = require('@aws-cdk/aws-s3');
import cdk = require('@aws-cdk/cdk');
import { IDatabase } from './database';
import { CfnTable } from './glue.generated';
import { Column } from './schema';
import { StorageType } from './storage-type';

export interface ITable extends cdk.IConstruct {
  readonly database: IDatabase;
  readonly bucket: s3.Bucket;
  readonly prefix: string;

  readonly tableName: string;
  readonly tableArn: string;
}

export interface TableProps {
  /**
   * Name of the table.
   */
  name: string;

  /**
   * Description of the table.
   *
   * @default generated
   */
  description?: string;

  /**
   * Database in which to store the table.
   */
  database: IDatabase;

  /**
   * S3 bucket in which to store data.
   *
   * @default one is created for you
   */
  bucket?: s3.Bucket;

  /**
   * S3 prefix under which table objects are stored.
   *
   * @default data/
   */
  prefix?: string;

  /**
   * Columns of the table.
   */
  columns: Column[];

  /**
   * Partition columns of the table.
   *
   * @default table is not partitioned
   */
  partitionKeys?: Column[]

  /**
   * Storage type of the table's data.
   */
  storageType: StorageType;

  /**
   * Indicates whether the table's data is compressed or not.
   *
   * @default false
   */
  compressed?: boolean;

  /**
   * Indicates whether the table data is stored in subdirectories.
   *
   * @default false
   */
  storedAsSubDirectories?: boolean;
}

/**
 * A Glue table.
 */
export class Table extends cdk.Construct implements ITable {
  public readonly database: IDatabase;
  public readonly bucket: s3.Bucket;
  public readonly prefix: string;

  public readonly tableName: string;
  public readonly tableArn: string;

  public readonly storageType: StorageType;
  public readonly columns: Column[];
  public readonly partitionKeys?: Column[];

  constructor(scope: cdk.Construct, id: string, props: TableProps) {
    super(scope, id);
    this.database = props.database;
    this.bucket = props.bucket || new s3.Bucket(this, 'Bucket');
    this.storageType = props.storageType;
    this.prefix = props.prefix || 'data/';
    this.columns = props.columns;
    this.partitionKeys = props.partitionKeys;

    const tableResource = new CfnTable(this, 'Table', {
      catalogId: props.database.catalogId,

      databaseName: props.database.databaseName,

      tableInput: {
        name: props.name,
        description: props.description || `${props.name} generated by CDK`,

        partitionKeys: renderColumns(props.partitionKeys),

        storageDescriptor: {
          location: cdk.Fn.join('', ['s3://', this.bucket.bucketName, '/', this.prefix]),
          compressed: props.compressed === undefined ? false : props.compressed,
          storedAsSubDirectories: props.storedAsSubDirectories === undefined ? false : props.storedAsSubDirectories,
          columns: renderColumns(props.columns),
          inputFormat: props.storageType.inputFormat,
          outputFormat: props.storageType.outputFormat,
          serdeInfo: {
            serializationLibrary: props.storageType.serializationLibrary
          }
        },

        tableType: 'EXTERNAL_TABLE'
      }
    });

    this.tableName = tableResource.ref;
    this.tableArn = cdk.Fn.join('', [this.database.databaseArn, '/', this.tableName]);
  }

  /**
   * Grant read permissions to the table and the underlying data stored in S3 to an IAM principal.
   *
   * @param identity the principal
   */
  public grantRead(identity: iam.IPrincipal): void {
    this.grant(identity, readPermissions);
    this.bucket.grantRead(identity);
  }

  /**
   * Grant write permissions to the table and the underlying data stored in S3 to an IAM principal.
   *
   * @param identity the principal
   */
  public grantWrite(identity: iam.IPrincipal): void {
    this.grant(identity, writePermissions);
    this.bucket.grantWrite(identity);
  }

  /**
   * Grant read and write permissions to the table and the underlying data stored in S3 to an IAM principal.
   *
   * @param identity the principal
   */
  public grantReadWrite(identity: iam.IPrincipal): void {
    this.grant(identity, readPermissions.concat(writePermissions));
    this.bucket.grantReadWrite(identity);
  }

  private grant(identity: iam.IPrincipal, permissions: string[]) {
    identity.addToPolicy(new iam.PolicyStatement()
      .addResource(this.tableArn)
      .addActions(...readPermissions.concat(writePermissions)));
  }
}

const readPermissions = [
  'glue:BatchDeletePartition',
  'glue:BatchGetPartition',
  'glue:GetPartition',
  'glue:GetPartitions',
  'glue:GetTable',
  'glue:GetTables',
  'glue:GetTableVersions'
];

const writePermissions = [
  'glue:BatchCreatePartition',
  'glue:BatchDeletePartition',
  'glue:CreatePartition',
  'glue:DeletePartition',
  'glue:UpdatePartition'
];

function renderColumns(columns?: Array<Column | Column>) {
  if (columns === undefined) {
    return undefined;
  }
  return columns.map(column => {
    return {
      name: column.name,
      type: column.type.inputString,
      comment: column.comment
    };
  });
}
