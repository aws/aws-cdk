import * as cdk from 'aws-cdk-lib';
import type * as ec2 from 'aws-cdk-lib/aws-ec2';
import * as iam from 'aws-cdk-lib/aws-iam';
import { CfnImageRecipe } from 'aws-cdk-lib/aws-imagebuilder';
import { memoizedGetter } from 'aws-cdk-lib/core/lib/helpers-internal';
import { addConstructMetadata, MethodMetadata } from 'aws-cdk-lib/core/lib/metadata-resource';
import { propertyInjectable } from 'aws-cdk-lib/core/lib/prop-injectable';
import type { Construct } from 'constructs';
import type { BaseImage } from './base-image';
import type { IContainerRecipe } from './container-recipe';
import type { ComponentConfiguration, IRecipeBase } from './recipe-base';

const IMAGE_RECIPE_SYMBOL = Symbol.for('@aws-cdk/aws-imagebuilder-alpha.ImageRecipe');

/**
 * Represents the latest version of an image recipe. When using the recipe in a pipeline, the pipeline will use the
 * latest recipe at the time of execution.
 *
 * @see https://docs.aws.amazon.com/imagebuilder/latest/userguide/ibhow-semantic-versioning.html
 */
const LATEST_VERSION = 'x.x.x';

/**
 * The default version to use in the image recipe. When the recipe is updated, the `x` will be incremented off from
 * the latest recipe version that exists.
 *
 * @see https://docs.aws.amazon.com/imagebuilder/latest/userguide/create-image-recipes.html
 */
const DEFAULT_RECIPE_VERSION = '1.0.x';

/**
 * An EC2 Image Builder Image Recipe.
 */
export interface IImageRecipe extends IRecipeBase {
  /**
   * The ARN of the image recipe
   *
   * @attribute
   */
  readonly imageRecipeArn: string;

  /**
   * The name of the image recipe
   *
   * @attribute
   */
  readonly imageRecipeName: string;

  /**
   * The version of the image recipe
   *
   * @attribute
   */
  readonly imageRecipeVersion: string;
}

/**
 * Properties for creating an Image Recipe resource
 */
export interface ImageRecipeProps {
  /**
   * The base image for customizations specified in the image recipe.
   */
  readonly baseImage: BaseImage;

  /**
   * The name of the image recipe.
   *
   * @default - a name is generated
   */
  readonly imageRecipeName?: string;

  /**
   * The version of the image recipe.
   *
   * @default 1.0.x
   */
  readonly imageRecipeVersion?: string;

  /**
   * The description of the image recipe.
   *
   * @default None
   */
  readonly description?: string;

  /**
   * The list of component configurations to apply in the image build.
   *
   * @default None
   */
  readonly components?: ComponentConfiguration[];

  /**
   * The additional tags to assign to the output AMI generated by the build.
   *
   * @default None
   */
  readonly amiTags?: { [key: string]: string };

  /**
   * The block devices to attach to the instance used for building the image.
   *
   * @default None
   */
  readonly blockDevices?: ec2.BlockDevice[];

  /**
   * The working directory for use during build and test workflows.
   *
   * @default - the Image Builder default working directory is used. For Linux and macOS builds, this would be /tmp. For
   * Windows builds, this would be C:/
   */
  readonly workingDirectory?: string;

  /**
   * Whether to uninstall the Systems Manager agent from your final build image, prior to creating the new AMI.
   *
   * @default - this is false if the Systems Manager agent is pre-installed on the base image. Otherwise, this is true.
   */
  readonly uninstallSsmAgentAfterBuild?: boolean;

  /**
   * The user data commands to pass to Image Builder build and test EC2 instances. For Linux and macOS, Image Builder
   * uses a default user data script to install the Systems Manager agent. If you override the user data, you must
   * ensure to add commands to install Systems Manager agent, if it is not pre-installed on your base image.
   *
   * @default None
   */
  readonly userDataOverride?: ec2.UserData;

  /**
   * The tags to apply to the image recipe
   *
   * @default None
   */
  readonly tags?: { [key: string]: string };
}

/**
 * Properties for an EC2 Image Builder image recipe
 */
export interface ImageRecipeAttributes {
  /**
   * The ARN of the image recipe
   *
   * @default - derived from the imageRecipeName
   */
  readonly imageRecipeArn?: string;

  /**
   * The name of the image recipe
   *
   * @default - derived from the imageRecipeArn
   */
  readonly imageRecipeName?: string;

  /**
   * The version of the image recipe
   *
   * @default - derived from imageRecipeArn. if a imageRecipeName is provided, the latest version, x.x.x, will
   * be used
   */
  readonly imageRecipeVersion?: string;
}

/**
 * A new or imported Image Recipe
 */
abstract class ImageRecipeBase extends cdk.Resource implements IImageRecipe {
  /**
   * The ARN of the image recipe
   */
  abstract readonly imageRecipeArn: string;

  /**
   * The name of the image recipe
   */
  abstract readonly imageRecipeName: string;

  /**
   * The version of the image recipe
   */
  abstract readonly imageRecipeVersion: string;

  /**
   * Grant custom actions to the given grantee for the image recipe
   * [disable-awslint:no-grants]
   *
   * @param grantee The principal
   * @param actions The list of actions
   */
  public grant(grantee: iam.IGrantable, ...actions: string[]): iam.Grant {
    return iam.Grant.addToPrincipal({
      grantee,
      actions,
      resourceArns: [this.imageRecipeArn],
      scope: this,
    });
  }

  /**
   * Grant read permissions to the given grantee for the image recipe
   * [disable-awslint:no-grants]
   *
   * @param grantee The principal
   */
  public grantRead(grantee: iam.IGrantable): iam.Grant {
    return this.grant(grantee, 'imagebuilder:GetImageRecipe');
  }

  /**
   * Indicates whether the recipe is a Container Recipe
   *
   * @internal
   */
  public _isContainerRecipe(): this is IContainerRecipe {
    return false;
  }

  /**
   * Indicates whether the recipe is an Image Recipe
   *
   * @internal
   */
  public _isImageRecipe(): this is IImageRecipe {
    return true;
  }
}

/**
 * Represents an EC2 Image Builder Image Recipe.
 *
 * @see https://docs.aws.amazon.com/imagebuilder/latest/userguide/manage-recipes.html
 */
@propertyInjectable
export class ImageRecipe extends ImageRecipeBase {
  /** Uniquely identifies this class. */
  public static readonly PROPERTY_INJECTION_ID: string = '@aws-cdk.aws-imagebuilder-alpha.ImageRecipe';

  /**
   * Import an existing image recipe given its ARN.
   */
  public static fromImageRecipeArn(scope: Construct, id: string, imageRecipeArn: string): IImageRecipe {
    return this.fromImageRecipeAttributes(scope, id, { imageRecipeArn });
  }

  /**
   * Import the latest version of an existing image recipe given its name. The provided name must be normalized by
   * converting all alphabetical characters to lowercase, and replacing all spaces and underscores with hyphens.
   */
  public static fromImageRecipeName(scope: Construct, id: string, imageRecipeName: string): IImageRecipe {
    return this.fromImageRecipeAttributes(scope, id, { imageRecipeName });
  }

  /**
   * Import an existing image recipe by providing its attributes. If the image recipe name is provided as an attribute,
   * it must be normalized by converting all alphabetical characters to lowercase, and replacing all spaces and
   * underscores with hyphens.
   */
  public static fromImageRecipeAttributes(scope: Construct, id: string, attrs: ImageRecipeAttributes): IImageRecipe {
    if (!attrs.imageRecipeArn && !attrs.imageRecipeName) {
      throw new cdk.ValidationError(
        'either imageRecipeArn or imageRecipeName must be provided to import an image recipe',
        scope,
      );
    }

    const imageRecipeArn =
      attrs.imageRecipeArn ??
      cdk.Stack.of(scope).formatArn({
        service: 'imagebuilder',
        resource: 'image-recipe',
        resourceName: `${attrs.imageRecipeName}/${attrs.imageRecipeVersion ?? LATEST_VERSION}`,
      });

    const [imageRecipeName, imageRecipeVersion] = (() => {
      if (attrs.imageRecipeName) {
        return [attrs.imageRecipeName, attrs.imageRecipeVersion ?? LATEST_VERSION];
      }

      const imageRecipeNameVersion = cdk.Stack.of(scope).splitArn(
        imageRecipeArn,
        cdk.ArnFormat.SLASH_RESOURCE_NAME,
      ).resourceName!;

      const imageRecipeNameVersionSplit = cdk.Fn.split('/', imageRecipeNameVersion);
      return [cdk.Fn.select(0, imageRecipeNameVersionSplit), cdk.Fn.select(1, imageRecipeNameVersionSplit)];
    })();

    class Import extends ImageRecipeBase {
      public readonly imageRecipeArn = imageRecipeArn;
      public readonly imageRecipeName = imageRecipeName;
      public readonly imageRecipeVersion = imageRecipeVersion;
    }

    return new Import(scope, id);
  }

  /**
   * Return whether the given object is an ImageRecipe.
   */
  public static isImageRecipe(x: any): x is ImageRecipe {
    return x !== null && typeof x === 'object' && IMAGE_RECIPE_SYMBOL in x;
  }

  private readonly blockDevices: ec2.BlockDevice[] = [];
  private resource: CfnImageRecipe;

  public constructor(scope: Construct, id: string, props: ImageRecipeProps) {
    super(scope, id, {
      physicalName:
        props.imageRecipeName ??
        cdk.Lazy.string({
          produce: () =>
            cdk.Names.uniqueResourceName(this, {
              maxLength: 128,
              separator: '-',
              allowedSpecialCharacters: '-',
            }).toLowerCase(), // Enforce lowercase for the auto-generated fallback
        }),
    });
    // Enhanced CDK Analytics Telemetry
    addConstructMetadata(this, props);

    Object.defineProperty(this, IMAGE_RECIPE_SYMBOL, { value: true });

    this.validateImageRecipeName();

    this.addBlockDevice(...(props.blockDevices ?? []));

    const components: CfnImageRecipe.ComponentConfigurationProperty[] | undefined = props.components?.map(
      (component) => ({
        componentArn: component.component.componentArn,
        ...(component.parameters && {
          parameters: Object.entries(component.parameters).map(
            ([name, param]): CfnImageRecipe.ComponentParameterProperty => ({
              name,
              value: param.value,
            }),
          ),
        }),
      }),
    );

    const imageRecipeVersion = props.imageRecipeVersion ?? DEFAULT_RECIPE_VERSION;
    this.resource = new CfnImageRecipe(this, 'Resource', {
      name: this.physicalName,
      version: imageRecipeVersion,
      description: props.description,
      parentImage: props.baseImage.image,
      blockDeviceMappings: cdk.Lazy.any({ produce: () => this.renderBlockDevices() }),
      workingDirectory: props.workingDirectory,
      additionalInstanceConfiguration: this.buildAdditionalInstanceConfiguration(props),
      amiTags: props.amiTags,
      tags: props.tags,
      ...(components?.length && { components }),
    });
  }

  @memoizedGetter
  public get imageRecipeName(): string {
    return this.getResourceNameAttribute(this.resource.attrName);
  }

  @memoizedGetter
  public get imageRecipeArn(): string {
    return this.getResourceArnAttribute(this.resource.attrArn, {
      service: 'imagebuilder',
      resource: 'image-recipe',
      resourceName: `${this.physicalName}/${this.resource.version}`,
    });
  }

  @memoizedGetter
  public get imageRecipeVersion(): string {
    return this.resource.getAtt('Version').toString();
  }

  /**
   * Adds block devices to attach to the instance used for building the image.
   *
   * @param blockDevices The list of block devices to attach
   */
  @MethodMetadata()
  public addBlockDevice(...blockDevices: ec2.BlockDevice[]): void {
    this.blockDevices.push(...blockDevices);
  }

  /**
   * Renders the input block devices, into the `BlockDeviceMapping[]` structure that CfnImageRecipe expects to receive.
   * This is rendered at synthesis time, as users can add additional block devices with `addBlockDevice`, after the
   * construct has been instantiated.
   *
   * @private
   */
  private renderBlockDevices(): CfnImageRecipe.InstanceBlockDeviceMappingProperty[] | undefined {
    const blockDevices = this.blockDevices.map((blockDevice): CfnImageRecipe.InstanceBlockDeviceMappingProperty => {
      const ebsDevice = blockDevice.volume.ebsDevice;
      const ebs: CfnImageRecipe.EbsInstanceBlockDeviceSpecificationProperty = {
        ...(ebsDevice?.deleteOnTermination !== undefined && { deleteOnTermination: ebsDevice.deleteOnTermination }),
        ...(ebsDevice?.encrypted !== undefined && { encrypted: ebsDevice.encrypted }),
        ...(ebsDevice?.iops !== undefined && { iops: ebsDevice.iops }),
        ...(ebsDevice?.kmsKey !== undefined && { kmsKeyId: ebsDevice.kmsKey.keyArn }),
        ...(ebsDevice?.snapshotId !== undefined && { snapshotId: ebsDevice.snapshotId }),
        ...(ebsDevice?.throughput !== undefined && { throughput: ebsDevice.throughput }),
        ...(ebsDevice?.volumeSize !== undefined && { volumeSize: ebsDevice.volumeSize }),
        ...(ebsDevice?.volumeType !== undefined && { volumeType: ebsDevice.volumeType }),
      };

      return {
        deviceName: blockDevice.deviceName,
        virtualName: blockDevice.volume.virtualName,
        ...(blockDevice.mappingEnabled === false && { noDevice: '' }),
        ...(Object.keys(ebs).length && { ebs }),
      };
    });

    return blockDevices.length ? blockDevices : undefined;
  }

  /**
   * Generates the additional instance configuration property into the `AdditionalInstanceConfiguration` type in the
   * CloudFormation L1 definition.
   *
   * @param props The props passed as input to the construct
   * @private
   */
  private buildAdditionalInstanceConfiguration(
    props: ImageRecipeProps,
  ): CfnImageRecipe.AdditionalInstanceConfigurationProperty | undefined {
    const systemsManagerAgent: CfnImageRecipe.SystemsManagerAgentProperty = {
      ...(props.uninstallSsmAgentAfterBuild !== undefined && {
        uninstallAfterBuild: props.uninstallSsmAgentAfterBuild,
      }),
    };

    const additionalInstanceConfiguration: CfnImageRecipe.AdditionalInstanceConfigurationProperty = {
      ...(Object.keys(systemsManagerAgent).length && { systemsManagerAgent }),
      ...(props.userDataOverride !== undefined && { userDataOverride: cdk.Fn.base64(props.userDataOverride.render()) }),
    };

    return Object.keys(additionalInstanceConfiguration).length ? additionalInstanceConfiguration : undefined;
  }

  private validateImageRecipeName() {
    if (cdk.Token.isUnresolved(this.physicalName)) {
      return; // Cannot validate unresolved tokens, given their actual value is rendered at deployment time
    }

    if (this.physicalName.length > 128) {
      throw new cdk.ValidationError(
        `the imageRecipeName cannot be longer than 128 characters, got: '${this.physicalName}'`,
        this,
      );
    }

    if (this.physicalName.includes(' ')) {
      throw new cdk.ValidationError(`the imageRecipeName cannot contain spaces, got: '${this.physicalName}'`, this);
    }

    if (this.physicalName.includes('_')) {
      throw new cdk.ValidationError(
        `the imageRecipeName cannot contain underscores, got: '${this.physicalName}'`,
        this,
      );
    }

    if (this.physicalName !== this.physicalName.toLowerCase()) {
      throw new cdk.ValidationError(`the imageRecipeName must be lowercase, got: '${this.physicalName}'`, this);
    }
  }
}
