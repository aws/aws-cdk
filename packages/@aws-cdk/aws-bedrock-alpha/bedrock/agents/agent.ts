/**
 *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance
 *  with the License. A copy of the License is located at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  or in the 'license' file accompanying this file. This file is distributed on an 'AS IS' BASIS, WITHOUT WARRANTIES
 *  OR CONDITIONS OF ANY KIND, express or implied. See the License for the specific language governing permissions
 *  and limitations under the License.
 */

import { Arn, ArnFormat, Duration, IResource, Lazy, Names, Resource, Stack, Token } from 'aws-cdk-lib/core';
import * as bedrock from 'aws-cdk-lib/aws-bedrock';
import * as cloudwatch from 'aws-cdk-lib/aws-cloudwatch';
import * as events from 'aws-cdk-lib/aws-events';
import * as iam from 'aws-cdk-lib/aws-iam';
import * as kms from 'aws-cdk-lib/aws-kms';
import { Construct, IConstruct } from 'constructs';
// Internal Libs
import { AgentActionGroup } from './action-group';
import { AgentAlias, IAgentAlias } from './agent-alias';
import { AgentCollaborator, AgentCollaboratorType } from './agent-collaborator';
import { PromptOverrideConfiguration } from './prompt-override';
import * as validation from './validation-helpers';
//import { IGuardrail } from '../guardrails/guardrails';
//import { IKnowledgeBase } from '../knowledge-bases/knowledge-base';
import { IInvokable } from '.././models';
import { Memory } from './memory';
import { OrchestrationType, CustomOrchestration } from './orchestration';

/******************************************************************************
 *                              COMMON
 *****************************************************************************/
/**
 * Represents an Agent, either created with CDK or imported.
 */
export interface IAgent extends IResource, iam.IGrantable {
  /**
   * The ARN of the agent.
   * @example "arn:aws:bedrock:us-east-1:123456789012:agent/OKDSJOGKMO"
   * @attribute
   */
  readonly agentArn: string;
  /**
   * The ID of the Agent.
   * @example "OKDSJOGKMO"
   * @attribute
   */
  readonly agentId: string;
  /**
   * The IAM role associated to the agent.
   */
  readonly role: iam.IRole;
  /**
   * Optional KMS encryption key associated with this agent
   */
  readonly kmsKey?: kms.IKey;
  /**
   * When this agent was last updated.
   */
  readonly lastUpdated?: string;

  /**
   * Grant invoke permissions on this agent to an IAM principal.
   */
  grantInvoke(grantee: iam.IGrantable): iam.Grant;

  /**
   * Defines a CloudWatch event rule triggered by agent events.
   */
  onEvent(id: string, options?: events.OnEventOptions): events.Rule;

  /**
   * Return the CloudWatch metric for agent count.
   */
  metricCount(props?: cloudwatch.MetricOptions): cloudwatch.Metric;
}
/******************************************************************************
 *                        ABSTRACT BASE CLASS
 *****************************************************************************/
/**
 * Abstract base class for an Agent.
 * Contains methods and attributes valid for Agents either created with CDK or imported.
 */
export abstract class AgentBase extends Resource implements IAgent {
  public abstract readonly agentArn: string;
  public abstract readonly agentId: string;
  public abstract readonly role: iam.IRole;
  public abstract readonly kmsKey?: kms.IKey;
  public abstract readonly lastUpdated?: string;
  public abstract agentVersion: string;
  public abstract readonly grantPrincipal: iam.IPrincipal;

  public grantInvoke(grantee: iam.IGrantable): iam.Grant {
    return iam.Grant.addToPrincipal({
      grantee,
      actions: ['bedrock:InvokeAgent'],
      resourceArns: [this.agentArn],
    });
  }

  public onEvent(id: string, options: events.OnEventOptions = {}): events.Rule {
    const rule = new events.Rule(this, id, options);
    rule.addTarget(options.target);
    rule.addEventPattern({
      source: ['aws.bedrock'],
      detail: {
        'agent-id': [this.agentId],
      },
    });
    return rule;
  }

  public metricCount(props?: cloudwatch.MetricOptions): cloudwatch.Metric {
    return new cloudwatch.Metric({
      namespace: 'AWS/Bedrock',
      metricName: 'Invocations',
      dimensionsMap: {
        AgentId: this.agentId,
      },
      ...props,
    }).attachTo(this);
  }
}

/******************************************************************************
 *                        PROPS FOR NEW CONSTRUCT
 *****************************************************************************/
/**
 * Properties for creating a CDK managed Bedrock Agent.
 */
export interface AgentProps {
  /**
   * The name of the agent.
   *
   * @default - A name is generated by CDK.
   */
  readonly name?: string;
  /**
   * The instruction used by the agent. This determines how the agent will perform his task.
   * This instruction must have a minimum of 40 characters.
   */
  readonly instruction: string;
  /**
   * The foundation model used for orchestration by the agent.
   */
  readonly foundationModel: IInvokable;
  /**
   * The existing IAM Role for the agent to use.
   * Ensure the role has a trust policy that allows the Bedrock service to assume the role.
   *
   * @default - A new role is created for you.
   */
  readonly existingRole?: iam.IRole;
  /**
   * Specifies whether to automatically update the `DRAFT` version of the agent after
   * making changes to the agent. The `DRAFT` version can be continually iterated
   * upon during internal development.
   *
   * @default - false
   */
  readonly shouldPrepareAgent?: boolean;
  /**
   * How long sessions should be kept open for the agent. If no conversation occurs
   * during this time, the session expires and Amazon Bedrock deletes any data
   * provided before the timeout.
   *
   * @default - 1 hour
   */
  readonly idleSessionTTL?: Duration;
  /**
   * The KMS key of the agent if custom encryption is configured.
   *
   * @default - An AWS managed key is used.
   */
  readonly kmsKey?: kms.IKey;
  /**
   * A description of the agent.
   *
   * @default - No description is provided.
   */
  readonly description?: string;
  /**
   * The Action Groups associated with the agent.
   */
  readonly actionGroups?: AgentActionGroup[];

  /**
   * Overrides some prompt templates in different parts of an agent sequence configuration.
   *
   * @default - No overrides are provided.
   */
  readonly promptOverrideConfiguration?: PromptOverrideConfiguration;
  /**
   * Select whether the agent can prompt additional information from the user when it does not have
   * enough information to respond to an utterance
   *
   * @default - false
   */
  readonly userInputEnabled?: boolean;
  /**
   * Select whether the agent can generate, run, and troubleshoot code when trying to complete a task
   *
   * @default - false
   */
  readonly codeInterpreterEnabled?: boolean;
  /**
   * Whether to delete the resource even if it's in use.
   *
   * @default - true
   */
  readonly forceDelete?: boolean;
  /**
   * The type and configuration of the memory to maintain context across multiple sessions and recall past interactions.
   * This can be useful for maintaining continuity in multi-turn conversations and recalling user preferences
   * or past interactions.
   *
   * @see https://docs.aws.amazon.com/bedrock/latest/userguide/agents-memory.html
   * @default - No memory will be used. Agents will retain context from the current session only.
   */
  readonly memory?: Memory;
  /**
   * The collaboration type for the agent.
   *
   * @default - No collaboration (AgentCollaboratorType.DISABLED).
   */
  readonly agentCollaboration?: AgentCollaboratorType;
  /**
   * Collaborators that this agent will work with.
   *
   * @default - No collaborators.
   */
  readonly agentCollaborators?: AgentCollaborator[];
  /**
   * Details of custom orchestration for the agent.
   *
   * @default - Standard orchestration.
   */
  readonly customOrchestration?: CustomOrchestration;
  /**
   * The type of orchestration to use for the agent.
   *
   * @default - STANDARD
   */
  readonly orchestrationType?: OrchestrationType;
}
/******************************************************************************
 *                      ATTRS FOR IMPORTED CONSTRUCT
 *****************************************************************************/
/**
 * Attributes for specifying an imported Bedrock Agent.
 */
export interface AgentAttributes {
  /**
   * The ARN of the agent.
   * @example "arn:aws:bedrock:us-east-1:123456789012:agent/OKDSJOGKMO"
   * @attribute
   */
  readonly agentArn: string;
  /**
   * The ARN of the IAM role associated to the agent.
   * @example "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
   * @attribute
   */
  readonly roleArn: string;
  /**
   * Optional KMS encryption key associated with this agent
   */
  readonly kmsKeyArn?: string;
  /**
   * When this agent was last updated.
   */
  readonly lastUpdated?: string;
  /**
   * The agent version. If no explicit versions have been created,
   * leave this  empty to use the DRAFT version. Otherwise, use the
   * version number (e.g. 1).
   */
  readonly agentVersion?: string;
}
/******************************************************************************
 *                        NEW CONSTRUCT DEFINITION
 *****************************************************************************/
/**
 * Class to create (or import) an Agent with CDK.
 * @cloudformationResource AWS::Bedrock::Agent
 */
export class Agent extends AgentBase {
  /**
   * Static Method for importing an existing Bedrock Agent.
   */
  public static fromAgentAttrs(scope: Construct, id: string, attrs: AgentAttributes): IAgent {
    class Import extends AgentBase {
      public readonly agentArn = attrs.agentArn;
      public readonly agentId = Arn.split(attrs.agentArn, ArnFormat.SLASH_RESOURCE_NAME).resourceName!;
      public readonly role = iam.Role.fromRoleArn(scope, `${id}Role`, attrs.roleArn);
      public readonly kmsKey = attrs.kmsKeyArn ? kms.Key.fromKeyArn(scope, `${id}Key`, attrs.kmsKeyArn) : undefined;
      public readonly lastUpdated = attrs.lastUpdated;
      public readonly agentVersion = attrs.agentVersion ?? 'DRAFT';
      public readonly grantPrincipal = this.role;
    }

    // Return new Agent
    return new Import(scope, id);
  }
  // ------------------------------------------------------
  // Base attributes
  // ------------------------------------------------------
  /**
   * The unique identifier for the agent
   */
  public readonly agentId: string;
  /**
   * The ARN of the agent.
   */
  public readonly agentArn: string;
  /**
   * The version of the agent.
   */
  public agentVersion: string;
  /**
   * The IAM role associated to the agent.
   */
  public readonly role: iam.IRole;
  /**
   * Optional KMS encryption key associated with this agent
   */
  public readonly kmsKey?: kms.IKey;
  /**
   * When this agent was last updated.
   */
  public readonly lastUpdated?: string;
  /**
   * The principal to grant permissions to
   */
  public readonly grantPrincipal: iam.IPrincipal;
  // ------------------------------------------------------
  // CDK-only attributes
  // ------------------------------------------------------
  /**
   * The name of the agent.
   */
  public readonly name: string;
  /**
   * Whether the agent will automatically update the DRAFT version of the agent after
   * making changes to the agent.
   */
  public readonly shouldPrepareAgent: boolean;
  /**
   * How long sessions should be kept open for the agent.
   */
  public readonly idleSessionTTL: Duration;
  /**
   * The foundation model used for orchestration by the agent.
   */
  public readonly foundationModel: IInvokable;
  /**
   * The default test alias for this agent. This corresponds to the test alias
   * (`TSTALIASID`) that points to the working (`DRAFT`) version.
   */
  public readonly testAlias: IAgentAlias;
  /**
   * Whether the agent can prompt additional information from the user when it does not have
   * enough information to respond to an utterance
   */
  public readonly userInputEnabled: boolean;
  /**
   * Whether the agent can generate, run, and troubleshoot code when trying to complete a task.
   */
  public readonly codeInterpreterEnabled: boolean;
  /**
   * Whether the resource will be deleted even if it's in use.
   */
  public readonly forceDelete: boolean;
  /**
   * Agent collaboration type.
   */
  public readonly agentCollaboration?: AgentCollaboratorType;
  /**
   * Agent collaborators.
   */
  public readonly agentCollaborators?: AgentCollaborator[];
  /**
   * Custom orchestration configuration.
   */
  public readonly customOrchestration?: CustomOrchestration;
  /**
   * The type of orchestration for the agent.
   */
  public readonly orchestrationType?: OrchestrationType;
  // ------------------------------------------------------
  // CDK-only attributes (optional)
  // ------------------------------------------------------
  /**
   * The description for the agent.
   */
  public readonly description?: string;
  /**
   * The instruction used by the agent. This determines how the agent will perform his task.
   */
  public readonly instruction?: string;
  /**
   * Overrides some prompt templates in different parts of an agent sequence configuration.
   *
   * @default - No overrides are provided.
   */
  readonly promptOverrideConfiguration?: PromptOverrideConfiguration;
  /**
   * The memory configuration for the agent.
   */
  public readonly memory?: Memory;
  // ------------------------------------------------------
  // Lazy Attributes
  // ------------------------------------------------------
  /**
   * The action groups associated with the agent.
   */
  public actionGroups: AgentActionGroup[];
  // ------------------------------------------------------
  // Internal Only
  // ------------------------------------------------------
  /**
   * The L1 representation of the agent
   */
  private readonly __resource: bedrock.CfnAgent;

  private readonly ROLE_NAME_SUFFIX = '-bedrockagent';

  private readonly MAXLENGTH_FOR_ROLE_NAME = 64;

  // ------------------------------------------------------
  // CONSTRUCTOR
  // ------------------------------------------------------
  constructor(scope: Construct, id: string, props: AgentProps) {
    super(scope, id);

    // ------------------------------------------------------
    // Validate props
    // ------------------------------------------------------
    if (props.instruction !== undefined && 
        !Token.isUnresolved(props.instruction) && 
        props.instruction.length < 40) {
      throw new Error('instruction must be at least 40 characters');
    }

    // ------------------------------------------------------
    // Set properties and defaults
    // ------------------------------------------------------
    this.name =
      props.name ??  this.generatePhysicalName() + this.ROLE_NAME_SUFFIX;
    this.idleSessionTTL = props.idleSessionTTL ?? Duration.hours(1);
    this.shouldPrepareAgent = props.shouldPrepareAgent ?? false;
    this.userInputEnabled = props.userInputEnabled ?? false;
    this.codeInterpreterEnabled = props.codeInterpreterEnabled ?? false;
    this.foundationModel = props.foundationModel;
    this.forceDelete = props.forceDelete ?? false;

    // Optional
    this.description = props.description;
    this.instruction = props.instruction;
    this.promptOverrideConfiguration = props.promptOverrideConfiguration;
    this.kmsKey = props.kmsKey;
    this.memory = props.memory;
    this.agentCollaboration = props.agentCollaboration;
    this.customOrchestration = props.customOrchestration;
    this.orchestrationType = props.orchestrationType;

    // ------------------------------------------------------
    // Role
    // ------------------------------------------------------
    // If existing role is provided, use it.
    if (props.existingRole) {
      this.role = props.existingRole;
    this.grantPrincipal = this.role;
      // Otherwise, create a new one
    } else {
      this.role = new iam.Role(this, 'Role', {
        // generate a role name
        roleName: this.generatePhysicalName() + this.ROLE_NAME_SUFFIX,
        // ensure the role has a trust policy that allows the Bedrock service to assume the role
        assumedBy: new iam.ServicePrincipal('bedrock.amazonaws.com').withConditions({
          StringEquals: {
            'aws:SourceAccount': { 'Ref': 'AWS::AccountId' },
          },
          ArnLike: {
            'aws:SourceArn': Stack.of(this).formatArn({
              service: 'bedrock',
              resource: 'agent',
              resourceName: '*',
              arnFormat: ArnFormat.SLASH_RESOURCE_NAME,
            }),
          },
        }),
      });
      this.grantPrincipal = this.role;
    }
    // ------------------------------------------------------
    // Set Lazy Props initial values
    // ------------------------------------------------------
    this.actionGroups = [];
    this.agentCollaborators = [];
    // Add Default Action Groups
    this.addActionGroup(AgentActionGroup.userInput(this.userInputEnabled));
    this.addActionGroup(AgentActionGroup.codeInterpreter(this.codeInterpreterEnabled));

    // Add specified elems through methods to handle permissions
    // this needs to happen after role creation / assignment
    props.actionGroups?.forEach(ag => {
      this.addActionGroup(ag);
    });
    props.agentCollaborators?.forEach(ac => {
      this.addAgentCollaborator(ac);
    });

    // Grant permissions for custom orchestration if provided
    if (this.customOrchestration?.executor?.lambdaFunction) {
      this.customOrchestration.executor.lambdaFunction.grantInvoke(this.role);
      this.customOrchestration.executor.lambdaFunction.addPermission(`OrchestrationLambdaInvocationPolicy-${this.node.addr.slice(0, 16)}`, {
        principal: new iam.ServicePrincipal('bedrock.amazonaws.com'),
        sourceArn: Lazy.string({ produce: () => this.agentArn }),
        sourceAccount: Stack.of(this).account,
      });
    }

    // ------------------------------------------------------
    // Set Lazy Validations
    // ------------------------------------------------------

    // ------------------------------------------------------
    // CFN Props - With Lazy support
    // ------------------------------------------------------
    const cfnProps: bedrock.CfnAgentProps = {
      actionGroups: Lazy.any({ produce: () => this.renderActionGroups() }, { omitEmptyArray: true }),
      agentName: this.name,
      agentResourceRoleArn: this.role.roleArn,
      autoPrepare: this.shouldPrepareAgent,
      customerEncryptionKeyArn: props.kmsKey?.keyArn,
      description: props.description,
      foundationModel: this.foundationModel.invokableArn,
      idleSessionTtlInSeconds: this.idleSessionTTL.toSeconds(),
      instruction: props.instruction,
      memoryConfiguration: props.memory,
      promptOverrideConfiguration: this.promptOverrideConfiguration?._render(),
      skipResourceInUseCheckOnDelete: this.forceDelete,
      agentCollaboration: this.agentCollaboration,
      agentCollaborators: Lazy.any({ produce: () => this.renderAgentCollaborators() }, { omitEmptyArray: true }),
      customOrchestration: this.renderCustomOrchestration(),
      orchestrationType: this.orchestrationType,
    };

    // ------------------------------------------------------
    // L1 Instantiation
    // ------------------------------------------------------
    this.__resource = new bedrock.CfnAgent(this, 'AgentResource', cfnProps);

    this.agentId = this.getResourceNameAttribute(this.__resource.attrAgentId);
    this.agentArn = this.getResourceArnAttribute(this.__resource.attrAgentArn, {
      service: 'bedrock',
      resource: 'agent',
      resourceName: this.physicalName,
      arnFormat: ArnFormat.SLASH_RESOURCE_NAME,
    });
    this.agentVersion = this.__resource.attrAgentVersion;
    this.lastUpdated = this.__resource.attrUpdatedAt;

    // Add explicit dependency between the agent resource and the agent's role default policy
    // See https://github.com/awslabs/generative-ai-cdk-constructs/issues/899
    if (!props.existingRole) {
      // add the appropriate permissions to use the FM
      const grant = this.foundationModel.grantInvoke(this.role);
      grant.applyBefore(this.__resource);
    }

    this.testAlias = AgentAlias.fromAttributes(this, 'DefaultAlias', {
      aliasId: 'TSTALIASID',
      aliasName: 'AgentTestAlias',
      agentVersion: 'DRAFT',
      agent: this,
    });
  }

  // ------------------------------------------------------
  // HELPER METHODS - addX()
  // ------------------------------------------------------
  
  /**
   * Add an action group to the agent.
   */
  public addActionGroup(actionGroup: AgentActionGroup) {
    // Do some checks
    validation.throwIfInvalid(this.validateActionGroup, actionGroup);
    // Add it to the array
    this.actionGroups.push(actionGroup);
    // Handle permissions to invoke the lambda function
    actionGroup.executor?.lambdaFunction?.grantInvoke(this.role);
    actionGroup.executor?.lambdaFunction?.addPermission(`LambdaInvocationPolicy-${this.node.addr.slice(0, 16)}`, {
      principal: new iam.ServicePrincipal('bedrock.amazonaws.com'),
      sourceArn: this.agentArn,
      sourceAccount: Stack.of(this).account,
    });
  }

  /**
   * Add an agent collaborator to the agent.
   */
  public addAgentCollaborator(agentCollaborator: AgentCollaborator) {
    this.agentCollaborators?.push(agentCollaborator);
    agentCollaborator.grant(this.role);
  }

  /**
   * Add multiple action groups to the agent.
   */
  public addActionGroups(...actionGroups: AgentActionGroup[]) {
    actionGroups.forEach(ag => this.addActionGroup(ag));
  }

  // ------------------------------------------------------
  // Lazy Renderers
  // ------------------------------------------------------

  /**
   * Render the action groups
   *
   * @internal This is an internal core function and should not be called directly.
   */
  private renderActionGroups(): bedrock.CfnAgent.AgentActionGroupProperty[] {
    const actionGroupsCfn: bedrock.CfnAgent.AgentActionGroupProperty[] = [];
    // Build the associations in the CFN format
    this.actionGroups.forEach(ag => {
      actionGroupsCfn.push(ag._render());
    });
    return actionGroupsCfn;
  }

  /**
   * Render the agent collaborators.
   *
   * @internal This is an internal core function and should not be called directly.
   */
  private renderAgentCollaborators(): bedrock.CfnAgent.AgentCollaboratorProperty[] | undefined {
    if (!this.agentCollaborators || this.agentCollaborators.length === 0) {
      return undefined;
    }

    const agentCollaboratorsCfn: bedrock.CfnAgent.AgentCollaboratorProperty[] = [];

    this.agentCollaborators.forEach(ac => {
      agentCollaboratorsCfn.push(ac._render());
    });
    return agentCollaboratorsCfn;
  }

  /**
   * Render the custom orchestration.
   *
   * @internal This is an internal core function and should not be called directly.
   */
  private renderCustomOrchestration(): bedrock.CfnAgent.CustomOrchestrationProperty | undefined {
    if (!this.customOrchestration) {
      return undefined;
    }

    return {
      executor: {
        lambda: this.customOrchestration.executor.lambdaFunction.functionArn,
      },
    };
  }

  // ------------------------------------------------------
  // Validators
  // ------------------------------------------------------
  /**
   * Check if the action group is valid
   */
  private validateActionGroup = (actionGroup: AgentActionGroup) => {
    console.log('Validating action group: ', actionGroup.name);
    let errors: string[] = [];
    // Find if there is a conflicting action group name
    if (this.actionGroups?.find(ag => ag.name === actionGroup.name)) {
      errors.push(`An action group with name: ${actionGroup.name} has already been defined`);
    }
    return errors;
  };

  

  private generatePhysicalNameHash(
    scope: IConstruct,
    prefix: string,
    options?: {
      maxLength?: number;
      lower?: boolean;
      separator?: string;
      allowedSpecialCharacters?: string;
      destroyCreate?: any;
    },
  ): string {
    const objectToHash = (obj: any): string => {
      if (obj === undefined) { return ''; }
      const jsonString = JSON.stringify(obj);
      const hash = require('crypto').createHash('sha256');
      return hash.update(jsonString).digest('hex').slice(0, 7);
    };

    const {
      maxLength = 256,
      lower = false,
      separator = '',
      allowedSpecialCharacters = undefined,
      destroyCreate = undefined,
    } = options ?? {};

    const hash = objectToHash(destroyCreate);
    if (maxLength < (prefix + hash + separator).length) {
      throw new Error('The prefix is longer than the maximum length.');
    }

    const uniqueName = Names.uniqueResourceName(
      scope,
      { maxLength: maxLength - (prefix + hash + separator).length, separator, allowedSpecialCharacters },
    );
    const name = `${prefix}${hash}${separator}${uniqueName}`;
    if (name.length > maxLength) {
      throw new Error(`The generated name is longer than the maximum length of ${maxLength}`);
    }
    return lower ? name.toLowerCase() : name;
  }

  protected generatePhysicalName(): string {
    const maxLength = this.MAXLENGTH_FOR_ROLE_NAME - this.ROLE_NAME_SUFFIX.length;
    return this.generatePhysicalNameHash(this, 'agent-', {
      maxLength,
      lower: true,
      separator: '-',
    });
  }
}
