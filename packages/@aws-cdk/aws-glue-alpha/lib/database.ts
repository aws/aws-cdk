import { CfnDatabase } from 'aws-cdk-lib/aws-glue';
import type { IResource } from 'aws-cdk-lib/core';
import { ArnFormat, Lazy, Names, Resource, Stack, UnscopedValidationError } from 'aws-cdk-lib/core';
import { memoizedGetter } from 'aws-cdk-lib/core/lib/helpers-internal';
import { addConstructMetadata } from 'aws-cdk-lib/core/lib/metadata-resource';
import { propertyInjectable } from 'aws-cdk-lib/core/lib/prop-injectable';
import type { Construct } from 'constructs';

export interface IDatabase extends IResource {
  /**
   * The ARN of the catalog.
   */
  readonly catalogArn: string;

  /**
   * The catalog id of the database (usually, the AWS account id)
   */
  readonly catalogId: string;

  /**
   * The ARN of the database.
   *
   * @attribute
   */
  readonly databaseArn: string;

  /**
   * The name of the database.
   *
   * @attribute
   */
  readonly databaseName: string;
}

export interface DatabaseProps {
  /**
   * The name of the database.
   *
   * @default - generated by CDK.
   */
  readonly databaseName?: string;

  /**
   * The location of the database (for example, an HDFS path).
   *
   * @default undefined. This field is optional in AWS::Glue::Database DatabaseInput
   * @see https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-database-databaseinput.html
   */
  readonly locationUri?: string;

  /**
   * A description of the database.
   *
   * @default - no database description
   */
  readonly description?: string;
}

/**
 * A Glue database.
 */
@propertyInjectable
export class Database extends Resource implements IDatabase {
  /** Uniquely identifies this class. */
  public static readonly PROPERTY_INJECTION_ID: string = '@aws-cdk.aws-glue-alpha.Database';

  public static fromDatabaseArn(scope: Construct, id: string, databaseArn: string): IDatabase {
    const stack = Stack.of(scope);

    class Import extends Resource implements IDatabase {
      public databaseArn = databaseArn;
      public databaseName = stack.splitArn(databaseArn, ArnFormat.SLASH_RESOURCE_NAME).resourceName!;
      public catalogArn = stack.formatArn({ service: 'glue', resource: 'catalog' });
      public catalogId = stack.account;
    }

    return new Import(scope, id);
  }

  /**
   * ARN of the Glue catalog in which this database is stored.
   */
  public readonly catalogArn: string;

  /**
   * The catalog id of the database (usually, the AWS account id).
   */
  public readonly catalogId: string;

  /**
   * Location URI of this database.
   */
  public locationUri?: string;

  private resource: CfnDatabase;

  constructor(scope: Construct, id: string, props: DatabaseProps = {}) {
    super(scope, id, {
      physicalName: props.databaseName ??
        Lazy.string({
          produce: () => Names.uniqueResourceName(this, {}).toLowerCase(),
        }),
    });
    // Enhanced CDK Analytics Telemetry
    addConstructMetadata(this, props);

    if (props.description !== undefined) {
      validateDescription(props.description);
    }

    let databaseInput: CfnDatabase.DatabaseInputProperty = {
      name: this.physicalName,
      description: props.description,
    };

    if (props.locationUri !== undefined) {
      validateLocationUri(props.locationUri);
      this.locationUri = props.locationUri;
      databaseInput = {
        locationUri: this.locationUri,
        ...databaseInput,
      };
    }

    this.catalogId = Stack.of(this).account;
    this.resource = new CfnDatabase(this, 'Resource', {
      catalogId: this.catalogId,
      databaseInput,
    });

    // catalogId is implicitly the accountId, which is why we don't pass the catalogId here
    this.catalogArn = Stack.of(this).formatArn({
      service: 'glue',
      resource: 'catalog',
    });
  }

  @memoizedGetter
  public get databaseName(): string {
    return this.getResourceNameAttribute(this.resource.ref);
  }

  @memoizedGetter
  public get databaseArn(): string {
    return this.stack.formatArn({
      service: 'glue',
      resource: 'database',
      resourceName: this.databaseName,
    });
  }
}

function validateLocationUri(locationUri: string): void {
  if (locationUri.length < 1 || locationUri.length > 1024) {
    throw new UnscopedValidationError(`locationUri length must be (inclusively) between 1 and 1024, got ${locationUri.length}`);
  }
}

function validateDescription(description: string): void {
  if (description.length > 2048) {
    throw new UnscopedValidationError(`description length must be less than or equal to 2048, got ${description.length}`);
  }
}
