import { Lazy } from "./lazy";
import { generatePhysicalName } from "./physical-name-generator";
import { IResource } from './resource';

/**
 * Options allowing customizing the automatically generated physical name of the resource.
 * Used in the {@link PhysicalName#auto} method.
 */
export interface AutoPhysicalNameOptions {
  /**
   * Allow the framework to automatically allocate a physical name during synthesis
   * in case this resource is referenced across environments.
   *
   * When resources are referenced across environments, the physical name of the
   * resource must be known during synthesis in order to avoid the need to communicate
   * across environments during deployment. This also removes the potential of cyclic
   * references.
   *
   * @default false A physical name will be allocated during deployment by AWS CloudFormation.
   */
  readonly crossEnvironment?: boolean;
}

/**
 * Represents the physical (that is, visible in the AWS Console) name of a resource.
 * These can be known at code runtime,
 * in the case of fixed, customer-provided names,
 * at synthesis time, in case of automatically assigned names by the framework,
 * or only at deploy time, assigned by CloudFormation -
 * which is the default.
 *
 * @see #auto()
 * @see #of()
 */
export abstract class PhysicalName {
  /**
   * A physical name that will be automatically generated.
   * The details of how and when that generation will occur can be customized by passing an instance
   * of {@link AutoPhysicalNameOptions}.
   * By default, the physical name of the resource will be generated by CloudFormation,
   * at deploy time.
   */
  public static auto(options: AutoPhysicalNameOptions = {}): PhysicalName {
    return new LateBoundPhysicalName(options);
  }

  /**
   * A fixed physical name (one that is known statically, at synthesis time).
   *
   * @param name the name to assign
   */
  public static of(name: string): PhysicalName {
    return new FixedPhysicalName(name);
  }

  protected constructor() {
  }

  /**
   * Returns the physical name, as a String.
   * If the customer assigned a physical name to the resource, it will be returned, unchanged;
   * can be `undefined`, if a physical name was not provided,
   * or an opaque Token, if a generated name should be assigned lazily at synthesis time.
   */
  public abstract get value(): string | undefined;

  /**
   * A callback method called if the resource this physical name
   * belongs to has been used in a cross-environment fashion.
   * Allows late-binding of the actual name to only be generated if necessary,
   * and kept deploy-time if not.
   *
   * The default implementation does nothing,
   * but can be overridden in subclasses.
   *
   * @param _resource the resource this physical name belongs to
   * @internal
   */
  public _resolveCrossEnvironment(_resource: IResource): void {
    // does nothing
  }
}

// implementations are private to this module,
// we only surface them through static factory methods

class FixedPhysicalName extends PhysicalName {
  constructor(public readonly value: string) {
    super();
  }
}

class LateBoundPhysicalName extends PhysicalName {
  /**
   * The value of the physical name -
   * either a Token string if crossEnvironment is true,
   * or undefined otherwise.
   */
  public readonly value: string | undefined;
  private name?: string;

  constructor(options: AutoPhysicalNameOptions) {
    super();

    this.value = options.crossEnvironment
      ? Lazy.stringValue({ produce: () => this.name })
      : undefined;
  }

  /** @internal */
  public _resolveCrossEnvironment(resource: IResource): void {
    if (!this.value) {
      // error out - a deploy-time name cannot be used across environments
      throw new Error(`Cannot use resource '${resource.node.path}' in a cross-environment fashion, ` +
        "as it doesn't have a physical name set. Use PhysicalName.auto({ crossEnvironment: true }) to enable cross env name allocation");
    }

    if (!this.name) {
      this.name = generatePhysicalName(resource);
    }
  }
}
