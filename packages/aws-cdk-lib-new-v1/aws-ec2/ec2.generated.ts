/* eslint-disable prettier/prettier,max-len */
import * as cdk from "aws-cdk-lib";
import * as constructs from "constructs";
import * as cfn_parse from "aws-cdk-lib/core/lib/helpers-internal";

/**
 * Creates a new Capacity Reservation with the specified attributes.
 *
 * For more information, see [Capacity Reservations](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-capacity-reservations.html) in the *Amazon EC2 User Guide* .
 *
 * @cloudformationResource AWS::EC2::CapacityReservation
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html
 */
export class CfnCapacityReservation extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::CapacityReservation";

  /**
   * Build a CfnCapacityReservation from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnCapacityReservation {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnCapacityReservationPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnCapacityReservation(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * Returns the Availability Zone in which the capacity is reserved. For example: `us-east-1a` .
   *
   * @cloudformationAttribute AvailabilityZone
   */
  public readonly attrAvailabilityZone: string;

  /**
   * Returns the remaining capacity, which indicates the number of instances that can be launched in the Capacity Reservation. For example: `9` .
   *
   * @cloudformationAttribute AvailableInstanceCount
   */
  public readonly attrAvailableInstanceCount: number;

  /**
   * The ID of the Capacity Reservation.
   *
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * Returns the type of instance for which the capacity is reserved. For example: `m4.large` .
   *
   * @cloudformationAttribute InstanceType
   */
  public readonly attrInstanceType: string;

  /**
   * Returns the tenancy of the Capacity Reservation. For example: `dedicated` .
   *
   * @cloudformationAttribute Tenancy
   */
  public readonly attrTenancy: string;

  /**
   * Returns the total number of instances for which the Capacity Reservation reserves capacity. For example: `15` .
   *
   * @cloudformationAttribute TotalInstanceCount
   */
  public readonly attrTotalInstanceCount: number;

  /**
   * The Availability Zone in which to create the Capacity Reservation.
   */
  public availabilityZone: string;

  /**
   * Indicates whether the Capacity Reservation supports EBS-optimized instances.
   */
  public ebsOptimized?: boolean | cdk.IResolvable;

  /**
   * The date and time at which the Capacity Reservation expires.
   */
  public endDate?: string;

  /**
   * Indicates the way in which the Capacity Reservation ends.
   */
  public endDateType?: string;

  /**
   * *Deprecated.*.
   */
  public ephemeralStorage?: boolean | cdk.IResolvable;

  /**
   * The number of instances for which to reserve capacity.
   */
  public instanceCount: number;

  /**
   * Indicates the type of instance launches that the Capacity Reservation accepts. The options include:.
   */
  public instanceMatchCriteria?: string;

  /**
   * The type of operating system for which to reserve capacity.
   */
  public instancePlatform: string;

  /**
   * The instance type for which to reserve capacity.
   */
  public instanceType: string;

  /**
   * The Amazon Resource Name (ARN) of the Outpost on which to create the Capacity Reservation.
   */
  public outPostArn?: string;

  /**
   * The Amazon Resource Name (ARN) of the cluster placement group in which to create the Capacity Reservation.
   */
  public placementGroupArn?: string;

  /**
   * The tags to apply to the Capacity Reservation during launch.
   */
  public tagSpecifications?: Array<cdk.IResolvable | CfnCapacityReservation.TagSpecificationProperty> | cdk.IResolvable;

  /**
   * Indicates the tenancy of the Capacity Reservation. A Capacity Reservation can have one of the following tenancy settings:.
   */
  public tenancy?: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnCapacityReservationProps) {
    super(scope, id, {
      "type": CfnCapacityReservation.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "availabilityZone", this);
    cdk.requireProperty(props, "instanceCount", this);
    cdk.requireProperty(props, "instancePlatform", this);
    cdk.requireProperty(props, "instanceType", this);

    this.attrAvailabilityZone = cdk.Token.asString(this.getAtt("AvailabilityZone", cdk.ResolutionTypeHint.STRING));
    this.attrAvailableInstanceCount = cdk.Token.asNumber(this.getAtt("AvailableInstanceCount", cdk.ResolutionTypeHint.NUMBER));
    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.attrInstanceType = cdk.Token.asString(this.getAtt("InstanceType", cdk.ResolutionTypeHint.STRING));
    this.attrTenancy = cdk.Token.asString(this.getAtt("Tenancy", cdk.ResolutionTypeHint.STRING));
    this.attrTotalInstanceCount = cdk.Token.asNumber(this.getAtt("TotalInstanceCount", cdk.ResolutionTypeHint.NUMBER));
    this.availabilityZone = props.availabilityZone;
    this.ebsOptimized = props.ebsOptimized;
    this.endDate = props.endDate;
    this.endDateType = props.endDateType;
    this.ephemeralStorage = props.ephemeralStorage;
    this.instanceCount = props.instanceCount;
    this.instanceMatchCriteria = props.instanceMatchCriteria;
    this.instancePlatform = props.instancePlatform;
    this.instanceType = props.instanceType;
    this.outPostArn = props.outPostArn;
    this.placementGroupArn = props.placementGroupArn;
    this.tagSpecifications = props.tagSpecifications;
    this.tenancy = props.tenancy;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "availabilityZone": this.availabilityZone,
      "ebsOptimized": this.ebsOptimized,
      "endDate": this.endDate,
      "endDateType": this.endDateType,
      "ephemeralStorage": this.ephemeralStorage,
      "instanceCount": this.instanceCount,
      "instanceMatchCriteria": this.instanceMatchCriteria,
      "instancePlatform": this.instancePlatform,
      "instanceType": this.instanceType,
      "outPostArn": this.outPostArn,
      "placementGroupArn": this.placementGroupArn,
      "tagSpecifications": this.tagSpecifications,
      "tenancy": this.tenancy
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnCapacityReservation.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnCapacityReservationPropsToCloudFormation(props);
  }
}

export namespace CfnCapacityReservation {
  /**
   * An array of key-value pairs to apply to this resource.
   *
   * For more information, see [Tag](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html) .
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservation-tagspecification.html
   */
  export interface TagSpecificationProperty {
    /**
     * The type of resource to tag.
     *
     * Specify `capacity-reservation` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservation-tagspecification.html#cfn-ec2-capacityreservation-tagspecification-resourcetype
     */
    readonly resourceType?: string;

    /**
     * The tags to apply to the resource.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservation-tagspecification.html#cfn-ec2-capacityreservation-tagspecification-tags
     */
    readonly tags?: Array<cdk.CfnTag>;
  }
}

/**
 * Properties for defining a `CfnCapacityReservation`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html
 */
export interface CfnCapacityReservationProps {
  /**
   * The Availability Zone in which to create the Capacity Reservation.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-availabilityzone
   */
  readonly availabilityZone: string;

  /**
   * Indicates whether the Capacity Reservation supports EBS-optimized instances.
   *
   * This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS- optimized instance.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-ebsoptimized
   */
  readonly ebsOptimized?: boolean | cdk.IResolvable;

  /**
   * The date and time at which the Capacity Reservation expires.
   *
   * When a Capacity Reservation expires, the reserved capacity is released and you can no longer launch instances into it. The Capacity Reservation's state changes to `expired` when it reaches its end date and time.
   *
   * You must provide an `EndDate` value if `EndDateType` is `limited` . Omit `EndDate` if `EndDateType` is `unlimited` .
   *
   * If the `EndDateType` is `limited` , the Capacity Reservation is cancelled within an hour from the specified time. For example, if you specify 5/31/2019, 13:30:55, the Capacity Reservation is guaranteed to end between 13:30:55 and 14:30:55 on 5/31/2019.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-enddate
   */
  readonly endDate?: string;

  /**
   * Indicates the way in which the Capacity Reservation ends.
   *
   * A Capacity Reservation can have one of the following end types:
   *
   * - `unlimited` - The Capacity Reservation remains active until you explicitly cancel it. Do not provide an `EndDate` if the `EndDateType` is `unlimited` .
   * - `limited` - The Capacity Reservation expires automatically at a specified date and time. You must provide an `EndDate` value if the `EndDateType` value is `limited` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-enddatetype
   */
  readonly endDateType?: string;

  /**
   * *Deprecated.*.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-ephemeralstorage
   */
  readonly ephemeralStorage?: boolean | cdk.IResolvable;

  /**
   * The number of instances for which to reserve capacity.
   *
   * Valid range: 1 - 1000
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-instancecount
   */
  readonly instanceCount: number;

  /**
   * Indicates the type of instance launches that the Capacity Reservation accepts. The options include:.
   *
   * - `open` - The Capacity Reservation automatically matches all instances that have matching attributes (instance type, platform, and Availability Zone). Instances that have matching attributes run in the Capacity Reservation automatically without specifying any additional parameters.
   * - `targeted` - The Capacity Reservation only accepts instances that have matching attributes (instance type, platform, and Availability Zone), and explicitly target the Capacity Reservation. This ensures that only permitted instances can use the reserved capacity.
   *
   * Default: `open`
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-instancematchcriteria
   */
  readonly instanceMatchCriteria?: string;

  /**
   * The type of operating system for which to reserve capacity.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-instanceplatform
   */
  readonly instancePlatform: string;

  /**
   * The instance type for which to reserve capacity.
   *
   * For more information, see [Instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the *Amazon EC2 User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-instancetype
   */
  readonly instanceType: string;

  /**
   * The Amazon Resource Name (ARN) of the Outpost on which to create the Capacity Reservation.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-outpostarn
   */
  readonly outPostArn?: string;

  /**
   * The Amazon Resource Name (ARN) of the cluster placement group in which to create the Capacity Reservation.
   *
   * For more information, see [Capacity Reservations for cluster placement groups](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/cr-cpg.html) in the *Amazon EC2 User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-placementgrouparn
   */
  readonly placementGroupArn?: string;

  /**
   * The tags to apply to the Capacity Reservation during launch.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-tagspecifications
   */
  readonly tagSpecifications?: Array<cdk.IResolvable | CfnCapacityReservation.TagSpecificationProperty> | cdk.IResolvable;

  /**
   * Indicates the tenancy of the Capacity Reservation. A Capacity Reservation can have one of the following tenancy settings:.
   *
   * - `default` - The Capacity Reservation is created on hardware that is shared with other AWS accounts .
   * - `dedicated` - The Capacity Reservation is created on single-tenant hardware that is dedicated to a single AWS account .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-tenancy
   */
  readonly tenancy?: string;
}

/**
 * Determine whether the given properties match those of a `TagSpecificationProperty`
 *
 * @param properties - the TypeScript properties of a `TagSpecificationProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnCapacityReservationTagSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("resourceType", cdk.validateString)(properties.resourceType));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \"TagSpecificationProperty\"");
}

// @ts-ignore TS6133
function convertCfnCapacityReservationTagSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnCapacityReservationTagSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "ResourceType": cdk.stringToCloudFormation(properties.resourceType),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnCapacityReservationTagSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnCapacityReservation.TagSpecificationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnCapacityReservation.TagSpecificationProperty>();
  ret.addPropertyResult("resourceType", "ResourceType", (properties.ResourceType != null ? cfn_parse.FromCloudFormation.getString(properties.ResourceType) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `CfnCapacityReservationProps`
 *
 * @param properties - the TypeScript properties of a `CfnCapacityReservationProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnCapacityReservationPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("availabilityZone", cdk.requiredValidator)(properties.availabilityZone));
  errors.collect(cdk.propertyValidator("availabilityZone", cdk.validateString)(properties.availabilityZone));
  errors.collect(cdk.propertyValidator("ebsOptimized", cdk.validateBoolean)(properties.ebsOptimized));
  errors.collect(cdk.propertyValidator("endDate", cdk.validateString)(properties.endDate));
  errors.collect(cdk.propertyValidator("endDateType", cdk.validateString)(properties.endDateType));
  errors.collect(cdk.propertyValidator("ephemeralStorage", cdk.validateBoolean)(properties.ephemeralStorage));
  errors.collect(cdk.propertyValidator("instanceCount", cdk.requiredValidator)(properties.instanceCount));
  errors.collect(cdk.propertyValidator("instanceCount", cdk.validateNumber)(properties.instanceCount));
  errors.collect(cdk.propertyValidator("instanceMatchCriteria", cdk.validateString)(properties.instanceMatchCriteria));
  errors.collect(cdk.propertyValidator("instancePlatform", cdk.requiredValidator)(properties.instancePlatform));
  errors.collect(cdk.propertyValidator("instancePlatform", cdk.validateString)(properties.instancePlatform));
  errors.collect(cdk.propertyValidator("instanceType", cdk.requiredValidator)(properties.instanceType));
  errors.collect(cdk.propertyValidator("instanceType", cdk.validateString)(properties.instanceType));
  errors.collect(cdk.propertyValidator("outPostArn", cdk.validateString)(properties.outPostArn));
  errors.collect(cdk.propertyValidator("placementGroupArn", cdk.validateString)(properties.placementGroupArn));
  errors.collect(cdk.propertyValidator("tagSpecifications", cdk.listValidator(CfnCapacityReservationTagSpecificationPropertyValidator))(properties.tagSpecifications));
  errors.collect(cdk.propertyValidator("tenancy", cdk.validateString)(properties.tenancy));
  return errors.wrap("supplied properties not correct for \"CfnCapacityReservationProps\"");
}

// @ts-ignore TS6133
function convertCfnCapacityReservationPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnCapacityReservationPropsValidator(properties).assertSuccess();
  return {
    "AvailabilityZone": cdk.stringToCloudFormation(properties.availabilityZone),
    "EbsOptimized": cdk.booleanToCloudFormation(properties.ebsOptimized),
    "EndDate": cdk.stringToCloudFormation(properties.endDate),
    "EndDateType": cdk.stringToCloudFormation(properties.endDateType),
    "EphemeralStorage": cdk.booleanToCloudFormation(properties.ephemeralStorage),
    "InstanceCount": cdk.numberToCloudFormation(properties.instanceCount),
    "InstanceMatchCriteria": cdk.stringToCloudFormation(properties.instanceMatchCriteria),
    "InstancePlatform": cdk.stringToCloudFormation(properties.instancePlatform),
    "InstanceType": cdk.stringToCloudFormation(properties.instanceType),
    "OutPostArn": cdk.stringToCloudFormation(properties.outPostArn),
    "PlacementGroupArn": cdk.stringToCloudFormation(properties.placementGroupArn),
    "TagSpecifications": cdk.listMapper(convertCfnCapacityReservationTagSpecificationPropertyToCloudFormation)(properties.tagSpecifications),
    "Tenancy": cdk.stringToCloudFormation(properties.tenancy)
  };
}

// @ts-ignore TS6133
function CfnCapacityReservationPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnCapacityReservationProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnCapacityReservationProps>();
  ret.addPropertyResult("availabilityZone", "AvailabilityZone", (properties.AvailabilityZone != null ? cfn_parse.FromCloudFormation.getString(properties.AvailabilityZone) : undefined));
  ret.addPropertyResult("ebsOptimized", "EbsOptimized", (properties.EbsOptimized != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EbsOptimized) : undefined));
  ret.addPropertyResult("endDate", "EndDate", (properties.EndDate != null ? cfn_parse.FromCloudFormation.getString(properties.EndDate) : undefined));
  ret.addPropertyResult("endDateType", "EndDateType", (properties.EndDateType != null ? cfn_parse.FromCloudFormation.getString(properties.EndDateType) : undefined));
  ret.addPropertyResult("ephemeralStorage", "EphemeralStorage", (properties.EphemeralStorage != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EphemeralStorage) : undefined));
  ret.addPropertyResult("instanceCount", "InstanceCount", (properties.InstanceCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.InstanceCount) : undefined));
  ret.addPropertyResult("instanceMatchCriteria", "InstanceMatchCriteria", (properties.InstanceMatchCriteria != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceMatchCriteria) : undefined));
  ret.addPropertyResult("instancePlatform", "InstancePlatform", (properties.InstancePlatform != null ? cfn_parse.FromCloudFormation.getString(properties.InstancePlatform) : undefined));
  ret.addPropertyResult("instanceType", "InstanceType", (properties.InstanceType != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceType) : undefined));
  ret.addPropertyResult("outPostArn", "OutPostArn", (properties.OutPostArn != null ? cfn_parse.FromCloudFormation.getString(properties.OutPostArn) : undefined));
  ret.addPropertyResult("placementGroupArn", "PlacementGroupArn", (properties.PlacementGroupArn != null ? cfn_parse.FromCloudFormation.getString(properties.PlacementGroupArn) : undefined));
  ret.addPropertyResult("tagSpecifications", "TagSpecifications", (properties.TagSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnCapacityReservationTagSpecificationPropertyFromCloudFormation)(properties.TagSpecifications) : undefined));
  ret.addPropertyResult("tenancy", "Tenancy", (properties.Tenancy != null ? cfn_parse.FromCloudFormation.getString(properties.Tenancy) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Creates a new Capacity Reservation Fleet with the specified attributes.
 *
 * For more information, see [Capacity Reservation Fleets](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/cr-fleets.html) in the *Amazon EC2 User Guide* .
 *
 * @cloudformationResource AWS::EC2::CapacityReservationFleet
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html
 */
export class CfnCapacityReservationFleet extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::CapacityReservationFleet";

  /**
   * Build a CfnCapacityReservationFleet from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnCapacityReservationFleet {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnCapacityReservationFleetPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnCapacityReservationFleet(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the Capacity Reservation Fleet.
   *
   * @cloudformationAttribute CapacityReservationFleetId
   */
  public readonly attrCapacityReservationFleetId: string;

  /**
   * The strategy used by the Capacity Reservation Fleet to determine which of the specified instance types to use.
   */
  public allocationStrategy?: string;

  /**
   * The date and time at which the Capacity Reservation Fleet expires.
   */
  public endDate?: string;

  /**
   * Indicates the type of instance launches that the Capacity Reservation Fleet accepts.
   */
  public instanceMatchCriteria?: string;

  /**
   * Information about the instance types for which to reserve the capacity.
   */
  public instanceTypeSpecifications?: Array<CfnCapacityReservationFleet.InstanceTypeSpecificationProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * Used to add an end date to a Capacity Reservation Fleet that has no end date and time.
   */
  public noRemoveEndDate?: boolean | cdk.IResolvable;

  /**
   * Used to remove an end date from a Capacity Reservation Fleet that is configured to end automatically at a specific date and time.
   */
  public removeEndDate?: boolean | cdk.IResolvable;

  /**
   * The tags to assign to the Capacity Reservation Fleet.
   */
  public tagSpecifications?: Array<cdk.IResolvable | CfnCapacityReservationFleet.TagSpecificationProperty> | cdk.IResolvable;

  /**
   * Indicates the tenancy of the Capacity Reservation Fleet.
   */
  public tenancy?: string;

  /**
   * The total number of capacity units to be reserved by the Capacity Reservation Fleet.
   */
  public totalTargetCapacity?: number;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnCapacityReservationFleetProps = {}) {
    super(scope, id, {
      "type": CfnCapacityReservationFleet.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.attrCapacityReservationFleetId = cdk.Token.asString(this.getAtt("CapacityReservationFleetId", cdk.ResolutionTypeHint.STRING));
    this.allocationStrategy = props.allocationStrategy;
    this.endDate = props.endDate;
    this.instanceMatchCriteria = props.instanceMatchCriteria;
    this.instanceTypeSpecifications = props.instanceTypeSpecifications;
    this.noRemoveEndDate = props.noRemoveEndDate;
    this.removeEndDate = props.removeEndDate;
    this.tagSpecifications = props.tagSpecifications;
    this.tenancy = props.tenancy;
    this.totalTargetCapacity = props.totalTargetCapacity;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "allocationStrategy": this.allocationStrategy,
      "endDate": this.endDate,
      "instanceMatchCriteria": this.instanceMatchCriteria,
      "instanceTypeSpecifications": this.instanceTypeSpecifications,
      "noRemoveEndDate": this.noRemoveEndDate,
      "removeEndDate": this.removeEndDate,
      "tagSpecifications": this.tagSpecifications,
      "tenancy": this.tenancy,
      "totalTargetCapacity": this.totalTargetCapacity
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnCapacityReservationFleet.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnCapacityReservationFleetPropsToCloudFormation(props);
  }
}

export namespace CfnCapacityReservationFleet {
  /**
   * The tags to apply to a resource when the resource is being created.
   *
   * When you specify a tag, you must specify the resource type to tag, otherwise the request will fail.
   *
   * > The `Valid Values` lists all the resource types that can be tagged. However, the action you're using might not support tagging all of these resource types. If you try to tag a resource type that is unsupported for the action you're using, you'll get an error.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-tagspecification.html
   */
  export interface TagSpecificationProperty {
    /**
     * The type of resource to tag on creation. Specify `capacity-reservation-fleet` .
     *
     * To tag a resource after it has been created, see [CreateTags](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateTags.html) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-tagspecification.html#cfn-ec2-capacityreservationfleet-tagspecification-resourcetype
     */
    readonly resourceType?: string;

    /**
     * The tags to apply to the resource.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-tagspecification.html#cfn-ec2-capacityreservationfleet-tagspecification-tags
     */
    readonly tags?: Array<cdk.CfnTag>;
  }

  /**
   * Specifies information about an instance type to use in a Capacity Reservation Fleet.
   *
   * `InstanceTypeSpecification` is a property of the [AWS::EC2::CapacityReservationFleet](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html) resource.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-instancetypespecification.html
   */
  export interface InstanceTypeSpecificationProperty {
    /**
     * The Availability Zone in which the Capacity Reservation Fleet reserves the capacity.
     *
     * A Capacity Reservation Fleet can't span Availability Zones. All instance type specifications that you specify for the Fleet must use the same Availability Zone.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-instancetypespecification.html#cfn-ec2-capacityreservationfleet-instancetypespecification-availabilityzone
     */
    readonly availabilityZone?: string;

    /**
     * The ID of the Availability Zone in which the Capacity Reservation Fleet reserves the capacity.
     *
     * A Capacity Reservation Fleet can't span Availability Zones. All instance type specifications that you specify for the Fleet must use the same Availability Zone.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-instancetypespecification.html#cfn-ec2-capacityreservationfleet-instancetypespecification-availabilityzoneid
     */
    readonly availabilityZoneId?: string;

    /**
     * Indicates whether the Capacity Reservation Fleet supports EBS-optimized instances types.
     *
     * This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using EBS-optimized instance types.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-instancetypespecification.html#cfn-ec2-capacityreservationfleet-instancetypespecification-ebsoptimized
     */
    readonly ebsOptimized?: boolean | cdk.IResolvable;

    /**
     * The type of operating system for which the Capacity Reservation Fleet reserves capacity.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-instancetypespecification.html#cfn-ec2-capacityreservationfleet-instancetypespecification-instanceplatform
     */
    readonly instancePlatform?: string;

    /**
     * The instance type for which the Capacity Reservation Fleet reserves capacity.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-instancetypespecification.html#cfn-ec2-capacityreservationfleet-instancetypespecification-instancetype
     */
    readonly instanceType?: string;

    /**
     * The priority to assign to the instance type.
     *
     * This value is used to determine which of the instance types specified for the Fleet should be prioritized for use. A lower value indicates a high priority. For more information, see [Instance type priority](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/crfleet-concepts.html#instance-priority) in the Amazon EC2 User Guide.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-instancetypespecification.html#cfn-ec2-capacityreservationfleet-instancetypespecification-priority
     */
    readonly priority?: number;

    /**
     * The number of capacity units provided by the specified instance type.
     *
     * This value, together with the total target capacity that you specify for the Fleet determine the number of instances for which the Fleet reserves capacity. Both values are based on units that make sense for your workload. For more information, see [Total target capacity](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/crfleet-concepts.html#target-capacity) in the Amazon EC2 User Guide.
     *
     * Valid Range: Minimum value of `0.001` . Maximum value of `99.999` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-instancetypespecification.html#cfn-ec2-capacityreservationfleet-instancetypespecification-weight
     */
    readonly weight?: number;
  }
}

/**
 * Properties for defining a `CfnCapacityReservationFleet`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html
 */
export interface CfnCapacityReservationFleetProps {
  /**
   * The strategy used by the Capacity Reservation Fleet to determine which of the specified instance types to use.
   *
   * Currently, only the `prioritized` allocation strategy is supported. For more information, see [Allocation strategy](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/crfleet-concepts.html#allocation-strategy) in the Amazon EC2 User Guide.
   *
   * Valid values: `prioritized`
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-allocationstrategy
   */
  readonly allocationStrategy?: string;

  /**
   * The date and time at which the Capacity Reservation Fleet expires.
   *
   * When the Capacity Reservation Fleet expires, its state changes to `expired` and all of the Capacity Reservations in the Fleet expire.
   *
   * The Capacity Reservation Fleet expires within an hour after the specified time. For example, if you specify `5/31/2019` , `13:30:55` , the Capacity Reservation Fleet is guaranteed to expire between `13:30:55` and `14:30:55` on `5/31/2019` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-enddate
   */
  readonly endDate?: string;

  /**
   * Indicates the type of instance launches that the Capacity Reservation Fleet accepts.
   *
   * All Capacity Reservations in the Fleet inherit this instance matching criteria.
   *
   * Currently, Capacity Reservation Fleets support `open` instance matching criteria only. This means that instances that have matching attributes (instance type, platform, and Availability Zone) run in the Capacity Reservations automatically. Instances do not need to explicitly target a Capacity Reservation Fleet to use its reserved capacity.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-instancematchcriteria
   */
  readonly instanceMatchCriteria?: string;

  /**
   * Information about the instance types for which to reserve the capacity.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-instancetypespecifications
   */
  readonly instanceTypeSpecifications?: Array<CfnCapacityReservationFleet.InstanceTypeSpecificationProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * Used to add an end date to a Capacity Reservation Fleet that has no end date and time.
   *
   * To add an end date to a Capacity Reservation Fleet, specify `true` for this paramater and specify the end date and time (in UTC time format) for the *EndDate* parameter.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-noremoveenddate
   */
  readonly noRemoveEndDate?: boolean | cdk.IResolvable;

  /**
   * Used to remove an end date from a Capacity Reservation Fleet that is configured to end automatically at a specific date and time.
   *
   * To remove the end date from a Capacity Reservation Fleet, specify `true` for this paramater and omit the *EndDate* parameter.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-removeenddate
   */
  readonly removeEndDate?: boolean | cdk.IResolvable;

  /**
   * The tags to assign to the Capacity Reservation Fleet.
   *
   * The tags are automatically assigned to the Capacity Reservations in the Fleet.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-tagspecifications
   */
  readonly tagSpecifications?: Array<cdk.IResolvable | CfnCapacityReservationFleet.TagSpecificationProperty> | cdk.IResolvable;

  /**
   * Indicates the tenancy of the Capacity Reservation Fleet.
   *
   * All Capacity Reservations in the Fleet inherit this tenancy. The Capacity Reservation Fleet can have one of the following tenancy settings:
   *
   * - `default` - The Capacity Reservation Fleet is created on hardware that is shared with other AWS accounts .
   * - `dedicated` - The Capacity Reservations are created on single-tenant hardware that is dedicated to a single AWS account .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-tenancy
   */
  readonly tenancy?: string;

  /**
   * The total number of capacity units to be reserved by the Capacity Reservation Fleet.
   *
   * This value, together with the instance type weights that you assign to each instance type used by the Fleet determine the number of instances for which the Fleet reserves capacity. Both values are based on units that make sense for your workload. For more information, see [Total target capacity](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/crfleet-concepts.html#target-capacity) in the Amazon EC2 User Guide.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-totaltargetcapacity
   */
  readonly totalTargetCapacity?: number;
}

/**
 * Determine whether the given properties match those of a `TagSpecificationProperty`
 *
 * @param properties - the TypeScript properties of a `TagSpecificationProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnCapacityReservationFleetTagSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("resourceType", cdk.validateString)(properties.resourceType));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \"TagSpecificationProperty\"");
}

// @ts-ignore TS6133
function convertCfnCapacityReservationFleetTagSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnCapacityReservationFleetTagSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "ResourceType": cdk.stringToCloudFormation(properties.resourceType),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnCapacityReservationFleetTagSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnCapacityReservationFleet.TagSpecificationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnCapacityReservationFleet.TagSpecificationProperty>();
  ret.addPropertyResult("resourceType", "ResourceType", (properties.ResourceType != null ? cfn_parse.FromCloudFormation.getString(properties.ResourceType) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `InstanceTypeSpecificationProperty`
 *
 * @param properties - the TypeScript properties of a `InstanceTypeSpecificationProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnCapacityReservationFleetInstanceTypeSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("availabilityZone", cdk.validateString)(properties.availabilityZone));
  errors.collect(cdk.propertyValidator("availabilityZoneId", cdk.validateString)(properties.availabilityZoneId));
  errors.collect(cdk.propertyValidator("ebsOptimized", cdk.validateBoolean)(properties.ebsOptimized));
  errors.collect(cdk.propertyValidator("instancePlatform", cdk.validateString)(properties.instancePlatform));
  errors.collect(cdk.propertyValidator("instanceType", cdk.validateString)(properties.instanceType));
  errors.collect(cdk.propertyValidator("priority", cdk.validateNumber)(properties.priority));
  errors.collect(cdk.propertyValidator("weight", cdk.validateNumber)(properties.weight));
  return errors.wrap("supplied properties not correct for \"InstanceTypeSpecificationProperty\"");
}

// @ts-ignore TS6133
function convertCfnCapacityReservationFleetInstanceTypeSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnCapacityReservationFleetInstanceTypeSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "AvailabilityZone": cdk.stringToCloudFormation(properties.availabilityZone),
    "AvailabilityZoneId": cdk.stringToCloudFormation(properties.availabilityZoneId),
    "EbsOptimized": cdk.booleanToCloudFormation(properties.ebsOptimized),
    "InstancePlatform": cdk.stringToCloudFormation(properties.instancePlatform),
    "InstanceType": cdk.stringToCloudFormation(properties.instanceType),
    "Priority": cdk.numberToCloudFormation(properties.priority),
    "Weight": cdk.numberToCloudFormation(properties.weight)
  };
}

// @ts-ignore TS6133
function CfnCapacityReservationFleetInstanceTypeSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnCapacityReservationFleet.InstanceTypeSpecificationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnCapacityReservationFleet.InstanceTypeSpecificationProperty>();
  ret.addPropertyResult("availabilityZone", "AvailabilityZone", (properties.AvailabilityZone != null ? cfn_parse.FromCloudFormation.getString(properties.AvailabilityZone) : undefined));
  ret.addPropertyResult("availabilityZoneId", "AvailabilityZoneId", (properties.AvailabilityZoneId != null ? cfn_parse.FromCloudFormation.getString(properties.AvailabilityZoneId) : undefined));
  ret.addPropertyResult("ebsOptimized", "EbsOptimized", (properties.EbsOptimized != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EbsOptimized) : undefined));
  ret.addPropertyResult("instancePlatform", "InstancePlatform", (properties.InstancePlatform != null ? cfn_parse.FromCloudFormation.getString(properties.InstancePlatform) : undefined));
  ret.addPropertyResult("instanceType", "InstanceType", (properties.InstanceType != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceType) : undefined));
  ret.addPropertyResult("priority", "Priority", (properties.Priority != null ? cfn_parse.FromCloudFormation.getNumber(properties.Priority) : undefined));
  ret.addPropertyResult("weight", "Weight", (properties.Weight != null ? cfn_parse.FromCloudFormation.getNumber(properties.Weight) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `CfnCapacityReservationFleetProps`
 *
 * @param properties - the TypeScript properties of a `CfnCapacityReservationFleetProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnCapacityReservationFleetPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("allocationStrategy", cdk.validateString)(properties.allocationStrategy));
  errors.collect(cdk.propertyValidator("endDate", cdk.validateString)(properties.endDate));
  errors.collect(cdk.propertyValidator("instanceMatchCriteria", cdk.validateString)(properties.instanceMatchCriteria));
  errors.collect(cdk.propertyValidator("instanceTypeSpecifications", cdk.listValidator(CfnCapacityReservationFleetInstanceTypeSpecificationPropertyValidator))(properties.instanceTypeSpecifications));
  errors.collect(cdk.propertyValidator("noRemoveEndDate", cdk.validateBoolean)(properties.noRemoveEndDate));
  errors.collect(cdk.propertyValidator("removeEndDate", cdk.validateBoolean)(properties.removeEndDate));
  errors.collect(cdk.propertyValidator("tagSpecifications", cdk.listValidator(CfnCapacityReservationFleetTagSpecificationPropertyValidator))(properties.tagSpecifications));
  errors.collect(cdk.propertyValidator("tenancy", cdk.validateString)(properties.tenancy));
  errors.collect(cdk.propertyValidator("totalTargetCapacity", cdk.validateNumber)(properties.totalTargetCapacity));
  return errors.wrap("supplied properties not correct for \"CfnCapacityReservationFleetProps\"");
}

// @ts-ignore TS6133
function convertCfnCapacityReservationFleetPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnCapacityReservationFleetPropsValidator(properties).assertSuccess();
  return {
    "AllocationStrategy": cdk.stringToCloudFormation(properties.allocationStrategy),
    "EndDate": cdk.stringToCloudFormation(properties.endDate),
    "InstanceMatchCriteria": cdk.stringToCloudFormation(properties.instanceMatchCriteria),
    "InstanceTypeSpecifications": cdk.listMapper(convertCfnCapacityReservationFleetInstanceTypeSpecificationPropertyToCloudFormation)(properties.instanceTypeSpecifications),
    "NoRemoveEndDate": cdk.booleanToCloudFormation(properties.noRemoveEndDate),
    "RemoveEndDate": cdk.booleanToCloudFormation(properties.removeEndDate),
    "TagSpecifications": cdk.listMapper(convertCfnCapacityReservationFleetTagSpecificationPropertyToCloudFormation)(properties.tagSpecifications),
    "Tenancy": cdk.stringToCloudFormation(properties.tenancy),
    "TotalTargetCapacity": cdk.numberToCloudFormation(properties.totalTargetCapacity)
  };
}

// @ts-ignore TS6133
function CfnCapacityReservationFleetPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnCapacityReservationFleetProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnCapacityReservationFleetProps>();
  ret.addPropertyResult("allocationStrategy", "AllocationStrategy", (properties.AllocationStrategy != null ? cfn_parse.FromCloudFormation.getString(properties.AllocationStrategy) : undefined));
  ret.addPropertyResult("endDate", "EndDate", (properties.EndDate != null ? cfn_parse.FromCloudFormation.getString(properties.EndDate) : undefined));
  ret.addPropertyResult("instanceMatchCriteria", "InstanceMatchCriteria", (properties.InstanceMatchCriteria != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceMatchCriteria) : undefined));
  ret.addPropertyResult("instanceTypeSpecifications", "InstanceTypeSpecifications", (properties.InstanceTypeSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnCapacityReservationFleetInstanceTypeSpecificationPropertyFromCloudFormation)(properties.InstanceTypeSpecifications) : undefined));
  ret.addPropertyResult("noRemoveEndDate", "NoRemoveEndDate", (properties.NoRemoveEndDate != null ? cfn_parse.FromCloudFormation.getBoolean(properties.NoRemoveEndDate) : undefined));
  ret.addPropertyResult("removeEndDate", "RemoveEndDate", (properties.RemoveEndDate != null ? cfn_parse.FromCloudFormation.getBoolean(properties.RemoveEndDate) : undefined));
  ret.addPropertyResult("tagSpecifications", "TagSpecifications", (properties.TagSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnCapacityReservationFleetTagSpecificationPropertyFromCloudFormation)(properties.TagSpecifications) : undefined));
  ret.addPropertyResult("tenancy", "Tenancy", (properties.Tenancy != null ? cfn_parse.FromCloudFormation.getString(properties.Tenancy) : undefined));
  ret.addPropertyResult("totalTargetCapacity", "TotalTargetCapacity", (properties.TotalTargetCapacity != null ? cfn_parse.FromCloudFormation.getNumber(properties.TotalTargetCapacity) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Creates a carrier gateway.
 *
 * For more information about carrier gateways, see [Carrier gateways](https://docs.aws.amazon.com/wavelength/latest/developerguide/how-wavelengths-work.html#wavelength-carrier-gateway) in the *AWS Wavelength Developer Guide* .
 *
 * @cloudformationResource AWS::EC2::CarrierGateway
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-carriergateway.html
 */
export class CfnCarrierGateway extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::CarrierGateway";

  /**
   * Build a CfnCarrierGateway from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnCarrierGateway {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnCarrierGatewayPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnCarrierGateway(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the carrier gateway.
   *
   * @cloudformationAttribute CarrierGatewayId
   */
  public readonly attrCarrierGatewayId: string;

  /**
   * The AWS account ID of the owner of the carrier gateway.
   *
   * @cloudformationAttribute OwnerId
   */
  public readonly attrOwnerId: string;

  /**
   * The state of the carrier gateway.
   *
   * @cloudformationAttribute State
   */
  public readonly attrState: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags assigned to the carrier gateway.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The ID of the VPC associated with the carrier gateway.
   */
  public vpcId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnCarrierGatewayProps) {
    super(scope, id, {
      "type": CfnCarrierGateway.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "vpcId", this);

    this.attrCarrierGatewayId = cdk.Token.asString(this.getAtt("CarrierGatewayId", cdk.ResolutionTypeHint.STRING));
    this.attrOwnerId = cdk.Token.asString(this.getAtt("OwnerId", cdk.ResolutionTypeHint.STRING));
    this.attrState = cdk.Token.asString(this.getAtt("State", cdk.ResolutionTypeHint.STRING));
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::CarrierGateway", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.vpcId = props.vpcId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "tags": this.tags.renderTags(),
      "vpcId": this.vpcId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnCarrierGateway.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnCarrierGatewayPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a `CfnCarrierGateway`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-carriergateway.html
 */
export interface CfnCarrierGatewayProps {
  /**
   * The tags assigned to the carrier gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-carriergateway.html#cfn-ec2-carriergateway-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The ID of the VPC associated with the carrier gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-carriergateway.html#cfn-ec2-carriergateway-vpcid
   */
  readonly vpcId: string;
}

/**
 * Determine whether the given properties match those of a `CfnCarrierGatewayProps`
 *
 * @param properties - the TypeScript properties of a `CfnCarrierGatewayProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnCarrierGatewayPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("vpcId", cdk.requiredValidator)(properties.vpcId));
  errors.collect(cdk.propertyValidator("vpcId", cdk.validateString)(properties.vpcId));
  return errors.wrap("supplied properties not correct for \"CfnCarrierGatewayProps\"");
}

// @ts-ignore TS6133
function convertCfnCarrierGatewayPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnCarrierGatewayPropsValidator(properties).assertSuccess();
  return {
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "VpcId": cdk.stringToCloudFormation(properties.vpcId)
  };
}

// @ts-ignore TS6133
function CfnCarrierGatewayPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnCarrierGatewayProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnCarrierGatewayProps>();
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("vpcId", "VpcId", (properties.VpcId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies an ingress authorization rule to add to a Client VPN endpoint.
 *
 * Ingress authorization rules act as firewall rules that grant access to networks. You must configure ingress authorization rules to enable clients to access resources in AWS or on-premises networks.
 *
 * @cloudformationResource AWS::EC2::ClientVpnAuthorizationRule
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnauthorizationrule.html
 */
export class CfnClientVpnAuthorizationRule extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::ClientVpnAuthorizationRule";

  /**
   * Build a CfnClientVpnAuthorizationRule from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnClientVpnAuthorizationRule {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnClientVpnAuthorizationRulePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnClientVpnAuthorizationRule(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The ID of the group to grant access to, for example, the Active Directory group or identity provider (IdP) group.
   */
  public accessGroupId?: string;

  /**
   * Indicates whether to grant access to all clients.
   */
  public authorizeAllGroups?: boolean | cdk.IResolvable;

  /**
   * The ID of the Client VPN endpoint.
   */
  public clientVpnEndpointId: string;

  /**
   * A brief description of the authorization rule.
   */
  public description?: string;

  /**
   * The IPv4 address range, in CIDR notation, of the network for which access is being authorized.
   */
  public targetNetworkCidr: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnClientVpnAuthorizationRuleProps) {
    super(scope, id, {
      "type": CfnClientVpnAuthorizationRule.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "clientVpnEndpointId", this);
    cdk.requireProperty(props, "targetNetworkCidr", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.accessGroupId = props.accessGroupId;
    this.authorizeAllGroups = props.authorizeAllGroups;
    this.clientVpnEndpointId = props.clientVpnEndpointId;
    this.description = props.description;
    this.targetNetworkCidr = props.targetNetworkCidr;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "accessGroupId": this.accessGroupId,
      "authorizeAllGroups": this.authorizeAllGroups,
      "clientVpnEndpointId": this.clientVpnEndpointId,
      "description": this.description,
      "targetNetworkCidr": this.targetNetworkCidr
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnClientVpnAuthorizationRule.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnClientVpnAuthorizationRulePropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a `CfnClientVpnAuthorizationRule`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnauthorizationrule.html
 */
export interface CfnClientVpnAuthorizationRuleProps {
  /**
   * The ID of the group to grant access to, for example, the Active Directory group or identity provider (IdP) group.
   *
   * Required if `AuthorizeAllGroups` is `false` or not specified.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnauthorizationrule.html#cfn-ec2-clientvpnauthorizationrule-accessgroupid
   */
  readonly accessGroupId?: string;

  /**
   * Indicates whether to grant access to all clients.
   *
   * Specify `true` to grant all clients who successfully establish a VPN connection access to the network. Must be set to `true` if `AccessGroupId` is not specified.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnauthorizationrule.html#cfn-ec2-clientvpnauthorizationrule-authorizeallgroups
   */
  readonly authorizeAllGroups?: boolean | cdk.IResolvable;

  /**
   * The ID of the Client VPN endpoint.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnauthorizationrule.html#cfn-ec2-clientvpnauthorizationrule-clientvpnendpointid
   */
  readonly clientVpnEndpointId: string;

  /**
   * A brief description of the authorization rule.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnauthorizationrule.html#cfn-ec2-clientvpnauthorizationrule-description
   */
  readonly description?: string;

  /**
   * The IPv4 address range, in CIDR notation, of the network for which access is being authorized.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnauthorizationrule.html#cfn-ec2-clientvpnauthorizationrule-targetnetworkcidr
   */
  readonly targetNetworkCidr: string;
}

/**
 * Determine whether the given properties match those of a `CfnClientVpnAuthorizationRuleProps`
 *
 * @param properties - the TypeScript properties of a `CfnClientVpnAuthorizationRuleProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnClientVpnAuthorizationRulePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("accessGroupId", cdk.validateString)(properties.accessGroupId));
  errors.collect(cdk.propertyValidator("authorizeAllGroups", cdk.validateBoolean)(properties.authorizeAllGroups));
  errors.collect(cdk.propertyValidator("clientVpnEndpointId", cdk.requiredValidator)(properties.clientVpnEndpointId));
  errors.collect(cdk.propertyValidator("clientVpnEndpointId", cdk.validateString)(properties.clientVpnEndpointId));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("targetNetworkCidr", cdk.requiredValidator)(properties.targetNetworkCidr));
  errors.collect(cdk.propertyValidator("targetNetworkCidr", cdk.validateString)(properties.targetNetworkCidr));
  return errors.wrap("supplied properties not correct for \"CfnClientVpnAuthorizationRuleProps\"");
}

// @ts-ignore TS6133
function convertCfnClientVpnAuthorizationRulePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnClientVpnAuthorizationRulePropsValidator(properties).assertSuccess();
  return {
    "AccessGroupId": cdk.stringToCloudFormation(properties.accessGroupId),
    "AuthorizeAllGroups": cdk.booleanToCloudFormation(properties.authorizeAllGroups),
    "ClientVpnEndpointId": cdk.stringToCloudFormation(properties.clientVpnEndpointId),
    "Description": cdk.stringToCloudFormation(properties.description),
    "TargetNetworkCidr": cdk.stringToCloudFormation(properties.targetNetworkCidr)
  };
}

// @ts-ignore TS6133
function CfnClientVpnAuthorizationRulePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnClientVpnAuthorizationRuleProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnClientVpnAuthorizationRuleProps>();
  ret.addPropertyResult("accessGroupId", "AccessGroupId", (properties.AccessGroupId != null ? cfn_parse.FromCloudFormation.getString(properties.AccessGroupId) : undefined));
  ret.addPropertyResult("authorizeAllGroups", "AuthorizeAllGroups", (properties.AuthorizeAllGroups != null ? cfn_parse.FromCloudFormation.getBoolean(properties.AuthorizeAllGroups) : undefined));
  ret.addPropertyResult("clientVpnEndpointId", "ClientVpnEndpointId", (properties.ClientVpnEndpointId != null ? cfn_parse.FromCloudFormation.getString(properties.ClientVpnEndpointId) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("targetNetworkCidr", "TargetNetworkCidr", (properties.TargetNetworkCidr != null ? cfn_parse.FromCloudFormation.getString(properties.TargetNetworkCidr) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a Client VPN endpoint.
 *
 * A Client VPN endpoint is the resource you create and configure to enable and manage client VPN sessions. It is the destination endpoint at which all client VPN sessions are terminated.
 *
 * @cloudformationResource AWS::EC2::ClientVpnEndpoint
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html
 */
export class CfnClientVpnEndpoint extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::ClientVpnEndpoint";

  /**
   * Build a CfnClientVpnEndpoint from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnClientVpnEndpoint {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnClientVpnEndpointPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnClientVpnEndpoint(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * Information about the authentication method to be used to authenticate clients.
   */
  public authenticationOptions: Array<CfnClientVpnEndpoint.ClientAuthenticationRequestProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * The IPv4 address range, in CIDR notation, from which to assign client IP addresses.
   */
  public clientCidrBlock: string;

  /**
   * The options for managing connection authorization for new client connections.
   */
  public clientConnectOptions?: CfnClientVpnEndpoint.ClientConnectOptionsProperty | cdk.IResolvable;

  /**
   * Options for enabling a customizable text banner that will be displayed on AWS provided clients when a VPN session is established.
   */
  public clientLoginBannerOptions?: CfnClientVpnEndpoint.ClientLoginBannerOptionsProperty | cdk.IResolvable;

  /**
   * Information about the client connection logging options.
   */
  public connectionLogOptions: CfnClientVpnEndpoint.ConnectionLogOptionsProperty | cdk.IResolvable;

  /**
   * A brief description of the Client VPN endpoint.
   */
  public description?: string;

  /**
   * Information about the DNS servers to be used for DNS resolution.
   */
  public dnsServers?: Array<string>;

  /**
   * The IDs of one or more security groups to apply to the target network.
   */
  public securityGroupIds?: Array<string>;

  /**
   * Specify whether to enable the self-service portal for the Client VPN endpoint.
   */
  public selfServicePortal?: string;

  /**
   * The ARN of the server certificate.
   */
  public serverCertificateArn: string;

  /**
   * The maximum VPN session duration time in hours.
   */
  public sessionTimeoutHours?: number;

  /**
   * Indicates whether split-tunnel is enabled on the AWS Client VPN endpoint.
   */
  public splitTunnel?: boolean | cdk.IResolvable;

  /**
   * The tags to apply to the Client VPN endpoint during creation.
   */
  public tagSpecifications?: Array<cdk.IResolvable | CfnClientVpnEndpoint.TagSpecificationProperty> | cdk.IResolvable;

  /**
   * The transport protocol to be used by the VPN session.
   */
  public transportProtocol?: string;

  /**
   * The ID of the VPC to associate with the Client VPN endpoint.
   */
  public vpcId?: string;

  /**
   * The port number to assign to the Client VPN endpoint for TCP and UDP traffic.
   */
  public vpnPort?: number;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnClientVpnEndpointProps) {
    super(scope, id, {
      "type": CfnClientVpnEndpoint.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "authenticationOptions", this);
    cdk.requireProperty(props, "clientCidrBlock", this);
    cdk.requireProperty(props, "connectionLogOptions", this);
    cdk.requireProperty(props, "serverCertificateArn", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.authenticationOptions = props.authenticationOptions;
    this.clientCidrBlock = props.clientCidrBlock;
    this.clientConnectOptions = props.clientConnectOptions;
    this.clientLoginBannerOptions = props.clientLoginBannerOptions;
    this.connectionLogOptions = props.connectionLogOptions;
    this.description = props.description;
    this.dnsServers = props.dnsServers;
    this.securityGroupIds = props.securityGroupIds;
    this.selfServicePortal = props.selfServicePortal;
    this.serverCertificateArn = props.serverCertificateArn;
    this.sessionTimeoutHours = props.sessionTimeoutHours;
    this.splitTunnel = props.splitTunnel;
    this.tagSpecifications = props.tagSpecifications;
    this.transportProtocol = props.transportProtocol;
    this.vpcId = props.vpcId;
    this.vpnPort = props.vpnPort;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "authenticationOptions": this.authenticationOptions,
      "clientCidrBlock": this.clientCidrBlock,
      "clientConnectOptions": this.clientConnectOptions,
      "clientLoginBannerOptions": this.clientLoginBannerOptions,
      "connectionLogOptions": this.connectionLogOptions,
      "description": this.description,
      "dnsServers": this.dnsServers,
      "securityGroupIds": this.securityGroupIds,
      "selfServicePortal": this.selfServicePortal,
      "serverCertificateArn": this.serverCertificateArn,
      "sessionTimeoutHours": this.sessionTimeoutHours,
      "splitTunnel": this.splitTunnel,
      "tagSpecifications": this.tagSpecifications,
      "transportProtocol": this.transportProtocol,
      "vpcId": this.vpcId,
      "vpnPort": this.vpnPort
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnClientVpnEndpoint.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnClientVpnEndpointPropsToCloudFormation(props);
  }
}

export namespace CfnClientVpnEndpoint {
  /**
   * Indicates whether client connect options are enabled.
   *
   * The default is `false` (not enabled).
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientconnectoptions.html
   */
  export interface ClientConnectOptionsProperty {
    /**
     * Indicates whether client connect options are enabled.
     *
     * The default is `false` (not enabled).
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientconnectoptions.html#cfn-ec2-clientvpnendpoint-clientconnectoptions-enabled
     */
    readonly enabled: boolean | cdk.IResolvable;

    /**
     * The Amazon Resource Name (ARN) of the AWS Lambda function used for connection authorization.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientconnectoptions.html#cfn-ec2-clientvpnendpoint-clientconnectoptions-lambdafunctionarn
     */
    readonly lambdaFunctionArn?: string;
  }

  /**
   * The tags to apply to a resource when the resource is being created.
   *
   * When you specify a tag, you must specify the resource type to tag, otherwise the request will fail.
   *
   * > The `Valid Values` lists all the resource types that can be tagged. However, the action you're using might not support tagging all of these resource types. If you try to tag a resource type that is unsupported for the action you're using, you'll get an error.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-tagspecification.html
   */
  export interface TagSpecificationProperty {
    /**
     * The type of resource to tag.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-tagspecification.html#cfn-ec2-clientvpnendpoint-tagspecification-resourcetype
     */
    readonly resourceType: string;

    /**
     * The tags to apply to the resource.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-tagspecification.html#cfn-ec2-clientvpnendpoint-tagspecification-tags
     */
    readonly tags: Array<cdk.CfnTag>;
  }

  /**
   * Describes the authentication method to be used by a Client VPN endpoint.
   *
   * For more information, see [Authentication](https://docs.aws.amazon.com/vpn/latest/clientvpn-admin/authentication-authrization.html#client-authentication) in the *AWS Client VPN Administrator Guide* .
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientauthenticationrequest.html
   */
  export interface ClientAuthenticationRequestProperty {
    /**
     * Information about the Active Directory to be used, if applicable.
     *
     * You must provide this information if *Type* is `directory-service-authentication` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientauthenticationrequest.html#cfn-ec2-clientvpnendpoint-clientauthenticationrequest-activedirectory
     */
    readonly activeDirectory?: CfnClientVpnEndpoint.DirectoryServiceAuthenticationRequestProperty | cdk.IResolvable;

    /**
     * Information about the IAM SAML identity provider, if applicable.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientauthenticationrequest.html#cfn-ec2-clientvpnendpoint-clientauthenticationrequest-federatedauthentication
     */
    readonly federatedAuthentication?: CfnClientVpnEndpoint.FederatedAuthenticationRequestProperty | cdk.IResolvable;

    /**
     * Information about the authentication certificates to be used, if applicable.
     *
     * You must provide this information if *Type* is `certificate-authentication` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientauthenticationrequest.html#cfn-ec2-clientvpnendpoint-clientauthenticationrequest-mutualauthentication
     */
    readonly mutualAuthentication?: CfnClientVpnEndpoint.CertificateAuthenticationRequestProperty | cdk.IResolvable;

    /**
     * The type of client authentication to be used.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientauthenticationrequest.html#cfn-ec2-clientvpnendpoint-clientauthenticationrequest-type
     */
    readonly type: string;
  }

  /**
   * Information about the client certificate to be used for authentication.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-certificateauthenticationrequest.html
   */
  export interface CertificateAuthenticationRequestProperty {
    /**
     * The ARN of the client certificate.
     *
     * The certificate must be signed by a certificate authority (CA) and it must be provisioned in AWS Certificate Manager (ACM).
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-certificateauthenticationrequest.html#cfn-ec2-clientvpnendpoint-certificateauthenticationrequest-clientrootcertificatechainarn
     */
    readonly clientRootCertificateChainArn: string;
  }

  /**
   * The IAM SAML identity provider used for federated authentication.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-federatedauthenticationrequest.html
   */
  export interface FederatedAuthenticationRequestProperty {
    /**
     * The Amazon Resource Name (ARN) of the IAM SAML identity provider.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-federatedauthenticationrequest.html#cfn-ec2-clientvpnendpoint-federatedauthenticationrequest-samlproviderarn
     */
    readonly samlProviderArn: string;

    /**
     * The Amazon Resource Name (ARN) of the IAM SAML identity provider for the self-service portal.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-federatedauthenticationrequest.html#cfn-ec2-clientvpnendpoint-federatedauthenticationrequest-selfservicesamlproviderarn
     */
    readonly selfServiceSamlProviderArn?: string;
  }

  /**
   * Describes the Active Directory to be used for client authentication.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-directoryserviceauthenticationrequest.html
   */
  export interface DirectoryServiceAuthenticationRequestProperty {
    /**
     * The ID of the Active Directory to be used for authentication.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-directoryserviceauthenticationrequest.html#cfn-ec2-clientvpnendpoint-directoryserviceauthenticationrequest-directoryid
     */
    readonly directoryId: string;
  }

  /**
   * Describes the client connection logging options for the Client VPN endpoint.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-connectionlogoptions.html
   */
  export interface ConnectionLogOptionsProperty {
    /**
     * The name of the CloudWatch Logs log group.
     *
     * Required if connection logging is enabled.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-connectionlogoptions.html#cfn-ec2-clientvpnendpoint-connectionlogoptions-cloudwatchloggroup
     */
    readonly cloudwatchLogGroup?: string;

    /**
     * The name of the CloudWatch Logs log stream to which the connection data is published.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-connectionlogoptions.html#cfn-ec2-clientvpnendpoint-connectionlogoptions-cloudwatchlogstream
     */
    readonly cloudwatchLogStream?: string;

    /**
     * Indicates whether connection logging is enabled.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-connectionlogoptions.html#cfn-ec2-clientvpnendpoint-connectionlogoptions-enabled
     */
    readonly enabled: boolean | cdk.IResolvable;
  }

  /**
   * Options for enabling a customizable text banner that will be displayed on AWS provided clients when a VPN session is established.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientloginbanneroptions.html
   */
  export interface ClientLoginBannerOptionsProperty {
    /**
     * Customizable text that will be displayed in a banner on AWS provided clients when a VPN session is established.
     *
     * UTF-8 encoded characters only. Maximum of 1400 characters.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientloginbanneroptions.html#cfn-ec2-clientvpnendpoint-clientloginbanneroptions-bannertext
     */
    readonly bannerText?: string;

    /**
     * Enable or disable a customizable text banner that will be displayed on AWS provided clients when a VPN session is established.
     *
     * Valid values: `true | false`
     *
     * Default value: `false`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientloginbanneroptions.html#cfn-ec2-clientvpnendpoint-clientloginbanneroptions-enabled
     */
    readonly enabled: boolean | cdk.IResolvable;
  }
}

/**
 * Properties for defining a `CfnClientVpnEndpoint`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html
 */
export interface CfnClientVpnEndpointProps {
  /**
   * Information about the authentication method to be used to authenticate clients.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-authenticationoptions
   */
  readonly authenticationOptions: Array<CfnClientVpnEndpoint.ClientAuthenticationRequestProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * The IPv4 address range, in CIDR notation, from which to assign client IP addresses.
   *
   * The address range cannot overlap with the local CIDR of the VPC in which the associated subnet is located, or the routes that you add manually. The address range cannot be changed after the Client VPN endpoint has been created. Client CIDR range must have a size of at least /22 and must not be greater than /12.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-clientcidrblock
   */
  readonly clientCidrBlock: string;

  /**
   * The options for managing connection authorization for new client connections.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-clientconnectoptions
   */
  readonly clientConnectOptions?: CfnClientVpnEndpoint.ClientConnectOptionsProperty | cdk.IResolvable;

  /**
   * Options for enabling a customizable text banner that will be displayed on AWS provided clients when a VPN session is established.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-clientloginbanneroptions
   */
  readonly clientLoginBannerOptions?: CfnClientVpnEndpoint.ClientLoginBannerOptionsProperty | cdk.IResolvable;

  /**
   * Information about the client connection logging options.
   *
   * If you enable client connection logging, data about client connections is sent to a Cloudwatch Logs log stream. The following information is logged:
   *
   * - Client connection requests
   * - Client connection results (successful and unsuccessful)
   * - Reasons for unsuccessful client connection requests
   * - Client connection termination time
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-connectionlogoptions
   */
  readonly connectionLogOptions: CfnClientVpnEndpoint.ConnectionLogOptionsProperty | cdk.IResolvable;

  /**
   * A brief description of the Client VPN endpoint.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-description
   */
  readonly description?: string;

  /**
   * Information about the DNS servers to be used for DNS resolution.
   *
   * A Client VPN endpoint can have up to two DNS servers. If no DNS server is specified, the DNS address configured on the device is used for the DNS server.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-dnsservers
   */
  readonly dnsServers?: Array<string>;

  /**
   * The IDs of one or more security groups to apply to the target network.
   *
   * You must also specify the ID of the VPC that contains the security groups.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-securitygroupids
   */
  readonly securityGroupIds?: Array<string>;

  /**
   * Specify whether to enable the self-service portal for the Client VPN endpoint.
   *
   * Default Value: `enabled`
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-selfserviceportal
   */
  readonly selfServicePortal?: string;

  /**
   * The ARN of the server certificate.
   *
   * For more information, see the [AWS Certificate Manager User Guide](https://docs.aws.amazon.com/acm/latest/userguide/) .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-servercertificatearn
   */
  readonly serverCertificateArn: string;

  /**
   * The maximum VPN session duration time in hours.
   *
   * Valid values: `8 | 10 | 12 | 24`
   *
   * Default value: `24`
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-sessiontimeouthours
   */
  readonly sessionTimeoutHours?: number;

  /**
   * Indicates whether split-tunnel is enabled on the AWS Client VPN endpoint.
   *
   * By default, split-tunnel on a VPN endpoint is disabled.
   *
   * For information about split-tunnel VPN endpoints, see [Split-tunnel AWS Client VPN endpoint](https://docs.aws.amazon.com/vpn/latest/clientvpn-admin/split-tunnel-vpn.html) in the *AWS Client VPN Administrator Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-splittunnel
   */
  readonly splitTunnel?: boolean | cdk.IResolvable;

  /**
   * The tags to apply to the Client VPN endpoint during creation.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-tagspecifications
   */
  readonly tagSpecifications?: Array<cdk.IResolvable | CfnClientVpnEndpoint.TagSpecificationProperty> | cdk.IResolvable;

  /**
   * The transport protocol to be used by the VPN session.
   *
   * Default value: `udp`
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-transportprotocol
   */
  readonly transportProtocol?: string;

  /**
   * The ID of the VPC to associate with the Client VPN endpoint.
   *
   * If no security group IDs are specified in the request, the default security group for the VPC is applied.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-vpcid
   */
  readonly vpcId?: string;

  /**
   * The port number to assign to the Client VPN endpoint for TCP and UDP traffic.
   *
   * Valid Values: `443` | `1194`
   *
   * Default Value: `443`
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-vpnport
   */
  readonly vpnPort?: number;
}

/**
 * Determine whether the given properties match those of a `ClientConnectOptionsProperty`
 *
 * @param properties - the TypeScript properties of a `ClientConnectOptionsProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnClientVpnEndpointClientConnectOptionsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("enabled", cdk.requiredValidator)(properties.enabled));
  errors.collect(cdk.propertyValidator("enabled", cdk.validateBoolean)(properties.enabled));
  errors.collect(cdk.propertyValidator("lambdaFunctionArn", cdk.validateString)(properties.lambdaFunctionArn));
  return errors.wrap("supplied properties not correct for \"ClientConnectOptionsProperty\"");
}

// @ts-ignore TS6133
function convertCfnClientVpnEndpointClientConnectOptionsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnClientVpnEndpointClientConnectOptionsPropertyValidator(properties).assertSuccess();
  return {
    "Enabled": cdk.booleanToCloudFormation(properties.enabled),
    "LambdaFunctionArn": cdk.stringToCloudFormation(properties.lambdaFunctionArn)
  };
}

// @ts-ignore TS6133
function CfnClientVpnEndpointClientConnectOptionsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnClientVpnEndpoint.ClientConnectOptionsProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnClientVpnEndpoint.ClientConnectOptionsProperty>();
  ret.addPropertyResult("enabled", "Enabled", (properties.Enabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Enabled) : undefined));
  ret.addPropertyResult("lambdaFunctionArn", "LambdaFunctionArn", (properties.LambdaFunctionArn != null ? cfn_parse.FromCloudFormation.getString(properties.LambdaFunctionArn) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `TagSpecificationProperty`
 *
 * @param properties - the TypeScript properties of a `TagSpecificationProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnClientVpnEndpointTagSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("resourceType", cdk.requiredValidator)(properties.resourceType));
  errors.collect(cdk.propertyValidator("resourceType", cdk.validateString)(properties.resourceType));
  errors.collect(cdk.propertyValidator("tags", cdk.requiredValidator)(properties.tags));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \"TagSpecificationProperty\"");
}

// @ts-ignore TS6133
function convertCfnClientVpnEndpointTagSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnClientVpnEndpointTagSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "ResourceType": cdk.stringToCloudFormation(properties.resourceType),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnClientVpnEndpointTagSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnClientVpnEndpoint.TagSpecificationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnClientVpnEndpoint.TagSpecificationProperty>();
  ret.addPropertyResult("resourceType", "ResourceType", (properties.ResourceType != null ? cfn_parse.FromCloudFormation.getString(properties.ResourceType) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `CertificateAuthenticationRequestProperty`
 *
 * @param properties - the TypeScript properties of a `CertificateAuthenticationRequestProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnClientVpnEndpointCertificateAuthenticationRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("clientRootCertificateChainArn", cdk.requiredValidator)(properties.clientRootCertificateChainArn));
  errors.collect(cdk.propertyValidator("clientRootCertificateChainArn", cdk.validateString)(properties.clientRootCertificateChainArn));
  return errors.wrap("supplied properties not correct for \"CertificateAuthenticationRequestProperty\"");
}

// @ts-ignore TS6133
function convertCfnClientVpnEndpointCertificateAuthenticationRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnClientVpnEndpointCertificateAuthenticationRequestPropertyValidator(properties).assertSuccess();
  return {
    "ClientRootCertificateChainArn": cdk.stringToCloudFormation(properties.clientRootCertificateChainArn)
  };
}

// @ts-ignore TS6133
function CfnClientVpnEndpointCertificateAuthenticationRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnClientVpnEndpoint.CertificateAuthenticationRequestProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnClientVpnEndpoint.CertificateAuthenticationRequestProperty>();
  ret.addPropertyResult("clientRootCertificateChainArn", "ClientRootCertificateChainArn", (properties.ClientRootCertificateChainArn != null ? cfn_parse.FromCloudFormation.getString(properties.ClientRootCertificateChainArn) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `FederatedAuthenticationRequestProperty`
 *
 * @param properties - the TypeScript properties of a `FederatedAuthenticationRequestProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnClientVpnEndpointFederatedAuthenticationRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("samlProviderArn", cdk.requiredValidator)(properties.samlProviderArn));
  errors.collect(cdk.propertyValidator("samlProviderArn", cdk.validateString)(properties.samlProviderArn));
  errors.collect(cdk.propertyValidator("selfServiceSamlProviderArn", cdk.validateString)(properties.selfServiceSamlProviderArn));
  return errors.wrap("supplied properties not correct for \"FederatedAuthenticationRequestProperty\"");
}

// @ts-ignore TS6133
function convertCfnClientVpnEndpointFederatedAuthenticationRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnClientVpnEndpointFederatedAuthenticationRequestPropertyValidator(properties).assertSuccess();
  return {
    "SAMLProviderArn": cdk.stringToCloudFormation(properties.samlProviderArn),
    "SelfServiceSAMLProviderArn": cdk.stringToCloudFormation(properties.selfServiceSamlProviderArn)
  };
}

// @ts-ignore TS6133
function CfnClientVpnEndpointFederatedAuthenticationRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnClientVpnEndpoint.FederatedAuthenticationRequestProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnClientVpnEndpoint.FederatedAuthenticationRequestProperty>();
  ret.addPropertyResult("samlProviderArn", "SAMLProviderArn", (properties.SAMLProviderArn != null ? cfn_parse.FromCloudFormation.getString(properties.SAMLProviderArn) : undefined));
  ret.addPropertyResult("selfServiceSamlProviderArn", "SelfServiceSAMLProviderArn", (properties.SelfServiceSAMLProviderArn != null ? cfn_parse.FromCloudFormation.getString(properties.SelfServiceSAMLProviderArn) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `DirectoryServiceAuthenticationRequestProperty`
 *
 * @param properties - the TypeScript properties of a `DirectoryServiceAuthenticationRequestProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnClientVpnEndpointDirectoryServiceAuthenticationRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("directoryId", cdk.requiredValidator)(properties.directoryId));
  errors.collect(cdk.propertyValidator("directoryId", cdk.validateString)(properties.directoryId));
  return errors.wrap("supplied properties not correct for \"DirectoryServiceAuthenticationRequestProperty\"");
}

// @ts-ignore TS6133
function convertCfnClientVpnEndpointDirectoryServiceAuthenticationRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnClientVpnEndpointDirectoryServiceAuthenticationRequestPropertyValidator(properties).assertSuccess();
  return {
    "DirectoryId": cdk.stringToCloudFormation(properties.directoryId)
  };
}

// @ts-ignore TS6133
function CfnClientVpnEndpointDirectoryServiceAuthenticationRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnClientVpnEndpoint.DirectoryServiceAuthenticationRequestProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnClientVpnEndpoint.DirectoryServiceAuthenticationRequestProperty>();
  ret.addPropertyResult("directoryId", "DirectoryId", (properties.DirectoryId != null ? cfn_parse.FromCloudFormation.getString(properties.DirectoryId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `ClientAuthenticationRequestProperty`
 *
 * @param properties - the TypeScript properties of a `ClientAuthenticationRequestProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnClientVpnEndpointClientAuthenticationRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("activeDirectory", CfnClientVpnEndpointDirectoryServiceAuthenticationRequestPropertyValidator)(properties.activeDirectory));
  errors.collect(cdk.propertyValidator("federatedAuthentication", CfnClientVpnEndpointFederatedAuthenticationRequestPropertyValidator)(properties.federatedAuthentication));
  errors.collect(cdk.propertyValidator("mutualAuthentication", CfnClientVpnEndpointCertificateAuthenticationRequestPropertyValidator)(properties.mutualAuthentication));
  errors.collect(cdk.propertyValidator("type", cdk.requiredValidator)(properties.type));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  return errors.wrap("supplied properties not correct for \"ClientAuthenticationRequestProperty\"");
}

// @ts-ignore TS6133
function convertCfnClientVpnEndpointClientAuthenticationRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnClientVpnEndpointClientAuthenticationRequestPropertyValidator(properties).assertSuccess();
  return {
    "ActiveDirectory": convertCfnClientVpnEndpointDirectoryServiceAuthenticationRequestPropertyToCloudFormation(properties.activeDirectory),
    "FederatedAuthentication": convertCfnClientVpnEndpointFederatedAuthenticationRequestPropertyToCloudFormation(properties.federatedAuthentication),
    "MutualAuthentication": convertCfnClientVpnEndpointCertificateAuthenticationRequestPropertyToCloudFormation(properties.mutualAuthentication),
    "Type": cdk.stringToCloudFormation(properties.type)
  };
}

// @ts-ignore TS6133
function CfnClientVpnEndpointClientAuthenticationRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnClientVpnEndpoint.ClientAuthenticationRequestProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnClientVpnEndpoint.ClientAuthenticationRequestProperty>();
  ret.addPropertyResult("activeDirectory", "ActiveDirectory", (properties.ActiveDirectory != null ? CfnClientVpnEndpointDirectoryServiceAuthenticationRequestPropertyFromCloudFormation(properties.ActiveDirectory) : undefined));
  ret.addPropertyResult("federatedAuthentication", "FederatedAuthentication", (properties.FederatedAuthentication != null ? CfnClientVpnEndpointFederatedAuthenticationRequestPropertyFromCloudFormation(properties.FederatedAuthentication) : undefined));
  ret.addPropertyResult("mutualAuthentication", "MutualAuthentication", (properties.MutualAuthentication != null ? CfnClientVpnEndpointCertificateAuthenticationRequestPropertyFromCloudFormation(properties.MutualAuthentication) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `ConnectionLogOptionsProperty`
 *
 * @param properties - the TypeScript properties of a `ConnectionLogOptionsProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnClientVpnEndpointConnectionLogOptionsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("cloudwatchLogGroup", cdk.validateString)(properties.cloudwatchLogGroup));
  errors.collect(cdk.propertyValidator("cloudwatchLogStream", cdk.validateString)(properties.cloudwatchLogStream));
  errors.collect(cdk.propertyValidator("enabled", cdk.requiredValidator)(properties.enabled));
  errors.collect(cdk.propertyValidator("enabled", cdk.validateBoolean)(properties.enabled));
  return errors.wrap("supplied properties not correct for \"ConnectionLogOptionsProperty\"");
}

// @ts-ignore TS6133
function convertCfnClientVpnEndpointConnectionLogOptionsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnClientVpnEndpointConnectionLogOptionsPropertyValidator(properties).assertSuccess();
  return {
    "CloudwatchLogGroup": cdk.stringToCloudFormation(properties.cloudwatchLogGroup),
    "CloudwatchLogStream": cdk.stringToCloudFormation(properties.cloudwatchLogStream),
    "Enabled": cdk.booleanToCloudFormation(properties.enabled)
  };
}

// @ts-ignore TS6133
function CfnClientVpnEndpointConnectionLogOptionsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnClientVpnEndpoint.ConnectionLogOptionsProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnClientVpnEndpoint.ConnectionLogOptionsProperty>();
  ret.addPropertyResult("cloudwatchLogGroup", "CloudwatchLogGroup", (properties.CloudwatchLogGroup != null ? cfn_parse.FromCloudFormation.getString(properties.CloudwatchLogGroup) : undefined));
  ret.addPropertyResult("cloudwatchLogStream", "CloudwatchLogStream", (properties.CloudwatchLogStream != null ? cfn_parse.FromCloudFormation.getString(properties.CloudwatchLogStream) : undefined));
  ret.addPropertyResult("enabled", "Enabled", (properties.Enabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Enabled) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `ClientLoginBannerOptionsProperty`
 *
 * @param properties - the TypeScript properties of a `ClientLoginBannerOptionsProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnClientVpnEndpointClientLoginBannerOptionsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("bannerText", cdk.validateString)(properties.bannerText));
  errors.collect(cdk.propertyValidator("enabled", cdk.requiredValidator)(properties.enabled));
  errors.collect(cdk.propertyValidator("enabled", cdk.validateBoolean)(properties.enabled));
  return errors.wrap("supplied properties not correct for \"ClientLoginBannerOptionsProperty\"");
}

// @ts-ignore TS6133
function convertCfnClientVpnEndpointClientLoginBannerOptionsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnClientVpnEndpointClientLoginBannerOptionsPropertyValidator(properties).assertSuccess();
  return {
    "BannerText": cdk.stringToCloudFormation(properties.bannerText),
    "Enabled": cdk.booleanToCloudFormation(properties.enabled)
  };
}

// @ts-ignore TS6133
function CfnClientVpnEndpointClientLoginBannerOptionsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnClientVpnEndpoint.ClientLoginBannerOptionsProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnClientVpnEndpoint.ClientLoginBannerOptionsProperty>();
  ret.addPropertyResult("bannerText", "BannerText", (properties.BannerText != null ? cfn_parse.FromCloudFormation.getString(properties.BannerText) : undefined));
  ret.addPropertyResult("enabled", "Enabled", (properties.Enabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Enabled) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `CfnClientVpnEndpointProps`
 *
 * @param properties - the TypeScript properties of a `CfnClientVpnEndpointProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnClientVpnEndpointPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("authenticationOptions", cdk.requiredValidator)(properties.authenticationOptions));
  errors.collect(cdk.propertyValidator("authenticationOptions", cdk.listValidator(CfnClientVpnEndpointClientAuthenticationRequestPropertyValidator))(properties.authenticationOptions));
  errors.collect(cdk.propertyValidator("clientCidrBlock", cdk.requiredValidator)(properties.clientCidrBlock));
  errors.collect(cdk.propertyValidator("clientCidrBlock", cdk.validateString)(properties.clientCidrBlock));
  errors.collect(cdk.propertyValidator("clientConnectOptions", CfnClientVpnEndpointClientConnectOptionsPropertyValidator)(properties.clientConnectOptions));
  errors.collect(cdk.propertyValidator("clientLoginBannerOptions", CfnClientVpnEndpointClientLoginBannerOptionsPropertyValidator)(properties.clientLoginBannerOptions));
  errors.collect(cdk.propertyValidator("connectionLogOptions", cdk.requiredValidator)(properties.connectionLogOptions));
  errors.collect(cdk.propertyValidator("connectionLogOptions", CfnClientVpnEndpointConnectionLogOptionsPropertyValidator)(properties.connectionLogOptions));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("dnsServers", cdk.listValidator(cdk.validateString))(properties.dnsServers));
  errors.collect(cdk.propertyValidator("securityGroupIds", cdk.listValidator(cdk.validateString))(properties.securityGroupIds));
  errors.collect(cdk.propertyValidator("selfServicePortal", cdk.validateString)(properties.selfServicePortal));
  errors.collect(cdk.propertyValidator("serverCertificateArn", cdk.requiredValidator)(properties.serverCertificateArn));
  errors.collect(cdk.propertyValidator("serverCertificateArn", cdk.validateString)(properties.serverCertificateArn));
  errors.collect(cdk.propertyValidator("sessionTimeoutHours", cdk.validateNumber)(properties.sessionTimeoutHours));
  errors.collect(cdk.propertyValidator("splitTunnel", cdk.validateBoolean)(properties.splitTunnel));
  errors.collect(cdk.propertyValidator("tagSpecifications", cdk.listValidator(CfnClientVpnEndpointTagSpecificationPropertyValidator))(properties.tagSpecifications));
  errors.collect(cdk.propertyValidator("transportProtocol", cdk.validateString)(properties.transportProtocol));
  errors.collect(cdk.propertyValidator("vpcId", cdk.validateString)(properties.vpcId));
  errors.collect(cdk.propertyValidator("vpnPort", cdk.validateNumber)(properties.vpnPort));
  return errors.wrap("supplied properties not correct for \"CfnClientVpnEndpointProps\"");
}

// @ts-ignore TS6133
function convertCfnClientVpnEndpointPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnClientVpnEndpointPropsValidator(properties).assertSuccess();
  return {
    "AuthenticationOptions": cdk.listMapper(convertCfnClientVpnEndpointClientAuthenticationRequestPropertyToCloudFormation)(properties.authenticationOptions),
    "ClientCidrBlock": cdk.stringToCloudFormation(properties.clientCidrBlock),
    "ClientConnectOptions": convertCfnClientVpnEndpointClientConnectOptionsPropertyToCloudFormation(properties.clientConnectOptions),
    "ClientLoginBannerOptions": convertCfnClientVpnEndpointClientLoginBannerOptionsPropertyToCloudFormation(properties.clientLoginBannerOptions),
    "ConnectionLogOptions": convertCfnClientVpnEndpointConnectionLogOptionsPropertyToCloudFormation(properties.connectionLogOptions),
    "Description": cdk.stringToCloudFormation(properties.description),
    "DnsServers": cdk.listMapper(cdk.stringToCloudFormation)(properties.dnsServers),
    "SecurityGroupIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.securityGroupIds),
    "SelfServicePortal": cdk.stringToCloudFormation(properties.selfServicePortal),
    "ServerCertificateArn": cdk.stringToCloudFormation(properties.serverCertificateArn),
    "SessionTimeoutHours": cdk.numberToCloudFormation(properties.sessionTimeoutHours),
    "SplitTunnel": cdk.booleanToCloudFormation(properties.splitTunnel),
    "TagSpecifications": cdk.listMapper(convertCfnClientVpnEndpointTagSpecificationPropertyToCloudFormation)(properties.tagSpecifications),
    "TransportProtocol": cdk.stringToCloudFormation(properties.transportProtocol),
    "VpcId": cdk.stringToCloudFormation(properties.vpcId),
    "VpnPort": cdk.numberToCloudFormation(properties.vpnPort)
  };
}

// @ts-ignore TS6133
function CfnClientVpnEndpointPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnClientVpnEndpointProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnClientVpnEndpointProps>();
  ret.addPropertyResult("authenticationOptions", "AuthenticationOptions", (properties.AuthenticationOptions != null ? cfn_parse.FromCloudFormation.getArray(CfnClientVpnEndpointClientAuthenticationRequestPropertyFromCloudFormation)(properties.AuthenticationOptions) : undefined));
  ret.addPropertyResult("clientCidrBlock", "ClientCidrBlock", (properties.ClientCidrBlock != null ? cfn_parse.FromCloudFormation.getString(properties.ClientCidrBlock) : undefined));
  ret.addPropertyResult("clientConnectOptions", "ClientConnectOptions", (properties.ClientConnectOptions != null ? CfnClientVpnEndpointClientConnectOptionsPropertyFromCloudFormation(properties.ClientConnectOptions) : undefined));
  ret.addPropertyResult("clientLoginBannerOptions", "ClientLoginBannerOptions", (properties.ClientLoginBannerOptions != null ? CfnClientVpnEndpointClientLoginBannerOptionsPropertyFromCloudFormation(properties.ClientLoginBannerOptions) : undefined));
  ret.addPropertyResult("connectionLogOptions", "ConnectionLogOptions", (properties.ConnectionLogOptions != null ? CfnClientVpnEndpointConnectionLogOptionsPropertyFromCloudFormation(properties.ConnectionLogOptions) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("dnsServers", "DnsServers", (properties.DnsServers != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.DnsServers) : undefined));
  ret.addPropertyResult("securityGroupIds", "SecurityGroupIds", (properties.SecurityGroupIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecurityGroupIds) : undefined));
  ret.addPropertyResult("selfServicePortal", "SelfServicePortal", (properties.SelfServicePortal != null ? cfn_parse.FromCloudFormation.getString(properties.SelfServicePortal) : undefined));
  ret.addPropertyResult("serverCertificateArn", "ServerCertificateArn", (properties.ServerCertificateArn != null ? cfn_parse.FromCloudFormation.getString(properties.ServerCertificateArn) : undefined));
  ret.addPropertyResult("sessionTimeoutHours", "SessionTimeoutHours", (properties.SessionTimeoutHours != null ? cfn_parse.FromCloudFormation.getNumber(properties.SessionTimeoutHours) : undefined));
  ret.addPropertyResult("splitTunnel", "SplitTunnel", (properties.SplitTunnel != null ? cfn_parse.FromCloudFormation.getBoolean(properties.SplitTunnel) : undefined));
  ret.addPropertyResult("tagSpecifications", "TagSpecifications", (properties.TagSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnClientVpnEndpointTagSpecificationPropertyFromCloudFormation)(properties.TagSpecifications) : undefined));
  ret.addPropertyResult("transportProtocol", "TransportProtocol", (properties.TransportProtocol != null ? cfn_parse.FromCloudFormation.getString(properties.TransportProtocol) : undefined));
  ret.addPropertyResult("vpcId", "VpcId", (properties.VpcId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcId) : undefined));
  ret.addPropertyResult("vpnPort", "VpnPort", (properties.VpnPort != null ? cfn_parse.FromCloudFormation.getNumber(properties.VpnPort) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a network route to add to a Client VPN endpoint.
 *
 * Each Client VPN endpoint has a route table that describes the available destination network routes. Each route in the route table specifies the path for traffic to specific resources or networks.
 *
 * A target network association must be created before you can specify a route. If you're setting up all the components of a Client VPN endpoint at the same time, you must use the [DependsOn Attribute](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-dependson.html) to declare a dependency on the `AWS::EC2::ClientVpnTargetNetworkAssociation` resource.
 *
 * @cloudformationResource AWS::EC2::ClientVpnRoute
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnroute.html
 */
export class CfnClientVpnRoute extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::ClientVpnRoute";

  /**
   * Build a CfnClientVpnRoute from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnClientVpnRoute {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnClientVpnRoutePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnClientVpnRoute(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The ID of the Client VPN endpoint to which to add the route.
   */
  public clientVpnEndpointId: string;

  /**
   * A brief description of the route.
   */
  public description?: string;

  /**
   * The IPv4 address range, in CIDR notation, of the route destination. For example:.
   */
  public destinationCidrBlock: string;

  /**
   * The ID of the subnet through which you want to route traffic.
   */
  public targetVpcSubnetId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnClientVpnRouteProps) {
    super(scope, id, {
      "type": CfnClientVpnRoute.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "clientVpnEndpointId", this);
    cdk.requireProperty(props, "destinationCidrBlock", this);
    cdk.requireProperty(props, "targetVpcSubnetId", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.clientVpnEndpointId = props.clientVpnEndpointId;
    this.description = props.description;
    this.destinationCidrBlock = props.destinationCidrBlock;
    this.targetVpcSubnetId = props.targetVpcSubnetId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "clientVpnEndpointId": this.clientVpnEndpointId,
      "description": this.description,
      "destinationCidrBlock": this.destinationCidrBlock,
      "targetVpcSubnetId": this.targetVpcSubnetId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnClientVpnRoute.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnClientVpnRoutePropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a `CfnClientVpnRoute`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnroute.html
 */
export interface CfnClientVpnRouteProps {
  /**
   * The ID of the Client VPN endpoint to which to add the route.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnroute.html#cfn-ec2-clientvpnroute-clientvpnendpointid
   */
  readonly clientVpnEndpointId: string;

  /**
   * A brief description of the route.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnroute.html#cfn-ec2-clientvpnroute-description
   */
  readonly description?: string;

  /**
   * The IPv4 address range, in CIDR notation, of the route destination. For example:.
   *
   * - To add a route for Internet access, enter `0.0.0.0/0`
   * - To add a route for a peered VPC, enter the peered VPC's IPv4 CIDR range
   * - To add a route for an on-premises network, enter the AWS Site-to-Site VPN connection's IPv4 CIDR range
   * - To add a route for the local network, enter the client CIDR range
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnroute.html#cfn-ec2-clientvpnroute-destinationcidrblock
   */
  readonly destinationCidrBlock: string;

  /**
   * The ID of the subnet through which you want to route traffic.
   *
   * The specified subnet must be an existing target network of the Client VPN endpoint.
   *
   * Alternatively, if you're adding a route for the local network, specify `local` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnroute.html#cfn-ec2-clientvpnroute-targetvpcsubnetid
   */
  readonly targetVpcSubnetId: string;
}

/**
 * Determine whether the given properties match those of a `CfnClientVpnRouteProps`
 *
 * @param properties - the TypeScript properties of a `CfnClientVpnRouteProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnClientVpnRoutePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("clientVpnEndpointId", cdk.requiredValidator)(properties.clientVpnEndpointId));
  errors.collect(cdk.propertyValidator("clientVpnEndpointId", cdk.validateString)(properties.clientVpnEndpointId));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("destinationCidrBlock", cdk.requiredValidator)(properties.destinationCidrBlock));
  errors.collect(cdk.propertyValidator("destinationCidrBlock", cdk.validateString)(properties.destinationCidrBlock));
  errors.collect(cdk.propertyValidator("targetVpcSubnetId", cdk.requiredValidator)(properties.targetVpcSubnetId));
  errors.collect(cdk.propertyValidator("targetVpcSubnetId", cdk.validateString)(properties.targetVpcSubnetId));
  return errors.wrap("supplied properties not correct for \"CfnClientVpnRouteProps\"");
}

// @ts-ignore TS6133
function convertCfnClientVpnRoutePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnClientVpnRoutePropsValidator(properties).assertSuccess();
  return {
    "ClientVpnEndpointId": cdk.stringToCloudFormation(properties.clientVpnEndpointId),
    "Description": cdk.stringToCloudFormation(properties.description),
    "DestinationCidrBlock": cdk.stringToCloudFormation(properties.destinationCidrBlock),
    "TargetVpcSubnetId": cdk.stringToCloudFormation(properties.targetVpcSubnetId)
  };
}

// @ts-ignore TS6133
function CfnClientVpnRoutePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnClientVpnRouteProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnClientVpnRouteProps>();
  ret.addPropertyResult("clientVpnEndpointId", "ClientVpnEndpointId", (properties.ClientVpnEndpointId != null ? cfn_parse.FromCloudFormation.getString(properties.ClientVpnEndpointId) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("destinationCidrBlock", "DestinationCidrBlock", (properties.DestinationCidrBlock != null ? cfn_parse.FromCloudFormation.getString(properties.DestinationCidrBlock) : undefined));
  ret.addPropertyResult("targetVpcSubnetId", "TargetVpcSubnetId", (properties.TargetVpcSubnetId != null ? cfn_parse.FromCloudFormation.getString(properties.TargetVpcSubnetId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a target network to associate with a Client VPN endpoint.
 *
 * A target network is a subnet in a VPC. You can associate multiple subnets from the same VPC with a Client VPN endpoint. You can associate only one subnet in each Availability Zone. We recommend that you associate at least two subnets to provide Availability Zone redundancy.
 *
 * @cloudformationResource AWS::EC2::ClientVpnTargetNetworkAssociation
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpntargetnetworkassociation.html
 */
export class CfnClientVpnTargetNetworkAssociation extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::ClientVpnTargetNetworkAssociation";

  /**
   * Build a CfnClientVpnTargetNetworkAssociation from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnClientVpnTargetNetworkAssociation {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnClientVpnTargetNetworkAssociationPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnClientVpnTargetNetworkAssociation(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The ID of the Client VPN endpoint.
   */
  public clientVpnEndpointId: string;

  /**
   * The ID of the subnet to associate with the Client VPN endpoint.
   */
  public subnetId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnClientVpnTargetNetworkAssociationProps) {
    super(scope, id, {
      "type": CfnClientVpnTargetNetworkAssociation.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "clientVpnEndpointId", this);
    cdk.requireProperty(props, "subnetId", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.clientVpnEndpointId = props.clientVpnEndpointId;
    this.subnetId = props.subnetId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "clientVpnEndpointId": this.clientVpnEndpointId,
      "subnetId": this.subnetId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnClientVpnTargetNetworkAssociation.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnClientVpnTargetNetworkAssociationPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a `CfnClientVpnTargetNetworkAssociation`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpntargetnetworkassociation.html
 */
export interface CfnClientVpnTargetNetworkAssociationProps {
  /**
   * The ID of the Client VPN endpoint.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpntargetnetworkassociation.html#cfn-ec2-clientvpntargetnetworkassociation-clientvpnendpointid
   */
  readonly clientVpnEndpointId: string;

  /**
   * The ID of the subnet to associate with the Client VPN endpoint.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpntargetnetworkassociation.html#cfn-ec2-clientvpntargetnetworkassociation-subnetid
   */
  readonly subnetId: string;
}

/**
 * Determine whether the given properties match those of a `CfnClientVpnTargetNetworkAssociationProps`
 *
 * @param properties - the TypeScript properties of a `CfnClientVpnTargetNetworkAssociationProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnClientVpnTargetNetworkAssociationPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("clientVpnEndpointId", cdk.requiredValidator)(properties.clientVpnEndpointId));
  errors.collect(cdk.propertyValidator("clientVpnEndpointId", cdk.validateString)(properties.clientVpnEndpointId));
  errors.collect(cdk.propertyValidator("subnetId", cdk.requiredValidator)(properties.subnetId));
  errors.collect(cdk.propertyValidator("subnetId", cdk.validateString)(properties.subnetId));
  return errors.wrap("supplied properties not correct for \"CfnClientVpnTargetNetworkAssociationProps\"");
}

// @ts-ignore TS6133
function convertCfnClientVpnTargetNetworkAssociationPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnClientVpnTargetNetworkAssociationPropsValidator(properties).assertSuccess();
  return {
    "ClientVpnEndpointId": cdk.stringToCloudFormation(properties.clientVpnEndpointId),
    "SubnetId": cdk.stringToCloudFormation(properties.subnetId)
  };
}

// @ts-ignore TS6133
function CfnClientVpnTargetNetworkAssociationPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnClientVpnTargetNetworkAssociationProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnClientVpnTargetNetworkAssociationProps>();
  ret.addPropertyResult("clientVpnEndpointId", "ClientVpnEndpointId", (properties.ClientVpnEndpointId != null ? cfn_parse.FromCloudFormation.getString(properties.ClientVpnEndpointId) : undefined));
  ret.addPropertyResult("subnetId", "SubnetId", (properties.SubnetId != null ? cfn_parse.FromCloudFormation.getString(properties.SubnetId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a customer gateway.
 *
 * @cloudformationResource AWS::EC2::CustomerGateway
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customergateway.html
 */
export class CfnCustomerGateway extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::CustomerGateway";

  /**
   * Build a CfnCustomerGateway from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnCustomerGateway {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnCustomerGatewayPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnCustomerGateway(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the customer gateway.
   *
   * @cloudformationAttribute CustomerGatewayId
   */
  public readonly attrCustomerGatewayId: string;

  /**
   * For devices that support BGP, the customer gateway's BGP ASN.
   */
  public bgpAsn: number;

  /**
   * The name of customer gateway device.
   */
  public deviceName?: string;

  /**
   * IPv4 address for the customer gateway device's outside interface.
   */
  public ipAddress: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * One or more tags for the customer gateway.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The type of VPN connection that this customer gateway supports ( `ipsec.1` ).
   */
  public type: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnCustomerGatewayProps) {
    super(scope, id, {
      "type": CfnCustomerGateway.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "bgpAsn", this);
    cdk.requireProperty(props, "ipAddress", this);
    cdk.requireProperty(props, "type", this);

    this.attrCustomerGatewayId = cdk.Token.asString(this.getAtt("CustomerGatewayId", cdk.ResolutionTypeHint.STRING));
    this.bgpAsn = props.bgpAsn;
    this.deviceName = props.deviceName;
    this.ipAddress = props.ipAddress;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::CustomerGateway", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.type = props.type;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "bgpAsn": this.bgpAsn,
      "deviceName": this.deviceName,
      "ipAddress": this.ipAddress,
      "tags": this.tags.renderTags(),
      "type": this.type
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnCustomerGateway.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnCustomerGatewayPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a `CfnCustomerGateway`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customergateway.html
 */
export interface CfnCustomerGatewayProps {
  /**
   * For devices that support BGP, the customer gateway's BGP ASN.
   *
   * Default: 65000
   *
   * @default - 65000
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customergateway.html#cfn-ec2-customergateway-bgpasn
   */
  readonly bgpAsn: number;

  /**
   * The name of customer gateway device.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customergateway.html#cfn-ec2-customergateway-devicename
   */
  readonly deviceName?: string;

  /**
   * IPv4 address for the customer gateway device's outside interface.
   *
   * The address must be static.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customergateway.html#cfn-ec2-customergateway-ipaddress
   */
  readonly ipAddress: string;

  /**
   * One or more tags for the customer gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customergateway.html#cfn-ec2-customergateway-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The type of VPN connection that this customer gateway supports ( `ipsec.1` ).
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customergateway.html#cfn-ec2-customergateway-type
   */
  readonly type: string;
}

/**
 * Determine whether the given properties match those of a `CfnCustomerGatewayProps`
 *
 * @param properties - the TypeScript properties of a `CfnCustomerGatewayProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnCustomerGatewayPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("bgpAsn", cdk.requiredValidator)(properties.bgpAsn));
  errors.collect(cdk.propertyValidator("bgpAsn", cdk.validateNumber)(properties.bgpAsn));
  errors.collect(cdk.propertyValidator("deviceName", cdk.validateString)(properties.deviceName));
  errors.collect(cdk.propertyValidator("ipAddress", cdk.requiredValidator)(properties.ipAddress));
  errors.collect(cdk.propertyValidator("ipAddress", cdk.validateString)(properties.ipAddress));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("type", cdk.requiredValidator)(properties.type));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  return errors.wrap("supplied properties not correct for \"CfnCustomerGatewayProps\"");
}

// @ts-ignore TS6133
function convertCfnCustomerGatewayPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnCustomerGatewayPropsValidator(properties).assertSuccess();
  return {
    "BgpAsn": cdk.numberToCloudFormation(properties.bgpAsn),
    "DeviceName": cdk.stringToCloudFormation(properties.deviceName),
    "IpAddress": cdk.stringToCloudFormation(properties.ipAddress),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "Type": cdk.stringToCloudFormation(properties.type)
  };
}

// @ts-ignore TS6133
function CfnCustomerGatewayPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnCustomerGatewayProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnCustomerGatewayProps>();
  ret.addPropertyResult("bgpAsn", "BgpAsn", (properties.BgpAsn != null ? cfn_parse.FromCloudFormation.getNumber(properties.BgpAsn) : undefined));
  ret.addPropertyResult("deviceName", "DeviceName", (properties.DeviceName != null ? cfn_parse.FromCloudFormation.getString(properties.DeviceName) : undefined));
  ret.addPropertyResult("ipAddress", "IpAddress", (properties.IpAddress != null ? cfn_parse.FromCloudFormation.getString(properties.IpAddress) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a set of DHCP options for your VPC.
 *
 * You must specify at least one of the following properties: `DomainNameServers` , `NetbiosNameServers` , `NtpServers` . If you specify `NetbiosNameServers` , you must specify `NetbiosNodeType` .
 *
 * @cloudformationResource AWS::EC2::DHCPOptions
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-dhcpoptions.html
 */
export class CfnDHCPOptions extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::DHCPOptions";

  /**
   * Build a CfnDHCPOptions from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnDHCPOptions {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnDHCPOptionsPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnDHCPOptions(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the DHCP options set.
   *
   * @cloudformationAttribute DhcpOptionsId
   */
  public readonly attrDhcpOptionsId: string;

  /**
   * This value is used to complete unqualified DNS hostnames.
   */
  public domainName?: string;

  /**
   * The IPv4 addresses of up to four domain name servers, or `AmazonProvidedDNS` .
   */
  public domainNameServers?: Array<string>;

  /**
   * The IPv4 addresses of up to four NetBIOS name servers.
   */
  public netbiosNameServers?: Array<string>;

  /**
   * The NetBIOS node type (1, 2, 4, or 8).
   */
  public netbiosNodeType?: number;

  /**
   * The IPv4 addresses of up to four Network Time Protocol (NTP) servers.
   */
  public ntpServers?: Array<string>;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * Any tags assigned to the DHCP options set.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnDHCPOptionsProps = {}) {
    super(scope, id, {
      "type": CfnDHCPOptions.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.attrDhcpOptionsId = cdk.Token.asString(this.getAtt("DhcpOptionsId", cdk.ResolutionTypeHint.STRING));
    this.domainName = props.domainName;
    this.domainNameServers = props.domainNameServers;
    this.netbiosNameServers = props.netbiosNameServers;
    this.netbiosNodeType = props.netbiosNodeType;
    this.ntpServers = props.ntpServers;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::DHCPOptions", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "domainName": this.domainName,
      "domainNameServers": this.domainNameServers,
      "netbiosNameServers": this.netbiosNameServers,
      "netbiosNodeType": this.netbiosNodeType,
      "ntpServers": this.ntpServers,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnDHCPOptions.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnDHCPOptionsPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a `CfnDHCPOptions`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-dhcpoptions.html
 */
export interface CfnDHCPOptionsProps {
  /**
   * This value is used to complete unqualified DNS hostnames.
   *
   * If you're using AmazonProvidedDNS in `us-east-1` , specify `ec2.internal` . If you're using AmazonProvidedDNS in another Region, specify *region* . `compute.internal` (for example, `ap-northeast-1.compute.internal` ). Otherwise, specify a domain name (for example, *MyCompany.com* ).
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-dhcpoptions.html#cfn-ec2-dhcpoptions-domainname
   */
  readonly domainName?: string;

  /**
   * The IPv4 addresses of up to four domain name servers, or `AmazonProvidedDNS` .
   *
   * The default is `AmazonProvidedDNS` . To have your instance receive a custom DNS hostname as specified in `DomainName` , you must set this property to a custom DNS server.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-dhcpoptions.html#cfn-ec2-dhcpoptions-domainnameservers
   */
  readonly domainNameServers?: Array<string>;

  /**
   * The IPv4 addresses of up to four NetBIOS name servers.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-dhcpoptions.html#cfn-ec2-dhcpoptions-netbiosnameservers
   */
  readonly netbiosNameServers?: Array<string>;

  /**
   * The NetBIOS node type (1, 2, 4, or 8).
   *
   * We recommend that you specify 2 (broadcast and multicast are not currently supported).
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-dhcpoptions.html#cfn-ec2-dhcpoptions-netbiosnodetype
   */
  readonly netbiosNodeType?: number;

  /**
   * The IPv4 addresses of up to four Network Time Protocol (NTP) servers.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-dhcpoptions.html#cfn-ec2-dhcpoptions-ntpservers
   */
  readonly ntpServers?: Array<string>;

  /**
   * Any tags assigned to the DHCP options set.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-dhcpoptions.html#cfn-ec2-dhcpoptions-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a `CfnDHCPOptionsProps`
 *
 * @param properties - the TypeScript properties of a `CfnDHCPOptionsProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnDHCPOptionsPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("domainName", cdk.validateString)(properties.domainName));
  errors.collect(cdk.propertyValidator("domainNameServers", cdk.listValidator(cdk.validateString))(properties.domainNameServers));
  errors.collect(cdk.propertyValidator("netbiosNameServers", cdk.listValidator(cdk.validateString))(properties.netbiosNameServers));
  errors.collect(cdk.propertyValidator("netbiosNodeType", cdk.validateNumber)(properties.netbiosNodeType));
  errors.collect(cdk.propertyValidator("ntpServers", cdk.listValidator(cdk.validateString))(properties.ntpServers));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \"CfnDHCPOptionsProps\"");
}

// @ts-ignore TS6133
function convertCfnDHCPOptionsPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnDHCPOptionsPropsValidator(properties).assertSuccess();
  return {
    "DomainName": cdk.stringToCloudFormation(properties.domainName),
    "DomainNameServers": cdk.listMapper(cdk.stringToCloudFormation)(properties.domainNameServers),
    "NetbiosNameServers": cdk.listMapper(cdk.stringToCloudFormation)(properties.netbiosNameServers),
    "NetbiosNodeType": cdk.numberToCloudFormation(properties.netbiosNodeType),
    "NtpServers": cdk.listMapper(cdk.stringToCloudFormation)(properties.ntpServers),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnDHCPOptionsPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnDHCPOptionsProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnDHCPOptionsProps>();
  ret.addPropertyResult("domainName", "DomainName", (properties.DomainName != null ? cfn_parse.FromCloudFormation.getString(properties.DomainName) : undefined));
  ret.addPropertyResult("domainNameServers", "DomainNameServers", (properties.DomainNameServers != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.DomainNameServers) : undefined));
  ret.addPropertyResult("netbiosNameServers", "NetbiosNameServers", (properties.NetbiosNameServers != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.NetbiosNameServers) : undefined));
  ret.addPropertyResult("netbiosNodeType", "NetbiosNodeType", (properties.NetbiosNodeType != null ? cfn_parse.FromCloudFormation.getNumber(properties.NetbiosNodeType) : undefined));
  ret.addPropertyResult("ntpServers", "NtpServers", (properties.NtpServers != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.NtpServers) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies the configuration information to launch a fleet--or group--of instances.
 *
 * An EC2 Fleet can launch multiple instance types across multiple Availability Zones, using the On-Demand Instance, Reserved Instance, and Spot Instance purchasing models together. Using EC2 Fleet, you can define separate On-Demand and Spot capacity targets, specify the instance types that work best for your applications, and specify how Amazon EC2 should distribute your fleet capacity within each purchasing model. For more information, see [Launching an EC2 Fleet](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet.html) in the *Amazon EC2 User Guide for Linux Instances* .
 *
 * @cloudformationResource AWS::EC2::EC2Fleet
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html
 */
export class CfnEC2Fleet extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::EC2Fleet";

  /**
   * Build a CfnEC2Fleet from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnEC2Fleet {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnEC2FleetPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnEC2Fleet(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the EC2 Fleet.
   *
   * @cloudformationAttribute FleetId
   */
  public readonly attrFleetId: string;

  /**
   * Reserved.
   */
  public context?: string;

  /**
   * Indicates whether running instances should be terminated if the total target capacity of the EC2 Fleet is decreased below the current size of the EC2 Fleet.
   */
  public excessCapacityTerminationPolicy?: string;

  /**
   * The configuration for the EC2 Fleet.
   */
  public launchTemplateConfigs: Array<CfnEC2Fleet.FleetLaunchTemplateConfigRequestProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * Describes the configuration of On-Demand Instances in an EC2 Fleet.
   */
  public onDemandOptions?: cdk.IResolvable | CfnEC2Fleet.OnDemandOptionsRequestProperty;

  /**
   * Indicates whether EC2 Fleet should replace unhealthy Spot Instances.
   */
  public replaceUnhealthyInstances?: boolean | cdk.IResolvable;

  /**
   * Describes the configuration of Spot Instances in an EC2 Fleet.
   */
  public spotOptions?: cdk.IResolvable | CfnEC2Fleet.SpotOptionsRequestProperty;

  /**
   * The key-value pair for tagging the EC2 Fleet request on creation. For more information, see [Tag your resources](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html#tag-resources) .
   */
  public tagSpecifications?: Array<cdk.IResolvable | CfnEC2Fleet.TagSpecificationProperty> | cdk.IResolvable;

  /**
   * The number of units to request.
   */
  public targetCapacitySpecification: cdk.IResolvable | CfnEC2Fleet.TargetCapacitySpecificationRequestProperty;

  /**
   * Indicates whether running instances should be terminated when the EC2 Fleet expires.
   */
  public terminateInstancesWithExpiration?: boolean | cdk.IResolvable;

  /**
   * The fleet type. The default value is `maintain` .
   */
  public type?: string;

  /**
   * The start date and time of the request, in UTC format (for example, *YYYY* - *MM* - *DD* T *HH* : *MM* : *SS* Z).
   */
  public validFrom?: string;

  /**
   * The end date and time of the request, in UTC format (for example, *YYYY* - *MM* - *DD* T *HH* : *MM* : *SS* Z).
   */
  public validUntil?: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnEC2FleetProps) {
    super(scope, id, {
      "type": CfnEC2Fleet.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "launchTemplateConfigs", this);
    cdk.requireProperty(props, "targetCapacitySpecification", this);

    this.attrFleetId = cdk.Token.asString(this.getAtt("FleetId", cdk.ResolutionTypeHint.STRING));
    this.context = props.context;
    this.excessCapacityTerminationPolicy = props.excessCapacityTerminationPolicy;
    this.launchTemplateConfigs = props.launchTemplateConfigs;
    this.onDemandOptions = props.onDemandOptions;
    this.replaceUnhealthyInstances = props.replaceUnhealthyInstances;
    this.spotOptions = props.spotOptions;
    this.tagSpecifications = props.tagSpecifications;
    this.targetCapacitySpecification = props.targetCapacitySpecification;
    this.terminateInstancesWithExpiration = props.terminateInstancesWithExpiration;
    this.type = props.type;
    this.validFrom = props.validFrom;
    this.validUntil = props.validUntil;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "context": this.context,
      "excessCapacityTerminationPolicy": this.excessCapacityTerminationPolicy,
      "launchTemplateConfigs": this.launchTemplateConfigs,
      "onDemandOptions": this.onDemandOptions,
      "replaceUnhealthyInstances": this.replaceUnhealthyInstances,
      "spotOptions": this.spotOptions,
      "tagSpecifications": this.tagSpecifications,
      "targetCapacitySpecification": this.targetCapacitySpecification,
      "terminateInstancesWithExpiration": this.terminateInstancesWithExpiration,
      "type": this.type,
      "validFrom": this.validFrom,
      "validUntil": this.validUntil
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnEC2Fleet.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnEC2FleetPropsToCloudFormation(props);
  }
}

export namespace CfnEC2Fleet {
  /**
   * Specifies the number of units to request for an EC2 Fleet.
   *
   * You can choose to set the target capacity in terms of instances or a performance characteristic that is important to your application workload, such as vCPUs, memory, or I/O. If the request type is `maintain` , you can specify a target capacity of `0` and add capacity later.
   *
   * `TargetCapacitySpecificationRequest` is a property of the [AWS::EC2::EC2Fleet](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html) resource.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-targetcapacityspecificationrequest.html
   */
  export interface TargetCapacitySpecificationRequestProperty {
    /**
     * The default target capacity type.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-targetcapacityspecificationrequest.html#cfn-ec2-ec2fleet-targetcapacityspecificationrequest-defaulttargetcapacitytype
     */
    readonly defaultTargetCapacityType?: string;

    /**
     * The number of On-Demand units to request.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-targetcapacityspecificationrequest.html#cfn-ec2-ec2fleet-targetcapacityspecificationrequest-ondemandtargetcapacity
     */
    readonly onDemandTargetCapacity?: number;

    /**
     * The number of Spot units to request.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-targetcapacityspecificationrequest.html#cfn-ec2-ec2fleet-targetcapacityspecificationrequest-spottargetcapacity
     */
    readonly spotTargetCapacity?: number;

    /**
     * The unit for the target capacity. You can specify this parameter only when using attributed-based instance type selection.
     *
     * Default: `units` (the number of instances)
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-targetcapacityspecificationrequest.html#cfn-ec2-ec2fleet-targetcapacityspecificationrequest-targetcapacityunittype
     */
    readonly targetCapacityUnitType?: string;

    /**
     * The number of units to request, filled using the default target capacity type.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-targetcapacityspecificationrequest.html#cfn-ec2-ec2fleet-targetcapacityspecificationrequest-totaltargetcapacity
     */
    readonly totalTargetCapacity: number;
  }

  /**
   * Specifies the allocation strategy of On-Demand Instances in an EC2 Fleet.
   *
   * `OnDemandOptionsRequest` is a property of the [AWS::EC2::EC2Fleet](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html) resource.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-ondemandoptionsrequest.html
   */
  export interface OnDemandOptionsRequestProperty {
    /**
     * The strategy that determines the order of the launch template overrides to use in fulfilling On-Demand capacity.
     *
     * `lowest-price` - EC2 Fleet uses price to determine the order, launching the lowest price first.
     *
     * `prioritized` - EC2 Fleet uses the priority that you assigned to each launch template override, launching the highest priority first.
     *
     * Default: `lowest-price`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-ondemandoptionsrequest.html#cfn-ec2-ec2fleet-ondemandoptionsrequest-allocationstrategy
     */
    readonly allocationStrategy?: string;

    /**
     * The strategy for using unused Capacity Reservations for fulfilling On-Demand capacity.
     *
     * Supported only for fleets of type `instant` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-ondemandoptionsrequest.html#cfn-ec2-ec2fleet-ondemandoptionsrequest-capacityreservationoptions
     */
    readonly capacityReservationOptions?: CfnEC2Fleet.CapacityReservationOptionsRequestProperty | cdk.IResolvable;

    /**
     * The maximum amount per hour for On-Demand Instances that you're willing to pay.
     *
     * > If your fleet includes T instances that are configured as `unlimited` , and if their average CPU usage exceeds the baseline utilization, you will incur a charge for surplus credits. The `MaxTotalPrice` does not account for surplus credits, and, if you use surplus credits, your final cost might be higher than what you specified for `MaxTotalPrice` . For more information, see [Surplus credits can incur charges](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances-unlimited-mode-concepts.html#unlimited-mode-surplus-credits) in the *EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-ondemandoptionsrequest.html#cfn-ec2-ec2fleet-ondemandoptionsrequest-maxtotalprice
     */
    readonly maxTotalPrice?: string;

    /**
     * The minimum target capacity for On-Demand Instances in the fleet.
     *
     * If the minimum target capacity is not reached, the fleet launches no instances.
     *
     * Supported only for fleets of type `instant` .
     *
     * At least one of the following must be specified: `SingleAvailabilityZone` | `SingleInstanceType`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-ondemandoptionsrequest.html#cfn-ec2-ec2fleet-ondemandoptionsrequest-mintargetcapacity
     */
    readonly minTargetCapacity?: number;

    /**
     * Indicates that the fleet launches all On-Demand Instances into a single Availability Zone.
     *
     * Supported only for fleets of type `instant` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-ondemandoptionsrequest.html#cfn-ec2-ec2fleet-ondemandoptionsrequest-singleavailabilityzone
     */
    readonly singleAvailabilityZone?: boolean | cdk.IResolvable;

    /**
     * Indicates that the fleet uses a single instance type to launch all On-Demand Instances in the fleet.
     *
     * Supported only for fleets of type `instant` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-ondemandoptionsrequest.html#cfn-ec2-ec2fleet-ondemandoptionsrequest-singleinstancetype
     */
    readonly singleInstanceType?: boolean | cdk.IResolvable;
  }

  /**
   * Describes the strategy for using unused Capacity Reservations for fulfilling On-Demand capacity.
   *
   * > This strategy can only be used if the EC2 Fleet is of type `instant` .
   *
   * For more information about Capacity Reservations, see [On-Demand Capacity Reservations](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-capacity-reservations.html) in the *Amazon EC2 User Guide* . For examples of using Capacity Reservations in an EC2 Fleet, see [EC2 Fleet example configurations](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-examples.html) in the *Amazon EC2 User Guide* .
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-capacityreservationoptionsrequest.html
   */
  export interface CapacityReservationOptionsRequestProperty {
    /**
     * Indicates whether to use unused Capacity Reservations for fulfilling On-Demand capacity.
     *
     * If you specify `use-capacity-reservations-first` , the fleet uses unused Capacity Reservations to fulfill On-Demand capacity up to the target On-Demand capacity. If multiple instance pools have unused Capacity Reservations, the On-Demand allocation strategy ( `lowest-price` or `prioritized` ) is applied. If the number of unused Capacity Reservations is less than the On-Demand target capacity, the remaining On-Demand target capacity is launched according to the On-Demand allocation strategy ( `lowest-price` or `prioritized` ).
     *
     * If you do not specify a value, the fleet fulfils the On-Demand capacity according to the chosen On-Demand allocation strategy.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-capacityreservationoptionsrequest.html#cfn-ec2-ec2fleet-capacityreservationoptionsrequest-usagestrategy
     */
    readonly usageStrategy?: string;
  }

  /**
   * Specifies the tags to apply to a resource when the resource is being created for an EC2 Fleet.
   *
   * `TagSpecification` is a property of the [AWS::EC2::EC2Fleet](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html) resource.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-tagspecification.html
   */
  export interface TagSpecificationProperty {
    /**
     * The type of resource to tag.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-tagspecification.html#cfn-ec2-ec2fleet-tagspecification-resourcetype
     */
    readonly resourceType?: string;

    /**
     * The tags to apply to the resource.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-tagspecification.html#cfn-ec2-ec2fleet-tagspecification-tags
     */
    readonly tags?: Array<cdk.CfnTag>;
  }

  /**
   * Specifies the configuration of Spot Instances for an EC2 Fleet.
   *
   * `SpotOptionsRequest` is a property of the [AWS::EC2::EC2Fleet](https://docs.aws.amazon.com//AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html) resource.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-spotoptionsrequest.html
   */
  export interface SpotOptionsRequestProperty {
    /**
     * Indicates how to allocate the target Spot Instance capacity across the Spot Instance pools specified by the EC2 Fleet.
     *
     * If the allocation strategy is `lowestPrice` , EC2 Fleet launches instances from the Spot Instance pools with the lowest price. This is the default allocation strategy.
     *
     * If the allocation strategy is `diversified` , EC2 Fleet launches instances from all the Spot Instance pools that you specify.
     *
     * If the allocation strategy is `capacityOptimized` , EC2 Fleet launches instances from Spot Instance pools that are optimally chosen based on the available Spot Instance capacity.
     *
     * *Allowed Values* : `lowestPrice` | `diversified` | `capacityOptimized` | `capacityOptimizedPrioritized`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-spotoptionsrequest.html#cfn-ec2-ec2fleet-spotoptionsrequest-allocationstrategy
     */
    readonly allocationStrategy?: string;

    /**
     * The behavior when a Spot Instance is interrupted.
     *
     * Default: `terminate`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-spotoptionsrequest.html#cfn-ec2-ec2fleet-spotoptionsrequest-instanceinterruptionbehavior
     */
    readonly instanceInterruptionBehavior?: string;

    /**
     * The number of Spot pools across which to allocate your target Spot capacity.
     *
     * Supported only when Spot `AllocationStrategy` is set to `lowest-price` . EC2 Fleet selects the cheapest Spot pools and evenly allocates your target Spot capacity across the number of Spot pools that you specify.
     *
     * Note that EC2 Fleet attempts to draw Spot Instances from the number of pools that you specify on a best effort basis. If a pool runs out of Spot capacity before fulfilling your target capacity, EC2 Fleet will continue to fulfill your request by drawing from the next cheapest pool. To ensure that your target capacity is met, you might receive Spot Instances from more than the number of pools that you specified. Similarly, if most of the pools have no Spot capacity, you might receive your full target capacity from fewer than the number of pools that you specified.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-spotoptionsrequest.html#cfn-ec2-ec2fleet-spotoptionsrequest-instancepoolstousecount
     */
    readonly instancePoolsToUseCount?: number;

    /**
     * The strategies for managing your Spot Instances that are at an elevated risk of being interrupted.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-spotoptionsrequest.html#cfn-ec2-ec2fleet-spotoptionsrequest-maintenancestrategies
     */
    readonly maintenanceStrategies?: cdk.IResolvable | CfnEC2Fleet.MaintenanceStrategiesProperty;

    /**
     * The maximum amount per hour for Spot Instances that you're willing to pay.
     *
     * We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price.
     *
     * > If you specify a maximum price, your Spot Instances will be interrupted more frequently than if you do not specify this parameter. > If your fleet includes T instances that are configured as `unlimited` , and if their average CPU usage exceeds the baseline utilization, you will incur a charge for surplus credits. The `MaxTotalPrice` does not account for surplus credits, and, if you use surplus credits, your final cost might be higher than what you specified for `MaxTotalPrice` . For more information, see [Surplus credits can incur charges](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances-unlimited-mode-concepts.html#unlimited-mode-surplus-credits) in the *EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-spotoptionsrequest.html#cfn-ec2-ec2fleet-spotoptionsrequest-maxtotalprice
     */
    readonly maxTotalPrice?: string;

    /**
     * The minimum target capacity for Spot Instances in the fleet.
     *
     * If the minimum target capacity is not reached, the fleet launches no instances.
     *
     * Supported only for fleets of type `instant` .
     *
     * At least one of the following must be specified: `SingleAvailabilityZone` | `SingleInstanceType`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-spotoptionsrequest.html#cfn-ec2-ec2fleet-spotoptionsrequest-mintargetcapacity
     */
    readonly minTargetCapacity?: number;

    /**
     * Indicates that the fleet launches all Spot Instances into a single Availability Zone.
     *
     * Supported only for fleets of type `instant` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-spotoptionsrequest.html#cfn-ec2-ec2fleet-spotoptionsrequest-singleavailabilityzone
     */
    readonly singleAvailabilityZone?: boolean | cdk.IResolvable;

    /**
     * Indicates that the fleet uses a single instance type to launch all Spot Instances in the fleet.
     *
     * Supported only for fleets of type `instant` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-spotoptionsrequest.html#cfn-ec2-ec2fleet-spotoptionsrequest-singleinstancetype
     */
    readonly singleInstanceType?: boolean | cdk.IResolvable;
  }

  /**
   * The strategies for managing your Spot Instances that are at an elevated risk of being interrupted.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-maintenancestrategies.html
   */
  export interface MaintenanceStrategiesProperty {
    /**
     * The strategy to use when Amazon EC2 emits a signal that your Spot Instance is at an elevated risk of being interrupted.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-maintenancestrategies.html#cfn-ec2-ec2fleet-maintenancestrategies-capacityrebalance
     */
    readonly capacityRebalance?: CfnEC2Fleet.CapacityRebalanceProperty | cdk.IResolvable;
  }

  /**
   * The Spot Instance replacement strategy to use when Amazon EC2 emits a rebalance notification signal that your Spot Instance is at an elevated risk of being interrupted.
   *
   * For more information, see [Capacity rebalancing](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-capacity-rebalance.html) in the *Amazon EC2 User Guide* .
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-capacityrebalance.html
   */
  export interface CapacityRebalanceProperty {
    /**
     * The replacement strategy to use. Only available for fleets of type `maintain` .
     *
     * `launch` - EC2 Fleet launches a replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet. EC2 Fleet does not terminate the instances that receive a rebalance notification. You can terminate the old instances, or you can leave them running. You are charged for all instances while they are running.
     *
     * `launch-before-terminate` - EC2 Fleet launches a replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet, and then, after a delay that you specify (in `TerminationDelay` ), terminates the instances that received a rebalance notification.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-capacityrebalance.html#cfn-ec2-ec2fleet-capacityrebalance-replacementstrategy
     */
    readonly replacementStrategy?: string;

    /**
     * The amount of time (in seconds) that Amazon EC2 waits before terminating the old Spot Instance after launching a new replacement Spot Instance.
     *
     * Required when `ReplacementStrategy` is set to `launch-before-terminate` .
     *
     * Not valid when `ReplacementStrategy` is set to `launch` .
     *
     * Valid values: Minimum value of `120` seconds. Maximum value of `7200` seconds.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-capacityrebalance.html#cfn-ec2-ec2fleet-capacityrebalance-terminationdelay
     */
    readonly terminationDelay?: number;
  }

  /**
   * Specifies a launch template and overrides for an EC2 Fleet.
   *
   * `FleetLaunchTemplateConfigRequest` is a property of the [AWS::EC2::EC2Fleet](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html) resource.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateconfigrequest.html
   */
  export interface FleetLaunchTemplateConfigRequestProperty {
    /**
     * The launch template to use.
     *
     * You must specify either the launch template ID or launch template name in the request.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateconfigrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplateconfigrequest-launchtemplatespecification
     */
    readonly launchTemplateSpecification?: CfnEC2Fleet.FleetLaunchTemplateSpecificationRequestProperty | cdk.IResolvable;

    /**
     * Any parameters that you specify override the same parameters in the launch template.
     *
     * For fleets of type `request` and `maintain` , a maximum of 300 items is allowed across all launch templates.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateconfigrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplateconfigrequest-overrides
     */
    readonly overrides?: Array<CfnEC2Fleet.FleetLaunchTemplateOverridesRequestProperty | cdk.IResolvable> | cdk.IResolvable;
  }

  /**
   * Specifies the launch template to be used by the EC2 Fleet for configuring Amazon EC2 instances.
   *
   * You must specify the following:
   *
   * - The ID or the name of the launch template, but not both.
   * - The version of the launch template.
   *
   * `FleetLaunchTemplateSpecificationRequest` is a property of the [FleetLaunchTemplateConfigRequest](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateconfigrequest.html) property type.
   *
   * For information about creating a launch template, see [AWS::EC2::LaunchTemplate](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html) and [Create a launch template](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-templates.html#create-launch-template) in the *Amazon EC2 User Guide* .
   *
   * For examples of launch templates, see [Examples](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#aws-resource-ec2-launchtemplate--examples) .
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplatespecificationrequest.html
   */
  export interface FleetLaunchTemplateSpecificationRequestProperty {
    /**
     * The ID of the launch template.
     *
     * You must specify the `LaunchTemplateId` or the `LaunchTemplateName` , but not both.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplatespecificationrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplatespecificationrequest-launchtemplateid
     */
    readonly launchTemplateId?: string;

    /**
     * The name of the launch template.
     *
     * You must specify the `LaunchTemplateName` or the `LaunchTemplateId` , but not both.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplatespecificationrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplatespecificationrequest-launchtemplatename
     */
    readonly launchTemplateName?: string;

    /**
     * The launch template version number, `$Latest` , or `$Default` . You must specify a value, otherwise the request fails.
     *
     * If the value is `$Latest` , Amazon EC2 uses the latest version of the launch template.
     *
     * If the value is `$Default` , Amazon EC2 uses the default version of the launch template.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplatespecificationrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplatespecificationrequest-version
     */
    readonly version: string;
  }

  /**
   * Specifies overrides for a launch template for an EC2 Fleet.
   *
   * `FleetLaunchTemplateOverridesRequest` is a property of the [FleetLaunchTemplateConfigRequest](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateconfigrequest.html) property type.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest.html
   */
  export interface FleetLaunchTemplateOverridesRequestProperty {
    /**
     * The Availability Zone in which to launch the instances.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest-availabilityzone
     */
    readonly availabilityZone?: string;

    /**
     * The attributes for the instance types.
     *
     * When you specify instance attributes, Amazon EC2 will identify instance types with those attributes.
     *
     * > If you specify `InstanceRequirements` , you can't specify `InstanceType` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest-instancerequirements
     */
    readonly instanceRequirements?: CfnEC2Fleet.InstanceRequirementsRequestProperty | cdk.IResolvable;

    /**
     * The instance type.
     *
     * `mac1.metal` is not supported as a launch template override.
     *
     * > If you specify `InstanceType` , you can't specify `InstanceRequirements` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest-instancetype
     */
    readonly instanceType?: string;

    /**
     * The maximum price per unit hour that you are willing to pay for a Spot Instance.
     *
     * We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price.
     *
     * > If you specify a maximum price, your instances will be interrupted more frequently than if you do not specify this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest-maxprice
     */
    readonly maxPrice?: string;

    /**
     * The location where the instance launched, if applicable.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest-placement
     */
    readonly placement?: cdk.IResolvable | CfnEC2Fleet.PlacementProperty;

    /**
     * The priority for the launch template override. The highest priority is launched first.
     *
     * If the On-Demand `AllocationStrategy` is set to `prioritized` , EC2 Fleet uses priority to determine which launch template override to use first in fulfilling On-Demand capacity.
     *
     * If the Spot `AllocationStrategy` is set to `capacity-optimized-prioritized` , EC2 Fleet uses priority on a best-effort basis to determine which launch template override to use in fulfilling Spot capacity, but optimizes for capacity first.
     *
     * Valid values are whole numbers starting at `0` . The lower the number, the higher the priority. If no number is set, the launch template override has the lowest priority. You can set the same priority for different launch template overrides.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest-priority
     */
    readonly priority?: number;

    /**
     * The IDs of the subnets in which to launch the instances.
     *
     * Separate multiple subnet IDs using commas (for example, `subnet-1234abcdeexample1, subnet-0987cdef6example2` ). A request of type `instant` can have only one subnet ID.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest-subnetid
     */
    readonly subnetId?: string;

    /**
     * The number of units provided by the specified instance type.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest-weightedcapacity
     */
    readonly weightedCapacity?: number;
  }

  /**
   * Describes the placement of an instance.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-placement.html
   */
  export interface PlacementProperty {
    /**
     * The affinity setting for the instance on the Dedicated Host.
     *
     * This parameter is not supported for [CreateFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet) or [ImportInstance](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportInstance.html) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-placement.html#cfn-ec2-ec2fleet-placement-affinity
     */
    readonly affinity?: string;

    /**
     * The Availability Zone of the instance.
     *
     * If not specified, an Availability Zone will be automatically chosen for you based on the load balancing criteria for the Region.
     *
     * This parameter is not supported for [CreateFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-placement.html#cfn-ec2-ec2fleet-placement-availabilityzone
     */
    readonly availabilityZone?: string;

    /**
     * The name of the placement group that the instance is in.
     *
     * If you specify `GroupName` , you can't specify `GroupId` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-placement.html#cfn-ec2-ec2fleet-placement-groupname
     */
    readonly groupName?: string;

    /**
     * The ID of the Dedicated Host on which the instance resides.
     *
     * This parameter is not supported for [CreateFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet) or [ImportInstance](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportInstance.html) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-placement.html#cfn-ec2-ec2fleet-placement-hostid
     */
    readonly hostId?: string;

    /**
     * The ARN of the host resource group in which to launch the instances.
     *
     * If you specify this parameter, either omit the *Tenancy* parameter or set it to `host` .
     *
     * This parameter is not supported for [CreateFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-placement.html#cfn-ec2-ec2fleet-placement-hostresourcegrouparn
     */
    readonly hostResourceGroupArn?: string;

    /**
     * The number of the partition that the instance is in.
     *
     * Valid only if the placement group strategy is set to `partition` .
     *
     * This parameter is not supported for [CreateFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-placement.html#cfn-ec2-ec2fleet-placement-partitionnumber
     */
    readonly partitionNumber?: number;

    /**
     * Reserved for future use.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-placement.html#cfn-ec2-ec2fleet-placement-spreaddomain
     */
    readonly spreadDomain?: string;

    /**
     * The tenancy of the instance. An instance with a tenancy of `dedicated` runs on single-tenant hardware.
     *
     * This parameter is not supported for [CreateFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet) . The `host` tenancy is not supported for [ImportInstance](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportInstance.html) or for T3 instances that are configured for the `unlimited` CPU credit option.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-placement.html#cfn-ec2-ec2fleet-placement-tenancy
     */
    readonly tenancy?: string;
  }

  /**
   * The attributes for the instance types.
   *
   * When you specify instance attributes, Amazon EC2 will identify instance types with these attributes.
   *
   * You must specify `VCpuCount` and `MemoryMiB` . All other attributes are optional. Any unspecified optional attribute is set to its default.
   *
   * When you specify multiple attributes, you get instance types that satisfy all of the specified attributes. If you specify multiple values for an attribute, you get instance types that satisfy any of the specified values.
   *
   * To limit the list of instance types from which Amazon EC2 can identify matching instance types, you can use one of the following parameters, but not both in the same request:
   *
   * - `AllowedInstanceTypes` - The instance types to include in the list. All other instance types are ignored, even if they match your specified attributes.
   * - `ExcludedInstanceTypes` - The instance types to exclude from the list, even if they match your specified attributes.
   *
   * > If you specify `InstanceRequirements` , you can't specify `InstanceType` .
   * >
   * > Attribute-based instance type selection is only supported when using Auto Scaling groups, EC2 Fleet, and Spot Fleet to launch instances. If you plan to use the launch template in the [launch instance wizard](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-instance-wizard.html) , or with the [RunInstances](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html) API or [AWS::EC2::Instance](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html) AWS CloudFormation resource, you can't specify `InstanceRequirements` .
   *
   * For more information, see [Attribute-based instance type selection for EC2 Fleet](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html) , [Attribute-based instance type selection for Spot Fleet](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-attribute-based-instance-type-selection.html) , and [Spot placement score](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-placement-score.html) in the *Amazon EC2 User Guide* .
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html
   */
  export interface InstanceRequirementsRequestProperty {
    /**
     * The minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips) on an instance.
     *
     * To exclude accelerator-enabled instance types, set `Max` to `0` .
     *
     * Default: No minimum or maximum limits
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-acceleratorcount
     */
    readonly acceleratorCount?: CfnEC2Fleet.AcceleratorCountRequestProperty | cdk.IResolvable;

    /**
     * Indicates whether instance types must have accelerators by specific manufacturers.
     *
     * - For instance types with AWS devices, specify `amazon-web-services` .
     * - For instance types with AMD devices, specify `amd` .
     * - For instance types with Habana devices, specify `habana` .
     * - For instance types with NVIDIA devices, specify `nvidia` .
     * - For instance types with Xilinx devices, specify `xilinx` .
     *
     * Default: Any manufacturer
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-acceleratormanufacturers
     */
    readonly acceleratorManufacturers?: Array<string>;

    /**
     * The accelerators that must be on the instance type.
     *
     * - For instance types with NVIDIA A10G GPUs, specify `a10g` .
     * - For instance types with NVIDIA A100 GPUs, specify `a100` .
     * - For instance types with NVIDIA H100 GPUs, specify `h100` .
     * - For instance types with AWS Inferentia chips, specify `inferentia` .
     * - For instance types with NVIDIA GRID K520 GPUs, specify `k520` .
     * - For instance types with NVIDIA K80 GPUs, specify `k80` .
     * - For instance types with NVIDIA M60 GPUs, specify `m60` .
     * - For instance types with AMD Radeon Pro V520 GPUs, specify `radeon-pro-v520` .
     * - For instance types with NVIDIA T4 GPUs, specify `t4` .
     * - For instance types with NVIDIA T4G GPUs, specify `t4g` .
     * - For instance types with Xilinx VU9P FPGAs, specify `vu9p` .
     * - For instance types with NVIDIA V100 GPUs, specify `v100` .
     *
     * Default: Any accelerator
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-acceleratornames
     */
    readonly acceleratorNames?: Array<string>;

    /**
     * The minimum and maximum amount of total accelerator memory, in MiB.
     *
     * Default: No minimum or maximum limits
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-acceleratortotalmemorymib
     */
    readonly acceleratorTotalMemoryMiB?: CfnEC2Fleet.AcceleratorTotalMemoryMiBRequestProperty | cdk.IResolvable;

    /**
     * The accelerator types that must be on the instance type.
     *
     * - To include instance types with GPU hardware, specify `gpu` .
     * - To include instance types with FPGA hardware, specify `fpga` .
     * - To include instance types with inference hardware, specify `inference` .
     *
     * Default: Any accelerator type
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-acceleratortypes
     */
    readonly acceleratorTypes?: Array<string>;

    /**
     * The instance types to apply your specified attributes against.
     *
     * All other instance types are ignored, even if they match your specified attributes.
     *
     * You can use strings with one or more wild cards, represented by an asterisk ( `*` ), to allow an instance type, size, or generation. The following are examples: `m5.8xlarge` , `c5*.*` , `m5a.*` , `r*` , `*3*` .
     *
     * For example, if you specify `c5*` ,Amazon EC2 will allow the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*` , Amazon EC2 will allow all the M5a instance types, but not the M5n instance types.
     *
     * > If you specify `AllowedInstanceTypes` , you can't specify `ExcludedInstanceTypes` .
     *
     * Default: All instance types
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-allowedinstancetypes
     */
    readonly allowedInstanceTypes?: Array<string>;

    /**
     * Indicates whether bare metal instance types must be included, excluded, or required.
     *
     * - To include bare metal instance types, specify `included` .
     * - To require only bare metal instance types, specify `required` .
     * - To exclude bare metal instance types, specify `excluded` .
     *
     * Default: `excluded`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-baremetal
     */
    readonly bareMetal?: string;

    /**
     * The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps.
     *
     * For more information, see [Amazon EBSoptimized instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html) in the *Amazon EC2 User Guide* .
     *
     * Default: No minimum or maximum limits
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-baselineebsbandwidthmbps
     */
    readonly baselineEbsBandwidthMbps?: CfnEC2Fleet.BaselineEbsBandwidthMbpsRequestProperty | cdk.IResolvable;

    /**
     * Indicates whether burstable performance T instance types are included, excluded, or required.
     *
     * For more information, see [Burstable performance instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html) .
     *
     * - To include burstable performance instance types, specify `included` .
     * - To require only burstable performance instance types, specify `required` .
     * - To exclude burstable performance instance types, specify `excluded` .
     *
     * Default: `excluded`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-burstableperformance
     */
    readonly burstablePerformance?: string;

    /**
     * The CPU manufacturers to include.
     *
     * - For instance types with Intel CPUs, specify `intel` .
     * - For instance types with AMD CPUs, specify `amd` .
     * - For instance types with AWS CPUs, specify `amazon-web-services` .
     *
     * > Don't confuse the CPU manufacturer with the CPU architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template.
     *
     * Default: Any manufacturer
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-cpumanufacturers
     */
    readonly cpuManufacturers?: Array<string>;

    /**
     * The instance types to exclude.
     *
     * You can use strings with one or more wild cards, represented by an asterisk ( `*` ), to exclude an instance family, type, size, or generation. The following are examples: `m5.8xlarge` , `c5*.*` , `m5a.*` , `r*` , `*3*` .
     *
     * For example, if you specify `c5*` ,Amazon EC2 will exclude the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*` , Amazon EC2 will exclude all the M5a instance types, but not the M5n instance types.
     *
     * > If you specify `ExcludedInstanceTypes` , you can't specify `AllowedInstanceTypes` .
     *
     * Default: No excluded instance types
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-excludedinstancetypes
     */
    readonly excludedInstanceTypes?: Array<string>;

    /**
     * Indicates whether current or previous generation instance types are included.
     *
     * The current generation instance types are recommended for use. Current generation instance types are typically the latest two to three generations in each instance family. For more information, see [Instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the *Amazon EC2 User Guide* .
     *
     * For current generation instance types, specify `current` .
     *
     * For previous generation instance types, specify `previous` .
     *
     * Default: Current and previous generation instance types
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-instancegenerations
     */
    readonly instanceGenerations?: Array<string>;

    /**
     * Indicates whether instance types with instance store volumes are included, excluded, or required.
     *
     * For more information, [Amazon EC2 instance store](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html) in the *Amazon EC2 User Guide* .
     *
     * - To include instance types with instance store volumes, specify `included` .
     * - To require only instance types with instance store volumes, specify `required` .
     * - To exclude instance types with instance store volumes, specify `excluded` .
     *
     * Default: `included`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-localstorage
     */
    readonly localStorage?: string;

    /**
     * The type of local storage that is required.
     *
     * - For instance types with hard disk drive (HDD) storage, specify `hdd` .
     * - For instance types with solid state drive (SSD) storage, specify `ssd` .
     *
     * Default: `hdd` and `ssd`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-localstoragetypes
     */
    readonly localStorageTypes?: Array<string>;

    /**
     * The minimum and maximum amount of memory per vCPU, in GiB.
     *
     * Default: No minimum or maximum limits
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-memorygibpervcpu
     */
    readonly memoryGiBPerVCpu?: cdk.IResolvable | CfnEC2Fleet.MemoryGiBPerVCpuRequestProperty;

    /**
     * The minimum and maximum amount of memory, in MiB.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-memorymib
     */
    readonly memoryMiB?: cdk.IResolvable | CfnEC2Fleet.MemoryMiBRequestProperty;

    /**
     * The minimum and maximum amount of baseline network bandwidth, in gigabits per second (Gbps).
     *
     * For more information, see [Amazon EC2 instance network bandwidth](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-network-bandwidth.html) in the *Amazon EC2 User Guide* .
     *
     * Default: No minimum or maximum limits
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-networkbandwidthgbps
     */
    readonly networkBandwidthGbps?: cdk.IResolvable | CfnEC2Fleet.NetworkBandwidthGbpsRequestProperty;

    /**
     * The minimum and maximum number of network interfaces.
     *
     * Default: No minimum or maximum limits
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-networkinterfacecount
     */
    readonly networkInterfaceCount?: cdk.IResolvable | CfnEC2Fleet.NetworkInterfaceCountRequestProperty;

    /**
     * The price protection threshold for On-Demand Instances.
     *
     * This is the maximum youll pay for an On-Demand Instance, expressed as a percentage above the least expensive current generation M, C, or R instance type with your specified attributes. When Amazon EC2 selects instance types with your attributes, it excludes instance types priced above your threshold.
     *
     * The parameter accepts an integer, which Amazon EC2 interprets as a percentage.
     *
     * To turn off price protection, specify a high value, such as `999999` .
     *
     * This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) and [GetInstanceTypesFromInstanceRequirements](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html) .
     *
     * > If you set `TargetCapacityUnitType` to `vcpu` or `memory-mib` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price.
     *
     * Default: `20`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-ondemandmaxpricepercentageoverlowestprice
     */
    readonly onDemandMaxPricePercentageOverLowestPrice?: number;

    /**
     * Indicates whether instance types must support hibernation for On-Demand Instances.
     *
     * This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) .
     *
     * Default: `false`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-requirehibernatesupport
     */
    readonly requireHibernateSupport?: boolean | cdk.IResolvable;

    /**
     * The price protection threshold for Spot Instance.
     *
     * This is the maximum youll pay for an Spot Instance, expressed as a percentage above the least expensive current generation M, C, or R instance type with your specified attributes. When Amazon EC2 selects instance types with your attributes, it excludes instance types priced above your threshold.
     *
     * The parameter accepts an integer, which Amazon EC2 interprets as a percentage.
     *
     * To turn off price protection, specify a high value, such as `999999` .
     *
     * This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) and [GetInstanceTypesFromInstanceRequirements](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html) .
     *
     * > If you set `TargetCapacityUnitType` to `vcpu` or `memory-mib` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price.
     *
     * Default: `100`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-spotmaxpricepercentageoverlowestprice
     */
    readonly spotMaxPricePercentageOverLowestPrice?: number;

    /**
     * The minimum and maximum amount of total local storage, in GB.
     *
     * Default: No minimum or maximum limits
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-totallocalstoragegb
     */
    readonly totalLocalStorageGb?: cdk.IResolvable | CfnEC2Fleet.TotalLocalStorageGBRequestProperty;

    /**
     * The minimum and maximum number of vCPUs.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-vcpucount
     */
    readonly vCpuCount?: cdk.IResolvable | CfnEC2Fleet.VCpuCountRangeRequestProperty;
  }

  /**
   * The minimum and maximum number of network interfaces.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-networkinterfacecountrequest.html
   */
  export interface NetworkInterfaceCountRequestProperty {
    /**
     * The maximum number of network interfaces.
     *
     * To specify no maximum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-networkinterfacecountrequest.html#cfn-ec2-ec2fleet-networkinterfacecountrequest-max
     */
    readonly max?: number;

    /**
     * The minimum number of network interfaces.
     *
     * To specify no minimum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-networkinterfacecountrequest.html#cfn-ec2-ec2fleet-networkinterfacecountrequest-min
     */
    readonly min?: number;
  }

  /**
   * The minimum and maximum amount of memory per vCPU, in GiB.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-memorygibpervcpurequest.html
   */
  export interface MemoryGiBPerVCpuRequestProperty {
    /**
     * The maximum amount of memory per vCPU, in GiB.
     *
     * To specify no maximum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-memorygibpervcpurequest.html#cfn-ec2-ec2fleet-memorygibpervcpurequest-max
     */
    readonly max?: number;

    /**
     * The minimum amount of memory per vCPU, in GiB.
     *
     * To specify no minimum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-memorygibpervcpurequest.html#cfn-ec2-ec2fleet-memorygibpervcpurequest-min
     */
    readonly min?: number;
  }

  /**
   * The minimum and maximum number of vCPUs.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-vcpucountrangerequest.html
   */
  export interface VCpuCountRangeRequestProperty {
    /**
     * The maximum number of vCPUs.
     *
     * To specify no maximum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-vcpucountrangerequest.html#cfn-ec2-ec2fleet-vcpucountrangerequest-max
     */
    readonly max?: number;

    /**
     * The minimum number of vCPUs.
     *
     * To specify no minimum limit, specify `0` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-vcpucountrangerequest.html#cfn-ec2-ec2fleet-vcpucountrangerequest-min
     */
    readonly min?: number;
  }

  /**
   * The minimum and maximum amount of network bandwidth, in gigabits per second (Gbps).
   *
   * > Setting the minimum bandwidth does not guarantee that your instance will achieve the minimum bandwidth. Amazon EC2 will identify instance types that support the specified minimum bandwidth, but the actual bandwidth of your instance might go below the specified minimum at times. For more information, see [Available instance bandwidth](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-network-bandwidth.html#available-instance-bandwidth) in the *Amazon EC2 User Guide* .
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-networkbandwidthgbpsrequest.html
   */
  export interface NetworkBandwidthGbpsRequestProperty {
    /**
     * The maximum amount of network bandwidth, in Gbps.
     *
     * To specify no maximum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-networkbandwidthgbpsrequest.html#cfn-ec2-ec2fleet-networkbandwidthgbpsrequest-max
     */
    readonly max?: number;

    /**
     * The minimum amount of network bandwidth, in Gbps.
     *
     * To specify no minimum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-networkbandwidthgbpsrequest.html#cfn-ec2-ec2fleet-networkbandwidthgbpsrequest-min
     */
    readonly min?: number;
  }

  /**
   * The minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips) on an instance.
   *
   * To exclude accelerator-enabled instance types, set `Max` to `0` .
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-acceleratorcountrequest.html
   */
  export interface AcceleratorCountRequestProperty {
    /**
     * The maximum number of accelerators.
     *
     * To specify no maximum limit, omit this parameter. To exclude accelerator-enabled instance types, set `Max` to `0` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-acceleratorcountrequest.html#cfn-ec2-ec2fleet-acceleratorcountrequest-max
     */
    readonly max?: number;

    /**
     * The minimum number of accelerators.
     *
     * To specify no minimum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-acceleratorcountrequest.html#cfn-ec2-ec2fleet-acceleratorcountrequest-min
     */
    readonly min?: number;
  }

  /**
   * The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps.
   *
   * For more information, see [Amazon EBSoptimized instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html) in the *Amazon EC2 User Guide* .
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-baselineebsbandwidthmbpsrequest.html
   */
  export interface BaselineEbsBandwidthMbpsRequestProperty {
    /**
     * The maximum baseline bandwidth, in Mbps.
     *
     * To specify no maximum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-baselineebsbandwidthmbpsrequest.html#cfn-ec2-ec2fleet-baselineebsbandwidthmbpsrequest-max
     */
    readonly max?: number;

    /**
     * The minimum baseline bandwidth, in Mbps.
     *
     * To specify no minimum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-baselineebsbandwidthmbpsrequest.html#cfn-ec2-ec2fleet-baselineebsbandwidthmbpsrequest-min
     */
    readonly min?: number;
  }

  /**
   * The minimum and maximum amount of total accelerator memory, in MiB.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-acceleratortotalmemorymibrequest.html
   */
  export interface AcceleratorTotalMemoryMiBRequestProperty {
    /**
     * The maximum amount of accelerator memory, in MiB.
     *
     * To specify no maximum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-acceleratortotalmemorymibrequest.html#cfn-ec2-ec2fleet-acceleratortotalmemorymibrequest-max
     */
    readonly max?: number;

    /**
     * The minimum amount of accelerator memory, in MiB.
     *
     * To specify no minimum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-acceleratortotalmemorymibrequest.html#cfn-ec2-ec2fleet-acceleratortotalmemorymibrequest-min
     */
    readonly min?: number;
  }

  /**
   * The minimum and maximum amount of memory, in MiB.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-memorymibrequest.html
   */
  export interface MemoryMiBRequestProperty {
    /**
     * The maximum amount of memory, in MiB.
     *
     * To specify no maximum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-memorymibrequest.html#cfn-ec2-ec2fleet-memorymibrequest-max
     */
    readonly max?: number;

    /**
     * The minimum amount of memory, in MiB.
     *
     * To specify no minimum limit, specify `0` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-memorymibrequest.html#cfn-ec2-ec2fleet-memorymibrequest-min
     */
    readonly min?: number;
  }

  /**
   * The minimum and maximum amount of total local storage, in GB.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-totallocalstoragegbrequest.html
   */
  export interface TotalLocalStorageGBRequestProperty {
    /**
     * The maximum amount of total local storage, in GB.
     *
     * To specify no maximum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-totallocalstoragegbrequest.html#cfn-ec2-ec2fleet-totallocalstoragegbrequest-max
     */
    readonly max?: number;

    /**
     * The minimum amount of total local storage, in GB.
     *
     * To specify no minimum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-totallocalstoragegbrequest.html#cfn-ec2-ec2fleet-totallocalstoragegbrequest-min
     */
    readonly min?: number;
  }
}

/**
 * Properties for defining a `CfnEC2Fleet`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html
 */
export interface CfnEC2FleetProps {
  /**
   * Reserved.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-context
   */
  readonly context?: string;

  /**
   * Indicates whether running instances should be terminated if the total target capacity of the EC2 Fleet is decreased below the current size of the EC2 Fleet.
   *
   * Supported only for fleets of type `maintain` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-excesscapacityterminationpolicy
   */
  readonly excessCapacityTerminationPolicy?: string;

  /**
   * The configuration for the EC2 Fleet.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-launchtemplateconfigs
   */
  readonly launchTemplateConfigs: Array<CfnEC2Fleet.FleetLaunchTemplateConfigRequestProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * Describes the configuration of On-Demand Instances in an EC2 Fleet.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-ondemandoptions
   */
  readonly onDemandOptions?: cdk.IResolvable | CfnEC2Fleet.OnDemandOptionsRequestProperty;

  /**
   * Indicates whether EC2 Fleet should replace unhealthy Spot Instances.
   *
   * Supported only for fleets of type `maintain` . For more information, see [EC2 Fleet health checks](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/manage-ec2-fleet.html#ec2-fleet-health-checks) in the *Amazon EC2 User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-replaceunhealthyinstances
   */
  readonly replaceUnhealthyInstances?: boolean | cdk.IResolvable;

  /**
   * Describes the configuration of Spot Instances in an EC2 Fleet.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-spotoptions
   */
  readonly spotOptions?: cdk.IResolvable | CfnEC2Fleet.SpotOptionsRequestProperty;

  /**
   * The key-value pair for tagging the EC2 Fleet request on creation. For more information, see [Tag your resources](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html#tag-resources) .
   *
   * If the fleet type is `instant` , specify a resource type of `fleet` to tag the fleet or `instance` to tag the instances at launch.
   *
   * If the fleet type is `maintain` or `request` , specify a resource type of `fleet` to tag the fleet. You cannot specify a resource type of `instance` . To tag instances at launch, specify the tags in a [launch template](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-templates.html#create-launch-template) .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-tagspecifications
   */
  readonly tagSpecifications?: Array<cdk.IResolvable | CfnEC2Fleet.TagSpecificationProperty> | cdk.IResolvable;

  /**
   * The number of units to request.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-targetcapacityspecification
   */
  readonly targetCapacitySpecification: cdk.IResolvable | CfnEC2Fleet.TargetCapacitySpecificationRequestProperty;

  /**
   * Indicates whether running instances should be terminated when the EC2 Fleet expires.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-terminateinstanceswithexpiration
   */
  readonly terminateInstancesWithExpiration?: boolean | cdk.IResolvable;

  /**
   * The fleet type. The default value is `maintain` .
   *
   * - `maintain` - The EC2 Fleet places an asynchronous request for your desired capacity, and continues to maintain your desired Spot capacity by replenishing interrupted Spot Instances.
   * - `request` - The EC2 Fleet places an asynchronous one-time request for your desired capacity, but does submit Spot requests in alternative capacity pools if Spot capacity is unavailable, and does not maintain Spot capacity if Spot Instances are interrupted.
   * - `instant` - The EC2 Fleet places a synchronous one-time request for your desired capacity, and returns errors for any instances that could not be launched.
   *
   * For more information, see [EC2 Fleet request types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-request-type.html) in the *Amazon EC2 User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-type
   */
  readonly type?: string;

  /**
   * The start date and time of the request, in UTC format (for example, *YYYY* - *MM* - *DD* T *HH* : *MM* : *SS* Z).
   *
   * The default is to start fulfilling the request immediately.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-validfrom
   */
  readonly validFrom?: string;

  /**
   * The end date and time of the request, in UTC format (for example, *YYYY* - *MM* - *DD* T *HH* : *MM* : *SS* Z).
   *
   * At this point, no new EC2 Fleet requests are placed or able to fulfill the request. If no value is specified, the request remains until you cancel it.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-validuntil
   */
  readonly validUntil?: string;
}

/**
 * Determine whether the given properties match those of a `TargetCapacitySpecificationRequestProperty`
 *
 * @param properties - the TypeScript properties of a `TargetCapacitySpecificationRequestProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnEC2FleetTargetCapacitySpecificationRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("defaultTargetCapacityType", cdk.validateString)(properties.defaultTargetCapacityType));
  errors.collect(cdk.propertyValidator("onDemandTargetCapacity", cdk.validateNumber)(properties.onDemandTargetCapacity));
  errors.collect(cdk.propertyValidator("spotTargetCapacity", cdk.validateNumber)(properties.spotTargetCapacity));
  errors.collect(cdk.propertyValidator("targetCapacityUnitType", cdk.validateString)(properties.targetCapacityUnitType));
  errors.collect(cdk.propertyValidator("totalTargetCapacity", cdk.requiredValidator)(properties.totalTargetCapacity));
  errors.collect(cdk.propertyValidator("totalTargetCapacity", cdk.validateNumber)(properties.totalTargetCapacity));
  return errors.wrap("supplied properties not correct for \"TargetCapacitySpecificationRequestProperty\"");
}

// @ts-ignore TS6133
function convertCfnEC2FleetTargetCapacitySpecificationRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnEC2FleetTargetCapacitySpecificationRequestPropertyValidator(properties).assertSuccess();
  return {
    "DefaultTargetCapacityType": cdk.stringToCloudFormation(properties.defaultTargetCapacityType),
    "OnDemandTargetCapacity": cdk.numberToCloudFormation(properties.onDemandTargetCapacity),
    "SpotTargetCapacity": cdk.numberToCloudFormation(properties.spotTargetCapacity),
    "TargetCapacityUnitType": cdk.stringToCloudFormation(properties.targetCapacityUnitType),
    "TotalTargetCapacity": cdk.numberToCloudFormation(properties.totalTargetCapacity)
  };
}

// @ts-ignore TS6133
function CfnEC2FleetTargetCapacitySpecificationRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnEC2Fleet.TargetCapacitySpecificationRequestProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnEC2Fleet.TargetCapacitySpecificationRequestProperty>();
  ret.addPropertyResult("defaultTargetCapacityType", "DefaultTargetCapacityType", (properties.DefaultTargetCapacityType != null ? cfn_parse.FromCloudFormation.getString(properties.DefaultTargetCapacityType) : undefined));
  ret.addPropertyResult("onDemandTargetCapacity", "OnDemandTargetCapacity", (properties.OnDemandTargetCapacity != null ? cfn_parse.FromCloudFormation.getNumber(properties.OnDemandTargetCapacity) : undefined));
  ret.addPropertyResult("spotTargetCapacity", "SpotTargetCapacity", (properties.SpotTargetCapacity != null ? cfn_parse.FromCloudFormation.getNumber(properties.SpotTargetCapacity) : undefined));
  ret.addPropertyResult("targetCapacityUnitType", "TargetCapacityUnitType", (properties.TargetCapacityUnitType != null ? cfn_parse.FromCloudFormation.getString(properties.TargetCapacityUnitType) : undefined));
  ret.addPropertyResult("totalTargetCapacity", "TotalTargetCapacity", (properties.TotalTargetCapacity != null ? cfn_parse.FromCloudFormation.getNumber(properties.TotalTargetCapacity) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `CapacityReservationOptionsRequestProperty`
 *
 * @param properties - the TypeScript properties of a `CapacityReservationOptionsRequestProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnEC2FleetCapacityReservationOptionsRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("usageStrategy", cdk.validateString)(properties.usageStrategy));
  return errors.wrap("supplied properties not correct for \"CapacityReservationOptionsRequestProperty\"");
}

// @ts-ignore TS6133
function convertCfnEC2FleetCapacityReservationOptionsRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnEC2FleetCapacityReservationOptionsRequestPropertyValidator(properties).assertSuccess();
  return {
    "UsageStrategy": cdk.stringToCloudFormation(properties.usageStrategy)
  };
}

// @ts-ignore TS6133
function CfnEC2FleetCapacityReservationOptionsRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnEC2Fleet.CapacityReservationOptionsRequestProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnEC2Fleet.CapacityReservationOptionsRequestProperty>();
  ret.addPropertyResult("usageStrategy", "UsageStrategy", (properties.UsageStrategy != null ? cfn_parse.FromCloudFormation.getString(properties.UsageStrategy) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `OnDemandOptionsRequestProperty`
 *
 * @param properties - the TypeScript properties of a `OnDemandOptionsRequestProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnEC2FleetOnDemandOptionsRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("allocationStrategy", cdk.validateString)(properties.allocationStrategy));
  errors.collect(cdk.propertyValidator("capacityReservationOptions", CfnEC2FleetCapacityReservationOptionsRequestPropertyValidator)(properties.capacityReservationOptions));
  errors.collect(cdk.propertyValidator("maxTotalPrice", cdk.validateString)(properties.maxTotalPrice));
  errors.collect(cdk.propertyValidator("minTargetCapacity", cdk.validateNumber)(properties.minTargetCapacity));
  errors.collect(cdk.propertyValidator("singleAvailabilityZone", cdk.validateBoolean)(properties.singleAvailabilityZone));
  errors.collect(cdk.propertyValidator("singleInstanceType", cdk.validateBoolean)(properties.singleInstanceType));
  return errors.wrap("supplied properties not correct for \"OnDemandOptionsRequestProperty\"");
}

// @ts-ignore TS6133
function convertCfnEC2FleetOnDemandOptionsRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnEC2FleetOnDemandOptionsRequestPropertyValidator(properties).assertSuccess();
  return {
    "AllocationStrategy": cdk.stringToCloudFormation(properties.allocationStrategy),
    "CapacityReservationOptions": convertCfnEC2FleetCapacityReservationOptionsRequestPropertyToCloudFormation(properties.capacityReservationOptions),
    "MaxTotalPrice": cdk.stringToCloudFormation(properties.maxTotalPrice),
    "MinTargetCapacity": cdk.numberToCloudFormation(properties.minTargetCapacity),
    "SingleAvailabilityZone": cdk.booleanToCloudFormation(properties.singleAvailabilityZone),
    "SingleInstanceType": cdk.booleanToCloudFormation(properties.singleInstanceType)
  };
}

// @ts-ignore TS6133
function CfnEC2FleetOnDemandOptionsRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnEC2Fleet.OnDemandOptionsRequestProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnEC2Fleet.OnDemandOptionsRequestProperty>();
  ret.addPropertyResult("allocationStrategy", "AllocationStrategy", (properties.AllocationStrategy != null ? cfn_parse.FromCloudFormation.getString(properties.AllocationStrategy) : undefined));
  ret.addPropertyResult("capacityReservationOptions", "CapacityReservationOptions", (properties.CapacityReservationOptions != null ? CfnEC2FleetCapacityReservationOptionsRequestPropertyFromCloudFormation(properties.CapacityReservationOptions) : undefined));
  ret.addPropertyResult("maxTotalPrice", "MaxTotalPrice", (properties.MaxTotalPrice != null ? cfn_parse.FromCloudFormation.getString(properties.MaxTotalPrice) : undefined));
  ret.addPropertyResult("minTargetCapacity", "MinTargetCapacity", (properties.MinTargetCapacity != null ? cfn_parse.FromCloudFormation.getNumber(properties.MinTargetCapacity) : undefined));
  ret.addPropertyResult("singleAvailabilityZone", "SingleAvailabilityZone", (properties.SingleAvailabilityZone != null ? cfn_parse.FromCloudFormation.getBoolean(properties.SingleAvailabilityZone) : undefined));
  ret.addPropertyResult("singleInstanceType", "SingleInstanceType", (properties.SingleInstanceType != null ? cfn_parse.FromCloudFormation.getBoolean(properties.SingleInstanceType) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `TagSpecificationProperty`
 *
 * @param properties - the TypeScript properties of a `TagSpecificationProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnEC2FleetTagSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("resourceType", cdk.validateString)(properties.resourceType));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \"TagSpecificationProperty\"");
}

// @ts-ignore TS6133
function convertCfnEC2FleetTagSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnEC2FleetTagSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "ResourceType": cdk.stringToCloudFormation(properties.resourceType),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnEC2FleetTagSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnEC2Fleet.TagSpecificationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnEC2Fleet.TagSpecificationProperty>();
  ret.addPropertyResult("resourceType", "ResourceType", (properties.ResourceType != null ? cfn_parse.FromCloudFormation.getString(properties.ResourceType) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `CapacityRebalanceProperty`
 *
 * @param properties - the TypeScript properties of a `CapacityRebalanceProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnEC2FleetCapacityRebalancePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("replacementStrategy", cdk.validateString)(properties.replacementStrategy));
  errors.collect(cdk.propertyValidator("terminationDelay", cdk.validateNumber)(properties.terminationDelay));
  return errors.wrap("supplied properties not correct for \"CapacityRebalanceProperty\"");
}

// @ts-ignore TS6133
function convertCfnEC2FleetCapacityRebalancePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnEC2FleetCapacityRebalancePropertyValidator(properties).assertSuccess();
  return {
    "ReplacementStrategy": cdk.stringToCloudFormation(properties.replacementStrategy),
    "TerminationDelay": cdk.numberToCloudFormation(properties.terminationDelay)
  };
}

// @ts-ignore TS6133
function CfnEC2FleetCapacityRebalancePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnEC2Fleet.CapacityRebalanceProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnEC2Fleet.CapacityRebalanceProperty>();
  ret.addPropertyResult("replacementStrategy", "ReplacementStrategy", (properties.ReplacementStrategy != null ? cfn_parse.FromCloudFormation.getString(properties.ReplacementStrategy) : undefined));
  ret.addPropertyResult("terminationDelay", "TerminationDelay", (properties.TerminationDelay != null ? cfn_parse.FromCloudFormation.getNumber(properties.TerminationDelay) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `MaintenanceStrategiesProperty`
 *
 * @param properties - the TypeScript properties of a `MaintenanceStrategiesProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnEC2FleetMaintenanceStrategiesPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("capacityRebalance", CfnEC2FleetCapacityRebalancePropertyValidator)(properties.capacityRebalance));
  return errors.wrap("supplied properties not correct for \"MaintenanceStrategiesProperty\"");
}

// @ts-ignore TS6133
function convertCfnEC2FleetMaintenanceStrategiesPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnEC2FleetMaintenanceStrategiesPropertyValidator(properties).assertSuccess();
  return {
    "CapacityRebalance": convertCfnEC2FleetCapacityRebalancePropertyToCloudFormation(properties.capacityRebalance)
  };
}

// @ts-ignore TS6133
function CfnEC2FleetMaintenanceStrategiesPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnEC2Fleet.MaintenanceStrategiesProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnEC2Fleet.MaintenanceStrategiesProperty>();
  ret.addPropertyResult("capacityRebalance", "CapacityRebalance", (properties.CapacityRebalance != null ? CfnEC2FleetCapacityRebalancePropertyFromCloudFormation(properties.CapacityRebalance) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `SpotOptionsRequestProperty`
 *
 * @param properties - the TypeScript properties of a `SpotOptionsRequestProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnEC2FleetSpotOptionsRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("allocationStrategy", cdk.validateString)(properties.allocationStrategy));
  errors.collect(cdk.propertyValidator("instanceInterruptionBehavior", cdk.validateString)(properties.instanceInterruptionBehavior));
  errors.collect(cdk.propertyValidator("instancePoolsToUseCount", cdk.validateNumber)(properties.instancePoolsToUseCount));
  errors.collect(cdk.propertyValidator("maintenanceStrategies", CfnEC2FleetMaintenanceStrategiesPropertyValidator)(properties.maintenanceStrategies));
  errors.collect(cdk.propertyValidator("maxTotalPrice", cdk.validateString)(properties.maxTotalPrice));
  errors.collect(cdk.propertyValidator("minTargetCapacity", cdk.validateNumber)(properties.minTargetCapacity));
  errors.collect(cdk.propertyValidator("singleAvailabilityZone", cdk.validateBoolean)(properties.singleAvailabilityZone));
  errors.collect(cdk.propertyValidator("singleInstanceType", cdk.validateBoolean)(properties.singleInstanceType));
  return errors.wrap("supplied properties not correct for \"SpotOptionsRequestProperty\"");
}

// @ts-ignore TS6133
function convertCfnEC2FleetSpotOptionsRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnEC2FleetSpotOptionsRequestPropertyValidator(properties).assertSuccess();
  return {
    "AllocationStrategy": cdk.stringToCloudFormation(properties.allocationStrategy),
    "InstanceInterruptionBehavior": cdk.stringToCloudFormation(properties.instanceInterruptionBehavior),
    "InstancePoolsToUseCount": cdk.numberToCloudFormation(properties.instancePoolsToUseCount),
    "MaintenanceStrategies": convertCfnEC2FleetMaintenanceStrategiesPropertyToCloudFormation(properties.maintenanceStrategies),
    "MaxTotalPrice": cdk.stringToCloudFormation(properties.maxTotalPrice),
    "MinTargetCapacity": cdk.numberToCloudFormation(properties.minTargetCapacity),
    "SingleAvailabilityZone": cdk.booleanToCloudFormation(properties.singleAvailabilityZone),
    "SingleInstanceType": cdk.booleanToCloudFormation(properties.singleInstanceType)
  };
}

// @ts-ignore TS6133
function CfnEC2FleetSpotOptionsRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnEC2Fleet.SpotOptionsRequestProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnEC2Fleet.SpotOptionsRequestProperty>();
  ret.addPropertyResult("allocationStrategy", "AllocationStrategy", (properties.AllocationStrategy != null ? cfn_parse.FromCloudFormation.getString(properties.AllocationStrategy) : undefined));
  ret.addPropertyResult("instanceInterruptionBehavior", "InstanceInterruptionBehavior", (properties.InstanceInterruptionBehavior != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceInterruptionBehavior) : undefined));
  ret.addPropertyResult("instancePoolsToUseCount", "InstancePoolsToUseCount", (properties.InstancePoolsToUseCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.InstancePoolsToUseCount) : undefined));
  ret.addPropertyResult("maintenanceStrategies", "MaintenanceStrategies", (properties.MaintenanceStrategies != null ? CfnEC2FleetMaintenanceStrategiesPropertyFromCloudFormation(properties.MaintenanceStrategies) : undefined));
  ret.addPropertyResult("maxTotalPrice", "MaxTotalPrice", (properties.MaxTotalPrice != null ? cfn_parse.FromCloudFormation.getString(properties.MaxTotalPrice) : undefined));
  ret.addPropertyResult("minTargetCapacity", "MinTargetCapacity", (properties.MinTargetCapacity != null ? cfn_parse.FromCloudFormation.getNumber(properties.MinTargetCapacity) : undefined));
  ret.addPropertyResult("singleAvailabilityZone", "SingleAvailabilityZone", (properties.SingleAvailabilityZone != null ? cfn_parse.FromCloudFormation.getBoolean(properties.SingleAvailabilityZone) : undefined));
  ret.addPropertyResult("singleInstanceType", "SingleInstanceType", (properties.SingleInstanceType != null ? cfn_parse.FromCloudFormation.getBoolean(properties.SingleInstanceType) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `FleetLaunchTemplateSpecificationRequestProperty`
 *
 * @param properties - the TypeScript properties of a `FleetLaunchTemplateSpecificationRequestProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnEC2FleetFleetLaunchTemplateSpecificationRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("launchTemplateId", cdk.validateString)(properties.launchTemplateId));
  errors.collect(cdk.propertyValidator("launchTemplateName", cdk.validateString)(properties.launchTemplateName));
  errors.collect(cdk.propertyValidator("version", cdk.requiredValidator)(properties.version));
  errors.collect(cdk.propertyValidator("version", cdk.validateString)(properties.version));
  return errors.wrap("supplied properties not correct for \"FleetLaunchTemplateSpecificationRequestProperty\"");
}

// @ts-ignore TS6133
function convertCfnEC2FleetFleetLaunchTemplateSpecificationRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnEC2FleetFleetLaunchTemplateSpecificationRequestPropertyValidator(properties).assertSuccess();
  return {
    "LaunchTemplateId": cdk.stringToCloudFormation(properties.launchTemplateId),
    "LaunchTemplateName": cdk.stringToCloudFormation(properties.launchTemplateName),
    "Version": cdk.stringToCloudFormation(properties.version)
  };
}

// @ts-ignore TS6133
function CfnEC2FleetFleetLaunchTemplateSpecificationRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnEC2Fleet.FleetLaunchTemplateSpecificationRequestProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnEC2Fleet.FleetLaunchTemplateSpecificationRequestProperty>();
  ret.addPropertyResult("launchTemplateId", "LaunchTemplateId", (properties.LaunchTemplateId != null ? cfn_parse.FromCloudFormation.getString(properties.LaunchTemplateId) : undefined));
  ret.addPropertyResult("launchTemplateName", "LaunchTemplateName", (properties.LaunchTemplateName != null ? cfn_parse.FromCloudFormation.getString(properties.LaunchTemplateName) : undefined));
  ret.addPropertyResult("version", "Version", (properties.Version != null ? cfn_parse.FromCloudFormation.getString(properties.Version) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `PlacementProperty`
 *
 * @param properties - the TypeScript properties of a `PlacementProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnEC2FleetPlacementPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("affinity", cdk.validateString)(properties.affinity));
  errors.collect(cdk.propertyValidator("availabilityZone", cdk.validateString)(properties.availabilityZone));
  errors.collect(cdk.propertyValidator("groupName", cdk.validateString)(properties.groupName));
  errors.collect(cdk.propertyValidator("hostId", cdk.validateString)(properties.hostId));
  errors.collect(cdk.propertyValidator("hostResourceGroupArn", cdk.validateString)(properties.hostResourceGroupArn));
  errors.collect(cdk.propertyValidator("partitionNumber", cdk.validateNumber)(properties.partitionNumber));
  errors.collect(cdk.propertyValidator("spreadDomain", cdk.validateString)(properties.spreadDomain));
  errors.collect(cdk.propertyValidator("tenancy", cdk.validateString)(properties.tenancy));
  return errors.wrap("supplied properties not correct for \"PlacementProperty\"");
}

// @ts-ignore TS6133
function convertCfnEC2FleetPlacementPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnEC2FleetPlacementPropertyValidator(properties).assertSuccess();
  return {
    "Affinity": cdk.stringToCloudFormation(properties.affinity),
    "AvailabilityZone": cdk.stringToCloudFormation(properties.availabilityZone),
    "GroupName": cdk.stringToCloudFormation(properties.groupName),
    "HostId": cdk.stringToCloudFormation(properties.hostId),
    "HostResourceGroupArn": cdk.stringToCloudFormation(properties.hostResourceGroupArn),
    "PartitionNumber": cdk.numberToCloudFormation(properties.partitionNumber),
    "SpreadDomain": cdk.stringToCloudFormation(properties.spreadDomain),
    "Tenancy": cdk.stringToCloudFormation(properties.tenancy)
  };
}

// @ts-ignore TS6133
function CfnEC2FleetPlacementPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnEC2Fleet.PlacementProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnEC2Fleet.PlacementProperty>();
  ret.addPropertyResult("affinity", "Affinity", (properties.Affinity != null ? cfn_parse.FromCloudFormation.getString(properties.Affinity) : undefined));
  ret.addPropertyResult("availabilityZone", "AvailabilityZone", (properties.AvailabilityZone != null ? cfn_parse.FromCloudFormation.getString(properties.AvailabilityZone) : undefined));
  ret.addPropertyResult("groupName", "GroupName", (properties.GroupName != null ? cfn_parse.FromCloudFormation.getString(properties.GroupName) : undefined));
  ret.addPropertyResult("hostId", "HostId", (properties.HostId != null ? cfn_parse.FromCloudFormation.getString(properties.HostId) : undefined));
  ret.addPropertyResult("hostResourceGroupArn", "HostResourceGroupArn", (properties.HostResourceGroupArn != null ? cfn_parse.FromCloudFormation.getString(properties.HostResourceGroupArn) : undefined));
  ret.addPropertyResult("partitionNumber", "PartitionNumber", (properties.PartitionNumber != null ? cfn_parse.FromCloudFormation.getNumber(properties.PartitionNumber) : undefined));
  ret.addPropertyResult("spreadDomain", "SpreadDomain", (properties.SpreadDomain != null ? cfn_parse.FromCloudFormation.getString(properties.SpreadDomain) : undefined));
  ret.addPropertyResult("tenancy", "Tenancy", (properties.Tenancy != null ? cfn_parse.FromCloudFormation.getString(properties.Tenancy) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `NetworkInterfaceCountRequestProperty`
 *
 * @param properties - the TypeScript properties of a `NetworkInterfaceCountRequestProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnEC2FleetNetworkInterfaceCountRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("max", cdk.validateNumber)(properties.max));
  errors.collect(cdk.propertyValidator("min", cdk.validateNumber)(properties.min));
  return errors.wrap("supplied properties not correct for \"NetworkInterfaceCountRequestProperty\"");
}

// @ts-ignore TS6133
function convertCfnEC2FleetNetworkInterfaceCountRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnEC2FleetNetworkInterfaceCountRequestPropertyValidator(properties).assertSuccess();
  return {
    "Max": cdk.numberToCloudFormation(properties.max),
    "Min": cdk.numberToCloudFormation(properties.min)
  };
}

// @ts-ignore TS6133
function CfnEC2FleetNetworkInterfaceCountRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnEC2Fleet.NetworkInterfaceCountRequestProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnEC2Fleet.NetworkInterfaceCountRequestProperty>();
  ret.addPropertyResult("max", "Max", (properties.Max != null ? cfn_parse.FromCloudFormation.getNumber(properties.Max) : undefined));
  ret.addPropertyResult("min", "Min", (properties.Min != null ? cfn_parse.FromCloudFormation.getNumber(properties.Min) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `MemoryGiBPerVCpuRequestProperty`
 *
 * @param properties - the TypeScript properties of a `MemoryGiBPerVCpuRequestProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnEC2FleetMemoryGiBPerVCpuRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("max", cdk.validateNumber)(properties.max));
  errors.collect(cdk.propertyValidator("min", cdk.validateNumber)(properties.min));
  return errors.wrap("supplied properties not correct for \"MemoryGiBPerVCpuRequestProperty\"");
}

// @ts-ignore TS6133
function convertCfnEC2FleetMemoryGiBPerVCpuRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnEC2FleetMemoryGiBPerVCpuRequestPropertyValidator(properties).assertSuccess();
  return {
    "Max": cdk.numberToCloudFormation(properties.max),
    "Min": cdk.numberToCloudFormation(properties.min)
  };
}

// @ts-ignore TS6133
function CfnEC2FleetMemoryGiBPerVCpuRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnEC2Fleet.MemoryGiBPerVCpuRequestProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnEC2Fleet.MemoryGiBPerVCpuRequestProperty>();
  ret.addPropertyResult("max", "Max", (properties.Max != null ? cfn_parse.FromCloudFormation.getNumber(properties.Max) : undefined));
  ret.addPropertyResult("min", "Min", (properties.Min != null ? cfn_parse.FromCloudFormation.getNumber(properties.Min) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `VCpuCountRangeRequestProperty`
 *
 * @param properties - the TypeScript properties of a `VCpuCountRangeRequestProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnEC2FleetVCpuCountRangeRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("max", cdk.validateNumber)(properties.max));
  errors.collect(cdk.propertyValidator("min", cdk.validateNumber)(properties.min));
  return errors.wrap("supplied properties not correct for \"VCpuCountRangeRequestProperty\"");
}

// @ts-ignore TS6133
function convertCfnEC2FleetVCpuCountRangeRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnEC2FleetVCpuCountRangeRequestPropertyValidator(properties).assertSuccess();
  return {
    "Max": cdk.numberToCloudFormation(properties.max),
    "Min": cdk.numberToCloudFormation(properties.min)
  };
}

// @ts-ignore TS6133
function CfnEC2FleetVCpuCountRangeRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnEC2Fleet.VCpuCountRangeRequestProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnEC2Fleet.VCpuCountRangeRequestProperty>();
  ret.addPropertyResult("max", "Max", (properties.Max != null ? cfn_parse.FromCloudFormation.getNumber(properties.Max) : undefined));
  ret.addPropertyResult("min", "Min", (properties.Min != null ? cfn_parse.FromCloudFormation.getNumber(properties.Min) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `NetworkBandwidthGbpsRequestProperty`
 *
 * @param properties - the TypeScript properties of a `NetworkBandwidthGbpsRequestProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnEC2FleetNetworkBandwidthGbpsRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("max", cdk.validateNumber)(properties.max));
  errors.collect(cdk.propertyValidator("min", cdk.validateNumber)(properties.min));
  return errors.wrap("supplied properties not correct for \"NetworkBandwidthGbpsRequestProperty\"");
}

// @ts-ignore TS6133
function convertCfnEC2FleetNetworkBandwidthGbpsRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnEC2FleetNetworkBandwidthGbpsRequestPropertyValidator(properties).assertSuccess();
  return {
    "Max": cdk.numberToCloudFormation(properties.max),
    "Min": cdk.numberToCloudFormation(properties.min)
  };
}

// @ts-ignore TS6133
function CfnEC2FleetNetworkBandwidthGbpsRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnEC2Fleet.NetworkBandwidthGbpsRequestProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnEC2Fleet.NetworkBandwidthGbpsRequestProperty>();
  ret.addPropertyResult("max", "Max", (properties.Max != null ? cfn_parse.FromCloudFormation.getNumber(properties.Max) : undefined));
  ret.addPropertyResult("min", "Min", (properties.Min != null ? cfn_parse.FromCloudFormation.getNumber(properties.Min) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `AcceleratorCountRequestProperty`
 *
 * @param properties - the TypeScript properties of a `AcceleratorCountRequestProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnEC2FleetAcceleratorCountRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("max", cdk.validateNumber)(properties.max));
  errors.collect(cdk.propertyValidator("min", cdk.validateNumber)(properties.min));
  return errors.wrap("supplied properties not correct for \"AcceleratorCountRequestProperty\"");
}

// @ts-ignore TS6133
function convertCfnEC2FleetAcceleratorCountRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnEC2FleetAcceleratorCountRequestPropertyValidator(properties).assertSuccess();
  return {
    "Max": cdk.numberToCloudFormation(properties.max),
    "Min": cdk.numberToCloudFormation(properties.min)
  };
}

// @ts-ignore TS6133
function CfnEC2FleetAcceleratorCountRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnEC2Fleet.AcceleratorCountRequestProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnEC2Fleet.AcceleratorCountRequestProperty>();
  ret.addPropertyResult("max", "Max", (properties.Max != null ? cfn_parse.FromCloudFormation.getNumber(properties.Max) : undefined));
  ret.addPropertyResult("min", "Min", (properties.Min != null ? cfn_parse.FromCloudFormation.getNumber(properties.Min) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `BaselineEbsBandwidthMbpsRequestProperty`
 *
 * @param properties - the TypeScript properties of a `BaselineEbsBandwidthMbpsRequestProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnEC2FleetBaselineEbsBandwidthMbpsRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("max", cdk.validateNumber)(properties.max));
  errors.collect(cdk.propertyValidator("min", cdk.validateNumber)(properties.min));
  return errors.wrap("supplied properties not correct for \"BaselineEbsBandwidthMbpsRequestProperty\"");
}

// @ts-ignore TS6133
function convertCfnEC2FleetBaselineEbsBandwidthMbpsRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnEC2FleetBaselineEbsBandwidthMbpsRequestPropertyValidator(properties).assertSuccess();
  return {
    "Max": cdk.numberToCloudFormation(properties.max),
    "Min": cdk.numberToCloudFormation(properties.min)
  };
}

// @ts-ignore TS6133
function CfnEC2FleetBaselineEbsBandwidthMbpsRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnEC2Fleet.BaselineEbsBandwidthMbpsRequestProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnEC2Fleet.BaselineEbsBandwidthMbpsRequestProperty>();
  ret.addPropertyResult("max", "Max", (properties.Max != null ? cfn_parse.FromCloudFormation.getNumber(properties.Max) : undefined));
  ret.addPropertyResult("min", "Min", (properties.Min != null ? cfn_parse.FromCloudFormation.getNumber(properties.Min) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `AcceleratorTotalMemoryMiBRequestProperty`
 *
 * @param properties - the TypeScript properties of a `AcceleratorTotalMemoryMiBRequestProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnEC2FleetAcceleratorTotalMemoryMiBRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("max", cdk.validateNumber)(properties.max));
  errors.collect(cdk.propertyValidator("min", cdk.validateNumber)(properties.min));
  return errors.wrap("supplied properties not correct for \"AcceleratorTotalMemoryMiBRequestProperty\"");
}

// @ts-ignore TS6133
function convertCfnEC2FleetAcceleratorTotalMemoryMiBRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnEC2FleetAcceleratorTotalMemoryMiBRequestPropertyValidator(properties).assertSuccess();
  return {
    "Max": cdk.numberToCloudFormation(properties.max),
    "Min": cdk.numberToCloudFormation(properties.min)
  };
}

// @ts-ignore TS6133
function CfnEC2FleetAcceleratorTotalMemoryMiBRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnEC2Fleet.AcceleratorTotalMemoryMiBRequestProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnEC2Fleet.AcceleratorTotalMemoryMiBRequestProperty>();
  ret.addPropertyResult("max", "Max", (properties.Max != null ? cfn_parse.FromCloudFormation.getNumber(properties.Max) : undefined));
  ret.addPropertyResult("min", "Min", (properties.Min != null ? cfn_parse.FromCloudFormation.getNumber(properties.Min) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `MemoryMiBRequestProperty`
 *
 * @param properties - the TypeScript properties of a `MemoryMiBRequestProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnEC2FleetMemoryMiBRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("max", cdk.validateNumber)(properties.max));
  errors.collect(cdk.propertyValidator("min", cdk.validateNumber)(properties.min));
  return errors.wrap("supplied properties not correct for \"MemoryMiBRequestProperty\"");
}

// @ts-ignore TS6133
function convertCfnEC2FleetMemoryMiBRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnEC2FleetMemoryMiBRequestPropertyValidator(properties).assertSuccess();
  return {
    "Max": cdk.numberToCloudFormation(properties.max),
    "Min": cdk.numberToCloudFormation(properties.min)
  };
}

// @ts-ignore TS6133
function CfnEC2FleetMemoryMiBRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnEC2Fleet.MemoryMiBRequestProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnEC2Fleet.MemoryMiBRequestProperty>();
  ret.addPropertyResult("max", "Max", (properties.Max != null ? cfn_parse.FromCloudFormation.getNumber(properties.Max) : undefined));
  ret.addPropertyResult("min", "Min", (properties.Min != null ? cfn_parse.FromCloudFormation.getNumber(properties.Min) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `TotalLocalStorageGBRequestProperty`
 *
 * @param properties - the TypeScript properties of a `TotalLocalStorageGBRequestProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnEC2FleetTotalLocalStorageGBRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("max", cdk.validateNumber)(properties.max));
  errors.collect(cdk.propertyValidator("min", cdk.validateNumber)(properties.min));
  return errors.wrap("supplied properties not correct for \"TotalLocalStorageGBRequestProperty\"");
}

// @ts-ignore TS6133
function convertCfnEC2FleetTotalLocalStorageGBRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnEC2FleetTotalLocalStorageGBRequestPropertyValidator(properties).assertSuccess();
  return {
    "Max": cdk.numberToCloudFormation(properties.max),
    "Min": cdk.numberToCloudFormation(properties.min)
  };
}

// @ts-ignore TS6133
function CfnEC2FleetTotalLocalStorageGBRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnEC2Fleet.TotalLocalStorageGBRequestProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnEC2Fleet.TotalLocalStorageGBRequestProperty>();
  ret.addPropertyResult("max", "Max", (properties.Max != null ? cfn_parse.FromCloudFormation.getNumber(properties.Max) : undefined));
  ret.addPropertyResult("min", "Min", (properties.Min != null ? cfn_parse.FromCloudFormation.getNumber(properties.Min) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `InstanceRequirementsRequestProperty`
 *
 * @param properties - the TypeScript properties of a `InstanceRequirementsRequestProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnEC2FleetInstanceRequirementsRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("acceleratorCount", CfnEC2FleetAcceleratorCountRequestPropertyValidator)(properties.acceleratorCount));
  errors.collect(cdk.propertyValidator("acceleratorManufacturers", cdk.listValidator(cdk.validateString))(properties.acceleratorManufacturers));
  errors.collect(cdk.propertyValidator("acceleratorNames", cdk.listValidator(cdk.validateString))(properties.acceleratorNames));
  errors.collect(cdk.propertyValidator("acceleratorTotalMemoryMiB", CfnEC2FleetAcceleratorTotalMemoryMiBRequestPropertyValidator)(properties.acceleratorTotalMemoryMiB));
  errors.collect(cdk.propertyValidator("acceleratorTypes", cdk.listValidator(cdk.validateString))(properties.acceleratorTypes));
  errors.collect(cdk.propertyValidator("allowedInstanceTypes", cdk.listValidator(cdk.validateString))(properties.allowedInstanceTypes));
  errors.collect(cdk.propertyValidator("bareMetal", cdk.validateString)(properties.bareMetal));
  errors.collect(cdk.propertyValidator("baselineEbsBandwidthMbps", CfnEC2FleetBaselineEbsBandwidthMbpsRequestPropertyValidator)(properties.baselineEbsBandwidthMbps));
  errors.collect(cdk.propertyValidator("burstablePerformance", cdk.validateString)(properties.burstablePerformance));
  errors.collect(cdk.propertyValidator("cpuManufacturers", cdk.listValidator(cdk.validateString))(properties.cpuManufacturers));
  errors.collect(cdk.propertyValidator("excludedInstanceTypes", cdk.listValidator(cdk.validateString))(properties.excludedInstanceTypes));
  errors.collect(cdk.propertyValidator("instanceGenerations", cdk.listValidator(cdk.validateString))(properties.instanceGenerations));
  errors.collect(cdk.propertyValidator("localStorage", cdk.validateString)(properties.localStorage));
  errors.collect(cdk.propertyValidator("localStorageTypes", cdk.listValidator(cdk.validateString))(properties.localStorageTypes));
  errors.collect(cdk.propertyValidator("memoryGiBPerVCpu", CfnEC2FleetMemoryGiBPerVCpuRequestPropertyValidator)(properties.memoryGiBPerVCpu));
  errors.collect(cdk.propertyValidator("memoryMiB", CfnEC2FleetMemoryMiBRequestPropertyValidator)(properties.memoryMiB));
  errors.collect(cdk.propertyValidator("networkBandwidthGbps", CfnEC2FleetNetworkBandwidthGbpsRequestPropertyValidator)(properties.networkBandwidthGbps));
  errors.collect(cdk.propertyValidator("networkInterfaceCount", CfnEC2FleetNetworkInterfaceCountRequestPropertyValidator)(properties.networkInterfaceCount));
  errors.collect(cdk.propertyValidator("onDemandMaxPricePercentageOverLowestPrice", cdk.validateNumber)(properties.onDemandMaxPricePercentageOverLowestPrice));
  errors.collect(cdk.propertyValidator("requireHibernateSupport", cdk.validateBoolean)(properties.requireHibernateSupport));
  errors.collect(cdk.propertyValidator("spotMaxPricePercentageOverLowestPrice", cdk.validateNumber)(properties.spotMaxPricePercentageOverLowestPrice));
  errors.collect(cdk.propertyValidator("totalLocalStorageGb", CfnEC2FleetTotalLocalStorageGBRequestPropertyValidator)(properties.totalLocalStorageGb));
  errors.collect(cdk.propertyValidator("vCpuCount", CfnEC2FleetVCpuCountRangeRequestPropertyValidator)(properties.vCpuCount));
  return errors.wrap("supplied properties not correct for \"InstanceRequirementsRequestProperty\"");
}

// @ts-ignore TS6133
function convertCfnEC2FleetInstanceRequirementsRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnEC2FleetInstanceRequirementsRequestPropertyValidator(properties).assertSuccess();
  return {
    "AcceleratorCount": convertCfnEC2FleetAcceleratorCountRequestPropertyToCloudFormation(properties.acceleratorCount),
    "AcceleratorManufacturers": cdk.listMapper(cdk.stringToCloudFormation)(properties.acceleratorManufacturers),
    "AcceleratorNames": cdk.listMapper(cdk.stringToCloudFormation)(properties.acceleratorNames),
    "AcceleratorTotalMemoryMiB": convertCfnEC2FleetAcceleratorTotalMemoryMiBRequestPropertyToCloudFormation(properties.acceleratorTotalMemoryMiB),
    "AcceleratorTypes": cdk.listMapper(cdk.stringToCloudFormation)(properties.acceleratorTypes),
    "AllowedInstanceTypes": cdk.listMapper(cdk.stringToCloudFormation)(properties.allowedInstanceTypes),
    "BareMetal": cdk.stringToCloudFormation(properties.bareMetal),
    "BaselineEbsBandwidthMbps": convertCfnEC2FleetBaselineEbsBandwidthMbpsRequestPropertyToCloudFormation(properties.baselineEbsBandwidthMbps),
    "BurstablePerformance": cdk.stringToCloudFormation(properties.burstablePerformance),
    "CpuManufacturers": cdk.listMapper(cdk.stringToCloudFormation)(properties.cpuManufacturers),
    "ExcludedInstanceTypes": cdk.listMapper(cdk.stringToCloudFormation)(properties.excludedInstanceTypes),
    "InstanceGenerations": cdk.listMapper(cdk.stringToCloudFormation)(properties.instanceGenerations),
    "LocalStorage": cdk.stringToCloudFormation(properties.localStorage),
    "LocalStorageTypes": cdk.listMapper(cdk.stringToCloudFormation)(properties.localStorageTypes),
    "MemoryGiBPerVCpu": convertCfnEC2FleetMemoryGiBPerVCpuRequestPropertyToCloudFormation(properties.memoryGiBPerVCpu),
    "MemoryMiB": convertCfnEC2FleetMemoryMiBRequestPropertyToCloudFormation(properties.memoryMiB),
    "NetworkBandwidthGbps": convertCfnEC2FleetNetworkBandwidthGbpsRequestPropertyToCloudFormation(properties.networkBandwidthGbps),
    "NetworkInterfaceCount": convertCfnEC2FleetNetworkInterfaceCountRequestPropertyToCloudFormation(properties.networkInterfaceCount),
    "OnDemandMaxPricePercentageOverLowestPrice": cdk.numberToCloudFormation(properties.onDemandMaxPricePercentageOverLowestPrice),
    "RequireHibernateSupport": cdk.booleanToCloudFormation(properties.requireHibernateSupport),
    "SpotMaxPricePercentageOverLowestPrice": cdk.numberToCloudFormation(properties.spotMaxPricePercentageOverLowestPrice),
    "TotalLocalStorageGB": convertCfnEC2FleetTotalLocalStorageGBRequestPropertyToCloudFormation(properties.totalLocalStorageGb),
    "VCpuCount": convertCfnEC2FleetVCpuCountRangeRequestPropertyToCloudFormation(properties.vCpuCount)
  };
}

// @ts-ignore TS6133
function CfnEC2FleetInstanceRequirementsRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnEC2Fleet.InstanceRequirementsRequestProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnEC2Fleet.InstanceRequirementsRequestProperty>();
  ret.addPropertyResult("acceleratorCount", "AcceleratorCount", (properties.AcceleratorCount != null ? CfnEC2FleetAcceleratorCountRequestPropertyFromCloudFormation(properties.AcceleratorCount) : undefined));
  ret.addPropertyResult("acceleratorManufacturers", "AcceleratorManufacturers", (properties.AcceleratorManufacturers != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.AcceleratorManufacturers) : undefined));
  ret.addPropertyResult("acceleratorNames", "AcceleratorNames", (properties.AcceleratorNames != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.AcceleratorNames) : undefined));
  ret.addPropertyResult("acceleratorTotalMemoryMiB", "AcceleratorTotalMemoryMiB", (properties.AcceleratorTotalMemoryMiB != null ? CfnEC2FleetAcceleratorTotalMemoryMiBRequestPropertyFromCloudFormation(properties.AcceleratorTotalMemoryMiB) : undefined));
  ret.addPropertyResult("acceleratorTypes", "AcceleratorTypes", (properties.AcceleratorTypes != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.AcceleratorTypes) : undefined));
  ret.addPropertyResult("allowedInstanceTypes", "AllowedInstanceTypes", (properties.AllowedInstanceTypes != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.AllowedInstanceTypes) : undefined));
  ret.addPropertyResult("bareMetal", "BareMetal", (properties.BareMetal != null ? cfn_parse.FromCloudFormation.getString(properties.BareMetal) : undefined));
  ret.addPropertyResult("baselineEbsBandwidthMbps", "BaselineEbsBandwidthMbps", (properties.BaselineEbsBandwidthMbps != null ? CfnEC2FleetBaselineEbsBandwidthMbpsRequestPropertyFromCloudFormation(properties.BaselineEbsBandwidthMbps) : undefined));
  ret.addPropertyResult("burstablePerformance", "BurstablePerformance", (properties.BurstablePerformance != null ? cfn_parse.FromCloudFormation.getString(properties.BurstablePerformance) : undefined));
  ret.addPropertyResult("cpuManufacturers", "CpuManufacturers", (properties.CpuManufacturers != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.CpuManufacturers) : undefined));
  ret.addPropertyResult("excludedInstanceTypes", "ExcludedInstanceTypes", (properties.ExcludedInstanceTypes != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.ExcludedInstanceTypes) : undefined));
  ret.addPropertyResult("instanceGenerations", "InstanceGenerations", (properties.InstanceGenerations != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.InstanceGenerations) : undefined));
  ret.addPropertyResult("localStorage", "LocalStorage", (properties.LocalStorage != null ? cfn_parse.FromCloudFormation.getString(properties.LocalStorage) : undefined));
  ret.addPropertyResult("localStorageTypes", "LocalStorageTypes", (properties.LocalStorageTypes != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.LocalStorageTypes) : undefined));
  ret.addPropertyResult("memoryGiBPerVCpu", "MemoryGiBPerVCpu", (properties.MemoryGiBPerVCpu != null ? CfnEC2FleetMemoryGiBPerVCpuRequestPropertyFromCloudFormation(properties.MemoryGiBPerVCpu) : undefined));
  ret.addPropertyResult("memoryMiB", "MemoryMiB", (properties.MemoryMiB != null ? CfnEC2FleetMemoryMiBRequestPropertyFromCloudFormation(properties.MemoryMiB) : undefined));
  ret.addPropertyResult("networkBandwidthGbps", "NetworkBandwidthGbps", (properties.NetworkBandwidthGbps != null ? CfnEC2FleetNetworkBandwidthGbpsRequestPropertyFromCloudFormation(properties.NetworkBandwidthGbps) : undefined));
  ret.addPropertyResult("networkInterfaceCount", "NetworkInterfaceCount", (properties.NetworkInterfaceCount != null ? CfnEC2FleetNetworkInterfaceCountRequestPropertyFromCloudFormation(properties.NetworkInterfaceCount) : undefined));
  ret.addPropertyResult("onDemandMaxPricePercentageOverLowestPrice", "OnDemandMaxPricePercentageOverLowestPrice", (properties.OnDemandMaxPricePercentageOverLowestPrice != null ? cfn_parse.FromCloudFormation.getNumber(properties.OnDemandMaxPricePercentageOverLowestPrice) : undefined));
  ret.addPropertyResult("requireHibernateSupport", "RequireHibernateSupport", (properties.RequireHibernateSupport != null ? cfn_parse.FromCloudFormation.getBoolean(properties.RequireHibernateSupport) : undefined));
  ret.addPropertyResult("spotMaxPricePercentageOverLowestPrice", "SpotMaxPricePercentageOverLowestPrice", (properties.SpotMaxPricePercentageOverLowestPrice != null ? cfn_parse.FromCloudFormation.getNumber(properties.SpotMaxPricePercentageOverLowestPrice) : undefined));
  ret.addPropertyResult("totalLocalStorageGb", "TotalLocalStorageGB", (properties.TotalLocalStorageGB != null ? CfnEC2FleetTotalLocalStorageGBRequestPropertyFromCloudFormation(properties.TotalLocalStorageGB) : undefined));
  ret.addPropertyResult("vCpuCount", "VCpuCount", (properties.VCpuCount != null ? CfnEC2FleetVCpuCountRangeRequestPropertyFromCloudFormation(properties.VCpuCount) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `FleetLaunchTemplateOverridesRequestProperty`
 *
 * @param properties - the TypeScript properties of a `FleetLaunchTemplateOverridesRequestProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnEC2FleetFleetLaunchTemplateOverridesRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("availabilityZone", cdk.validateString)(properties.availabilityZone));
  errors.collect(cdk.propertyValidator("instanceRequirements", CfnEC2FleetInstanceRequirementsRequestPropertyValidator)(properties.instanceRequirements));
  errors.collect(cdk.propertyValidator("instanceType", cdk.validateString)(properties.instanceType));
  errors.collect(cdk.propertyValidator("maxPrice", cdk.validateString)(properties.maxPrice));
  errors.collect(cdk.propertyValidator("placement", CfnEC2FleetPlacementPropertyValidator)(properties.placement));
  errors.collect(cdk.propertyValidator("priority", cdk.validateNumber)(properties.priority));
  errors.collect(cdk.propertyValidator("subnetId", cdk.validateString)(properties.subnetId));
  errors.collect(cdk.propertyValidator("weightedCapacity", cdk.validateNumber)(properties.weightedCapacity));
  return errors.wrap("supplied properties not correct for \"FleetLaunchTemplateOverridesRequestProperty\"");
}

// @ts-ignore TS6133
function convertCfnEC2FleetFleetLaunchTemplateOverridesRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnEC2FleetFleetLaunchTemplateOverridesRequestPropertyValidator(properties).assertSuccess();
  return {
    "AvailabilityZone": cdk.stringToCloudFormation(properties.availabilityZone),
    "InstanceRequirements": convertCfnEC2FleetInstanceRequirementsRequestPropertyToCloudFormation(properties.instanceRequirements),
    "InstanceType": cdk.stringToCloudFormation(properties.instanceType),
    "MaxPrice": cdk.stringToCloudFormation(properties.maxPrice),
    "Placement": convertCfnEC2FleetPlacementPropertyToCloudFormation(properties.placement),
    "Priority": cdk.numberToCloudFormation(properties.priority),
    "SubnetId": cdk.stringToCloudFormation(properties.subnetId),
    "WeightedCapacity": cdk.numberToCloudFormation(properties.weightedCapacity)
  };
}

// @ts-ignore TS6133
function CfnEC2FleetFleetLaunchTemplateOverridesRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnEC2Fleet.FleetLaunchTemplateOverridesRequestProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnEC2Fleet.FleetLaunchTemplateOverridesRequestProperty>();
  ret.addPropertyResult("availabilityZone", "AvailabilityZone", (properties.AvailabilityZone != null ? cfn_parse.FromCloudFormation.getString(properties.AvailabilityZone) : undefined));
  ret.addPropertyResult("instanceRequirements", "InstanceRequirements", (properties.InstanceRequirements != null ? CfnEC2FleetInstanceRequirementsRequestPropertyFromCloudFormation(properties.InstanceRequirements) : undefined));
  ret.addPropertyResult("instanceType", "InstanceType", (properties.InstanceType != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceType) : undefined));
  ret.addPropertyResult("maxPrice", "MaxPrice", (properties.MaxPrice != null ? cfn_parse.FromCloudFormation.getString(properties.MaxPrice) : undefined));
  ret.addPropertyResult("placement", "Placement", (properties.Placement != null ? CfnEC2FleetPlacementPropertyFromCloudFormation(properties.Placement) : undefined));
  ret.addPropertyResult("priority", "Priority", (properties.Priority != null ? cfn_parse.FromCloudFormation.getNumber(properties.Priority) : undefined));
  ret.addPropertyResult("subnetId", "SubnetId", (properties.SubnetId != null ? cfn_parse.FromCloudFormation.getString(properties.SubnetId) : undefined));
  ret.addPropertyResult("weightedCapacity", "WeightedCapacity", (properties.WeightedCapacity != null ? cfn_parse.FromCloudFormation.getNumber(properties.WeightedCapacity) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `FleetLaunchTemplateConfigRequestProperty`
 *
 * @param properties - the TypeScript properties of a `FleetLaunchTemplateConfigRequestProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnEC2FleetFleetLaunchTemplateConfigRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("launchTemplateSpecification", CfnEC2FleetFleetLaunchTemplateSpecificationRequestPropertyValidator)(properties.launchTemplateSpecification));
  errors.collect(cdk.propertyValidator("overrides", cdk.listValidator(CfnEC2FleetFleetLaunchTemplateOverridesRequestPropertyValidator))(properties.overrides));
  return errors.wrap("supplied properties not correct for \"FleetLaunchTemplateConfigRequestProperty\"");
}

// @ts-ignore TS6133
function convertCfnEC2FleetFleetLaunchTemplateConfigRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnEC2FleetFleetLaunchTemplateConfigRequestPropertyValidator(properties).assertSuccess();
  return {
    "LaunchTemplateSpecification": convertCfnEC2FleetFleetLaunchTemplateSpecificationRequestPropertyToCloudFormation(properties.launchTemplateSpecification),
    "Overrides": cdk.listMapper(convertCfnEC2FleetFleetLaunchTemplateOverridesRequestPropertyToCloudFormation)(properties.overrides)
  };
}

// @ts-ignore TS6133
function CfnEC2FleetFleetLaunchTemplateConfigRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnEC2Fleet.FleetLaunchTemplateConfigRequestProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnEC2Fleet.FleetLaunchTemplateConfigRequestProperty>();
  ret.addPropertyResult("launchTemplateSpecification", "LaunchTemplateSpecification", (properties.LaunchTemplateSpecification != null ? CfnEC2FleetFleetLaunchTemplateSpecificationRequestPropertyFromCloudFormation(properties.LaunchTemplateSpecification) : undefined));
  ret.addPropertyResult("overrides", "Overrides", (properties.Overrides != null ? cfn_parse.FromCloudFormation.getArray(CfnEC2FleetFleetLaunchTemplateOverridesRequestPropertyFromCloudFormation)(properties.Overrides) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `CfnEC2FleetProps`
 *
 * @param properties - the TypeScript properties of a `CfnEC2FleetProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnEC2FleetPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("context", cdk.validateString)(properties.context));
  errors.collect(cdk.propertyValidator("excessCapacityTerminationPolicy", cdk.validateString)(properties.excessCapacityTerminationPolicy));
  errors.collect(cdk.propertyValidator("launchTemplateConfigs", cdk.requiredValidator)(properties.launchTemplateConfigs));
  errors.collect(cdk.propertyValidator("launchTemplateConfigs", cdk.listValidator(CfnEC2FleetFleetLaunchTemplateConfigRequestPropertyValidator))(properties.launchTemplateConfigs));
  errors.collect(cdk.propertyValidator("onDemandOptions", CfnEC2FleetOnDemandOptionsRequestPropertyValidator)(properties.onDemandOptions));
  errors.collect(cdk.propertyValidator("replaceUnhealthyInstances", cdk.validateBoolean)(properties.replaceUnhealthyInstances));
  errors.collect(cdk.propertyValidator("spotOptions", CfnEC2FleetSpotOptionsRequestPropertyValidator)(properties.spotOptions));
  errors.collect(cdk.propertyValidator("tagSpecifications", cdk.listValidator(CfnEC2FleetTagSpecificationPropertyValidator))(properties.tagSpecifications));
  errors.collect(cdk.propertyValidator("targetCapacitySpecification", cdk.requiredValidator)(properties.targetCapacitySpecification));
  errors.collect(cdk.propertyValidator("targetCapacitySpecification", CfnEC2FleetTargetCapacitySpecificationRequestPropertyValidator)(properties.targetCapacitySpecification));
  errors.collect(cdk.propertyValidator("terminateInstancesWithExpiration", cdk.validateBoolean)(properties.terminateInstancesWithExpiration));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  errors.collect(cdk.propertyValidator("validFrom", cdk.validateString)(properties.validFrom));
  errors.collect(cdk.propertyValidator("validUntil", cdk.validateString)(properties.validUntil));
  return errors.wrap("supplied properties not correct for \"CfnEC2FleetProps\"");
}

// @ts-ignore TS6133
function convertCfnEC2FleetPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnEC2FleetPropsValidator(properties).assertSuccess();
  return {
    "Context": cdk.stringToCloudFormation(properties.context),
    "ExcessCapacityTerminationPolicy": cdk.stringToCloudFormation(properties.excessCapacityTerminationPolicy),
    "LaunchTemplateConfigs": cdk.listMapper(convertCfnEC2FleetFleetLaunchTemplateConfigRequestPropertyToCloudFormation)(properties.launchTemplateConfigs),
    "OnDemandOptions": convertCfnEC2FleetOnDemandOptionsRequestPropertyToCloudFormation(properties.onDemandOptions),
    "ReplaceUnhealthyInstances": cdk.booleanToCloudFormation(properties.replaceUnhealthyInstances),
    "SpotOptions": convertCfnEC2FleetSpotOptionsRequestPropertyToCloudFormation(properties.spotOptions),
    "TagSpecifications": cdk.listMapper(convertCfnEC2FleetTagSpecificationPropertyToCloudFormation)(properties.tagSpecifications),
    "TargetCapacitySpecification": convertCfnEC2FleetTargetCapacitySpecificationRequestPropertyToCloudFormation(properties.targetCapacitySpecification),
    "TerminateInstancesWithExpiration": cdk.booleanToCloudFormation(properties.terminateInstancesWithExpiration),
    "Type": cdk.stringToCloudFormation(properties.type),
    "ValidFrom": cdk.stringToCloudFormation(properties.validFrom),
    "ValidUntil": cdk.stringToCloudFormation(properties.validUntil)
  };
}

// @ts-ignore TS6133
function CfnEC2FleetPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnEC2FleetProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnEC2FleetProps>();
  ret.addPropertyResult("context", "Context", (properties.Context != null ? cfn_parse.FromCloudFormation.getString(properties.Context) : undefined));
  ret.addPropertyResult("excessCapacityTerminationPolicy", "ExcessCapacityTerminationPolicy", (properties.ExcessCapacityTerminationPolicy != null ? cfn_parse.FromCloudFormation.getString(properties.ExcessCapacityTerminationPolicy) : undefined));
  ret.addPropertyResult("launchTemplateConfigs", "LaunchTemplateConfigs", (properties.LaunchTemplateConfigs != null ? cfn_parse.FromCloudFormation.getArray(CfnEC2FleetFleetLaunchTemplateConfigRequestPropertyFromCloudFormation)(properties.LaunchTemplateConfigs) : undefined));
  ret.addPropertyResult("onDemandOptions", "OnDemandOptions", (properties.OnDemandOptions != null ? CfnEC2FleetOnDemandOptionsRequestPropertyFromCloudFormation(properties.OnDemandOptions) : undefined));
  ret.addPropertyResult("replaceUnhealthyInstances", "ReplaceUnhealthyInstances", (properties.ReplaceUnhealthyInstances != null ? cfn_parse.FromCloudFormation.getBoolean(properties.ReplaceUnhealthyInstances) : undefined));
  ret.addPropertyResult("spotOptions", "SpotOptions", (properties.SpotOptions != null ? CfnEC2FleetSpotOptionsRequestPropertyFromCloudFormation(properties.SpotOptions) : undefined));
  ret.addPropertyResult("tagSpecifications", "TagSpecifications", (properties.TagSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnEC2FleetTagSpecificationPropertyFromCloudFormation)(properties.TagSpecifications) : undefined));
  ret.addPropertyResult("targetCapacitySpecification", "TargetCapacitySpecification", (properties.TargetCapacitySpecification != null ? CfnEC2FleetTargetCapacitySpecificationRequestPropertyFromCloudFormation(properties.TargetCapacitySpecification) : undefined));
  ret.addPropertyResult("terminateInstancesWithExpiration", "TerminateInstancesWithExpiration", (properties.TerminateInstancesWithExpiration != null ? cfn_parse.FromCloudFormation.getBoolean(properties.TerminateInstancesWithExpiration) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addPropertyResult("validFrom", "ValidFrom", (properties.ValidFrom != null ? cfn_parse.FromCloudFormation.getString(properties.ValidFrom) : undefined));
  ret.addPropertyResult("validUntil", "ValidUntil", (properties.ValidUntil != null ? cfn_parse.FromCloudFormation.getString(properties.ValidUntil) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies an Elastic IP (EIP) address and can, optionally, associate it with an Amazon EC2 instance.
 *
 * You can allocate an Elastic IP address from an address pool owned by AWS or from an address pool created from a public IPv4 address range that you have brought to AWS for use with your AWS resources using bring your own IP addresses (BYOIP). For more information, see [Bring Your Own IP Addresses (BYOIP)](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-byoip.html) in the *Amazon EC2 User Guide* .
 *
 * For more information, see [Elastic IP Addresses](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/elastic-ip-addresses-eip.html) in the *Amazon EC2 User Guide* .
 *
 * @cloudformationResource AWS::EC2::EIP
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eip.html
 */
export class CfnEIP extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::EIP";

  /**
   * Build a CfnEIP from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnEIP {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnEIPPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnEIP(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID that AWS assigns to represent the allocation of the address for use with Amazon VPC. This is returned only for VPC elastic IP addresses. For example, `eipalloc-5723d13e` .
   *
   * @cloudformationAttribute AllocationId
   */
  public readonly attrAllocationId: string;

  /**
   * The Elastic IP address.
   *
   * @cloudformationAttribute PublicIp
   */
  public readonly attrPublicIp: string;

  /**
   * The network ( `vpc` ).
   */
  public domain?: string;

  /**
   * The ID of the instance.
   */
  public instanceId?: string;

  /**
   * A unique set of Availability Zones, Local Zones, or Wavelength Zones from which AWS advertises IP addresses.
   */
  public networkBorderGroup?: string;

  /**
   * The ID of an address pool that you own.
   */
  public publicIpv4Pool?: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * Any tags assigned to the Elastic IP address.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The Elastic IP address you are accepting for transfer.
   */
  public transferAddress?: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnEIPProps = {}) {
    super(scope, id, {
      "type": CfnEIP.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.attrAllocationId = cdk.Token.asString(this.getAtt("AllocationId", cdk.ResolutionTypeHint.STRING));
    this.attrPublicIp = cdk.Token.asString(this.getAtt("PublicIp", cdk.ResolutionTypeHint.STRING));
    this.domain = props.domain;
    this.instanceId = props.instanceId;
    this.networkBorderGroup = props.networkBorderGroup;
    this.publicIpv4Pool = props.publicIpv4Pool;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::EIP", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.transferAddress = props.transferAddress;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "domain": this.domain,
      "instanceId": this.instanceId,
      "networkBorderGroup": this.networkBorderGroup,
      "publicIpv4Pool": this.publicIpv4Pool,
      "tags": this.tags.renderTags(),
      "transferAddress": this.transferAddress
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnEIP.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnEIPPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a `CfnEIP`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eip.html
 */
export interface CfnEIPProps {
  /**
   * The network ( `vpc` ).
   *
   * If you define an Elastic IP address and associate it with a VPC that is defined in the same template, you must declare a dependency on the VPC-gateway attachment by using the [DependsOn Attribute](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-dependson.html) on this resource.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eip.html#cfn-ec2-eip-domain
   */
  readonly domain?: string;

  /**
   * The ID of the instance.
   *
   * > Updates to the `InstanceId` property may require *some interruptions* . Updates on an EIP reassociates the address on its associated resource.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eip.html#cfn-ec2-eip-instanceid
   */
  readonly instanceId?: string;

  /**
   * A unique set of Availability Zones, Local Zones, or Wavelength Zones from which AWS advertises IP addresses.
   *
   * Use this parameter to limit the IP address to this location. IP addresses cannot move between network border groups.
   *
   * Use [DescribeAvailabilityZones](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeAvailabilityZones.html) to view the network border groups.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eip.html#cfn-ec2-eip-networkbordergroup
   */
  readonly networkBorderGroup?: string;

  /**
   * The ID of an address pool that you own.
   *
   * Use this parameter to let Amazon EC2 select an address from the address pool.
   *
   * > Updates to the `PublicIpv4Pool` property may require *some interruptions* . Updates on an EIP reassociates the address on its associated resource.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eip.html#cfn-ec2-eip-publicipv4pool
   */
  readonly publicIpv4Pool?: string;

  /**
   * Any tags assigned to the Elastic IP address.
   *
   * > Updates to the `Tags` property may require *some interruptions* . Updates on an EIP reassociates the address on its associated resource.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eip.html#cfn-ec2-eip-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The Elastic IP address you are accepting for transfer.
   *
   * You can only accept one transferred address. For more information on Elastic IP address transfers, see [Transfer Elastic IP addresses](https://docs.aws.amazon.com/vpc/latest/userguide/vpc-eips.html#transfer-EIPs-intro) in the *Amazon Virtual Private Cloud User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eip.html#cfn-ec2-eip-transferaddress
   */
  readonly transferAddress?: string;
}

/**
 * Determine whether the given properties match those of a `CfnEIPProps`
 *
 * @param properties - the TypeScript properties of a `CfnEIPProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnEIPPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("domain", cdk.validateString)(properties.domain));
  errors.collect(cdk.propertyValidator("instanceId", cdk.validateString)(properties.instanceId));
  errors.collect(cdk.propertyValidator("networkBorderGroup", cdk.validateString)(properties.networkBorderGroup));
  errors.collect(cdk.propertyValidator("publicIpv4Pool", cdk.validateString)(properties.publicIpv4Pool));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("transferAddress", cdk.validateString)(properties.transferAddress));
  return errors.wrap("supplied properties not correct for \"CfnEIPProps\"");
}

// @ts-ignore TS6133
function convertCfnEIPPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnEIPPropsValidator(properties).assertSuccess();
  return {
    "Domain": cdk.stringToCloudFormation(properties.domain),
    "InstanceId": cdk.stringToCloudFormation(properties.instanceId),
    "NetworkBorderGroup": cdk.stringToCloudFormation(properties.networkBorderGroup),
    "PublicIpv4Pool": cdk.stringToCloudFormation(properties.publicIpv4Pool),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "TransferAddress": cdk.stringToCloudFormation(properties.transferAddress)
  };
}

// @ts-ignore TS6133
function CfnEIPPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnEIPProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnEIPProps>();
  ret.addPropertyResult("domain", "Domain", (properties.Domain != null ? cfn_parse.FromCloudFormation.getString(properties.Domain) : undefined));
  ret.addPropertyResult("instanceId", "InstanceId", (properties.InstanceId != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceId) : undefined));
  ret.addPropertyResult("networkBorderGroup", "NetworkBorderGroup", (properties.NetworkBorderGroup != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkBorderGroup) : undefined));
  ret.addPropertyResult("publicIpv4Pool", "PublicIpv4Pool", (properties.PublicIpv4Pool != null ? cfn_parse.FromCloudFormation.getString(properties.PublicIpv4Pool) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("transferAddress", "TransferAddress", (properties.TransferAddress != null ? cfn_parse.FromCloudFormation.getString(properties.TransferAddress) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Associates an Elastic IP address with an instance or a network interface.
 *
 * Before you can use an Elastic IP address, you must allocate it to your account. For more information about working with Elastic IP addresses, see [Elastic IP address concepts and rules](https://docs.aws.amazon.com/vpc/latest/userguide/vpc-eips.html#vpc-eip-overview) .
 *
 * You must specify `AllocationId` and either `InstanceId` , `NetworkInterfaceId` , or `PrivateIpAddress` .
 *
 * @cloudformationResource AWS::EC2::EIPAssociation
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eipassociation.html
 */
export class CfnEIPAssociation extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::EIPAssociation";

  /**
   * Build a CfnEIPAssociation from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnEIPAssociation {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnEIPAssociationPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnEIPAssociation(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the association.
   *
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The allocation ID.
   */
  public allocationId?: string;

  /**
   * The Elastic IP address to associate with the instance.
   *
   * @deprecated this property has been deprecated
   */
  public eip?: string;

  /**
   * The ID of the instance.
   */
  public instanceId?: string;

  /**
   * The ID of the network interface.
   */
  public networkInterfaceId?: string;

  /**
   * The primary or secondary private IP address to associate with the Elastic IP address.
   */
  public privateIpAddress?: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnEIPAssociationProps = {}) {
    super(scope, id, {
      "type": CfnEIPAssociation.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.allocationId = props.allocationId;
    this.eip = props.eip;
    this.instanceId = props.instanceId;
    this.networkInterfaceId = props.networkInterfaceId;
    this.privateIpAddress = props.privateIpAddress;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "allocationId": this.allocationId,
      "eip": this.eip,
      "instanceId": this.instanceId,
      "networkInterfaceId": this.networkInterfaceId,
      "privateIpAddress": this.privateIpAddress
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnEIPAssociation.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnEIPAssociationPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a `CfnEIPAssociation`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eipassociation.html
 */
export interface CfnEIPAssociationProps {
  /**
   * The allocation ID.
   *
   * This is required.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eipassociation.html#cfn-ec2-eipassociation-allocationid
   */
  readonly allocationId?: string;

  /**
   * The Elastic IP address to associate with the instance.
   *
   * @deprecated this property has been deprecated
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eipassociation.html#cfn-ec2-eipassociation-eip
   */
  readonly eip?: string;

  /**
   * The ID of the instance.
   *
   * The instance must have exactly one attached network interface. You can specify either the instance ID or the network interface ID, but not both.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eipassociation.html#cfn-ec2-eipassociation-instanceid
   */
  readonly instanceId?: string;

  /**
   * The ID of the network interface.
   *
   * If the instance has more than one network interface, you must specify a network interface ID.
   *
   * You can specify either the instance ID or the network interface ID, but not both.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eipassociation.html#cfn-ec2-eipassociation-networkinterfaceid
   */
  readonly networkInterfaceId?: string;

  /**
   * The primary or secondary private IP address to associate with the Elastic IP address.
   *
   * If no private IP address is specified, the Elastic IP address is associated with the primary private IP address.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eipassociation.html#cfn-ec2-eipassociation-privateipaddress
   */
  readonly privateIpAddress?: string;
}

/**
 * Determine whether the given properties match those of a `CfnEIPAssociationProps`
 *
 * @param properties - the TypeScript properties of a `CfnEIPAssociationProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnEIPAssociationPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("allocationId", cdk.validateString)(properties.allocationId));
  errors.collect(cdk.propertyValidator("eip", cdk.validateString)(properties.eip));
  errors.collect(cdk.propertyValidator("instanceId", cdk.validateString)(properties.instanceId));
  errors.collect(cdk.propertyValidator("networkInterfaceId", cdk.validateString)(properties.networkInterfaceId));
  errors.collect(cdk.propertyValidator("privateIpAddress", cdk.validateString)(properties.privateIpAddress));
  return errors.wrap("supplied properties not correct for \"CfnEIPAssociationProps\"");
}

// @ts-ignore TS6133
function convertCfnEIPAssociationPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnEIPAssociationPropsValidator(properties).assertSuccess();
  return {
    "AllocationId": cdk.stringToCloudFormation(properties.allocationId),
    "EIP": cdk.stringToCloudFormation(properties.eip),
    "InstanceId": cdk.stringToCloudFormation(properties.instanceId),
    "NetworkInterfaceId": cdk.stringToCloudFormation(properties.networkInterfaceId),
    "PrivateIpAddress": cdk.stringToCloudFormation(properties.privateIpAddress)
  };
}

// @ts-ignore TS6133
function CfnEIPAssociationPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnEIPAssociationProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnEIPAssociationProps>();
  ret.addPropertyResult("allocationId", "AllocationId", (properties.AllocationId != null ? cfn_parse.FromCloudFormation.getString(properties.AllocationId) : undefined));
  ret.addPropertyResult("eip", "EIP", (properties.EIP != null ? cfn_parse.FromCloudFormation.getString(properties.EIP) : undefined));
  ret.addPropertyResult("instanceId", "InstanceId", (properties.InstanceId != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceId) : undefined));
  ret.addPropertyResult("networkInterfaceId", "NetworkInterfaceId", (properties.NetworkInterfaceId != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkInterfaceId) : undefined));
  ret.addPropertyResult("privateIpAddress", "PrivateIpAddress", (properties.PrivateIpAddress != null ? cfn_parse.FromCloudFormation.getString(properties.PrivateIpAddress) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * [IPv6 only] Specifies an egress-only internet gateway for your VPC.
 *
 * An egress-only internet gateway is used to enable outbound communication over IPv6 from instances in your VPC to the internet, and prevents hosts outside of your VPC from initiating an IPv6 connection with your instance.
 *
 * For more information, see [Egress-only internet gateway](https://docs.aws.amazon.com/vpc/latest/userguide/egress-only-internet-gateway.html) in the *Amazon VPC User Guide* .
 *
 * @cloudformationResource AWS::EC2::EgressOnlyInternetGateway
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-egressonlyinternetgateway.html
 */
export class CfnEgressOnlyInternetGateway extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::EgressOnlyInternetGateway";

  /**
   * Build a CfnEgressOnlyInternetGateway from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnEgressOnlyInternetGateway {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnEgressOnlyInternetGatewayPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnEgressOnlyInternetGateway(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the egress-only internet gateway.
   *
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The ID of the VPC for which to create the egress-only internet gateway.
   */
  public vpcId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnEgressOnlyInternetGatewayProps) {
    super(scope, id, {
      "type": CfnEgressOnlyInternetGateway.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "vpcId", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.vpcId = props.vpcId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "vpcId": this.vpcId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnEgressOnlyInternetGateway.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnEgressOnlyInternetGatewayPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a `CfnEgressOnlyInternetGateway`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-egressonlyinternetgateway.html
 */
export interface CfnEgressOnlyInternetGatewayProps {
  /**
   * The ID of the VPC for which to create the egress-only internet gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-egressonlyinternetgateway.html#cfn-ec2-egressonlyinternetgateway-vpcid
   */
  readonly vpcId: string;
}

/**
 * Determine whether the given properties match those of a `CfnEgressOnlyInternetGatewayProps`
 *
 * @param properties - the TypeScript properties of a `CfnEgressOnlyInternetGatewayProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnEgressOnlyInternetGatewayPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("vpcId", cdk.requiredValidator)(properties.vpcId));
  errors.collect(cdk.propertyValidator("vpcId", cdk.validateString)(properties.vpcId));
  return errors.wrap("supplied properties not correct for \"CfnEgressOnlyInternetGatewayProps\"");
}

// @ts-ignore TS6133
function convertCfnEgressOnlyInternetGatewayPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnEgressOnlyInternetGatewayPropsValidator(properties).assertSuccess();
  return {
    "VpcId": cdk.stringToCloudFormation(properties.vpcId)
  };
}

// @ts-ignore TS6133
function CfnEgressOnlyInternetGatewayPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnEgressOnlyInternetGatewayProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnEgressOnlyInternetGatewayProps>();
  ret.addPropertyResult("vpcId", "VpcId", (properties.VpcId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Associates an AWS Identity and Access Management (IAM) role with an AWS Certificate Manager (ACM) certificate.
 *
 * This enables the certificate to be used by the ACM for Nitro Enclaves application inside an enclave. For more information, see [AWS Certificate Manager for Nitro Enclaves](https://docs.aws.amazon.com/enclaves/latest/user/nitro-enclave-refapp.html) in the *AWS Nitro Enclaves User Guide* .
 *
 * When the IAM role is associated with the ACM certificate, the certificate, certificate chain, and encrypted private key are placed in an Amazon S3 location that only the associated IAM role can access. The private key of the certificate is encrypted with an AWS managed key that has an attached attestation-based key policy.
 *
 * To enable the IAM role to access the Amazon S3 object, you must grant it permission to call `s3:GetObject` on the Amazon S3 bucket returned by the command. To enable the IAM role to access the KMS key, you must grant it permission to call `kms:Decrypt` on the KMS key returned by the command. For more information, see [Grant the role permission to access the certificate and encryption key](https://docs.aws.amazon.com/enclaves/latest/user/nitro-enclave-refapp.html#add-policy) in the *AWS Nitro Enclaves User Guide* .
 *
 * @cloudformationResource AWS::EC2::EnclaveCertificateIamRoleAssociation
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-enclavecertificateiamroleassociation.html
 */
export class CfnEnclaveCertificateIamRoleAssociation extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::EnclaveCertificateIamRoleAssociation";

  /**
   * Build a CfnEnclaveCertificateIamRoleAssociation from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnEnclaveCertificateIamRoleAssociation {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnEnclaveCertificateIamRoleAssociationPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnEnclaveCertificateIamRoleAssociation(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The name of the Amazon S3 bucket to which the certificate was uploaded.
   *
   * @cloudformationAttribute CertificateS3BucketName
   */
  public readonly attrCertificateS3BucketName: string;

  /**
   * The Amazon S3 object key where the certificate, certificate chain, and encrypted private key bundle are stored. The object key is formatted as follows: `role_arn` / `certificate_arn` .
   *
   * @cloudformationAttribute CertificateS3ObjectKey
   */
  public readonly attrCertificateS3ObjectKey: string;

  /**
   * The ID of the AWS KMS key used to encrypt the private key of the certificate.
   *
   * @cloudformationAttribute EncryptionKmsKeyId
   */
  public readonly attrEncryptionKmsKeyId: string;

  /**
   * The ARN of the ACM certificate with which to associate the IAM role.
   */
  public certificateArn: string;

  /**
   * The ARN of the IAM role to associate with the ACM certificate.
   */
  public roleArn: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnEnclaveCertificateIamRoleAssociationProps) {
    super(scope, id, {
      "type": CfnEnclaveCertificateIamRoleAssociation.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "certificateArn", this);
    cdk.requireProperty(props, "roleArn", this);

    this.attrCertificateS3BucketName = cdk.Token.asString(this.getAtt("CertificateS3BucketName", cdk.ResolutionTypeHint.STRING));
    this.attrCertificateS3ObjectKey = cdk.Token.asString(this.getAtt("CertificateS3ObjectKey", cdk.ResolutionTypeHint.STRING));
    this.attrEncryptionKmsKeyId = cdk.Token.asString(this.getAtt("EncryptionKmsKeyId", cdk.ResolutionTypeHint.STRING));
    this.certificateArn = props.certificateArn;
    this.roleArn = props.roleArn;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "certificateArn": this.certificateArn,
      "roleArn": this.roleArn
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnEnclaveCertificateIamRoleAssociation.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnEnclaveCertificateIamRoleAssociationPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a `CfnEnclaveCertificateIamRoleAssociation`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-enclavecertificateiamroleassociation.html
 */
export interface CfnEnclaveCertificateIamRoleAssociationProps {
  /**
   * The ARN of the ACM certificate with which to associate the IAM role.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-enclavecertificateiamroleassociation.html#cfn-ec2-enclavecertificateiamroleassociation-certificatearn
   */
  readonly certificateArn: string;

  /**
   * The ARN of the IAM role to associate with the ACM certificate.
   *
   * You can associate up to 16 IAM roles with an ACM certificate.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-enclavecertificateiamroleassociation.html#cfn-ec2-enclavecertificateiamroleassociation-rolearn
   */
  readonly roleArn: string;
}

/**
 * Determine whether the given properties match those of a `CfnEnclaveCertificateIamRoleAssociationProps`
 *
 * @param properties - the TypeScript properties of a `CfnEnclaveCertificateIamRoleAssociationProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnEnclaveCertificateIamRoleAssociationPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("certificateArn", cdk.requiredValidator)(properties.certificateArn));
  errors.collect(cdk.propertyValidator("certificateArn", cdk.validateString)(properties.certificateArn));
  errors.collect(cdk.propertyValidator("roleArn", cdk.requiredValidator)(properties.roleArn));
  errors.collect(cdk.propertyValidator("roleArn", cdk.validateString)(properties.roleArn));
  return errors.wrap("supplied properties not correct for \"CfnEnclaveCertificateIamRoleAssociationProps\"");
}

// @ts-ignore TS6133
function convertCfnEnclaveCertificateIamRoleAssociationPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnEnclaveCertificateIamRoleAssociationPropsValidator(properties).assertSuccess();
  return {
    "CertificateArn": cdk.stringToCloudFormation(properties.certificateArn),
    "RoleArn": cdk.stringToCloudFormation(properties.roleArn)
  };
}

// @ts-ignore TS6133
function CfnEnclaveCertificateIamRoleAssociationPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnEnclaveCertificateIamRoleAssociationProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnEnclaveCertificateIamRoleAssociationProps>();
  ret.addPropertyResult("certificateArn", "CertificateArn", (properties.CertificateArn != null ? cfn_parse.FromCloudFormation.getString(properties.CertificateArn) : undefined));
  ret.addPropertyResult("roleArn", "RoleArn", (properties.RoleArn != null ? cfn_parse.FromCloudFormation.getString(properties.RoleArn) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a VPC flow log that captures IP traffic for a specified network interface, subnet, or VPC.
 *
 * To view the log data, use Amazon CloudWatch Logs (CloudWatch Logs) to help troubleshoot connection issues. For example, you can use a flow log to investigate why certain traffic isn't reaching an instance, which can help you diagnose overly restrictive security group rules. For more information, see [VPC Flow Logs](https://docs.aws.amazon.com/vpc/latest/userguide/flow-logs.html) in the *Amazon VPC User Guide* .
 *
 * @cloudformationResource AWS::EC2::FlowLog
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html
 */
export class CfnFlowLog extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::FlowLog";

  /**
   * Build a CfnFlowLog from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnFlowLog {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnFlowLogPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnFlowLog(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the flow log. For example, `fl-123456abc123abc1` .
   *
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The ARN of the IAM role that allows the service to publish flow logs across accounts.
   */
  public deliverCrossAccountRole?: string;

  /**
   * The ARN of the IAM role that allows Amazon EC2 to publish flow logs to a CloudWatch Logs log group in your account.
   */
  public deliverLogsPermissionArn?: string;

  /**
   * The destination options. The following options are supported:.
   */
  public destinationOptions?: any | cdk.IResolvable;

  /**
   * The destination for the flow log data. The meaning of this parameter depends on the destination type.
   */
  public logDestination?: string;

  /**
   * The type of destination for the flow log data.
   */
  public logDestinationType?: string;

  /**
   * The fields to include in the flow log record, in the order in which they should appear.
   */
  public logFormat?: string;

  /**
   * The name of a new or existing CloudWatch Logs log group where Amazon EC2 publishes your flow logs.
   */
  public logGroupName?: string;

  /**
   * The maximum interval of time during which a flow of packets is captured and aggregated into a flow log record.
   */
  public maxAggregationInterval?: number;

  /**
   * The ID of the resource to monitor.
   */
  public resourceId: string;

  /**
   * The type of resource to monitor.
   */
  public resourceType: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags to apply to the flow logs.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The type of traffic to monitor (accepted traffic, rejected traffic, or all traffic).
   */
  public trafficType?: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnFlowLogProps) {
    super(scope, id, {
      "type": CfnFlowLog.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "resourceId", this);
    cdk.requireProperty(props, "resourceType", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.deliverCrossAccountRole = props.deliverCrossAccountRole;
    this.deliverLogsPermissionArn = props.deliverLogsPermissionArn;
    this.destinationOptions = props.destinationOptions;
    this.logDestination = props.logDestination;
    this.logDestinationType = props.logDestinationType;
    this.logFormat = props.logFormat;
    this.logGroupName = props.logGroupName;
    this.maxAggregationInterval = props.maxAggregationInterval;
    this.resourceId = props.resourceId;
    this.resourceType = props.resourceType;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::FlowLog", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.trafficType = props.trafficType;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "deliverCrossAccountRole": this.deliverCrossAccountRole,
      "deliverLogsPermissionArn": this.deliverLogsPermissionArn,
      "destinationOptions": this.destinationOptions,
      "logDestination": this.logDestination,
      "logDestinationType": this.logDestinationType,
      "logFormat": this.logFormat,
      "logGroupName": this.logGroupName,
      "maxAggregationInterval": this.maxAggregationInterval,
      "resourceId": this.resourceId,
      "resourceType": this.resourceType,
      "tags": this.tags.renderTags(),
      "trafficType": this.trafficType
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnFlowLog.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnFlowLogPropsToCloudFormation(props);
  }
}

export namespace CfnFlowLog {
  /**
   * Describes the destination options for a flow log.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-flowlog-destinationoptions.html
   */
  export interface DestinationOptionsProperty {
    /**
     * The format for the flow log.
     *
     * The default is `plain-text` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-flowlog-destinationoptions.html#cfn-ec2-flowlog-destinationoptions-fileformat
     */
    readonly fileFormat: string;

    /**
     * Indicates whether to use Hive-compatible prefixes for flow logs stored in Amazon S3.
     *
     * The default is `false` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-flowlog-destinationoptions.html#cfn-ec2-flowlog-destinationoptions-hivecompatiblepartitions
     */
    readonly hiveCompatiblePartitions: boolean | cdk.IResolvable;

    /**
     * Indicates whether to partition the flow log per hour.
     *
     * This reduces the cost and response time for queries. The default is `false` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-flowlog-destinationoptions.html#cfn-ec2-flowlog-destinationoptions-perhourpartition
     */
    readonly perHourPartition: boolean | cdk.IResolvable;
  }
}

/**
 * Properties for defining a `CfnFlowLog`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html
 */
export interface CfnFlowLogProps {
  /**
   * The ARN of the IAM role that allows the service to publish flow logs across accounts.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-delivercrossaccountrole
   */
  readonly deliverCrossAccountRole?: string;

  /**
   * The ARN of the IAM role that allows Amazon EC2 to publish flow logs to a CloudWatch Logs log group in your account.
   *
   * This parameter is required if the destination type is `cloud-watch-logs` and unsupported otherwise.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-deliverlogspermissionarn
   */
  readonly deliverLogsPermissionArn?: string;

  /**
   * The destination options. The following options are supported:.
   *
   * - `FileFormat` - The format for the flow log ( `plain-text` | `parquet` ). The default is `plain-text` .
   * - `HiveCompatiblePartitions` - Indicates whether to use Hive-compatible prefixes for flow logs stored in Amazon S3 ( `true` | `false` ). The default is `false` .
   * - `PerHourPartition` - Indicates whether to partition the flow log per hour ( `true` | `false` ). The default is `false` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-destinationoptions
   */
  readonly destinationOptions?: any | cdk.IResolvable;

  /**
   * The destination for the flow log data. The meaning of this parameter depends on the destination type.
   *
   * - If the destination type is `cloud-watch-logs` , specify the ARN of a CloudWatch Logs log group. For example:
   *
   * arn:aws:logs: *region* : *account_id* :log-group: *my_group*
   *
   * Alternatively, use the `LogGroupName` parameter.
   * - If the destination type is `s3` , specify the ARN of an S3 bucket. For example:
   *
   * arn:aws:s3::: *my_bucket* / *my_subfolder* /
   *
   * The subfolder is optional. Note that you can't use `AWSLogs` as a subfolder name.
   * - If the destination type is `kinesis-data-firehose` , specify the ARN of a Kinesis Data Firehose delivery stream. For example:
   *
   * arn:aws:firehose: *region* : *account_id* :deliverystream: *my_stream*
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-logdestination
   */
  readonly logDestination?: string;

  /**
   * The type of destination for the flow log data.
   *
   * Default: `cloud-watch-logs`
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-logdestinationtype
   */
  readonly logDestinationType?: string;

  /**
   * The fields to include in the flow log record, in the order in which they should appear.
   *
   * If you omit this parameter, the flow log is created using the default format. If you specify this parameter, you must include at least one field. For more information about the available fields, see [Flow log records](https://docs.aws.amazon.com/vpc/latest/userguide/flow-logs.html#flow-log-records) in the *Amazon VPC User Guide* or [Transit Gateway Flow Log records](https://docs.aws.amazon.com/vpc/latest/tgw/tgw-flow-logs.html#flow-log-records) in the *AWS Transit Gateway Guide* .
   *
   * Specify the fields using the `${field-id}` format, separated by spaces.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-logformat
   */
  readonly logFormat?: string;

  /**
   * The name of a new or existing CloudWatch Logs log group where Amazon EC2 publishes your flow logs.
   *
   * This parameter is valid only if the destination type is `cloud-watch-logs` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-loggroupname
   */
  readonly logGroupName?: string;

  /**
   * The maximum interval of time during which a flow of packets is captured and aggregated into a flow log record.
   *
   * The possible values are 60 seconds (1 minute) or 600 seconds (10 minutes). This parameter must be 60 seconds for transit gateway resource types.
   *
   * When a network interface is attached to a [Nitro-based instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances) , the aggregation interval is always 60 seconds or less, regardless of the value that you specify.
   *
   * Default: 600
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-maxaggregationinterval
   */
  readonly maxAggregationInterval?: number;

  /**
   * The ID of the resource to monitor.
   *
   * For example, if the resource type is `VPC` , specify the ID of the VPC.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-resourceid
   */
  readonly resourceId: string;

  /**
   * The type of resource to monitor.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-resourcetype
   */
  readonly resourceType: string;

  /**
   * The tags to apply to the flow logs.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The type of traffic to monitor (accepted traffic, rejected traffic, or all traffic).
   *
   * This parameter is not supported for transit gateway resource types. It is required for the other resource types.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-traffictype
   */
  readonly trafficType?: string;
}

/**
 * Determine whether the given properties match those of a `DestinationOptionsProperty`
 *
 * @param properties - the TypeScript properties of a `DestinationOptionsProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFlowLogDestinationOptionsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("fileFormat", cdk.requiredValidator)(properties.fileFormat));
  errors.collect(cdk.propertyValidator("fileFormat", cdk.validateString)(properties.fileFormat));
  errors.collect(cdk.propertyValidator("hiveCompatiblePartitions", cdk.requiredValidator)(properties.hiveCompatiblePartitions));
  errors.collect(cdk.propertyValidator("hiveCompatiblePartitions", cdk.validateBoolean)(properties.hiveCompatiblePartitions));
  errors.collect(cdk.propertyValidator("perHourPartition", cdk.requiredValidator)(properties.perHourPartition));
  errors.collect(cdk.propertyValidator("perHourPartition", cdk.validateBoolean)(properties.perHourPartition));
  return errors.wrap("supplied properties not correct for \"DestinationOptionsProperty\"");
}

// @ts-ignore TS6133
function convertCfnFlowLogDestinationOptionsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFlowLogDestinationOptionsPropertyValidator(properties).assertSuccess();
  return {
    "FileFormat": cdk.stringToCloudFormation(properties.fileFormat),
    "HiveCompatiblePartitions": cdk.booleanToCloudFormation(properties.hiveCompatiblePartitions),
    "PerHourPartition": cdk.booleanToCloudFormation(properties.perHourPartition)
  };
}

// @ts-ignore TS6133
function CfnFlowLogDestinationOptionsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnFlowLog.DestinationOptionsProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFlowLog.DestinationOptionsProperty>();
  ret.addPropertyResult("fileFormat", "FileFormat", (properties.FileFormat != null ? cfn_parse.FromCloudFormation.getString(properties.FileFormat) : undefined));
  ret.addPropertyResult("hiveCompatiblePartitions", "HiveCompatiblePartitions", (properties.HiveCompatiblePartitions != null ? cfn_parse.FromCloudFormation.getBoolean(properties.HiveCompatiblePartitions) : undefined));
  ret.addPropertyResult("perHourPartition", "PerHourPartition", (properties.PerHourPartition != null ? cfn_parse.FromCloudFormation.getBoolean(properties.PerHourPartition) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `CfnFlowLogProps`
 *
 * @param properties - the TypeScript properties of a `CfnFlowLogProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFlowLogPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("deliverCrossAccountRole", cdk.validateString)(properties.deliverCrossAccountRole));
  errors.collect(cdk.propertyValidator("deliverLogsPermissionArn", cdk.validateString)(properties.deliverLogsPermissionArn));
  errors.collect(cdk.propertyValidator("destinationOptions", cdk.validateObject)(properties.destinationOptions));
  errors.collect(cdk.propertyValidator("logDestination", cdk.validateString)(properties.logDestination));
  errors.collect(cdk.propertyValidator("logDestinationType", cdk.validateString)(properties.logDestinationType));
  errors.collect(cdk.propertyValidator("logFormat", cdk.validateString)(properties.logFormat));
  errors.collect(cdk.propertyValidator("logGroupName", cdk.validateString)(properties.logGroupName));
  errors.collect(cdk.propertyValidator("maxAggregationInterval", cdk.validateNumber)(properties.maxAggregationInterval));
  errors.collect(cdk.propertyValidator("resourceId", cdk.requiredValidator)(properties.resourceId));
  errors.collect(cdk.propertyValidator("resourceId", cdk.validateString)(properties.resourceId));
  errors.collect(cdk.propertyValidator("resourceType", cdk.requiredValidator)(properties.resourceType));
  errors.collect(cdk.propertyValidator("resourceType", cdk.validateString)(properties.resourceType));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("trafficType", cdk.validateString)(properties.trafficType));
  return errors.wrap("supplied properties not correct for \"CfnFlowLogProps\"");
}

// @ts-ignore TS6133
function convertCfnFlowLogPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFlowLogPropsValidator(properties).assertSuccess();
  return {
    "DeliverCrossAccountRole": cdk.stringToCloudFormation(properties.deliverCrossAccountRole),
    "DeliverLogsPermissionArn": cdk.stringToCloudFormation(properties.deliverLogsPermissionArn),
    "DestinationOptions": cdk.objectToCloudFormation(properties.destinationOptions),
    "LogDestination": cdk.stringToCloudFormation(properties.logDestination),
    "LogDestinationType": cdk.stringToCloudFormation(properties.logDestinationType),
    "LogFormat": cdk.stringToCloudFormation(properties.logFormat),
    "LogGroupName": cdk.stringToCloudFormation(properties.logGroupName),
    "MaxAggregationInterval": cdk.numberToCloudFormation(properties.maxAggregationInterval),
    "ResourceId": cdk.stringToCloudFormation(properties.resourceId),
    "ResourceType": cdk.stringToCloudFormation(properties.resourceType),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "TrafficType": cdk.stringToCloudFormation(properties.trafficType)
  };
}

// @ts-ignore TS6133
function CfnFlowLogPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnFlowLogProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFlowLogProps>();
  ret.addPropertyResult("deliverCrossAccountRole", "DeliverCrossAccountRole", (properties.DeliverCrossAccountRole != null ? cfn_parse.FromCloudFormation.getString(properties.DeliverCrossAccountRole) : undefined));
  ret.addPropertyResult("deliverLogsPermissionArn", "DeliverLogsPermissionArn", (properties.DeliverLogsPermissionArn != null ? cfn_parse.FromCloudFormation.getString(properties.DeliverLogsPermissionArn) : undefined));
  ret.addPropertyResult("destinationOptions", "DestinationOptions", (properties.DestinationOptions != null ? cfn_parse.FromCloudFormation.getAny(properties.DestinationOptions) : undefined));
  ret.addPropertyResult("logDestination", "LogDestination", (properties.LogDestination != null ? cfn_parse.FromCloudFormation.getString(properties.LogDestination) : undefined));
  ret.addPropertyResult("logDestinationType", "LogDestinationType", (properties.LogDestinationType != null ? cfn_parse.FromCloudFormation.getString(properties.LogDestinationType) : undefined));
  ret.addPropertyResult("logFormat", "LogFormat", (properties.LogFormat != null ? cfn_parse.FromCloudFormation.getString(properties.LogFormat) : undefined));
  ret.addPropertyResult("logGroupName", "LogGroupName", (properties.LogGroupName != null ? cfn_parse.FromCloudFormation.getString(properties.LogGroupName) : undefined));
  ret.addPropertyResult("maxAggregationInterval", "MaxAggregationInterval", (properties.MaxAggregationInterval != null ? cfn_parse.FromCloudFormation.getNumber(properties.MaxAggregationInterval) : undefined));
  ret.addPropertyResult("resourceId", "ResourceId", (properties.ResourceId != null ? cfn_parse.FromCloudFormation.getString(properties.ResourceId) : undefined));
  ret.addPropertyResult("resourceType", "ResourceType", (properties.ResourceType != null ? cfn_parse.FromCloudFormation.getString(properties.ResourceType) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("trafficType", "TrafficType", (properties.TrafficType != null ? cfn_parse.FromCloudFormation.getString(properties.TrafficType) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Associates a virtual private gateway or internet gateway with a route table.
 *
 * The gateway and route table must be in the same VPC. This association causes the incoming traffic to the gateway to be routed according to the routes in the route table.
 *
 * @cloudformationResource AWS::EC2::GatewayRouteTableAssociation
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-gatewayroutetableassociation.html
 */
export class CfnGatewayRouteTableAssociation extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::GatewayRouteTableAssociation";

  /**
   * Build a CfnGatewayRouteTableAssociation from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnGatewayRouteTableAssociation {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnGatewayRouteTableAssociationPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnGatewayRouteTableAssociation(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the route table association.
   *
   * @cloudformationAttribute AssociationId
   */
  public readonly attrAssociationId: string;

  /**
   * The ID of the gateway.
   */
  public gatewayId: string;

  /**
   * The ID of the route table.
   */
  public routeTableId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnGatewayRouteTableAssociationProps) {
    super(scope, id, {
      "type": CfnGatewayRouteTableAssociation.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "gatewayId", this);
    cdk.requireProperty(props, "routeTableId", this);

    this.attrAssociationId = cdk.Token.asString(this.getAtt("AssociationId", cdk.ResolutionTypeHint.STRING));
    this.gatewayId = props.gatewayId;
    this.routeTableId = props.routeTableId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "gatewayId": this.gatewayId,
      "routeTableId": this.routeTableId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnGatewayRouteTableAssociation.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnGatewayRouteTableAssociationPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a `CfnGatewayRouteTableAssociation`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-gatewayroutetableassociation.html
 */
export interface CfnGatewayRouteTableAssociationProps {
  /**
   * The ID of the gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-gatewayroutetableassociation.html#cfn-ec2-gatewayroutetableassociation-gatewayid
   */
  readonly gatewayId: string;

  /**
   * The ID of the route table.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-gatewayroutetableassociation.html#cfn-ec2-gatewayroutetableassociation-routetableid
   */
  readonly routeTableId: string;
}

/**
 * Determine whether the given properties match those of a `CfnGatewayRouteTableAssociationProps`
 *
 * @param properties - the TypeScript properties of a `CfnGatewayRouteTableAssociationProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnGatewayRouteTableAssociationPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("gatewayId", cdk.requiredValidator)(properties.gatewayId));
  errors.collect(cdk.propertyValidator("gatewayId", cdk.validateString)(properties.gatewayId));
  errors.collect(cdk.propertyValidator("routeTableId", cdk.requiredValidator)(properties.routeTableId));
  errors.collect(cdk.propertyValidator("routeTableId", cdk.validateString)(properties.routeTableId));
  return errors.wrap("supplied properties not correct for \"CfnGatewayRouteTableAssociationProps\"");
}

// @ts-ignore TS6133
function convertCfnGatewayRouteTableAssociationPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnGatewayRouteTableAssociationPropsValidator(properties).assertSuccess();
  return {
    "GatewayId": cdk.stringToCloudFormation(properties.gatewayId),
    "RouteTableId": cdk.stringToCloudFormation(properties.routeTableId)
  };
}

// @ts-ignore TS6133
function CfnGatewayRouteTableAssociationPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnGatewayRouteTableAssociationProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnGatewayRouteTableAssociationProps>();
  ret.addPropertyResult("gatewayId", "GatewayId", (properties.GatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.GatewayId) : undefined));
  ret.addPropertyResult("routeTableId", "RouteTableId", (properties.RouteTableId != null ? cfn_parse.FromCloudFormation.getString(properties.RouteTableId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Allocates a fully dedicated physical server for launching EC2 instances.
 *
 * Because the host is fully dedicated for your use, it can help you address compliance requirements and reduce costs by allowing you to use your existing server-bound software licenses. For more information, see [Dedicated Hosts](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/dedicated-hosts-overview.html) in the *Amazon EC2 User Guide for Linux Instances* .
 *
 * @cloudformationResource AWS::EC2::Host
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-host.html
 */
export class CfnHost extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::Host";

  /**
   * Build a CfnHost from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnHost {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnHostPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnHost(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the host.
   *
   * @cloudformationAttribute HostId
   */
  public readonly attrHostId: string;

  /**
   * The ID of the Outpost hardware asset on which the Dedicated Host is allocated.
   */
  public assetId?: string;

  /**
   * Indicates whether the host accepts any untargeted instance launches that match its instance type configuration, or if it only accepts Host tenancy instance launches that specify its unique host ID.
   */
  public autoPlacement?: string;

  /**
   * The Availability Zone in which to allocate the Dedicated Host.
   */
  public availabilityZone: string;

  /**
   * Indicates whether host maintenance is enabled or disabled for the Dedicated Host.
   */
  public hostMaintenance?: string;

  /**
   * Indicates whether to enable or disable host recovery for the Dedicated Host.
   */
  public hostRecovery?: string;

  /**
   * The instance family supported by the Dedicated Host.
   */
  public instanceFamily?: string;

  /**
   * Specifies the instance type to be supported by the Dedicated Hosts.
   */
  public instanceType?: string;

  /**
   * The Amazon Resource Name (ARN) of the AWS Outpost on which the Dedicated Host is allocated.
   */
  public outpostArn?: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnHostProps) {
    super(scope, id, {
      "type": CfnHost.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "availabilityZone", this);

    this.attrHostId = cdk.Token.asString(this.getAtt("HostId", cdk.ResolutionTypeHint.STRING));
    this.assetId = props.assetId;
    this.autoPlacement = props.autoPlacement;
    this.availabilityZone = props.availabilityZone;
    this.hostMaintenance = props.hostMaintenance;
    this.hostRecovery = props.hostRecovery;
    this.instanceFamily = props.instanceFamily;
    this.instanceType = props.instanceType;
    this.outpostArn = props.outpostArn;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "assetId": this.assetId,
      "autoPlacement": this.autoPlacement,
      "availabilityZone": this.availabilityZone,
      "hostMaintenance": this.hostMaintenance,
      "hostRecovery": this.hostRecovery,
      "instanceFamily": this.instanceFamily,
      "instanceType": this.instanceType,
      "outpostArn": this.outpostArn
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnHost.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnHostPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a `CfnHost`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-host.html
 */
export interface CfnHostProps {
  /**
   * The ID of the Outpost hardware asset on which the Dedicated Host is allocated.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-host.html#cfn-ec2-host-assetid
   */
  readonly assetId?: string;

  /**
   * Indicates whether the host accepts any untargeted instance launches that match its instance type configuration, or if it only accepts Host tenancy instance launches that specify its unique host ID.
   *
   * For more information, see [Understanding auto-placement and affinity](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/how-dedicated-hosts-work.html#dedicated-hosts-understanding) in the *Amazon EC2 User Guide* .
   *
   * Default: `on`
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-host.html#cfn-ec2-host-autoplacement
   */
  readonly autoPlacement?: string;

  /**
   * The Availability Zone in which to allocate the Dedicated Host.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-host.html#cfn-ec2-host-availabilityzone
   */
  readonly availabilityZone: string;

  /**
   * Indicates whether host maintenance is enabled or disabled for the Dedicated Host.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-host.html#cfn-ec2-host-hostmaintenance
   */
  readonly hostMaintenance?: string;

  /**
   * Indicates whether to enable or disable host recovery for the Dedicated Host.
   *
   * Host recovery is disabled by default. For more information, see [Host recovery](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/dedicated-hosts-recovery.html) in the *Amazon EC2 User Guide* .
   *
   * Default: `off`
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-host.html#cfn-ec2-host-hostrecovery
   */
  readonly hostRecovery?: string;

  /**
   * The instance family supported by the Dedicated Host.
   *
   * For example, `m5` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-host.html#cfn-ec2-host-instancefamily
   */
  readonly instanceFamily?: string;

  /**
   * Specifies the instance type to be supported by the Dedicated Hosts.
   *
   * If you specify an instance type, the Dedicated Hosts support instances of the specified instance type only.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-host.html#cfn-ec2-host-instancetype
   */
  readonly instanceType?: string;

  /**
   * The Amazon Resource Name (ARN) of the AWS Outpost on which the Dedicated Host is allocated.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-host.html#cfn-ec2-host-outpostarn
   */
  readonly outpostArn?: string;
}

/**
 * Determine whether the given properties match those of a `CfnHostProps`
 *
 * @param properties - the TypeScript properties of a `CfnHostProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnHostPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("assetId", cdk.validateString)(properties.assetId));
  errors.collect(cdk.propertyValidator("autoPlacement", cdk.validateString)(properties.autoPlacement));
  errors.collect(cdk.propertyValidator("availabilityZone", cdk.requiredValidator)(properties.availabilityZone));
  errors.collect(cdk.propertyValidator("availabilityZone", cdk.validateString)(properties.availabilityZone));
  errors.collect(cdk.propertyValidator("hostMaintenance", cdk.validateString)(properties.hostMaintenance));
  errors.collect(cdk.propertyValidator("hostRecovery", cdk.validateString)(properties.hostRecovery));
  errors.collect(cdk.propertyValidator("instanceFamily", cdk.validateString)(properties.instanceFamily));
  errors.collect(cdk.propertyValidator("instanceType", cdk.validateString)(properties.instanceType));
  errors.collect(cdk.propertyValidator("outpostArn", cdk.validateString)(properties.outpostArn));
  return errors.wrap("supplied properties not correct for \"CfnHostProps\"");
}

// @ts-ignore TS6133
function convertCfnHostPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnHostPropsValidator(properties).assertSuccess();
  return {
    "AssetId": cdk.stringToCloudFormation(properties.assetId),
    "AutoPlacement": cdk.stringToCloudFormation(properties.autoPlacement),
    "AvailabilityZone": cdk.stringToCloudFormation(properties.availabilityZone),
    "HostMaintenance": cdk.stringToCloudFormation(properties.hostMaintenance),
    "HostRecovery": cdk.stringToCloudFormation(properties.hostRecovery),
    "InstanceFamily": cdk.stringToCloudFormation(properties.instanceFamily),
    "InstanceType": cdk.stringToCloudFormation(properties.instanceType),
    "OutpostArn": cdk.stringToCloudFormation(properties.outpostArn)
  };
}

// @ts-ignore TS6133
function CfnHostPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnHostProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnHostProps>();
  ret.addPropertyResult("assetId", "AssetId", (properties.AssetId != null ? cfn_parse.FromCloudFormation.getString(properties.AssetId) : undefined));
  ret.addPropertyResult("autoPlacement", "AutoPlacement", (properties.AutoPlacement != null ? cfn_parse.FromCloudFormation.getString(properties.AutoPlacement) : undefined));
  ret.addPropertyResult("availabilityZone", "AvailabilityZone", (properties.AvailabilityZone != null ? cfn_parse.FromCloudFormation.getString(properties.AvailabilityZone) : undefined));
  ret.addPropertyResult("hostMaintenance", "HostMaintenance", (properties.HostMaintenance != null ? cfn_parse.FromCloudFormation.getString(properties.HostMaintenance) : undefined));
  ret.addPropertyResult("hostRecovery", "HostRecovery", (properties.HostRecovery != null ? cfn_parse.FromCloudFormation.getString(properties.HostRecovery) : undefined));
  ret.addPropertyResult("instanceFamily", "InstanceFamily", (properties.InstanceFamily != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceFamily) : undefined));
  ret.addPropertyResult("instanceType", "InstanceType", (properties.InstanceType != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceType) : undefined));
  ret.addPropertyResult("outpostArn", "OutpostArn", (properties.OutpostArn != null ? cfn_parse.FromCloudFormation.getString(properties.OutpostArn) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * IPAM is a VPC feature that you can use to automate your IP address management workflows including assigning, tracking, troubleshooting, and auditing IP addresses across AWS Regions and accounts throughout your AWS Organization.
 *
 * For more information, see [What is IPAM?](https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html) in the *Amazon VPC IPAM User Guide* .
 *
 * There are AWS Identity and Access Management (IAM) permissions required to fully manage an IPAM in CloudFormation. For more information, see [Example policy](https://docs.aws.amazon.com//vpc/latest/ipam/iam-ipam-policy-examples.html) in the *Amazon VPC IPAM User Guide* .
 *
 * @cloudformationResource AWS::EC2::IPAM
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipam.html
 */
export class CfnIPAM extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::IPAM";

  /**
   * Build a CfnIPAM from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnIPAM {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnIPAMPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnIPAM(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ARN of the IPAM.
   *
   * @cloudformationAttribute Arn
   */
  public readonly attrArn: string;

  /**
   * The ID of the default resource discovery association.
   *
   * @cloudformationAttribute DefaultResourceDiscoveryAssociationId
   */
  public readonly attrDefaultResourceDiscoveryAssociationId: string;

  /**
   * The ID of the default resource discovery.
   *
   * @cloudformationAttribute DefaultResourceDiscoveryId
   */
  public readonly attrDefaultResourceDiscoveryId: string;

  /**
   * The ID of the IPAM.
   *
   * @cloudformationAttribute IpamId
   */
  public readonly attrIpamId: string;

  /**
   * The ID of the default private scope.
   *
   * @cloudformationAttribute PrivateDefaultScopeId
   */
  public readonly attrPrivateDefaultScopeId: string;

  /**
   * The ID of the default public scope.
   *
   * @cloudformationAttribute PublicDefaultScopeId
   */
  public readonly attrPublicDefaultScopeId: string;

  /**
   * The number of resource discovery associations.
   *
   * @cloudformationAttribute ResourceDiscoveryAssociationCount
   */
  public readonly attrResourceDiscoveryAssociationCount: number;

  /**
   * The number of scopes.
   *
   * @cloudformationAttribute ScopeCount
   */
  public readonly attrScopeCount: number;

  /**
   * The description for the IPAM.
   */
  public description?: string;

  /**
   * The operating Regions for an IPAM.
   */
  public operatingRegions?: Array<CfnIPAM.IpamOperatingRegionProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The key/value combination of a tag assigned to the resource.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * IPAM is offered in a Free Tier and an Advanced Tier.
   */
  public tier?: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnIPAMProps = {}) {
    super(scope, id, {
      "type": CfnIPAM.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.attrArn = cdk.Token.asString(this.getAtt("Arn", cdk.ResolutionTypeHint.STRING));
    this.attrDefaultResourceDiscoveryAssociationId = cdk.Token.asString(this.getAtt("DefaultResourceDiscoveryAssociationId", cdk.ResolutionTypeHint.STRING));
    this.attrDefaultResourceDiscoveryId = cdk.Token.asString(this.getAtt("DefaultResourceDiscoveryId", cdk.ResolutionTypeHint.STRING));
    this.attrIpamId = cdk.Token.asString(this.getAtt("IpamId", cdk.ResolutionTypeHint.STRING));
    this.attrPrivateDefaultScopeId = cdk.Token.asString(this.getAtt("PrivateDefaultScopeId", cdk.ResolutionTypeHint.STRING));
    this.attrPublicDefaultScopeId = cdk.Token.asString(this.getAtt("PublicDefaultScopeId", cdk.ResolutionTypeHint.STRING));
    this.attrResourceDiscoveryAssociationCount = cdk.Token.asNumber(this.getAtt("ResourceDiscoveryAssociationCount", cdk.ResolutionTypeHint.NUMBER));
    this.attrScopeCount = cdk.Token.asNumber(this.getAtt("ScopeCount", cdk.ResolutionTypeHint.NUMBER));
    this.description = props.description;
    this.operatingRegions = props.operatingRegions;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::IPAM", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.tier = props.tier;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "description": this.description,
      "operatingRegions": this.operatingRegions,
      "tags": this.tags.renderTags(),
      "tier": this.tier
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnIPAM.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnIPAMPropsToCloudFormation(props);
  }
}

export namespace CfnIPAM {
  /**
   * The operating Regions for an IPAM.
   *
   * Operating Regions are AWS Regions where the IPAM is allowed to manage IP address CIDRs. IPAM only discovers and monitors resources in the AWS Regions you select as operating Regions.
   *
   * For more information about operating Regions, see [Create an IPAM](https://docs.aws.amazon.com//vpc/latest/ipam/create-ipam.html) in the *Amazon VPC IPAM User Guide* .
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipam-ipamoperatingregion.html
   */
  export interface IpamOperatingRegionProperty {
    /**
     * The name of the operating Region.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipam-ipamoperatingregion.html#cfn-ec2-ipam-ipamoperatingregion-regionname
     */
    readonly regionName: string;
  }
}

/**
 * Properties for defining a `CfnIPAM`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipam.html
 */
export interface CfnIPAMProps {
  /**
   * The description for the IPAM.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipam.html#cfn-ec2-ipam-description
   */
  readonly description?: string;

  /**
   * The operating Regions for an IPAM.
   *
   * Operating Regions are AWS Regions where the IPAM is allowed to manage IP address CIDRs. IPAM only discovers and monitors resources in the AWS Regions you select as operating Regions.
   *
   * For more information about operating Regions, see [Create an IPAM](https://docs.aws.amazon.com//vpc/latest/ipam/create-ipam.html) in the *Amazon VPC IPAM User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipam.html#cfn-ec2-ipam-operatingregions
   */
  readonly operatingRegions?: Array<CfnIPAM.IpamOperatingRegionProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * The key/value combination of a tag assigned to the resource.
   *
   * Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key `Owner` and the value `TeamA` , specify `tag:Owner` for the filter name and `TeamA` for the filter value.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipam.html#cfn-ec2-ipam-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * IPAM is offered in a Free Tier and an Advanced Tier.
   *
   * For more information about the features available in each tier and the costs associated with the tiers, see the [VPC IPAM product pricing page](https://docs.aws.amazon.com//vpc/pricing/) .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipam.html#cfn-ec2-ipam-tier
   */
  readonly tier?: string;
}

/**
 * Determine whether the given properties match those of a `IpamOperatingRegionProperty`
 *
 * @param properties - the TypeScript properties of a `IpamOperatingRegionProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnIPAMIpamOperatingRegionPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("regionName", cdk.requiredValidator)(properties.regionName));
  errors.collect(cdk.propertyValidator("regionName", cdk.validateString)(properties.regionName));
  return errors.wrap("supplied properties not correct for \"IpamOperatingRegionProperty\"");
}

// @ts-ignore TS6133
function convertCfnIPAMIpamOperatingRegionPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnIPAMIpamOperatingRegionPropertyValidator(properties).assertSuccess();
  return {
    "RegionName": cdk.stringToCloudFormation(properties.regionName)
  };
}

// @ts-ignore TS6133
function CfnIPAMIpamOperatingRegionPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnIPAM.IpamOperatingRegionProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnIPAM.IpamOperatingRegionProperty>();
  ret.addPropertyResult("regionName", "RegionName", (properties.RegionName != null ? cfn_parse.FromCloudFormation.getString(properties.RegionName) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `CfnIPAMProps`
 *
 * @param properties - the TypeScript properties of a `CfnIPAMProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnIPAMPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("operatingRegions", cdk.listValidator(CfnIPAMIpamOperatingRegionPropertyValidator))(properties.operatingRegions));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("tier", cdk.validateString)(properties.tier));
  return errors.wrap("supplied properties not correct for \"CfnIPAMProps\"");
}

// @ts-ignore TS6133
function convertCfnIPAMPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnIPAMPropsValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "OperatingRegions": cdk.listMapper(convertCfnIPAMIpamOperatingRegionPropertyToCloudFormation)(properties.operatingRegions),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "Tier": cdk.stringToCloudFormation(properties.tier)
  };
}

// @ts-ignore TS6133
function CfnIPAMPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnIPAMProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnIPAMProps>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("operatingRegions", "OperatingRegions", (properties.OperatingRegions != null ? cfn_parse.FromCloudFormation.getArray(CfnIPAMIpamOperatingRegionPropertyFromCloudFormation)(properties.OperatingRegions) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("tier", "Tier", (properties.Tier != null ? cfn_parse.FromCloudFormation.getString(properties.Tier) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * In IPAM, an allocation is a CIDR assignment from an IPAM pool to another IPAM pool or to a resource.
 *
 * @cloudformationResource AWS::EC2::IPAMAllocation
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamallocation.html
 */
export class CfnIPAMAllocation extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::IPAMAllocation";

  /**
   * Build a CfnIPAMAllocation from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnIPAMAllocation {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnIPAMAllocationPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnIPAMAllocation(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of an allocation.
   *
   * @cloudformationAttribute IpamPoolAllocationId
   */
  public readonly attrIpamPoolAllocationId: string;

  /**
   * The CIDR you would like to allocate from the IPAM pool. Note the following:.
   */
  public cidr?: string;

  /**
   * A description for the allocation.
   */
  public description?: string;

  /**
   * The ID of the IPAM pool from which you would like to allocate a CIDR.
   */
  public ipamPoolId: string;

  /**
   * The netmask length of the CIDR you would like to allocate from the IPAM pool. Note the following:.
   */
  public netmaskLength?: number;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnIPAMAllocationProps) {
    super(scope, id, {
      "type": CfnIPAMAllocation.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "ipamPoolId", this);

    this.attrIpamPoolAllocationId = cdk.Token.asString(this.getAtt("IpamPoolAllocationId", cdk.ResolutionTypeHint.STRING));
    this.cidr = props.cidr;
    this.description = props.description;
    this.ipamPoolId = props.ipamPoolId;
    this.netmaskLength = props.netmaskLength;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "cidr": this.cidr,
      "description": this.description,
      "ipamPoolId": this.ipamPoolId,
      "netmaskLength": this.netmaskLength
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnIPAMAllocation.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnIPAMAllocationPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a `CfnIPAMAllocation`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamallocation.html
 */
export interface CfnIPAMAllocationProps {
  /**
   * The CIDR you would like to allocate from the IPAM pool. Note the following:.
   *
   * - If there is no DefaultNetmaskLength allocation rule set on the pool, you must specify either the NetmaskLength or the CIDR.
   * - If the DefaultNetmaskLength allocation rule is set on the pool, you can specify either the NetmaskLength or the CIDR and the DefaultNetmaskLength allocation rule will be ignored.
   *
   * Possible values: Any available IPv4 or IPv6 CIDR.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamallocation.html#cfn-ec2-ipamallocation-cidr
   */
  readonly cidr?: string;

  /**
   * A description for the allocation.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamallocation.html#cfn-ec2-ipamallocation-description
   */
  readonly description?: string;

  /**
   * The ID of the IPAM pool from which you would like to allocate a CIDR.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamallocation.html#cfn-ec2-ipamallocation-ipampoolid
   */
  readonly ipamPoolId: string;

  /**
   * The netmask length of the CIDR you would like to allocate from the IPAM pool. Note the following:.
   *
   * - If there is no DefaultNetmaskLength allocation rule set on the pool, you must specify either the NetmaskLength or the CIDR.
   * - If the DefaultNetmaskLength allocation rule is set on the pool, you can specify either the NetmaskLength or the CIDR and the DefaultNetmaskLength allocation rule will be ignored.
   *
   * Possible netmask lengths for IPv4 addresses are 0 - 32. Possible netmask lengths for IPv6 addresses are 0 - 128.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamallocation.html#cfn-ec2-ipamallocation-netmasklength
   */
  readonly netmaskLength?: number;
}

/**
 * Determine whether the given properties match those of a `CfnIPAMAllocationProps`
 *
 * @param properties - the TypeScript properties of a `CfnIPAMAllocationProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnIPAMAllocationPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("cidr", cdk.validateString)(properties.cidr));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("ipamPoolId", cdk.requiredValidator)(properties.ipamPoolId));
  errors.collect(cdk.propertyValidator("ipamPoolId", cdk.validateString)(properties.ipamPoolId));
  errors.collect(cdk.propertyValidator("netmaskLength", cdk.validateNumber)(properties.netmaskLength));
  return errors.wrap("supplied properties not correct for \"CfnIPAMAllocationProps\"");
}

// @ts-ignore TS6133
function convertCfnIPAMAllocationPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnIPAMAllocationPropsValidator(properties).assertSuccess();
  return {
    "Cidr": cdk.stringToCloudFormation(properties.cidr),
    "Description": cdk.stringToCloudFormation(properties.description),
    "IpamPoolId": cdk.stringToCloudFormation(properties.ipamPoolId),
    "NetmaskLength": cdk.numberToCloudFormation(properties.netmaskLength)
  };
}

// @ts-ignore TS6133
function CfnIPAMAllocationPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnIPAMAllocationProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnIPAMAllocationProps>();
  ret.addPropertyResult("cidr", "Cidr", (properties.Cidr != null ? cfn_parse.FromCloudFormation.getString(properties.Cidr) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("ipamPoolId", "IpamPoolId", (properties.IpamPoolId != null ? cfn_parse.FromCloudFormation.getString(properties.IpamPoolId) : undefined));
  ret.addPropertyResult("netmaskLength", "NetmaskLength", (properties.NetmaskLength != null ? cfn_parse.FromCloudFormation.getNumber(properties.NetmaskLength) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * In IPAM, a pool is a collection of contiguous IP addresses CIDRs.
 *
 * Pools enable you to organize your IP addresses according to your routing and security needs. For example, if you have separate routing and security needs for development and production applications, you can create a pool for each.
 *
 * @cloudformationResource AWS::EC2::IPAMPool
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html
 */
export class CfnIPAMPool extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::IPAMPool";

  /**
   * Build a CfnIPAMPool from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnIPAMPool {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnIPAMPoolPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnIPAMPool(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ARN of the IPAM pool.
   *
   * @cloudformationAttribute Arn
   */
  public readonly attrArn: string;

  /**
   * The ARN of the IPAM.
   *
   * @cloudformationAttribute IpamArn
   */
  public readonly attrIpamArn: string;

  /**
   * The ID of the IPAM pool.
   *
   * @cloudformationAttribute IpamPoolId
   */
  public readonly attrIpamPoolId: string;

  /**
   * The ARN of the scope of the IPAM pool.
   *
   * @cloudformationAttribute IpamScopeArn
   */
  public readonly attrIpamScopeArn: string;

  /**
   * The scope of the IPAM.
   *
   * @cloudformationAttribute IpamScopeType
   */
  public readonly attrIpamScopeType: string;

  /**
   * The depth of pools in your IPAM pool. The pool depth quota is 10.
   *
   * @cloudformationAttribute PoolDepth
   */
  public readonly attrPoolDepth: number;

  /**
   * The state of the IPAM pool.
   *
   * @cloudformationAttribute State
   */
  public readonly attrState: string;

  /**
   * A message related to the failed creation of an IPAM pool.
   *
   * @cloudformationAttribute StateMessage
   */
  public readonly attrStateMessage: string;

  /**
   * The address family of the pool.
   */
  public addressFamily: string;

  /**
   * The default netmask length for allocations added to this pool.
   */
  public allocationDefaultNetmaskLength?: number;

  /**
   * The maximum netmask length possible for CIDR allocations in this IPAM pool to be compliant.
   */
  public allocationMaxNetmaskLength?: number;

  /**
   * The minimum netmask length required for CIDR allocations in this IPAM pool to be compliant.
   */
  public allocationMinNetmaskLength?: number;

  /**
   * Tags that are required for resources that use CIDRs from this IPAM pool.
   */
  public allocationResourceTags?: Array<cdk.CfnTag | cdk.IResolvable> | cdk.IResolvable;

  /**
   * If selected, IPAM will continuously look for resources within the CIDR range of this pool and automatically import them as allocations into your IPAM.
   */
  public autoImport?: boolean | cdk.IResolvable;

  /**
   * Limits which service in AWS that the pool can be used in.
   */
  public awsService?: string;

  /**
   * The description of the IPAM pool.
   */
  public description?: string;

  /**
   * The ID of the scope in which you would like to create the IPAM pool.
   */
  public ipamScopeId: string;

  /**
   * The locale of the IPAM pool.
   */
  public locale?: string;

  /**
   * Information about the CIDRs provisioned to an IPAM pool.
   */
  public provisionedCidrs?: Array<cdk.IResolvable | CfnIPAMPool.ProvisionedCidrProperty> | cdk.IResolvable;

  /**
   * The IP address source for pools in the public scope.
   */
  public publicIpSource?: string;

  /**
   * Determines if a pool is publicly advertisable.
   */
  public publiclyAdvertisable?: boolean | cdk.IResolvable;

  /**
   * The ID of the source IPAM pool.
   */
  public sourceIpamPoolId?: string;

  /**
   * The resource associated with this pool's space.
   */
  public sourceResource?: cdk.IResolvable | CfnIPAMPool.SourceResourceProperty;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The key/value combination of a tag assigned to the resource.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnIPAMPoolProps) {
    super(scope, id, {
      "type": CfnIPAMPool.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "addressFamily", this);
    cdk.requireProperty(props, "ipamScopeId", this);

    this.attrArn = cdk.Token.asString(this.getAtt("Arn", cdk.ResolutionTypeHint.STRING));
    this.attrIpamArn = cdk.Token.asString(this.getAtt("IpamArn", cdk.ResolutionTypeHint.STRING));
    this.attrIpamPoolId = cdk.Token.asString(this.getAtt("IpamPoolId", cdk.ResolutionTypeHint.STRING));
    this.attrIpamScopeArn = cdk.Token.asString(this.getAtt("IpamScopeArn", cdk.ResolutionTypeHint.STRING));
    this.attrIpamScopeType = cdk.Token.asString(this.getAtt("IpamScopeType", cdk.ResolutionTypeHint.STRING));
    this.attrPoolDepth = cdk.Token.asNumber(this.getAtt("PoolDepth", cdk.ResolutionTypeHint.NUMBER));
    this.attrState = cdk.Token.asString(this.getAtt("State", cdk.ResolutionTypeHint.STRING));
    this.attrStateMessage = cdk.Token.asString(this.getAtt("StateMessage", cdk.ResolutionTypeHint.STRING));
    this.addressFamily = props.addressFamily;
    this.allocationDefaultNetmaskLength = props.allocationDefaultNetmaskLength;
    this.allocationMaxNetmaskLength = props.allocationMaxNetmaskLength;
    this.allocationMinNetmaskLength = props.allocationMinNetmaskLength;
    this.allocationResourceTags = props.allocationResourceTags;
    this.autoImport = props.autoImport;
    this.awsService = props.awsService;
    this.description = props.description;
    this.ipamScopeId = props.ipamScopeId;
    this.locale = props.locale;
    this.provisionedCidrs = props.provisionedCidrs;
    this.publicIpSource = props.publicIpSource;
    this.publiclyAdvertisable = props.publiclyAdvertisable;
    this.sourceIpamPoolId = props.sourceIpamPoolId;
    this.sourceResource = props.sourceResource;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::IPAMPool", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "addressFamily": this.addressFamily,
      "allocationDefaultNetmaskLength": this.allocationDefaultNetmaskLength,
      "allocationMaxNetmaskLength": this.allocationMaxNetmaskLength,
      "allocationMinNetmaskLength": this.allocationMinNetmaskLength,
      "allocationResourceTags": this.allocationResourceTags,
      "autoImport": this.autoImport,
      "awsService": this.awsService,
      "description": this.description,
      "ipamScopeId": this.ipamScopeId,
      "locale": this.locale,
      "provisionedCidrs": this.provisionedCidrs,
      "publicIpSource": this.publicIpSource,
      "publiclyAdvertisable": this.publiclyAdvertisable,
      "sourceIpamPoolId": this.sourceIpamPoolId,
      "sourceResource": this.sourceResource,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnIPAMPool.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnIPAMPoolPropsToCloudFormation(props);
  }
}

export namespace CfnIPAMPool {
  /**
   * The CIDR provisioned to the IPAM pool.
   *
   * A CIDR is a representation of an IP address and its associated network mask (or netmask) and refers to a range of IP addresses. An IPv4 CIDR example is `10.24.34.0/23` . An IPv6 CIDR example is `2001:DB8::/32` .
   *
   * > This resource type does not allow you to provision a CIDR using the netmask length. To provision a CIDR using netmask length, use [AWS::EC2::IPAMPoolCidr](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampoolcidr.html) .
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipampool-provisionedcidr.html
   */
  export interface ProvisionedCidrProperty {
    /**
     * The CIDR provisioned to the IPAM pool.
     *
     * A CIDR is a representation of an IP address and its associated network mask (or netmask) and refers to a range of IP addresses. An IPv4 CIDR example is `10.24.34.0/23` . An IPv6 CIDR example is `2001:DB8::/32` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipampool-provisionedcidr.html#cfn-ec2-ipampool-provisionedcidr-cidr
     */
    readonly cidr: string;
  }

  /**
   * The resource associated with this pool's space.
   *
   * Depending on the ResourceType, setting a SourceResource changes which space can be provisioned in this pool and which types of resources can receive allocations
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipampool-sourceresource.html
   */
  export interface SourceResourceProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipampool-sourceresource.html#cfn-ec2-ipampool-sourceresource-resourceid
     */
    readonly resourceId: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipampool-sourceresource.html#cfn-ec2-ipampool-sourceresource-resourceowner
     */
    readonly resourceOwner: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipampool-sourceresource.html#cfn-ec2-ipampool-sourceresource-resourceregion
     */
    readonly resourceRegion: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipampool-sourceresource.html#cfn-ec2-ipampool-sourceresource-resourcetype
     */
    readonly resourceType: string;
  }
}

/**
 * Properties for defining a `CfnIPAMPool`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html
 */
export interface CfnIPAMPoolProps {
  /**
   * The address family of the pool.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-addressfamily
   */
  readonly addressFamily: string;

  /**
   * The default netmask length for allocations added to this pool.
   *
   * If, for example, the CIDR assigned to this pool is 10.0.0.0/8 and you enter 16 here, new allocations will default to 10.0.0.0/16.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-allocationdefaultnetmasklength
   */
  readonly allocationDefaultNetmaskLength?: number;

  /**
   * The maximum netmask length possible for CIDR allocations in this IPAM pool to be compliant.
   *
   * The maximum netmask length must be greater than the minimum netmask length. Possible netmask lengths for IPv4 addresses are 0 - 32. Possible netmask lengths for IPv6 addresses are 0 - 128.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-allocationmaxnetmasklength
   */
  readonly allocationMaxNetmaskLength?: number;

  /**
   * The minimum netmask length required for CIDR allocations in this IPAM pool to be compliant.
   *
   * The minimum netmask length must be less than the maximum netmask length. Possible netmask lengths for IPv4 addresses are 0 - 32. Possible netmask lengths for IPv6 addresses are 0 - 128.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-allocationminnetmasklength
   */
  readonly allocationMinNetmaskLength?: number;

  /**
   * Tags that are required for resources that use CIDRs from this IPAM pool.
   *
   * Resources that do not have these tags will not be allowed to allocate space from the pool. If the resources have their tags changed after they have allocated space or if the allocation tagging requirements are changed on the pool, the resource may be marked as noncompliant.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-allocationresourcetags
   */
  readonly allocationResourceTags?: Array<cdk.CfnTag | cdk.IResolvable> | cdk.IResolvable;

  /**
   * If selected, IPAM will continuously look for resources within the CIDR range of this pool and automatically import them as allocations into your IPAM.
   *
   * The CIDRs that will be allocated for these resources must not already be allocated to other resources in order for the import to succeed. IPAM will import a CIDR regardless of its compliance with the pool's allocation rules, so a resource might be imported and subsequently marked as noncompliant. If IPAM discovers multiple CIDRs that overlap, IPAM will import the largest CIDR only. If IPAM discovers multiple CIDRs with matching CIDRs, IPAM will randomly import one of them only.
   *
   * A locale must be set on the pool for this feature to work.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-autoimport
   */
  readonly autoImport?: boolean | cdk.IResolvable;

  /**
   * Limits which service in AWS that the pool can be used in.
   *
   * "ec2", for example, allows users to use space for Elastic IP addresses and VPCs.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-awsservice
   */
  readonly awsService?: string;

  /**
   * The description of the IPAM pool.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-description
   */
  readonly description?: string;

  /**
   * The ID of the scope in which you would like to create the IPAM pool.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-ipamscopeid
   */
  readonly ipamScopeId: string;

  /**
   * The locale of the IPAM pool.
   *
   * In IPAM, the locale is the AWS Region where you want to make an IPAM pool available for allocations. Only resources in the same Region as the locale of the pool can get IP address allocations from the pool. You can only allocate a CIDR for a VPC, for example, from an IPAM pool that shares a locale with the VPCs Region. Note that once you choose a Locale for a pool, you cannot modify it. If you choose an AWS Region for locale that has not been configured as an operating Region for the IPAM, you'll get an error.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-locale
   */
  readonly locale?: string;

  /**
   * Information about the CIDRs provisioned to an IPAM pool.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-provisionedcidrs
   */
  readonly provisionedCidrs?: Array<cdk.IResolvable | CfnIPAMPool.ProvisionedCidrProperty> | cdk.IResolvable;

  /**
   * The IP address source for pools in the public scope.
   *
   * Only used for provisioning IP address CIDRs to pools in the public scope. Default is `BYOIP` . For more information, see [Create IPv6 pools](https://docs.aws.amazon.com//vpc/latest/ipam/intro-create-ipv6-pools.html) in the *Amazon VPC IPAM User Guide* . By default, you can add only one Amazon-provided IPv6 CIDR block to a top-level IPv6 pool. For information on increasing the default limit, see [Quotas for your IPAM](https://docs.aws.amazon.com//vpc/latest/ipam/quotas-ipam.html) in the *Amazon VPC IPAM User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-publicipsource
   */
  readonly publicIpSource?: string;

  /**
   * Determines if a pool is publicly advertisable.
   *
   * This option is not available for pools with AddressFamily set to `ipv4` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-publiclyadvertisable
   */
  readonly publiclyAdvertisable?: boolean | cdk.IResolvable;

  /**
   * The ID of the source IPAM pool.
   *
   * You can use this option to create an IPAM pool within an existing source pool.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-sourceipampoolid
   */
  readonly sourceIpamPoolId?: string;

  /**
   * The resource associated with this pool's space.
   *
   * Depending on the ResourceType, setting a SourceResource changes which space can be provisioned in this pool and which types of resources can receive allocations
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-sourceresource
   */
  readonly sourceResource?: cdk.IResolvable | CfnIPAMPool.SourceResourceProperty;

  /**
   * The key/value combination of a tag assigned to the resource.
   *
   * Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key `Owner` and the value `TeamA` , specify `tag:Owner` for the filter name and `TeamA` for the filter value.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a `ProvisionedCidrProperty`
 *
 * @param properties - the TypeScript properties of a `ProvisionedCidrProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnIPAMPoolProvisionedCidrPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("cidr", cdk.requiredValidator)(properties.cidr));
  errors.collect(cdk.propertyValidator("cidr", cdk.validateString)(properties.cidr));
  return errors.wrap("supplied properties not correct for \"ProvisionedCidrProperty\"");
}

// @ts-ignore TS6133
function convertCfnIPAMPoolProvisionedCidrPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnIPAMPoolProvisionedCidrPropertyValidator(properties).assertSuccess();
  return {
    "Cidr": cdk.stringToCloudFormation(properties.cidr)
  };
}

// @ts-ignore TS6133
function CfnIPAMPoolProvisionedCidrPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnIPAMPool.ProvisionedCidrProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnIPAMPool.ProvisionedCidrProperty>();
  ret.addPropertyResult("cidr", "Cidr", (properties.Cidr != null ? cfn_parse.FromCloudFormation.getString(properties.Cidr) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `SourceResourceProperty`
 *
 * @param properties - the TypeScript properties of a `SourceResourceProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnIPAMPoolSourceResourcePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("resourceId", cdk.requiredValidator)(properties.resourceId));
  errors.collect(cdk.propertyValidator("resourceId", cdk.validateString)(properties.resourceId));
  errors.collect(cdk.propertyValidator("resourceOwner", cdk.requiredValidator)(properties.resourceOwner));
  errors.collect(cdk.propertyValidator("resourceOwner", cdk.validateString)(properties.resourceOwner));
  errors.collect(cdk.propertyValidator("resourceRegion", cdk.requiredValidator)(properties.resourceRegion));
  errors.collect(cdk.propertyValidator("resourceRegion", cdk.validateString)(properties.resourceRegion));
  errors.collect(cdk.propertyValidator("resourceType", cdk.requiredValidator)(properties.resourceType));
  errors.collect(cdk.propertyValidator("resourceType", cdk.validateString)(properties.resourceType));
  return errors.wrap("supplied properties not correct for \"SourceResourceProperty\"");
}

// @ts-ignore TS6133
function convertCfnIPAMPoolSourceResourcePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnIPAMPoolSourceResourcePropertyValidator(properties).assertSuccess();
  return {
    "ResourceId": cdk.stringToCloudFormation(properties.resourceId),
    "ResourceOwner": cdk.stringToCloudFormation(properties.resourceOwner),
    "ResourceRegion": cdk.stringToCloudFormation(properties.resourceRegion),
    "ResourceType": cdk.stringToCloudFormation(properties.resourceType)
  };
}

// @ts-ignore TS6133
function CfnIPAMPoolSourceResourcePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnIPAMPool.SourceResourceProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnIPAMPool.SourceResourceProperty>();
  ret.addPropertyResult("resourceId", "ResourceId", (properties.ResourceId != null ? cfn_parse.FromCloudFormation.getString(properties.ResourceId) : undefined));
  ret.addPropertyResult("resourceOwner", "ResourceOwner", (properties.ResourceOwner != null ? cfn_parse.FromCloudFormation.getString(properties.ResourceOwner) : undefined));
  ret.addPropertyResult("resourceRegion", "ResourceRegion", (properties.ResourceRegion != null ? cfn_parse.FromCloudFormation.getString(properties.ResourceRegion) : undefined));
  ret.addPropertyResult("resourceType", "ResourceType", (properties.ResourceType != null ? cfn_parse.FromCloudFormation.getString(properties.ResourceType) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `CfnIPAMPoolProps`
 *
 * @param properties - the TypeScript properties of a `CfnIPAMPoolProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnIPAMPoolPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("addressFamily", cdk.requiredValidator)(properties.addressFamily));
  errors.collect(cdk.propertyValidator("addressFamily", cdk.validateString)(properties.addressFamily));
  errors.collect(cdk.propertyValidator("allocationDefaultNetmaskLength", cdk.validateNumber)(properties.allocationDefaultNetmaskLength));
  errors.collect(cdk.propertyValidator("allocationMaxNetmaskLength", cdk.validateNumber)(properties.allocationMaxNetmaskLength));
  errors.collect(cdk.propertyValidator("allocationMinNetmaskLength", cdk.validateNumber)(properties.allocationMinNetmaskLength));
  errors.collect(cdk.propertyValidator("allocationResourceTags", cdk.listValidator(cdk.validateCfnTag))(properties.allocationResourceTags));
  errors.collect(cdk.propertyValidator("autoImport", cdk.validateBoolean)(properties.autoImport));
  errors.collect(cdk.propertyValidator("awsService", cdk.validateString)(properties.awsService));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("ipamScopeId", cdk.requiredValidator)(properties.ipamScopeId));
  errors.collect(cdk.propertyValidator("ipamScopeId", cdk.validateString)(properties.ipamScopeId));
  errors.collect(cdk.propertyValidator("locale", cdk.validateString)(properties.locale));
  errors.collect(cdk.propertyValidator("provisionedCidrs", cdk.listValidator(CfnIPAMPoolProvisionedCidrPropertyValidator))(properties.provisionedCidrs));
  errors.collect(cdk.propertyValidator("publicIpSource", cdk.validateString)(properties.publicIpSource));
  errors.collect(cdk.propertyValidator("publiclyAdvertisable", cdk.validateBoolean)(properties.publiclyAdvertisable));
  errors.collect(cdk.propertyValidator("sourceIpamPoolId", cdk.validateString)(properties.sourceIpamPoolId));
  errors.collect(cdk.propertyValidator("sourceResource", CfnIPAMPoolSourceResourcePropertyValidator)(properties.sourceResource));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \"CfnIPAMPoolProps\"");
}

// @ts-ignore TS6133
function convertCfnIPAMPoolPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnIPAMPoolPropsValidator(properties).assertSuccess();
  return {
    "AddressFamily": cdk.stringToCloudFormation(properties.addressFamily),
    "AllocationDefaultNetmaskLength": cdk.numberToCloudFormation(properties.allocationDefaultNetmaskLength),
    "AllocationMaxNetmaskLength": cdk.numberToCloudFormation(properties.allocationMaxNetmaskLength),
    "AllocationMinNetmaskLength": cdk.numberToCloudFormation(properties.allocationMinNetmaskLength),
    "AllocationResourceTags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.allocationResourceTags),
    "AutoImport": cdk.booleanToCloudFormation(properties.autoImport),
    "AwsService": cdk.stringToCloudFormation(properties.awsService),
    "Description": cdk.stringToCloudFormation(properties.description),
    "IpamScopeId": cdk.stringToCloudFormation(properties.ipamScopeId),
    "Locale": cdk.stringToCloudFormation(properties.locale),
    "ProvisionedCidrs": cdk.listMapper(convertCfnIPAMPoolProvisionedCidrPropertyToCloudFormation)(properties.provisionedCidrs),
    "PublicIpSource": cdk.stringToCloudFormation(properties.publicIpSource),
    "PubliclyAdvertisable": cdk.booleanToCloudFormation(properties.publiclyAdvertisable),
    "SourceIpamPoolId": cdk.stringToCloudFormation(properties.sourceIpamPoolId),
    "SourceResource": convertCfnIPAMPoolSourceResourcePropertyToCloudFormation(properties.sourceResource),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnIPAMPoolPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnIPAMPoolProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnIPAMPoolProps>();
  ret.addPropertyResult("addressFamily", "AddressFamily", (properties.AddressFamily != null ? cfn_parse.FromCloudFormation.getString(properties.AddressFamily) : undefined));
  ret.addPropertyResult("allocationDefaultNetmaskLength", "AllocationDefaultNetmaskLength", (properties.AllocationDefaultNetmaskLength != null ? cfn_parse.FromCloudFormation.getNumber(properties.AllocationDefaultNetmaskLength) : undefined));
  ret.addPropertyResult("allocationMaxNetmaskLength", "AllocationMaxNetmaskLength", (properties.AllocationMaxNetmaskLength != null ? cfn_parse.FromCloudFormation.getNumber(properties.AllocationMaxNetmaskLength) : undefined));
  ret.addPropertyResult("allocationMinNetmaskLength", "AllocationMinNetmaskLength", (properties.AllocationMinNetmaskLength != null ? cfn_parse.FromCloudFormation.getNumber(properties.AllocationMinNetmaskLength) : undefined));
  ret.addPropertyResult("allocationResourceTags", "AllocationResourceTags", (properties.AllocationResourceTags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.AllocationResourceTags) : undefined));
  ret.addPropertyResult("autoImport", "AutoImport", (properties.AutoImport != null ? cfn_parse.FromCloudFormation.getBoolean(properties.AutoImport) : undefined));
  ret.addPropertyResult("awsService", "AwsService", (properties.AwsService != null ? cfn_parse.FromCloudFormation.getString(properties.AwsService) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("ipamScopeId", "IpamScopeId", (properties.IpamScopeId != null ? cfn_parse.FromCloudFormation.getString(properties.IpamScopeId) : undefined));
  ret.addPropertyResult("locale", "Locale", (properties.Locale != null ? cfn_parse.FromCloudFormation.getString(properties.Locale) : undefined));
  ret.addPropertyResult("provisionedCidrs", "ProvisionedCidrs", (properties.ProvisionedCidrs != null ? cfn_parse.FromCloudFormation.getArray(CfnIPAMPoolProvisionedCidrPropertyFromCloudFormation)(properties.ProvisionedCidrs) : undefined));
  ret.addPropertyResult("publicIpSource", "PublicIpSource", (properties.PublicIpSource != null ? cfn_parse.FromCloudFormation.getString(properties.PublicIpSource) : undefined));
  ret.addPropertyResult("publiclyAdvertisable", "PubliclyAdvertisable", (properties.PubliclyAdvertisable != null ? cfn_parse.FromCloudFormation.getBoolean(properties.PubliclyAdvertisable) : undefined));
  ret.addPropertyResult("sourceIpamPoolId", "SourceIpamPoolId", (properties.SourceIpamPoolId != null ? cfn_parse.FromCloudFormation.getString(properties.SourceIpamPoolId) : undefined));
  ret.addPropertyResult("sourceResource", "SourceResource", (properties.SourceResource != null ? CfnIPAMPoolSourceResourcePropertyFromCloudFormation(properties.SourceResource) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * A CIDR provisioned to an IPAM pool.
 *
 * @cloudformationResource AWS::EC2::IPAMPoolCidr
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampoolcidr.html
 */
export class CfnIPAMPoolCidr extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::IPAMPoolCidr";

  /**
   * Build a CfnIPAMPoolCidr from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnIPAMPoolCidr {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnIPAMPoolCidrPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnIPAMPoolCidr(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The IPAM pool CIDR ID.
   *
   * @cloudformationAttribute IpamPoolCidrId
   */
  public readonly attrIpamPoolCidrId: string;

  /**
   * The state of the CIDR.
   *
   * @cloudformationAttribute State
   */
  public readonly attrState: string;

  /**
   * The CIDR provisioned to the IPAM pool.
   */
  public cidr?: string;

  /**
   * The ID of the IPAM pool.
   */
  public ipamPoolId: string;

  /**
   * The netmask length of the CIDR you'd like to provision to a pool.
   */
  public netmaskLength?: number;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnIPAMPoolCidrProps) {
    super(scope, id, {
      "type": CfnIPAMPoolCidr.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "ipamPoolId", this);

    this.attrIpamPoolCidrId = cdk.Token.asString(this.getAtt("IpamPoolCidrId", cdk.ResolutionTypeHint.STRING));
    this.attrState = cdk.Token.asString(this.getAtt("State", cdk.ResolutionTypeHint.STRING));
    this.cidr = props.cidr;
    this.ipamPoolId = props.ipamPoolId;
    this.netmaskLength = props.netmaskLength;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "cidr": this.cidr,
      "ipamPoolId": this.ipamPoolId,
      "netmaskLength": this.netmaskLength
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnIPAMPoolCidr.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnIPAMPoolCidrPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a `CfnIPAMPoolCidr`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampoolcidr.html
 */
export interface CfnIPAMPoolCidrProps {
  /**
   * The CIDR provisioned to the IPAM pool.
   *
   * A CIDR is a representation of an IP address and its associated network mask (or netmask) and refers to a range of IP addresses. An IPv4 CIDR example is `10.24.34.0/23` . An IPv6 CIDR example is `2001:DB8::/32` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampoolcidr.html#cfn-ec2-ipampoolcidr-cidr
   */
  readonly cidr?: string;

  /**
   * The ID of the IPAM pool.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampoolcidr.html#cfn-ec2-ipampoolcidr-ipampoolid
   */
  readonly ipamPoolId: string;

  /**
   * The netmask length of the CIDR you'd like to provision to a pool.
   *
   * Can be used for provisioning Amazon-provided IPv6 CIDRs to top-level pools and for provisioning CIDRs to pools with source pools. Cannot be used to provision BYOIP CIDRs to top-level pools. "NetmaskLength" or "Cidr" is required.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampoolcidr.html#cfn-ec2-ipampoolcidr-netmasklength
   */
  readonly netmaskLength?: number;
}

/**
 * Determine whether the given properties match those of a `CfnIPAMPoolCidrProps`
 *
 * @param properties - the TypeScript properties of a `CfnIPAMPoolCidrProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnIPAMPoolCidrPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("cidr", cdk.validateString)(properties.cidr));
  errors.collect(cdk.propertyValidator("ipamPoolId", cdk.requiredValidator)(properties.ipamPoolId));
  errors.collect(cdk.propertyValidator("ipamPoolId", cdk.validateString)(properties.ipamPoolId));
  errors.collect(cdk.propertyValidator("netmaskLength", cdk.validateNumber)(properties.netmaskLength));
  return errors.wrap("supplied properties not correct for \"CfnIPAMPoolCidrProps\"");
}

// @ts-ignore TS6133
function convertCfnIPAMPoolCidrPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnIPAMPoolCidrPropsValidator(properties).assertSuccess();
  return {
    "Cidr": cdk.stringToCloudFormation(properties.cidr),
    "IpamPoolId": cdk.stringToCloudFormation(properties.ipamPoolId),
    "NetmaskLength": cdk.numberToCloudFormation(properties.netmaskLength)
  };
}

// @ts-ignore TS6133
function CfnIPAMPoolCidrPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnIPAMPoolCidrProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnIPAMPoolCidrProps>();
  ret.addPropertyResult("cidr", "Cidr", (properties.Cidr != null ? cfn_parse.FromCloudFormation.getString(properties.Cidr) : undefined));
  ret.addPropertyResult("ipamPoolId", "IpamPoolId", (properties.IpamPoolId != null ? cfn_parse.FromCloudFormation.getString(properties.IpamPoolId) : undefined));
  ret.addPropertyResult("netmaskLength", "NetmaskLength", (properties.NetmaskLength != null ? cfn_parse.FromCloudFormation.getNumber(properties.NetmaskLength) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * A resource discovery is an IPAM component that enables IPAM to manage and monitor resources that belong to the owning account.
 *
 * @cloudformationResource AWS::EC2::IPAMResourceDiscovery
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamresourcediscovery.html
 */
export class CfnIPAMResourceDiscovery extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::IPAMResourceDiscovery";

  /**
   * Build a CfnIPAMResourceDiscovery from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnIPAMResourceDiscovery {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnIPAMResourceDiscoveryPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnIPAMResourceDiscovery(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The resource discovery ARN.
   *
   * @cloudformationAttribute IpamResourceDiscoveryArn
   */
  public readonly attrIpamResourceDiscoveryArn: string;

  /**
   * The resource discovery ID.
   *
   * @cloudformationAttribute IpamResourceDiscoveryId
   */
  public readonly attrIpamResourceDiscoveryId: string;

  /**
   * The resource discovery Region.
   *
   * @cloudformationAttribute IpamResourceDiscoveryRegion
   */
  public readonly attrIpamResourceDiscoveryRegion: string;

  /**
   * Defines if the resource discovery is the default. The default resource discovery is the resource discovery automatically created when you create an IPAM.
   *
   * @cloudformationAttribute IsDefault
   */
  public readonly attrIsDefault: cdk.IResolvable;

  /**
   * The owner ID.
   *
   * @cloudformationAttribute OwnerId
   */
  public readonly attrOwnerId: string;

  /**
   * The resource discovery's state.
   *
   * - `create-in-progress` - Resource discovery is being created.
   * - `create-complete` - Resource discovery creation is complete.
   * - `create-failed` - Resource discovery creation has failed.
   * - `modify-in-progress` - Resource discovery is being modified.
   * - `modify-complete` - Resource discovery modification is complete.
   * - `modify-failed` - Resource discovery modification has failed.
   * - `delete-in-progress` - Resource discovery is being deleted.
   * - `delete-complete` - Resource discovery deletion is complete.
   * - `delete-failed` - Resource discovery deletion has failed.
   * - `isolate-in-progress` - AWS account that created the resource discovery has been removed and the resource discovery is being isolated.
   * - `isolate-complete` - Resource discovery isolation is complete.
   * - `restore-in-progress` - AWS account that created the resource discovery and was isolated has been restored.
   *
   * @cloudformationAttribute State
   */
  public readonly attrState: string;

  /**
   * The resource discovery description.
   */
  public description?: string;

  /**
   * The operating Regions for the resource discovery.
   */
  public operatingRegions?: Array<CfnIPAMResourceDiscovery.IpamOperatingRegionProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * A tag is a label that you assign to an AWS resource.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnIPAMResourceDiscoveryProps = {}) {
    super(scope, id, {
      "type": CfnIPAMResourceDiscovery.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.attrIpamResourceDiscoveryArn = cdk.Token.asString(this.getAtt("IpamResourceDiscoveryArn", cdk.ResolutionTypeHint.STRING));
    this.attrIpamResourceDiscoveryId = cdk.Token.asString(this.getAtt("IpamResourceDiscoveryId", cdk.ResolutionTypeHint.STRING));
    this.attrIpamResourceDiscoveryRegion = cdk.Token.asString(this.getAtt("IpamResourceDiscoveryRegion", cdk.ResolutionTypeHint.STRING));
    this.attrIsDefault = this.getAtt("IsDefault");
    this.attrOwnerId = cdk.Token.asString(this.getAtt("OwnerId", cdk.ResolutionTypeHint.STRING));
    this.attrState = cdk.Token.asString(this.getAtt("State", cdk.ResolutionTypeHint.STRING));
    this.description = props.description;
    this.operatingRegions = props.operatingRegions;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::IPAMResourceDiscovery", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "description": this.description,
      "operatingRegions": this.operatingRegions,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnIPAMResourceDiscovery.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnIPAMResourceDiscoveryPropsToCloudFormation(props);
  }
}

export namespace CfnIPAMResourceDiscovery {
  /**
   * The operating Regions for an IPAM.
   *
   * Operating Regions are AWS Regions where the IPAM is allowed to manage IP address CIDRs. IPAM only discovers and monitors resources in the AWS Regions you select as operating Regions.
   *
   * For more information about operating Regions, see [Create an IPAM](https://docs.aws.amazon.com//vpc/latest/ipam/create-ipam.html) in the *Amazon VPC IPAM User Guide* .
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipamresourcediscovery-ipamoperatingregion.html
   */
  export interface IpamOperatingRegionProperty {
    /**
     * The name of the operating Region.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipamresourcediscovery-ipamoperatingregion.html#cfn-ec2-ipamresourcediscovery-ipamoperatingregion-regionname
     */
    readonly regionName: string;
  }
}

/**
 * Properties for defining a `CfnIPAMResourceDiscovery`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamresourcediscovery.html
 */
export interface CfnIPAMResourceDiscoveryProps {
  /**
   * The resource discovery description.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamresourcediscovery.html#cfn-ec2-ipamresourcediscovery-description
   */
  readonly description?: string;

  /**
   * The operating Regions for the resource discovery.
   *
   * Operating Regions are AWS Regions where the IPAM is allowed to manage IP address CIDRs. IPAM only discovers and monitors resources in the AWS Regions you select as operating Regions.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamresourcediscovery.html#cfn-ec2-ipamresourcediscovery-operatingregions
   */
  readonly operatingRegions?: Array<CfnIPAMResourceDiscovery.IpamOperatingRegionProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * A tag is a label that you assign to an AWS resource.
   *
   * Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your AWS costs.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamresourcediscovery.html#cfn-ec2-ipamresourcediscovery-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a `IpamOperatingRegionProperty`
 *
 * @param properties - the TypeScript properties of a `IpamOperatingRegionProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnIPAMResourceDiscoveryIpamOperatingRegionPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("regionName", cdk.requiredValidator)(properties.regionName));
  errors.collect(cdk.propertyValidator("regionName", cdk.validateString)(properties.regionName));
  return errors.wrap("supplied properties not correct for \"IpamOperatingRegionProperty\"");
}

// @ts-ignore TS6133
function convertCfnIPAMResourceDiscoveryIpamOperatingRegionPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnIPAMResourceDiscoveryIpamOperatingRegionPropertyValidator(properties).assertSuccess();
  return {
    "RegionName": cdk.stringToCloudFormation(properties.regionName)
  };
}

// @ts-ignore TS6133
function CfnIPAMResourceDiscoveryIpamOperatingRegionPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnIPAMResourceDiscovery.IpamOperatingRegionProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnIPAMResourceDiscovery.IpamOperatingRegionProperty>();
  ret.addPropertyResult("regionName", "RegionName", (properties.RegionName != null ? cfn_parse.FromCloudFormation.getString(properties.RegionName) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `CfnIPAMResourceDiscoveryProps`
 *
 * @param properties - the TypeScript properties of a `CfnIPAMResourceDiscoveryProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnIPAMResourceDiscoveryPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("operatingRegions", cdk.listValidator(CfnIPAMResourceDiscoveryIpamOperatingRegionPropertyValidator))(properties.operatingRegions));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \"CfnIPAMResourceDiscoveryProps\"");
}

// @ts-ignore TS6133
function convertCfnIPAMResourceDiscoveryPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnIPAMResourceDiscoveryPropsValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "OperatingRegions": cdk.listMapper(convertCfnIPAMResourceDiscoveryIpamOperatingRegionPropertyToCloudFormation)(properties.operatingRegions),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnIPAMResourceDiscoveryPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnIPAMResourceDiscoveryProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnIPAMResourceDiscoveryProps>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("operatingRegions", "OperatingRegions", (properties.OperatingRegions != null ? cfn_parse.FromCloudFormation.getArray(CfnIPAMResourceDiscoveryIpamOperatingRegionPropertyFromCloudFormation)(properties.OperatingRegions) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * An IPAM resource discovery association.
 *
 * An associated resource discovery is a resource discovery that has been associated with an IPAM. IPAM aggregates the resource CIDRs discovered by the associated resource discovery.
 *
 * @cloudformationResource AWS::EC2::IPAMResourceDiscoveryAssociation
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamresourcediscoveryassociation.html
 */
export class CfnIPAMResourceDiscoveryAssociation extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::IPAMResourceDiscoveryAssociation";

  /**
   * Build a CfnIPAMResourceDiscoveryAssociation from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnIPAMResourceDiscoveryAssociation {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnIPAMResourceDiscoveryAssociationPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnIPAMResourceDiscoveryAssociation(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The IPAM ARN.
   *
   * @cloudformationAttribute IpamArn
   */
  public readonly attrIpamArn: string;

  /**
   * The IPAM home Region.
   *
   * @cloudformationAttribute IpamRegion
   */
  public readonly attrIpamRegion: string;

  /**
   * The resource discovery association ARN.
   *
   * @cloudformationAttribute IpamResourceDiscoveryAssociationArn
   */
  public readonly attrIpamResourceDiscoveryAssociationArn: string;

  /**
   * The resource discovery association ID.
   *
   * @cloudformationAttribute IpamResourceDiscoveryAssociationId
   */
  public readonly attrIpamResourceDiscoveryAssociationId: string;

  /**
   * Defines if the resource discovery is the default. When you create an IPAM, a default resource discovery is created for your IPAM and it's associated with your IPAM.
   *
   * @cloudformationAttribute IsDefault
   */
  public readonly attrIsDefault: cdk.IResolvable;

  /**
   * The owner ID.
   *
   * @cloudformationAttribute OwnerId
   */
  public readonly attrOwnerId: string;

  /**
   * The resource discovery status.
   *
   * - `active` - Connection or permissions required to read the results of the resource discovery are intact.
   * - `not-found` - Connection or permissions required to read the results of the resource discovery are broken. This may happen if the owner of the resource discovery stopped sharing it or deleted the resource discovery. Verify the resource discovery still exists and the AWS RAM resource share is still intact.
   *
   * @cloudformationAttribute ResourceDiscoveryStatus
   */
  public readonly attrResourceDiscoveryStatus: string;

  /**
   * The lifecycle state of the association when you associate or disassociate a resource discovery.
   *
   * - `associate-in-progress` - Resource discovery is being associated.
   * - `associate-complete` - Resource discovery association is complete.
   * - `associate-failed` - Resource discovery association has failed.
   * - `disassociate-in-progress` - Resource discovery is being disassociated.
   * - `disassociate-complete` - Resource discovery disassociation is complete.
   * - `disassociate-failed` - Resource discovery disassociation has failed.
   * - `isolate-in-progress` - AWS account that created the resource discovery association has been removed and the resource discovery associatation is being isolated.
   * - `isolate-complete` - Resource discovery isolation is complete..
   * - `restore-in-progress` - Resource discovery is being restored.
   *
   * @cloudformationAttribute State
   */
  public readonly attrState: string;

  /**
   * The IPAM ID.
   */
  public ipamId: string;

  /**
   * The resource discovery ID.
   */
  public ipamResourceDiscoveryId: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * A tag is a label that you assign to an AWS resource.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnIPAMResourceDiscoveryAssociationProps) {
    super(scope, id, {
      "type": CfnIPAMResourceDiscoveryAssociation.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "ipamId", this);
    cdk.requireProperty(props, "ipamResourceDiscoveryId", this);

    this.attrIpamArn = cdk.Token.asString(this.getAtt("IpamArn", cdk.ResolutionTypeHint.STRING));
    this.attrIpamRegion = cdk.Token.asString(this.getAtt("IpamRegion", cdk.ResolutionTypeHint.STRING));
    this.attrIpamResourceDiscoveryAssociationArn = cdk.Token.asString(this.getAtt("IpamResourceDiscoveryAssociationArn", cdk.ResolutionTypeHint.STRING));
    this.attrIpamResourceDiscoveryAssociationId = cdk.Token.asString(this.getAtt("IpamResourceDiscoveryAssociationId", cdk.ResolutionTypeHint.STRING));
    this.attrIsDefault = this.getAtt("IsDefault");
    this.attrOwnerId = cdk.Token.asString(this.getAtt("OwnerId", cdk.ResolutionTypeHint.STRING));
    this.attrResourceDiscoveryStatus = cdk.Token.asString(this.getAtt("ResourceDiscoveryStatus", cdk.ResolutionTypeHint.STRING));
    this.attrState = cdk.Token.asString(this.getAtt("State", cdk.ResolutionTypeHint.STRING));
    this.ipamId = props.ipamId;
    this.ipamResourceDiscoveryId = props.ipamResourceDiscoveryId;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::IPAMResourceDiscoveryAssociation", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "ipamId": this.ipamId,
      "ipamResourceDiscoveryId": this.ipamResourceDiscoveryId,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnIPAMResourceDiscoveryAssociation.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnIPAMResourceDiscoveryAssociationPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a `CfnIPAMResourceDiscoveryAssociation`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamresourcediscoveryassociation.html
 */
export interface CfnIPAMResourceDiscoveryAssociationProps {
  /**
   * The IPAM ID.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamresourcediscoveryassociation.html#cfn-ec2-ipamresourcediscoveryassociation-ipamid
   */
  readonly ipamId: string;

  /**
   * The resource discovery ID.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamresourcediscoveryassociation.html#cfn-ec2-ipamresourcediscoveryassociation-ipamresourcediscoveryid
   */
  readonly ipamResourceDiscoveryId: string;

  /**
   * A tag is a label that you assign to an AWS resource.
   *
   * Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your AWS costs.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamresourcediscoveryassociation.html#cfn-ec2-ipamresourcediscoveryassociation-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a `CfnIPAMResourceDiscoveryAssociationProps`
 *
 * @param properties - the TypeScript properties of a `CfnIPAMResourceDiscoveryAssociationProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnIPAMResourceDiscoveryAssociationPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("ipamId", cdk.requiredValidator)(properties.ipamId));
  errors.collect(cdk.propertyValidator("ipamId", cdk.validateString)(properties.ipamId));
  errors.collect(cdk.propertyValidator("ipamResourceDiscoveryId", cdk.requiredValidator)(properties.ipamResourceDiscoveryId));
  errors.collect(cdk.propertyValidator("ipamResourceDiscoveryId", cdk.validateString)(properties.ipamResourceDiscoveryId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \"CfnIPAMResourceDiscoveryAssociationProps\"");
}

// @ts-ignore TS6133
function convertCfnIPAMResourceDiscoveryAssociationPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnIPAMResourceDiscoveryAssociationPropsValidator(properties).assertSuccess();
  return {
    "IpamId": cdk.stringToCloudFormation(properties.ipamId),
    "IpamResourceDiscoveryId": cdk.stringToCloudFormation(properties.ipamResourceDiscoveryId),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnIPAMResourceDiscoveryAssociationPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnIPAMResourceDiscoveryAssociationProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnIPAMResourceDiscoveryAssociationProps>();
  ret.addPropertyResult("ipamId", "IpamId", (properties.IpamId != null ? cfn_parse.FromCloudFormation.getString(properties.IpamId) : undefined));
  ret.addPropertyResult("ipamResourceDiscoveryId", "IpamResourceDiscoveryId", (properties.IpamResourceDiscoveryId != null ? cfn_parse.FromCloudFormation.getString(properties.IpamResourceDiscoveryId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * In IPAM, a scope is the highest-level container within IPAM.
 *
 * An IPAM contains two default scopes. Each scope represents the IP space for a single network. The private scope is intended for all private IP address space. The public scope is intended for all public IP address space. Scopes enable you to reuse IP addresses across multiple unconnected networks without causing IP address overlap or conflict.
 *
 * For more information, see [How IPAM works](https://docs.aws.amazon.com//vpc/latest/ipam/how-it-works-ipam.html) in the *Amazon VPC IPAM User Guide* .
 *
 * @cloudformationResource AWS::EC2::IPAMScope
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamscope.html
 */
export class CfnIPAMScope extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::IPAMScope";

  /**
   * Build a CfnIPAMScope from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnIPAMScope {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnIPAMScopePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnIPAMScope(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ARN of the scope.
   *
   * @cloudformationAttribute Arn
   */
  public readonly attrArn: string;

  /**
   * The ARN of an IPAM.
   *
   * @cloudformationAttribute IpamArn
   */
  public readonly attrIpamArn: string;

  /**
   * The ID of an IPAM scope.
   *
   * @cloudformationAttribute IpamScopeId
   */
  public readonly attrIpamScopeId: string;

  /**
   * The type of the scope.
   *
   * @cloudformationAttribute IpamScopeType
   */
  public readonly attrIpamScopeType: string;

  /**
   * Defines if the scope is the default scope or not.
   *
   * @cloudformationAttribute IsDefault
   */
  public readonly attrIsDefault: cdk.IResolvable;

  /**
   * The number of pools in a scope.
   *
   * @cloudformationAttribute PoolCount
   */
  public readonly attrPoolCount: number;

  /**
   * The description of the scope.
   */
  public description?: string;

  /**
   * The ID of the IPAM for which you're creating this scope.
   */
  public ipamId: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The key/value combination of a tag assigned to the resource.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnIPAMScopeProps) {
    super(scope, id, {
      "type": CfnIPAMScope.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "ipamId", this);

    this.attrArn = cdk.Token.asString(this.getAtt("Arn", cdk.ResolutionTypeHint.STRING));
    this.attrIpamArn = cdk.Token.asString(this.getAtt("IpamArn", cdk.ResolutionTypeHint.STRING));
    this.attrIpamScopeId = cdk.Token.asString(this.getAtt("IpamScopeId", cdk.ResolutionTypeHint.STRING));
    this.attrIpamScopeType = cdk.Token.asString(this.getAtt("IpamScopeType", cdk.ResolutionTypeHint.STRING));
    this.attrIsDefault = this.getAtt("IsDefault");
    this.attrPoolCount = cdk.Token.asNumber(this.getAtt("PoolCount", cdk.ResolutionTypeHint.NUMBER));
    this.description = props.description;
    this.ipamId = props.ipamId;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::IPAMScope", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "description": this.description,
      "ipamId": this.ipamId,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnIPAMScope.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnIPAMScopePropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a `CfnIPAMScope`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamscope.html
 */
export interface CfnIPAMScopeProps {
  /**
   * The description of the scope.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamscope.html#cfn-ec2-ipamscope-description
   */
  readonly description?: string;

  /**
   * The ID of the IPAM for which you're creating this scope.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamscope.html#cfn-ec2-ipamscope-ipamid
   */
  readonly ipamId: string;

  /**
   * The key/value combination of a tag assigned to the resource.
   *
   * Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key `Owner` and the value `TeamA` , specify `tag:Owner` for the filter name and `TeamA` for the filter value.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamscope.html#cfn-ec2-ipamscope-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a `CfnIPAMScopeProps`
 *
 * @param properties - the TypeScript properties of a `CfnIPAMScopeProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnIPAMScopePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("ipamId", cdk.requiredValidator)(properties.ipamId));
  errors.collect(cdk.propertyValidator("ipamId", cdk.validateString)(properties.ipamId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \"CfnIPAMScopeProps\"");
}

// @ts-ignore TS6133
function convertCfnIPAMScopePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnIPAMScopePropsValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "IpamId": cdk.stringToCloudFormation(properties.ipamId),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnIPAMScopePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnIPAMScopeProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnIPAMScopeProps>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("ipamId", "IpamId", (properties.IpamId != null ? cfn_parse.FromCloudFormation.getString(properties.IpamId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies an EC2 instance.
 *
 * If an Elastic IP address is attached to your instance, AWS CloudFormation reattaches the Elastic IP address after it updates the instance. For more information about updating stacks, see [AWS CloudFormation Stacks Updates](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks.html) .
 *
 * @cloudformationResource AWS::EC2::Instance
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html
 */
export class CfnInstance extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::Instance";

  /**
   * Build a CfnInstance from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnInstance {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnInstancePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnInstance(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The Availability Zone where the specified instance is launched. For example: `us-east-1b` .
   *
   * You can retrieve a list of all Availability Zones for a Region by using the [Fn::GetAZs](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference-getavailabilityzones.html) intrinsic function.
   *
   * @cloudformationAttribute AvailabilityZone
   */
  public readonly attrAvailabilityZone: string;

  /**
   * The ID of the instance.
   *
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The private DNS name of the specified instance. For example: `ip-10-24-34-0.ec2.internal` .
   *
   * @cloudformationAttribute PrivateDnsName
   */
  public readonly attrPrivateDnsName: string;

  /**
   * The private IP address of the specified instance. For example: `10.24.34.0` .
   *
   * @cloudformationAttribute PrivateIp
   */
  public readonly attrPrivateIp: string;

  /**
   * The public DNS name of the specified instance. For example: `ec2-107-20-50-45.compute-1.amazonaws.com` .
   *
   * @cloudformationAttribute PublicDnsName
   */
  public readonly attrPublicDnsName: string;

  /**
   * The public IP address of the specified instance. For example: `192.0.2.0` .
   *
   * @cloudformationAttribute PublicIp
   */
  public readonly attrPublicIp: string;

  /**
   * This property is reserved for internal use.
   */
  public additionalInfo?: string;

  /**
   * Indicates whether the instance is associated with a dedicated host.
   */
  public affinity?: string;

  /**
   * The Availability Zone of the instance.
   */
  public availabilityZone?: string;

  /**
   * The block device mapping entries that defines the block devices to attach to the instance at launch.
   */
  public blockDeviceMappings?: Array<CfnInstance.BlockDeviceMappingProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * The CPU options for the instance.
   */
  public cpuOptions?: CfnInstance.CpuOptionsProperty | cdk.IResolvable;

  /**
   * The credit option for CPU usage of the burstable performance instance.
   */
  public creditSpecification?: CfnInstance.CreditSpecificationProperty | cdk.IResolvable;

  /**
   * If you set this parameter to `true` , you can't terminate the instance using the Amazon EC2 console, CLI, or API;
   */
  public disableApiTermination?: boolean | cdk.IResolvable;

  /**
   * Indicates whether the instance is optimized for Amazon EBS I/O.
   */
  public ebsOptimized?: boolean | cdk.IResolvable;

  /**
   * An elastic GPU to associate with the instance.
   */
  public elasticGpuSpecifications?: Array<CfnInstance.ElasticGpuSpecificationProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * An elastic inference accelerator to associate with the instance.
   */
  public elasticInferenceAccelerators?: Array<CfnInstance.ElasticInferenceAcceleratorProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * Indicates whether the instance is enabled for AWS Nitro Enclaves.
   */
  public enclaveOptions?: CfnInstance.EnclaveOptionsProperty | cdk.IResolvable;

  /**
   * Indicates whether an instance is enabled for hibernation.
   */
  public hibernationOptions?: CfnInstance.HibernationOptionsProperty | cdk.IResolvable;

  /**
   * If you specify host for the `Affinity` property, the ID of a dedicated host that the instance is associated with.
   */
  public hostId?: string;

  /**
   * The ARN of the host resource group in which to launch the instances.
   */
  public hostResourceGroupArn?: string;

  /**
   * The name of an IAM instance profile.
   */
  public iamInstanceProfile?: string;

  /**
   * The ID of the AMI.
   */
  public imageId?: string;

  /**
   * Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).
   */
  public instanceInitiatedShutdownBehavior?: string;

  /**
   * The instance type. For more information, see [Instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the *Amazon EC2 User Guide* .
   */
  public instanceType?: string;

  /**
   * The number of IPv6 addresses to associate with the primary network interface.
   */
  public ipv6AddressCount?: number;

  /**
   * The IPv6 addresses from the range of the subnet to associate with the primary network interface.
   */
  public ipv6Addresses?: Array<CfnInstance.InstanceIpv6AddressProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * The ID of the kernel.
   */
  public kernelId?: string;

  /**
   * The name of the key pair. You can create a key pair using [CreateKeyPair](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateKeyPair.html) or [ImportKeyPair](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportKeyPair.html) .
   */
  public keyName?: string;

  /**
   * The launch template to use to launch the instances.
   */
  public launchTemplate?: cdk.IResolvable | CfnInstance.LaunchTemplateSpecificationProperty;

  /**
   * The license configurations.
   */
  public licenseSpecifications?: Array<cdk.IResolvable | CfnInstance.LicenseSpecificationProperty> | cdk.IResolvable;

  /**
   * Specifies whether detailed monitoring is enabled for the instance.
   */
  public monitoring?: boolean | cdk.IResolvable;

  /**
   * The network interfaces to associate with the instance.
   */
  public networkInterfaces?: Array<cdk.IResolvable | CfnInstance.NetworkInterfaceProperty> | cdk.IResolvable;

  /**
   * The name of an existing placement group that you want to launch the instance into (cluster | partition | spread).
   */
  public placementGroupName?: string;

  /**
   * The options for the instance hostname.
   */
  public privateDnsNameOptions?: cdk.IResolvable | CfnInstance.PrivateDnsNameOptionsProperty;

  /**
   * The primary IPv4 address. You must specify a value from the IPv4 address range of the subnet.
   */
  public privateIpAddress?: string;

  /**
   * Indicates whether to assign the tags from the instance to all of the volumes attached to the instance at launch.
   */
  public propagateTagsToVolumeOnCreation?: boolean | cdk.IResolvable;

  /**
   * The ID of the RAM disk to select.
   */
  public ramdiskId?: string;

  /**
   * The IDs of the security groups.
   */
  public securityGroupIds?: Array<string>;

  /**
   * [Default VPC] The names of the security groups. For a nondefault VPC, you must use security group IDs instead.
   */
  public securityGroups?: Array<string>;

  /**
   * Enable or disable source/destination checks, which ensure that the instance is either the source or the destination of any traffic that it receives.
   */
  public sourceDestCheck?: boolean | cdk.IResolvable;

  /**
   * The SSM [document](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssm-document.html) and parameter values in AWS Systems Manager to associate with this instance. To use this property, you must specify an IAM instance profile role for the instance. For more information, see [Create an IAM instance profile for Systems Manager](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-configuring-access-role.html) in the *AWS Systems Manager User Guide* .
   */
  public ssmAssociations?: Array<cdk.IResolvable | CfnInstance.SsmAssociationProperty> | cdk.IResolvable;

  /**
   * The ID of the subnet to launch the instance into.
   */
  public subnetId?: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags to add to the instance.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The tenancy of the instance.
   */
  public tenancy?: string;

  /**
   * The parameters or scripts to store as user data.
   */
  public userData?: string;

  /**
   * The volumes to attach to the instance.
   */
  public volumes?: Array<cdk.IResolvable | CfnInstance.VolumeProperty> | cdk.IResolvable;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnInstanceProps = {}) {
    super(scope, id, {
      "type": CfnInstance.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.attrAvailabilityZone = cdk.Token.asString(this.getAtt("AvailabilityZone", cdk.ResolutionTypeHint.STRING));
    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.attrPrivateDnsName = cdk.Token.asString(this.getAtt("PrivateDnsName", cdk.ResolutionTypeHint.STRING));
    this.attrPrivateIp = cdk.Token.asString(this.getAtt("PrivateIp", cdk.ResolutionTypeHint.STRING));
    this.attrPublicDnsName = cdk.Token.asString(this.getAtt("PublicDnsName", cdk.ResolutionTypeHint.STRING));
    this.attrPublicIp = cdk.Token.asString(this.getAtt("PublicIp", cdk.ResolutionTypeHint.STRING));
    this.additionalInfo = props.additionalInfo;
    this.affinity = props.affinity;
    this.availabilityZone = props.availabilityZone;
    this.blockDeviceMappings = props.blockDeviceMappings;
    this.cpuOptions = props.cpuOptions;
    this.creditSpecification = props.creditSpecification;
    this.disableApiTermination = props.disableApiTermination;
    this.ebsOptimized = props.ebsOptimized;
    this.elasticGpuSpecifications = props.elasticGpuSpecifications;
    this.elasticInferenceAccelerators = props.elasticInferenceAccelerators;
    this.enclaveOptions = props.enclaveOptions;
    this.hibernationOptions = props.hibernationOptions;
    this.hostId = props.hostId;
    this.hostResourceGroupArn = props.hostResourceGroupArn;
    this.iamInstanceProfile = props.iamInstanceProfile;
    this.imageId = props.imageId;
    this.instanceInitiatedShutdownBehavior = props.instanceInitiatedShutdownBehavior;
    this.instanceType = props.instanceType;
    this.ipv6AddressCount = props.ipv6AddressCount;
    this.ipv6Addresses = props.ipv6Addresses;
    this.kernelId = props.kernelId;
    this.keyName = props.keyName;
    this.launchTemplate = props.launchTemplate;
    this.licenseSpecifications = props.licenseSpecifications;
    this.monitoring = props.monitoring;
    this.networkInterfaces = props.networkInterfaces;
    this.placementGroupName = props.placementGroupName;
    this.privateDnsNameOptions = props.privateDnsNameOptions;
    this.privateIpAddress = props.privateIpAddress;
    this.propagateTagsToVolumeOnCreation = props.propagateTagsToVolumeOnCreation;
    this.ramdiskId = props.ramdiskId;
    this.securityGroupIds = props.securityGroupIds;
    this.securityGroups = props.securityGroups;
    this.sourceDestCheck = props.sourceDestCheck;
    this.ssmAssociations = props.ssmAssociations;
    this.subnetId = props.subnetId;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::Instance", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.tenancy = props.tenancy;
    this.userData = props.userData;
    this.volumes = props.volumes;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "additionalInfo": this.additionalInfo,
      "affinity": this.affinity,
      "availabilityZone": this.availabilityZone,
      "blockDeviceMappings": this.blockDeviceMappings,
      "cpuOptions": this.cpuOptions,
      "creditSpecification": this.creditSpecification,
      "disableApiTermination": this.disableApiTermination,
      "ebsOptimized": this.ebsOptimized,
      "elasticGpuSpecifications": this.elasticGpuSpecifications,
      "elasticInferenceAccelerators": this.elasticInferenceAccelerators,
      "enclaveOptions": this.enclaveOptions,
      "hibernationOptions": this.hibernationOptions,
      "hostId": this.hostId,
      "hostResourceGroupArn": this.hostResourceGroupArn,
      "iamInstanceProfile": this.iamInstanceProfile,
      "imageId": this.imageId,
      "instanceInitiatedShutdownBehavior": this.instanceInitiatedShutdownBehavior,
      "instanceType": this.instanceType,
      "ipv6AddressCount": this.ipv6AddressCount,
      "ipv6Addresses": this.ipv6Addresses,
      "kernelId": this.kernelId,
      "keyName": this.keyName,
      "launchTemplate": this.launchTemplate,
      "licenseSpecifications": this.licenseSpecifications,
      "monitoring": this.monitoring,
      "networkInterfaces": this.networkInterfaces,
      "placementGroupName": this.placementGroupName,
      "privateDnsNameOptions": this.privateDnsNameOptions,
      "privateIpAddress": this.privateIpAddress,
      "propagateTagsToVolumeOnCreation": this.propagateTagsToVolumeOnCreation,
      "ramdiskId": this.ramdiskId,
      "securityGroupIds": this.securityGroupIds,
      "securityGroups": this.securityGroups,
      "sourceDestCheck": this.sourceDestCheck,
      "ssmAssociations": this.ssmAssociations,
      "subnetId": this.subnetId,
      "tags": this.tags.renderTags(),
      "tenancy": this.tenancy,
      "userData": this.userData,
      "volumes": this.volumes
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnInstance.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnInstancePropsToCloudFormation(props);
  }
}

export namespace CfnInstance {
  /**
   * Specifies a block device mapping for an instance.
   *
   * You must specify exactly one of the following properties: `VirtualName` , `Ebs` , or `NoDevice` .
   *
   * `BlockDeviceMapping` is a property of the [AWS::EC2::Instance](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html) resource.
   *
   * > After the instance is running, you can modify only the `DeleteOnTermination` parameter for the attached volumes without interrupting the instance. Modifying any other parameter results in instance [replacement](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement) .
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-blockdevicemapping.html
   */
  export interface BlockDeviceMappingProperty {
    /**
     * The device name (for example, `/dev/sdh` or `xvdh` ).
     *
     * > After the instance is running, this parameter is used to specify the device name of the block device mapping to update.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-blockdevicemapping.html#cfn-ec2-instance-blockdevicemapping-devicename
     */
    readonly deviceName: string;

    /**
     * Parameters used to automatically set up EBS volumes when the instance is launched.
     *
     * > After the instance is running, you can modify only the `DeleteOnTermination` parameter for the attached volumes without interrupting the instance. Modifying any other parameter results in instance [replacement](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-no-interrupt) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-blockdevicemapping.html#cfn-ec2-instance-blockdevicemapping-ebs
     */
    readonly ebs?: CfnInstance.EbsProperty | cdk.IResolvable;

    /**
     * To omit the device from the block device mapping, specify an empty string.
     *
     * > After the instance is running, modifying this parameter results in instance [replacement](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-blockdevicemapping.html#cfn-ec2-instance-blockdevicemapping-nodevice
     */
    readonly noDevice?: cdk.IResolvable | CfnInstance.NoDeviceProperty;

    /**
     * The virtual device name ( `ephemeral` N).
     *
     * The name must be in the form `ephemeral` *X* where *X* is a number starting from zero (0). For example, an instance type with 2 available instance store volumes can specify mappings for `ephemeral0` and `ephemeral1` . The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume.
     *
     * NVMe instance store volumes are automatically enumerated and assigned a device name. Including them in your block device mapping has no effect.
     *
     * *Constraints* : For M3 instances, you must specify instance store volumes in the block device mapping for the instance. When you launch an M3 instance, we ignore any instance store volumes specified in the block device mapping for the AMI.
     *
     * > After the instance is running, modifying this parameter results in instance [replacement](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-blockdevicemapping.html#cfn-ec2-instance-blockdevicemapping-virtualname
     */
    readonly virtualName?: string;
  }

  /**
   * Specifies a block device for an EBS volume.
   *
   * `Ebs` is a property of the [Amazon EC2 BlockDeviceMapping](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-blockdev-mapping.html) property.
   *
   * > After the instance is running, you can modify only the `DeleteOnTermination` parameters for the attached volumes without interrupting the instance. Modifying any other parameter results in instance [replacement](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement) .
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ebs.html
   */
  export interface EbsProperty {
    /**
     * Indicates whether the EBS volume is deleted on instance termination.
     *
     * For more information, see [Preserving Amazon EBS volumes on instance termination](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/terminating-instances.html#preserving-volumes-on-termination) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ebs.html#cfn-ec2-instance-ebs-deleteontermination
     */
    readonly deleteOnTermination?: boolean | cdk.IResolvable;

    /**
     * Indicates whether the volume should be encrypted.
     *
     * The effect of setting the encryption state to `true` depends on the volume origin (new or from a snapshot), starting encryption state, ownership, and whether encryption by default is enabled. For more information, see [Encryption by default](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#encryption-by-default) in the *Amazon Elastic Compute Cloud User Guide* .
     *
     * Encrypted Amazon EBS volumes must be attached to instances that support Amazon EBS encryption. For more information, see [Supported instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#EBSEncryption_supported_instances) .
     *
     * > After the instance is running, modifying this parameter results in instance [replacement](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ebs.html#cfn-ec2-instance-ebs-encrypted
     */
    readonly encrypted?: boolean | cdk.IResolvable;

    /**
     * The number of I/O operations per second (IOPS).
     *
     * For `gp3` , `io1` , and `io2` volumes, this represents the number of IOPS that are provisioned for the volume. For `gp2` volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting.
     *
     * The following are the supported values for each volume type:
     *
     * - `gp3` : 3,000-16,000 IOPS
     * - `io1` : 100-64,000 IOPS
     * - `io2` : 100-64,000 IOPS
     *
     * For `io1` and `io2` volumes, we guarantee 64,000 IOPS only for [Instances built on the Nitro System](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances) . Other instance families guarantee performance up to 32,000 IOPS.
     *
     * This parameter is required for `io1` and `io2` volumes. The default for `gp3` volumes is 3,000 IOPS. This parameter is not supported for `gp2` , `st1` , `sc1` , or `standard` volumes.
     *
     * > After the instance is running, modifying this parameter results in instance [replacement](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ebs.html#cfn-ec2-instance-ebs-iops
     */
    readonly iops?: number;

    /**
     * The identifier of the AWS KMS key to use for Amazon EBS encryption.
     *
     * If `KmsKeyId` is specified, the encrypted state must be `true` . If the encrypted state is `true` but you do not specify `KmsKeyId` , your KMS key for EBS is used.
     *
     * You can specify the KMS key using any of the following:
     *
     * - Key ID. For example, 1234abcd-12ab-34cd-56ef-1234567890ab.
     * - Key alias. For example, alias/ExampleAlias.
     * - Key ARN. For example, arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab.
     * - Alias ARN. For example, arn:aws:kms:us-west-2:111122223333:alias/ExampleAlias.
     *
     * > After the instance is running, modifying this parameter results in instance [replacement](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ebs.html#cfn-ec2-instance-ebs-kmskeyid
     */
    readonly kmsKeyId?: string;

    /**
     * The ID of the snapshot.
     *
     * If you specify both `SnapshotId` and `VolumeSize` , `VolumeSize` must be equal or greater than the size of the snapshot.
     *
     * > After the instance is running, modifying this parameter results in instance [replacement](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ebs.html#cfn-ec2-instance-ebs-snapshotid
     */
    readonly snapshotId?: string;

    /**
     * The size of the volume, in GiBs.
     *
     * You must specify either a snapshot ID or a volume size. If you specify a snapshot, the default is the snapshot size. You can specify a volume size that is equal to or larger than the snapshot size.
     *
     * The following are the supported volumes sizes for each volume type:
     *
     * - `gp2` and `gp3` :1-16,384
     * - `io1` and `io2` : 4-16,384
     * - `st1` and `sc1` : 125-16,384
     * - `standard` : 1-1,024
     *
     * > After the instance is running, modifying this parameter results in instance [replacement](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ebs.html#cfn-ec2-instance-ebs-volumesize
     */
    readonly volumeSize?: number;

    /**
     * The volume type.
     *
     * For more information, see [Amazon EBS volume types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html) in the *Amazon EC2 User Guide* . If the volume type is `io1` or `io2` , you must specify the IOPS that the volume supports.
     *
     * > After the instance is running, modifying this parameter results in instance [replacement](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ebs.html#cfn-ec2-instance-ebs-volumetype
     */
    readonly volumeType?: string;
  }

  /**
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-nodevice.html
   */
  export interface NoDeviceProperty {

  }

  /**
   * Specifies the CPU options for the instance.
   *
   * When you specify CPU options, you must specify both the number of CPU cores and threads per core.
   *
   * Modifying the CPU options for an instance results in instance [replacement](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement) .
   *
   * For more information, see [Optimize CPU options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html) in the *Amazon Elastic Compute Cloud User Guide* .
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-cpuoptions.html
   */
  export interface CpuOptionsProperty {
    /**
     * The number of CPU cores for the instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-cpuoptions.html#cfn-ec2-instance-cpuoptions-corecount
     */
    readonly coreCount?: number;

    /**
     * The number of threads per CPU core.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-cpuoptions.html#cfn-ec2-instance-cpuoptions-threadspercore
     */
    readonly threadsPerCore?: number;
  }

  /**
   * Specifies the credit option for CPU usage of a T instance.
   *
   * `CreditSpecification` is a property of the [AWS::EC2::Instance](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html) resource.
   *
   * For more information, see [Burstable performance instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html) in the *Amazon EC2 User Guide* .
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-creditspecification.html
   */
  export interface CreditSpecificationProperty {
    /**
     * The credit option for CPU usage of the instance.
     *
     * Valid values: `standard` | `unlimited`
     *
     * T3 instances with `host` tenancy do not support the `unlimited` CPU credit option.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-creditspecification.html#cfn-ec2-instance-creditspecification-cpucredits
     */
    readonly cpuCredits?: string;
  }

  /**
   * Specifies the type of Elastic GPU.
   *
   * An Elastic GPU is a GPU resource that you can attach to your Amazon EC2 instance to accelerate the graphics performance of your applications. For more information, see [Amazon EC2 Elastic GPUs](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/elastic-graphics.html) in the *Amazon EC2 User Guide for Windows Instances* .
   *
   * `ElasticGpuSpecification` is a property of the [AWS::EC2::Instance](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html) resource.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticgpuspecification.html
   */
  export interface ElasticGpuSpecificationProperty {
    /**
     * The type of Elastic Graphics accelerator.
     *
     * For more information about the values to specify for `Type` , see [Elastic Graphics Basics](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/elastic-graphics.html#elastic-graphics-basics) , specifically the Elastic Graphics accelerator column, in the *Amazon Elastic Compute Cloud User Guide for Windows Instances* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticgpuspecification.html#cfn-ec2-instance-elasticgpuspecification-type
     */
    readonly type: string;
  }

  /**
   * Specifies the Elastic Inference Accelerator for the instance.
   *
   * `ElasticInferenceAccelerator` is a property of the [AWS::EC2::Instance](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html) resource.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticinferenceaccelerator.html
   */
  export interface ElasticInferenceAcceleratorProperty {
    /**
     * The number of elastic inference accelerators to attach to the instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticinferenceaccelerator.html#cfn-ec2-instance-elasticinferenceaccelerator-count
     */
    readonly count?: number;

    /**
     * The type of elastic inference accelerator.
     *
     * The possible values are `eia1.medium` , `eia1.large` , `eia1.xlarge` , `eia2.medium` , `eia2.large` , and `eia2.xlarge` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticinferenceaccelerator.html#cfn-ec2-instance-elasticinferenceaccelerator-type
     */
    readonly type: string;
  }

  /**
   * Indicates whether the instance is enabled for AWS Nitro Enclaves.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-enclaveoptions.html
   */
  export interface EnclaveOptionsProperty {
    /**
     * If this parameter is set to `true` , the instance is enabled for AWS Nitro Enclaves;
     *
     * otherwise, it is not enabled for AWS Nitro Enclaves.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-enclaveoptions.html#cfn-ec2-instance-enclaveoptions-enabled
     */
    readonly enabled?: boolean | cdk.IResolvable;
  }

  /**
   * Specifies the hibernation options for the instance.
   *
   * `HibernationOptions` is a property of the [AWS::EC2::Instance](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html) resource.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-hibernationoptions.html
   */
  export interface HibernationOptionsProperty {
    /**
     * Set to `true` to enable your instance for hibernation.
     *
     * For Spot Instances, if you set `Configured` to `true` , either omit the `InstanceInterruptionBehavior` parameter (for [`SpotMarketOptions`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_SpotMarketOptions.html) ), or set it to `hibernate` . When `Configured` is true:
     *
     * - If you omit `InstanceInterruptionBehavior` , it defaults to `hibernate` .
     * - If you set `InstanceInterruptionBehavior` to a value other than `hibernate` , you'll get an error.
     *
     * Default: `false`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-hibernationoptions.html#cfn-ec2-instance-hibernationoptions-configured
     */
    readonly configured?: boolean | cdk.IResolvable;
  }

  /**
   * Specifies the IPv6 address for the instance.
   *
   * `InstanceIpv6Address` is a property of the [AWS::EC2::Instance](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html) resource.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-instanceipv6address.html
   */
  export interface InstanceIpv6AddressProperty {
    /**
     * The IPv6 address.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-instanceipv6address.html#cfn-ec2-instance-instanceipv6address-ipv6address
     */
    readonly ipv6Address: string;
  }

  /**
   * Specifies a launch template to use when launching an Amazon EC2 instance.
   *
   * You must specify the following:
   *
   * - The ID or the name of the launch template, but not both.
   * - The version of the launch template.
   *
   * `LaunchTemplateSpecification` is a property of the [AWS::EC2::Instance](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html) resource.
   *
   * For information about creating a launch template, see [AWS::EC2::LaunchTemplate](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html) and [Create a launch template](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-templates.html#create-launch-template) in the *Amazon EC2 User Guide* .
   *
   * For examples of launch templates, see [Examples](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#aws-resource-ec2-launchtemplate--examples) .
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-launchtemplatespecification.html
   */
  export interface LaunchTemplateSpecificationProperty {
    /**
     * The ID of the launch template.
     *
     * You must specify the `LaunchTemplateId` or the `LaunchTemplateName` , but not both.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-launchtemplatespecification.html#cfn-ec2-instance-launchtemplatespecification-launchtemplateid
     */
    readonly launchTemplateId?: string;

    /**
     * The name of the launch template.
     *
     * You must specify the `LaunchTemplateName` or the `LaunchTemplateId` , but not both.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-launchtemplatespecification.html#cfn-ec2-instance-launchtemplatespecification-launchtemplatename
     */
    readonly launchTemplateName?: string;

    /**
     * The version number of the launch template.
     *
     * Specifying `$Latest` or `$Default` for the template version number is not supported. However, you can specify `LatestVersionNumber` or `DefaultVersionNumber` using the `Fn::GetAtt` intrinsic function. For more information, see [Fn::GetAtt](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#aws-resource-ec2-launchtemplate-return-values-fn--getatt) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-launchtemplatespecification.html#cfn-ec2-instance-launchtemplatespecification-version
     */
    readonly version: string;
  }

  /**
   * Specifies the license configuration to use.
   *
   * `LicenseSpecification` is a property of the [AWS::EC2::Instance](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html) resource.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-licensespecification.html
   */
  export interface LicenseSpecificationProperty {
    /**
     * The Amazon Resource Name (ARN) of the license configuration.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-licensespecification.html#cfn-ec2-instance-licensespecification-licenseconfigurationarn
     */
    readonly licenseConfigurationArn: string;
  }

  /**
   * Specifies a network interface that is to be attached to an instance.
   *
   * You can create a network interface when launching an instance. For an example, see the [AWS::EC2::Instance examples](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#aws-properties-ec2-instance--examples--Automatically_assign_a_public_IP_address) .
   *
   * Alternatively, you can attach an existing network interface when launching an instance. For an example, see the [AWS::EC2:NetworkInterface examples](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#aws-resource-ec2-networkinterface--examples) .
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html
   */
  export interface NetworkInterfaceProperty {
    /**
     * Indicates whether to assign a carrier IP address to the network interface.
     *
     * You can only assign a carrier IP address to a network interface that is in a subnet in a Wavelength Zone. For more information about carrier IP addresses, see [Carrier IP address](https://docs.aws.amazon.com/wavelength/latest/developerguide/how-wavelengths-work.html#provider-owned-ip) in the *AWS Wavelength Developer Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-associatecarrieripaddress
     */
    readonly associateCarrierIpAddress?: boolean | cdk.IResolvable;

    /**
     * Indicates whether to assign a public IPv4 address to an instance.
     *
     * Applies only if creating a network interface when launching an instance. The network interface must be the primary network interface. If launching into a default subnet, the default value is `true` .
     *
     * Starting on February 1, 2024, AWS will charge for all public IPv4 addresses, including public IPv4 addresses associated with running instances and Elastic IP addresses. For more information, see the *Public IPv4 Address* tab on the [VPC pricing page](https://docs.aws.amazon.com/vpc/pricing/) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-associatepublicipaddress
     */
    readonly associatePublicIpAddress?: boolean | cdk.IResolvable;

    /**
     * Indicates whether the network interface is deleted when the instance is terminated.
     *
     * Applies only if creating a network interface when launching an instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-deleteontermination
     */
    readonly deleteOnTermination?: boolean | cdk.IResolvable;

    /**
     * The description of the network interface.
     *
     * Applies only if creating a network interface when launching an instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-description
     */
    readonly description?: string;

    /**
     * The position of the network interface in the attachment order.
     *
     * A primary network interface has a device index of 0.
     *
     * If you create a network interface when launching an instance, you must specify the device index.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-deviceindex
     */
    readonly deviceIndex: string;

    /**
     * The IDs of the security groups for the network interface.
     *
     * Applies only if creating a network interface when launching an instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-groupset
     */
    readonly groupSet?: Array<string>;

    /**
     * A number of IPv6 addresses to assign to the network interface.
     *
     * Amazon EC2 chooses the IPv6 addresses from the range of the subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-ipv6addresscount
     */
    readonly ipv6AddressCount?: number;

    /**
     * The IPv6 addresses to assign to the network interface.
     *
     * You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-ipv6addresses
     */
    readonly ipv6Addresses?: Array<CfnInstance.InstanceIpv6AddressProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The ID of the network interface, when attaching an existing network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-networkinterfaceid
     */
    readonly networkInterfaceId?: string;

    /**
     * The private IPv4 address of the network interface.
     *
     * Applies only if creating a network interface when launching an instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-privateipaddress
     */
    readonly privateIpAddress?: string;

    /**
     * One or more private IPv4 addresses to assign to the network interface.
     *
     * Only one private IPv4 address can be designated as primary.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-privateipaddresses
     */
    readonly privateIpAddresses?: Array<cdk.IResolvable | CfnInstance.PrivateIpAddressSpecificationProperty> | cdk.IResolvable;

    /**
     * The number of secondary private IPv4 addresses.
     *
     * You can't specify this option and specify more than one private IP address using the private IP addresses option.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-secondaryprivateipaddresscount
     */
    readonly secondaryPrivateIpAddressCount?: number;

    /**
     * The ID of the subnet associated with the network interface.
     *
     * Applies only if creating a network interface when launching an instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-subnetid
     */
    readonly subnetId?: string;
  }

  /**
   * Specifies a secondary private IPv4 address for a network interface.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privateipaddressspecification.html
   */
  export interface PrivateIpAddressSpecificationProperty {
    /**
     * Indicates whether the private IPv4 address is the primary private IPv4 address.
     *
     * Only one IPv4 address can be designated as primary.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privateipaddressspecification.html#cfn-ec2-instance-privateipaddressspecification-primary
     */
    readonly primary: boolean | cdk.IResolvable;

    /**
     * The private IPv4 address.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privateipaddressspecification.html#cfn-ec2-instance-privateipaddressspecification-privateipaddress
     */
    readonly privateIpAddress: string;
  }

  /**
   * The type of hostnames to assign to instances in the subnet at launch.
   *
   * For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 only subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID. For more information, see [Amazon EC2 instance hostname types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html) in the *Amazon Elastic Compute Cloud User Guide* .
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privatednsnameoptions.html
   */
  export interface PrivateDnsNameOptionsProperty {
    /**
     * Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records.
     *
     * For more information, see [Amazon EC2 instance hostname types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html) in the *Amazon Elastic Compute Cloud User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privatednsnameoptions.html#cfn-ec2-instance-privatednsnameoptions-enableresourcenamednsaaaarecord
     */
    readonly enableResourceNameDnsAaaaRecord?: boolean | cdk.IResolvable;

    /**
     * Indicates whether to respond to DNS queries for instance hostnames with DNS A records.
     *
     * For more information, see [Amazon EC2 instance hostname types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html) in the *Amazon Elastic Compute Cloud User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privatednsnameoptions.html#cfn-ec2-instance-privatednsnameoptions-enableresourcenamednsarecord
     */
    readonly enableResourceNameDnsARecord?: boolean | cdk.IResolvable;

    /**
     * The type of hostnames to assign to instances in the subnet at launch.
     *
     * For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 only subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID. For more information, see [Amazon EC2 instance hostname types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html) in the *Amazon Elastic Compute Cloud User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privatednsnameoptions.html#cfn-ec2-instance-privatednsnameoptions-hostnametype
     */
    readonly hostnameType?: string;
  }

  /**
   * Specifies the SSM document and parameter values in AWS Systems Manager to associate with an instance.
   *
   * `SsmAssociations` is a property of the [AWS::EC2::Instance](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html) resource.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociation.html
   */
  export interface SsmAssociationProperty {
    /**
     * The input parameter values to use with the associated SSM document.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociation.html#cfn-ec2-instance-ssmassociation-associationparameters
     */
    readonly associationParameters?: Array<CfnInstance.AssociationParameterProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The name of an SSM document to associate with the instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociation.html#cfn-ec2-instance-ssmassociation-documentname
     */
    readonly documentName: string;
  }

  /**
   * Specifies input parameter values for an SSM document in AWS Systems Manager .
   *
   * `AssociationParameter` is a property of the [Amazon EC2 Instance SsmAssociation](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociations.html) property.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-associationparameter.html
   */
  export interface AssociationParameterProperty {
    /**
     * The name of an input parameter that is in the associated SSM document.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-associationparameter.html#cfn-ec2-instance-associationparameter-key
     */
    readonly key: string;

    /**
     * The value of an input parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-associationparameter.html#cfn-ec2-instance-associationparameter-value
     */
    readonly value: Array<string>;
  }

  /**
   * Specifies a volume to attach to an instance.
   *
   * `Volume` is an embedded property of the [AWS::EC2::Instance](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html) resource.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-volume.html
   */
  export interface VolumeProperty {
    /**
     * The device name (for example, `/dev/sdh` or `xvdh` ).
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-volume.html#cfn-ec2-instance-volume-device
     */
    readonly device: string;

    /**
     * The ID of the EBS volume.
     *
     * The volume and instance must be within the same Availability Zone.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-volume.html#cfn-ec2-instance-volume-volumeid
     */
    readonly volumeId: string;
  }
}

/**
 * Properties for defining a `CfnInstance`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html
 */
export interface CfnInstanceProps {
  /**
   * This property is reserved for internal use.
   *
   * If you use it, the stack fails with this error: `Bad property set: [Testing this property] (Service: AmazonEC2; Status Code: 400; Error Code: InvalidParameterCombination; Request ID: 0XXXXXX-49c7-4b40-8bcc-76885dcXXXXX)` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-additionalinfo
   */
  readonly additionalInfo?: string;

  /**
   * Indicates whether the instance is associated with a dedicated host.
   *
   * If you want the instance to always restart on the same host on which it was launched, specify `host` . If you want the instance to restart on any available host, but try to launch onto the last host it ran on (on a best-effort basis), specify `default` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-affinity
   */
  readonly affinity?: string;

  /**
   * The Availability Zone of the instance.
   *
   * If not specified, an Availability Zone will be automatically chosen for you based on the load balancing criteria for the Region.
   *
   * This parameter is not supported by [DescribeImageAttribute](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeImageAttribute.html) .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-availabilityzone
   */
  readonly availabilityZone?: string;

  /**
   * The block device mapping entries that defines the block devices to attach to the instance at launch.
   *
   * By default, the block devices specified in the block device mapping for the AMI are used. You can override the AMI block device mapping using the instance block device mapping. For the root volume, you can override only the volume size, volume type, volume encryption settings, and the `DeleteOnTermination` setting.
   *
   * > After the instance is running, you can modify only the `DeleteOnTermination` parameter for the attached volumes without interrupting the instance. Modifying any other parameter results in instance [replacement](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement) .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-blockdevicemappings
   */
  readonly blockDeviceMappings?: Array<CfnInstance.BlockDeviceMappingProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * The CPU options for the instance.
   *
   * For more information, see [Optimize CPU options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html) in the *Amazon Elastic Compute Cloud User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-cpuoptions
   */
  readonly cpuOptions?: CfnInstance.CpuOptionsProperty | cdk.IResolvable;

  /**
   * The credit option for CPU usage of the burstable performance instance.
   *
   * Valid values are `standard` and `unlimited` . To change this attribute after launch, use [ModifyInstanceCreditSpecification](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceCreditSpecification.html) . For more information, see [Burstable performance instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html) in the *Amazon EC2 User Guide* .
   *
   * Default: `standard` (T2 instances) or `unlimited` (T3/T3a/T4g instances)
   *
   * For T3 instances with `host` tenancy, only `standard` is supported.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-creditspecification
   */
  readonly creditSpecification?: CfnInstance.CreditSpecificationProperty | cdk.IResolvable;

  /**
   * If you set this parameter to `true` , you can't terminate the instance using the Amazon EC2 console, CLI, or API;
   *
   * otherwise, you can. To change this attribute after launch, use [ModifyInstanceAttribute](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceAttribute.html) . Alternatively, if you set `InstanceInitiatedShutdownBehavior` to `terminate` , you can terminate the instance by running the shutdown command from the instance.
   *
   * Default: `false`
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-disableapitermination
   */
  readonly disableApiTermination?: boolean | cdk.IResolvable;

  /**
   * Indicates whether the instance is optimized for Amazon EBS I/O.
   *
   * This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal Amazon EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance.
   *
   * Default: `false`
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-ebsoptimized
   */
  readonly ebsOptimized?: boolean | cdk.IResolvable;

  /**
   * An elastic GPU to associate with the instance.
   *
   * An Elastic GPU is a GPU resource that you can attach to your Windows instance to accelerate the graphics performance of your applications. For more information, see [Amazon EC2 Elastic GPUs](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/elastic-graphics.html) in the *Amazon EC2 User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-elasticgpuspecifications
   */
  readonly elasticGpuSpecifications?: Array<CfnInstance.ElasticGpuSpecificationProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * An elastic inference accelerator to associate with the instance.
   *
   * Elastic inference accelerators are a resource you can attach to your Amazon EC2 instances to accelerate your Deep Learning (DL) inference workloads.
   *
   * You cannot specify accelerators from different generations in the same request.
   *
   * > Starting April 15, 2023, AWS will not onboard new customers to Amazon Elastic Inference (EI), and will help current customers migrate their workloads to options that offer better price and performance. After April 15, 2023, new customers will not be able to launch instances with Amazon EI accelerators in Amazon SageMaker, Amazon ECS, or Amazon EC2. However, customers who have used Amazon EI at least once during the past 30-day period are considered current customers and will be able to continue using the service.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-elasticinferenceaccelerators
   */
  readonly elasticInferenceAccelerators?: Array<CfnInstance.ElasticInferenceAcceleratorProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * Indicates whether the instance is enabled for AWS Nitro Enclaves.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-enclaveoptions
   */
  readonly enclaveOptions?: CfnInstance.EnclaveOptionsProperty | cdk.IResolvable;

  /**
   * Indicates whether an instance is enabled for hibernation.
   *
   * This parameter is valid only if the instance meets the [hibernation prerequisites](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/hibernating-prerequisites.html) . For more information, see [Hibernate your instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html) in the *Amazon EC2 User Guide* .
   *
   * You can't enable hibernation and AWS Nitro Enclaves on the same instance.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-hibernationoptions
   */
  readonly hibernationOptions?: CfnInstance.HibernationOptionsProperty | cdk.IResolvable;

  /**
   * If you specify host for the `Affinity` property, the ID of a dedicated host that the instance is associated with.
   *
   * If you don't specify an ID, Amazon EC2 launches the instance onto any available, compatible dedicated host in your account. This type of launch is called an untargeted launch. Note that for untargeted launches, you must have a compatible, dedicated host available to successfully launch instances.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-hostid
   */
  readonly hostId?: string;

  /**
   * The ARN of the host resource group in which to launch the instances.
   *
   * If you specify a host resource group ARN, omit the *Tenancy* parameter or set it to `host` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-hostresourcegrouparn
   */
  readonly hostResourceGroupArn?: string;

  /**
   * The name of an IAM instance profile.
   *
   * To create a new IAM instance profile, use the [AWS::IAM::InstanceProfile](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-instanceprofile.html) resource.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-iaminstanceprofile
   */
  readonly iamInstanceProfile?: string;

  /**
   * The ID of the AMI.
   *
   * An AMI ID is required to launch an instance and must be specified here or in a launch template.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-imageid
   */
  readonly imageId?: string;

  /**
   * Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).
   *
   * Default: `stop`
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-instanceinitiatedshutdownbehavior
   */
  readonly instanceInitiatedShutdownBehavior?: string;

  /**
   * The instance type. For more information, see [Instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the *Amazon EC2 User Guide* .
   *
   * When you change your EBS-backed instance type, instance restart or replacement behavior depends on the instance type compatibility between the old and new types. An instance with an instance store volume as the root volume is always replaced. For more information, see [Change the instance type](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-resize.html) in the *Amazon EC2 User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-instancetype
   */
  readonly instanceType?: string;

  /**
   * The number of IPv6 addresses to associate with the primary network interface.
   *
   * Amazon EC2 chooses the IPv6 addresses from the range of your subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch.
   *
   * You cannot specify this option and the network interfaces option in the same request.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-ipv6addresscount
   */
  readonly ipv6AddressCount?: number;

  /**
   * The IPv6 addresses from the range of the subnet to associate with the primary network interface.
   *
   * You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch.
   *
   * You cannot specify this option and the network interfaces option in the same request.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-ipv6addresses
   */
  readonly ipv6Addresses?: Array<CfnInstance.InstanceIpv6AddressProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * The ID of the kernel.
   *
   * > We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see [PV-GRUB](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html) in the *Amazon EC2 User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-kernelid
   */
  readonly kernelId?: string;

  /**
   * The name of the key pair. You can create a key pair using [CreateKeyPair](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateKeyPair.html) or [ImportKeyPair](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportKeyPair.html) .
   *
   * > If you do not specify a key pair, you can't connect to the instance unless you choose an AMI that is configured to allow users another way to log in.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-keyname
   */
  readonly keyName?: string;

  /**
   * The launch template to use to launch the instances.
   *
   * Any parameters that you specify in the AWS CloudFormation template override the same parameters in the launch template. You can specify either the name or ID of a launch template, but not both.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-launchtemplate
   */
  readonly launchTemplate?: cdk.IResolvable | CfnInstance.LaunchTemplateSpecificationProperty;

  /**
   * The license configurations.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-licensespecifications
   */
  readonly licenseSpecifications?: Array<cdk.IResolvable | CfnInstance.LicenseSpecificationProperty> | cdk.IResolvable;

  /**
   * Specifies whether detailed monitoring is enabled for the instance.
   *
   * Specify `true` to enable detailed monitoring. Otherwise, basic monitoring is enabled. For more information about detailed monitoring, see [Enable or turn off detailed monitoring for your instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-cloudwatch-new.html) in the *Amazon EC2 User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-monitoring
   */
  readonly monitoring?: boolean | cdk.IResolvable;

  /**
   * The network interfaces to associate with the instance.
   *
   * > If you use this property to point to a network interface, you must terminate the original interface before attaching a new one to allow the update of the instance to succeed.
   * >
   * > If this resource has a public IP address and is also in a VPC that is defined in the same template, you must use the [DependsOn Attribute](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-dependson.html) to declare a dependency on the VPC-gateway attachment.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-networkinterfaces
   */
  readonly networkInterfaces?: Array<cdk.IResolvable | CfnInstance.NetworkInterfaceProperty> | cdk.IResolvable;

  /**
   * The name of an existing placement group that you want to launch the instance into (cluster | partition | spread).
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-placementgroupname
   */
  readonly placementGroupName?: string;

  /**
   * The options for the instance hostname.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-privatednsnameoptions
   */
  readonly privateDnsNameOptions?: cdk.IResolvable | CfnInstance.PrivateDnsNameOptionsProperty;

  /**
   * The primary IPv4 address. You must specify a value from the IPv4 address range of the subnet.
   *
   * Only one private IP address can be designated as primary. You can't specify this option if you've specified the option to designate a private IP address as the primary IP address in a network interface specification. You cannot specify this option if you're launching more than one instance in the request.
   *
   * You cannot specify this option and the network interfaces option in the same request.
   *
   * If you make an update to an instance that requires replacement, you must assign a new private IP address. During a replacement, AWS CloudFormation creates a new instance but doesn't delete the old instance until the stack has successfully updated. If the stack update fails, AWS CloudFormation uses the old instance to roll back the stack to the previous working state. The old and new instances cannot have the same private IP address.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-privateipaddress
   */
  readonly privateIpAddress?: string;

  /**
   * Indicates whether to assign the tags from the instance to all of the volumes attached to the instance at launch.
   *
   * If you specify `true` and you assign tags to the instance, those tags are automatically assigned to all of the volumes that you attach to the instance at launch. If you specify `false` , those tags are not assigned to the attached volumes.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-propagatetagstovolumeoncreation
   */
  readonly propagateTagsToVolumeOnCreation?: boolean | cdk.IResolvable;

  /**
   * The ID of the RAM disk to select.
   *
   * Some kernels require additional drivers at launch. Check the kernel requirements for information about whether you need to specify a RAM disk. To find kernel requirements, go to the AWS Resource Center and search for the kernel ID.
   *
   * > We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see [PV-GRUB](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html) in the *Amazon EC2 User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-ramdiskid
   */
  readonly ramdiskId?: string;

  /**
   * The IDs of the security groups.
   *
   * You can specify the IDs of existing security groups and references to resources created by the stack template.
   *
   * If you specify a network interface, you must specify any security groups as part of the network interface.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-securitygroupids
   */
  readonly securityGroupIds?: Array<string>;

  /**
   * [Default VPC] The names of the security groups. For a nondefault VPC, you must use security group IDs instead.
   *
   * You cannot specify this option and the network interfaces option in the same request. The list can contain both the name of existing Amazon EC2 security groups or references to AWS::EC2::SecurityGroup resources created in the template.
   *
   * Default: Amazon EC2 uses the default security group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-securitygroups
   */
  readonly securityGroups?: Array<string>;

  /**
   * Enable or disable source/destination checks, which ensure that the instance is either the source or the destination of any traffic that it receives.
   *
   * If the value is `true` , source/destination checks are enabled; otherwise, they are disabled. The default value is `true` . You must disable source/destination checks if the instance runs services such as network address translation, routing, or firewalls.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-sourcedestcheck
   */
  readonly sourceDestCheck?: boolean | cdk.IResolvable;

  /**
   * The SSM [document](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssm-document.html) and parameter values in AWS Systems Manager to associate with this instance. To use this property, you must specify an IAM instance profile role for the instance. For more information, see [Create an IAM instance profile for Systems Manager](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-configuring-access-role.html) in the *AWS Systems Manager User Guide* .
   *
   * > You can associate only one document with an instance.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-ssmassociations
   */
  readonly ssmAssociations?: Array<cdk.IResolvable | CfnInstance.SsmAssociationProperty> | cdk.IResolvable;

  /**
   * The ID of the subnet to launch the instance into.
   *
   * If you specify a network interface, you must specify any subnets as part of the network interface.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-subnetid
   */
  readonly subnetId?: string;

  /**
   * The tags to add to the instance.
   *
   * These tags are not applied to the EBS volumes, such as the root volume, unless [PropagateTagsToVolumeOnCreation](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-propagatetagstovolumeoncreation) is `true` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The tenancy of the instance.
   *
   * An instance with a tenancy of `dedicated` runs on single-tenant hardware.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-tenancy
   */
  readonly tenancy?: string;

  /**
   * The parameters or scripts to store as user data.
   *
   * Any scripts in user data are run when you launch the instance. User data is limited to 16 KB. You must provide base64-encoded text. For more information, see [Fn::Base64](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference-base64.html) .
   *
   * If the root volume is an EBS volume and you update user data, CloudFormation restarts the instance. If the root volume is an instance store volume and you update user data, the instance is replaced.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-userdata
   */
  readonly userData?: string;

  /**
   * The volumes to attach to the instance.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-volumes
   */
  readonly volumes?: Array<cdk.IResolvable | CfnInstance.VolumeProperty> | cdk.IResolvable;
}

/**
 * Determine whether the given properties match those of a `EbsProperty`
 *
 * @param properties - the TypeScript properties of a `EbsProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnInstanceEbsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("deleteOnTermination", cdk.validateBoolean)(properties.deleteOnTermination));
  errors.collect(cdk.propertyValidator("encrypted", cdk.validateBoolean)(properties.encrypted));
  errors.collect(cdk.propertyValidator("iops", cdk.validateNumber)(properties.iops));
  errors.collect(cdk.propertyValidator("kmsKeyId", cdk.validateString)(properties.kmsKeyId));
  errors.collect(cdk.propertyValidator("snapshotId", cdk.validateString)(properties.snapshotId));
  errors.collect(cdk.propertyValidator("volumeSize", cdk.validateNumber)(properties.volumeSize));
  errors.collect(cdk.propertyValidator("volumeType", cdk.validateString)(properties.volumeType));
  return errors.wrap("supplied properties not correct for \"EbsProperty\"");
}

// @ts-ignore TS6133
function convertCfnInstanceEbsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnInstanceEbsPropertyValidator(properties).assertSuccess();
  return {
    "DeleteOnTermination": cdk.booleanToCloudFormation(properties.deleteOnTermination),
    "Encrypted": cdk.booleanToCloudFormation(properties.encrypted),
    "Iops": cdk.numberToCloudFormation(properties.iops),
    "KmsKeyId": cdk.stringToCloudFormation(properties.kmsKeyId),
    "SnapshotId": cdk.stringToCloudFormation(properties.snapshotId),
    "VolumeSize": cdk.numberToCloudFormation(properties.volumeSize),
    "VolumeType": cdk.stringToCloudFormation(properties.volumeType)
  };
}

// @ts-ignore TS6133
function CfnInstanceEbsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnInstance.EbsProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnInstance.EbsProperty>();
  ret.addPropertyResult("deleteOnTermination", "DeleteOnTermination", (properties.DeleteOnTermination != null ? cfn_parse.FromCloudFormation.getBoolean(properties.DeleteOnTermination) : undefined));
  ret.addPropertyResult("encrypted", "Encrypted", (properties.Encrypted != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Encrypted) : undefined));
  ret.addPropertyResult("iops", "Iops", (properties.Iops != null ? cfn_parse.FromCloudFormation.getNumber(properties.Iops) : undefined));
  ret.addPropertyResult("kmsKeyId", "KmsKeyId", (properties.KmsKeyId != null ? cfn_parse.FromCloudFormation.getString(properties.KmsKeyId) : undefined));
  ret.addPropertyResult("snapshotId", "SnapshotId", (properties.SnapshotId != null ? cfn_parse.FromCloudFormation.getString(properties.SnapshotId) : undefined));
  ret.addPropertyResult("volumeSize", "VolumeSize", (properties.VolumeSize != null ? cfn_parse.FromCloudFormation.getNumber(properties.VolumeSize) : undefined));
  ret.addPropertyResult("volumeType", "VolumeType", (properties.VolumeType != null ? cfn_parse.FromCloudFormation.getString(properties.VolumeType) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `NoDeviceProperty`
 *
 * @param properties - the TypeScript properties of a `NoDeviceProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnInstanceNoDevicePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  return errors.wrap("supplied properties not correct for \"NoDeviceProperty\"");
}

// @ts-ignore TS6133
function convertCfnInstanceNoDevicePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnInstanceNoDevicePropertyValidator(properties).assertSuccess();
  return {};
}

// @ts-ignore TS6133
function CfnInstanceNoDevicePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnInstance.NoDeviceProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnInstance.NoDeviceProperty>();
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `BlockDeviceMappingProperty`
 *
 * @param properties - the TypeScript properties of a `BlockDeviceMappingProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnInstanceBlockDeviceMappingPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("deviceName", cdk.requiredValidator)(properties.deviceName));
  errors.collect(cdk.propertyValidator("deviceName", cdk.validateString)(properties.deviceName));
  errors.collect(cdk.propertyValidator("ebs", CfnInstanceEbsPropertyValidator)(properties.ebs));
  errors.collect(cdk.propertyValidator("noDevice", CfnInstanceNoDevicePropertyValidator)(properties.noDevice));
  errors.collect(cdk.propertyValidator("virtualName", cdk.validateString)(properties.virtualName));
  return errors.wrap("supplied properties not correct for \"BlockDeviceMappingProperty\"");
}

// @ts-ignore TS6133
function convertCfnInstanceBlockDeviceMappingPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnInstanceBlockDeviceMappingPropertyValidator(properties).assertSuccess();
  return {
    "DeviceName": cdk.stringToCloudFormation(properties.deviceName),
    "Ebs": convertCfnInstanceEbsPropertyToCloudFormation(properties.ebs),
    "NoDevice": convertCfnInstanceNoDevicePropertyToCloudFormation(properties.noDevice),
    "VirtualName": cdk.stringToCloudFormation(properties.virtualName)
  };
}

// @ts-ignore TS6133
function CfnInstanceBlockDeviceMappingPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnInstance.BlockDeviceMappingProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnInstance.BlockDeviceMappingProperty>();
  ret.addPropertyResult("deviceName", "DeviceName", (properties.DeviceName != null ? cfn_parse.FromCloudFormation.getString(properties.DeviceName) : undefined));
  ret.addPropertyResult("ebs", "Ebs", (properties.Ebs != null ? CfnInstanceEbsPropertyFromCloudFormation(properties.Ebs) : undefined));
  ret.addPropertyResult("noDevice", "NoDevice", (properties.NoDevice != null ? CfnInstanceNoDevicePropertyFromCloudFormation(properties.NoDevice) : undefined));
  ret.addPropertyResult("virtualName", "VirtualName", (properties.VirtualName != null ? cfn_parse.FromCloudFormation.getString(properties.VirtualName) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `CpuOptionsProperty`
 *
 * @param properties - the TypeScript properties of a `CpuOptionsProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnInstanceCpuOptionsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("coreCount", cdk.validateNumber)(properties.coreCount));
  errors.collect(cdk.propertyValidator("threadsPerCore", cdk.validateNumber)(properties.threadsPerCore));
  return errors.wrap("supplied properties not correct for \"CpuOptionsProperty\"");
}

// @ts-ignore TS6133
function convertCfnInstanceCpuOptionsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnInstanceCpuOptionsPropertyValidator(properties).assertSuccess();
  return {
    "CoreCount": cdk.numberToCloudFormation(properties.coreCount),
    "ThreadsPerCore": cdk.numberToCloudFormation(properties.threadsPerCore)
  };
}

// @ts-ignore TS6133
function CfnInstanceCpuOptionsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnInstance.CpuOptionsProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnInstance.CpuOptionsProperty>();
  ret.addPropertyResult("coreCount", "CoreCount", (properties.CoreCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.CoreCount) : undefined));
  ret.addPropertyResult("threadsPerCore", "ThreadsPerCore", (properties.ThreadsPerCore != null ? cfn_parse.FromCloudFormation.getNumber(properties.ThreadsPerCore) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `CreditSpecificationProperty`
 *
 * @param properties - the TypeScript properties of a `CreditSpecificationProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnInstanceCreditSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("cpuCredits", cdk.validateString)(properties.cpuCredits));
  return errors.wrap("supplied properties not correct for \"CreditSpecificationProperty\"");
}

// @ts-ignore TS6133
function convertCfnInstanceCreditSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnInstanceCreditSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "CPUCredits": cdk.stringToCloudFormation(properties.cpuCredits)
  };
}

// @ts-ignore TS6133
function CfnInstanceCreditSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnInstance.CreditSpecificationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnInstance.CreditSpecificationProperty>();
  ret.addPropertyResult("cpuCredits", "CPUCredits", (properties.CPUCredits != null ? cfn_parse.FromCloudFormation.getString(properties.CPUCredits) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `ElasticGpuSpecificationProperty`
 *
 * @param properties - the TypeScript properties of a `ElasticGpuSpecificationProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnInstanceElasticGpuSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("type", cdk.requiredValidator)(properties.type));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  return errors.wrap("supplied properties not correct for \"ElasticGpuSpecificationProperty\"");
}

// @ts-ignore TS6133
function convertCfnInstanceElasticGpuSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnInstanceElasticGpuSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "Type": cdk.stringToCloudFormation(properties.type)
  };
}

// @ts-ignore TS6133
function CfnInstanceElasticGpuSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnInstance.ElasticGpuSpecificationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnInstance.ElasticGpuSpecificationProperty>();
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `ElasticInferenceAcceleratorProperty`
 *
 * @param properties - the TypeScript properties of a `ElasticInferenceAcceleratorProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnInstanceElasticInferenceAcceleratorPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("count", cdk.validateNumber)(properties.count));
  errors.collect(cdk.propertyValidator("type", cdk.requiredValidator)(properties.type));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  return errors.wrap("supplied properties not correct for \"ElasticInferenceAcceleratorProperty\"");
}

// @ts-ignore TS6133
function convertCfnInstanceElasticInferenceAcceleratorPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnInstanceElasticInferenceAcceleratorPropertyValidator(properties).assertSuccess();
  return {
    "Count": cdk.numberToCloudFormation(properties.count),
    "Type": cdk.stringToCloudFormation(properties.type)
  };
}

// @ts-ignore TS6133
function CfnInstanceElasticInferenceAcceleratorPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnInstance.ElasticInferenceAcceleratorProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnInstance.ElasticInferenceAcceleratorProperty>();
  ret.addPropertyResult("count", "Count", (properties.Count != null ? cfn_parse.FromCloudFormation.getNumber(properties.Count) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `EnclaveOptionsProperty`
 *
 * @param properties - the TypeScript properties of a `EnclaveOptionsProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnInstanceEnclaveOptionsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("enabled", cdk.validateBoolean)(properties.enabled));
  return errors.wrap("supplied properties not correct for \"EnclaveOptionsProperty\"");
}

// @ts-ignore TS6133
function convertCfnInstanceEnclaveOptionsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnInstanceEnclaveOptionsPropertyValidator(properties).assertSuccess();
  return {
    "Enabled": cdk.booleanToCloudFormation(properties.enabled)
  };
}

// @ts-ignore TS6133
function CfnInstanceEnclaveOptionsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnInstance.EnclaveOptionsProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnInstance.EnclaveOptionsProperty>();
  ret.addPropertyResult("enabled", "Enabled", (properties.Enabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Enabled) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `HibernationOptionsProperty`
 *
 * @param properties - the TypeScript properties of a `HibernationOptionsProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnInstanceHibernationOptionsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("configured", cdk.validateBoolean)(properties.configured));
  return errors.wrap("supplied properties not correct for \"HibernationOptionsProperty\"");
}

// @ts-ignore TS6133
function convertCfnInstanceHibernationOptionsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnInstanceHibernationOptionsPropertyValidator(properties).assertSuccess();
  return {
    "Configured": cdk.booleanToCloudFormation(properties.configured)
  };
}

// @ts-ignore TS6133
function CfnInstanceHibernationOptionsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnInstance.HibernationOptionsProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnInstance.HibernationOptionsProperty>();
  ret.addPropertyResult("configured", "Configured", (properties.Configured != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Configured) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `InstanceIpv6AddressProperty`
 *
 * @param properties - the TypeScript properties of a `InstanceIpv6AddressProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnInstanceInstanceIpv6AddressPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("ipv6Address", cdk.requiredValidator)(properties.ipv6Address));
  errors.collect(cdk.propertyValidator("ipv6Address", cdk.validateString)(properties.ipv6Address));
  return errors.wrap("supplied properties not correct for \"InstanceIpv6AddressProperty\"");
}

// @ts-ignore TS6133
function convertCfnInstanceInstanceIpv6AddressPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnInstanceInstanceIpv6AddressPropertyValidator(properties).assertSuccess();
  return {
    "Ipv6Address": cdk.stringToCloudFormation(properties.ipv6Address)
  };
}

// @ts-ignore TS6133
function CfnInstanceInstanceIpv6AddressPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnInstance.InstanceIpv6AddressProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnInstance.InstanceIpv6AddressProperty>();
  ret.addPropertyResult("ipv6Address", "Ipv6Address", (properties.Ipv6Address != null ? cfn_parse.FromCloudFormation.getString(properties.Ipv6Address) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `LaunchTemplateSpecificationProperty`
 *
 * @param properties - the TypeScript properties of a `LaunchTemplateSpecificationProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnInstanceLaunchTemplateSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("launchTemplateId", cdk.validateString)(properties.launchTemplateId));
  errors.collect(cdk.propertyValidator("launchTemplateName", cdk.validateString)(properties.launchTemplateName));
  errors.collect(cdk.propertyValidator("version", cdk.requiredValidator)(properties.version));
  errors.collect(cdk.propertyValidator("version", cdk.validateString)(properties.version));
  return errors.wrap("supplied properties not correct for \"LaunchTemplateSpecificationProperty\"");
}

// @ts-ignore TS6133
function convertCfnInstanceLaunchTemplateSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnInstanceLaunchTemplateSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "LaunchTemplateId": cdk.stringToCloudFormation(properties.launchTemplateId),
    "LaunchTemplateName": cdk.stringToCloudFormation(properties.launchTemplateName),
    "Version": cdk.stringToCloudFormation(properties.version)
  };
}

// @ts-ignore TS6133
function CfnInstanceLaunchTemplateSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnInstance.LaunchTemplateSpecificationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnInstance.LaunchTemplateSpecificationProperty>();
  ret.addPropertyResult("launchTemplateId", "LaunchTemplateId", (properties.LaunchTemplateId != null ? cfn_parse.FromCloudFormation.getString(properties.LaunchTemplateId) : undefined));
  ret.addPropertyResult("launchTemplateName", "LaunchTemplateName", (properties.LaunchTemplateName != null ? cfn_parse.FromCloudFormation.getString(properties.LaunchTemplateName) : undefined));
  ret.addPropertyResult("version", "Version", (properties.Version != null ? cfn_parse.FromCloudFormation.getString(properties.Version) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `LicenseSpecificationProperty`
 *
 * @param properties - the TypeScript properties of a `LicenseSpecificationProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnInstanceLicenseSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("licenseConfigurationArn", cdk.requiredValidator)(properties.licenseConfigurationArn));
  errors.collect(cdk.propertyValidator("licenseConfigurationArn", cdk.validateString)(properties.licenseConfigurationArn));
  return errors.wrap("supplied properties not correct for \"LicenseSpecificationProperty\"");
}

// @ts-ignore TS6133
function convertCfnInstanceLicenseSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnInstanceLicenseSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "LicenseConfigurationArn": cdk.stringToCloudFormation(properties.licenseConfigurationArn)
  };
}

// @ts-ignore TS6133
function CfnInstanceLicenseSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnInstance.LicenseSpecificationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnInstance.LicenseSpecificationProperty>();
  ret.addPropertyResult("licenseConfigurationArn", "LicenseConfigurationArn", (properties.LicenseConfigurationArn != null ? cfn_parse.FromCloudFormation.getString(properties.LicenseConfigurationArn) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `PrivateIpAddressSpecificationProperty`
 *
 * @param properties - the TypeScript properties of a `PrivateIpAddressSpecificationProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnInstancePrivateIpAddressSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("primary", cdk.requiredValidator)(properties.primary));
  errors.collect(cdk.propertyValidator("primary", cdk.validateBoolean)(properties.primary));
  errors.collect(cdk.propertyValidator("privateIpAddress", cdk.requiredValidator)(properties.privateIpAddress));
  errors.collect(cdk.propertyValidator("privateIpAddress", cdk.validateString)(properties.privateIpAddress));
  return errors.wrap("supplied properties not correct for \"PrivateIpAddressSpecificationProperty\"");
}

// @ts-ignore TS6133
function convertCfnInstancePrivateIpAddressSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnInstancePrivateIpAddressSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "Primary": cdk.booleanToCloudFormation(properties.primary),
    "PrivateIpAddress": cdk.stringToCloudFormation(properties.privateIpAddress)
  };
}

// @ts-ignore TS6133
function CfnInstancePrivateIpAddressSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnInstance.PrivateIpAddressSpecificationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnInstance.PrivateIpAddressSpecificationProperty>();
  ret.addPropertyResult("primary", "Primary", (properties.Primary != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Primary) : undefined));
  ret.addPropertyResult("privateIpAddress", "PrivateIpAddress", (properties.PrivateIpAddress != null ? cfn_parse.FromCloudFormation.getString(properties.PrivateIpAddress) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `NetworkInterfaceProperty`
 *
 * @param properties - the TypeScript properties of a `NetworkInterfaceProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnInstanceNetworkInterfacePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("associateCarrierIpAddress", cdk.validateBoolean)(properties.associateCarrierIpAddress));
  errors.collect(cdk.propertyValidator("associatePublicIpAddress", cdk.validateBoolean)(properties.associatePublicIpAddress));
  errors.collect(cdk.propertyValidator("deleteOnTermination", cdk.validateBoolean)(properties.deleteOnTermination));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("deviceIndex", cdk.requiredValidator)(properties.deviceIndex));
  errors.collect(cdk.propertyValidator("deviceIndex", cdk.validateString)(properties.deviceIndex));
  errors.collect(cdk.propertyValidator("groupSet", cdk.listValidator(cdk.validateString))(properties.groupSet));
  errors.collect(cdk.propertyValidator("ipv6AddressCount", cdk.validateNumber)(properties.ipv6AddressCount));
  errors.collect(cdk.propertyValidator("ipv6Addresses", cdk.listValidator(CfnInstanceInstanceIpv6AddressPropertyValidator))(properties.ipv6Addresses));
  errors.collect(cdk.propertyValidator("networkInterfaceId", cdk.validateString)(properties.networkInterfaceId));
  errors.collect(cdk.propertyValidator("privateIpAddress", cdk.validateString)(properties.privateIpAddress));
  errors.collect(cdk.propertyValidator("privateIpAddresses", cdk.listValidator(CfnInstancePrivateIpAddressSpecificationPropertyValidator))(properties.privateIpAddresses));
  errors.collect(cdk.propertyValidator("secondaryPrivateIpAddressCount", cdk.validateNumber)(properties.secondaryPrivateIpAddressCount));
  errors.collect(cdk.propertyValidator("subnetId", cdk.validateString)(properties.subnetId));
  return errors.wrap("supplied properties not correct for \"NetworkInterfaceProperty\"");
}

// @ts-ignore TS6133
function convertCfnInstanceNetworkInterfacePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnInstanceNetworkInterfacePropertyValidator(properties).assertSuccess();
  return {
    "AssociateCarrierIpAddress": cdk.booleanToCloudFormation(properties.associateCarrierIpAddress),
    "AssociatePublicIpAddress": cdk.booleanToCloudFormation(properties.associatePublicIpAddress),
    "DeleteOnTermination": cdk.booleanToCloudFormation(properties.deleteOnTermination),
    "Description": cdk.stringToCloudFormation(properties.description),
    "DeviceIndex": cdk.stringToCloudFormation(properties.deviceIndex),
    "GroupSet": cdk.listMapper(cdk.stringToCloudFormation)(properties.groupSet),
    "Ipv6AddressCount": cdk.numberToCloudFormation(properties.ipv6AddressCount),
    "Ipv6Addresses": cdk.listMapper(convertCfnInstanceInstanceIpv6AddressPropertyToCloudFormation)(properties.ipv6Addresses),
    "NetworkInterfaceId": cdk.stringToCloudFormation(properties.networkInterfaceId),
    "PrivateIpAddress": cdk.stringToCloudFormation(properties.privateIpAddress),
    "PrivateIpAddresses": cdk.listMapper(convertCfnInstancePrivateIpAddressSpecificationPropertyToCloudFormation)(properties.privateIpAddresses),
    "SecondaryPrivateIpAddressCount": cdk.numberToCloudFormation(properties.secondaryPrivateIpAddressCount),
    "SubnetId": cdk.stringToCloudFormation(properties.subnetId)
  };
}

// @ts-ignore TS6133
function CfnInstanceNetworkInterfacePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnInstance.NetworkInterfaceProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnInstance.NetworkInterfaceProperty>();
  ret.addPropertyResult("associateCarrierIpAddress", "AssociateCarrierIpAddress", (properties.AssociateCarrierIpAddress != null ? cfn_parse.FromCloudFormation.getBoolean(properties.AssociateCarrierIpAddress) : undefined));
  ret.addPropertyResult("associatePublicIpAddress", "AssociatePublicIpAddress", (properties.AssociatePublicIpAddress != null ? cfn_parse.FromCloudFormation.getBoolean(properties.AssociatePublicIpAddress) : undefined));
  ret.addPropertyResult("deleteOnTermination", "DeleteOnTermination", (properties.DeleteOnTermination != null ? cfn_parse.FromCloudFormation.getBoolean(properties.DeleteOnTermination) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("deviceIndex", "DeviceIndex", (properties.DeviceIndex != null ? cfn_parse.FromCloudFormation.getString(properties.DeviceIndex) : undefined));
  ret.addPropertyResult("groupSet", "GroupSet", (properties.GroupSet != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.GroupSet) : undefined));
  ret.addPropertyResult("ipv6AddressCount", "Ipv6AddressCount", (properties.Ipv6AddressCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.Ipv6AddressCount) : undefined));
  ret.addPropertyResult("ipv6Addresses", "Ipv6Addresses", (properties.Ipv6Addresses != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceInstanceIpv6AddressPropertyFromCloudFormation)(properties.Ipv6Addresses) : undefined));
  ret.addPropertyResult("networkInterfaceId", "NetworkInterfaceId", (properties.NetworkInterfaceId != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkInterfaceId) : undefined));
  ret.addPropertyResult("privateIpAddress", "PrivateIpAddress", (properties.PrivateIpAddress != null ? cfn_parse.FromCloudFormation.getString(properties.PrivateIpAddress) : undefined));
  ret.addPropertyResult("privateIpAddresses", "PrivateIpAddresses", (properties.PrivateIpAddresses != null ? cfn_parse.FromCloudFormation.getArray(CfnInstancePrivateIpAddressSpecificationPropertyFromCloudFormation)(properties.PrivateIpAddresses) : undefined));
  ret.addPropertyResult("secondaryPrivateIpAddressCount", "SecondaryPrivateIpAddressCount", (properties.SecondaryPrivateIpAddressCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.SecondaryPrivateIpAddressCount) : undefined));
  ret.addPropertyResult("subnetId", "SubnetId", (properties.SubnetId != null ? cfn_parse.FromCloudFormation.getString(properties.SubnetId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `PrivateDnsNameOptionsProperty`
 *
 * @param properties - the TypeScript properties of a `PrivateDnsNameOptionsProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnInstancePrivateDnsNameOptionsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("enableResourceNameDnsAaaaRecord", cdk.validateBoolean)(properties.enableResourceNameDnsAaaaRecord));
  errors.collect(cdk.propertyValidator("enableResourceNameDnsARecord", cdk.validateBoolean)(properties.enableResourceNameDnsARecord));
  errors.collect(cdk.propertyValidator("hostnameType", cdk.validateString)(properties.hostnameType));
  return errors.wrap("supplied properties not correct for \"PrivateDnsNameOptionsProperty\"");
}

// @ts-ignore TS6133
function convertCfnInstancePrivateDnsNameOptionsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnInstancePrivateDnsNameOptionsPropertyValidator(properties).assertSuccess();
  return {
    "EnableResourceNameDnsAAAARecord": cdk.booleanToCloudFormation(properties.enableResourceNameDnsAaaaRecord),
    "EnableResourceNameDnsARecord": cdk.booleanToCloudFormation(properties.enableResourceNameDnsARecord),
    "HostnameType": cdk.stringToCloudFormation(properties.hostnameType)
  };
}

// @ts-ignore TS6133
function CfnInstancePrivateDnsNameOptionsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnInstance.PrivateDnsNameOptionsProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnInstance.PrivateDnsNameOptionsProperty>();
  ret.addPropertyResult("enableResourceNameDnsAaaaRecord", "EnableResourceNameDnsAAAARecord", (properties.EnableResourceNameDnsAAAARecord != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EnableResourceNameDnsAAAARecord) : undefined));
  ret.addPropertyResult("enableResourceNameDnsARecord", "EnableResourceNameDnsARecord", (properties.EnableResourceNameDnsARecord != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EnableResourceNameDnsARecord) : undefined));
  ret.addPropertyResult("hostnameType", "HostnameType", (properties.HostnameType != null ? cfn_parse.FromCloudFormation.getString(properties.HostnameType) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `AssociationParameterProperty`
 *
 * @param properties - the TypeScript properties of a `AssociationParameterProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnInstanceAssociationParameterPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("key", cdk.requiredValidator)(properties.key));
  errors.collect(cdk.propertyValidator("key", cdk.validateString)(properties.key));
  errors.collect(cdk.propertyValidator("value", cdk.requiredValidator)(properties.value));
  errors.collect(cdk.propertyValidator("value", cdk.listValidator(cdk.validateString))(properties.value));
  return errors.wrap("supplied properties not correct for \"AssociationParameterProperty\"");
}

// @ts-ignore TS6133
function convertCfnInstanceAssociationParameterPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnInstanceAssociationParameterPropertyValidator(properties).assertSuccess();
  return {
    "Key": cdk.stringToCloudFormation(properties.key),
    "Value": cdk.listMapper(cdk.stringToCloudFormation)(properties.value)
  };
}

// @ts-ignore TS6133
function CfnInstanceAssociationParameterPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnInstance.AssociationParameterProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnInstance.AssociationParameterProperty>();
  ret.addPropertyResult("key", "Key", (properties.Key != null ? cfn_parse.FromCloudFormation.getString(properties.Key) : undefined));
  ret.addPropertyResult("value", "Value", (properties.Value != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.Value) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `SsmAssociationProperty`
 *
 * @param properties - the TypeScript properties of a `SsmAssociationProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnInstanceSsmAssociationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("associationParameters", cdk.listValidator(CfnInstanceAssociationParameterPropertyValidator))(properties.associationParameters));
  errors.collect(cdk.propertyValidator("documentName", cdk.requiredValidator)(properties.documentName));
  errors.collect(cdk.propertyValidator("documentName", cdk.validateString)(properties.documentName));
  return errors.wrap("supplied properties not correct for \"SsmAssociationProperty\"");
}

// @ts-ignore TS6133
function convertCfnInstanceSsmAssociationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnInstanceSsmAssociationPropertyValidator(properties).assertSuccess();
  return {
    "AssociationParameters": cdk.listMapper(convertCfnInstanceAssociationParameterPropertyToCloudFormation)(properties.associationParameters),
    "DocumentName": cdk.stringToCloudFormation(properties.documentName)
  };
}

// @ts-ignore TS6133
function CfnInstanceSsmAssociationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnInstance.SsmAssociationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnInstance.SsmAssociationProperty>();
  ret.addPropertyResult("associationParameters", "AssociationParameters", (properties.AssociationParameters != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceAssociationParameterPropertyFromCloudFormation)(properties.AssociationParameters) : undefined));
  ret.addPropertyResult("documentName", "DocumentName", (properties.DocumentName != null ? cfn_parse.FromCloudFormation.getString(properties.DocumentName) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `VolumeProperty`
 *
 * @param properties - the TypeScript properties of a `VolumeProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnInstanceVolumePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("device", cdk.requiredValidator)(properties.device));
  errors.collect(cdk.propertyValidator("device", cdk.validateString)(properties.device));
  errors.collect(cdk.propertyValidator("volumeId", cdk.requiredValidator)(properties.volumeId));
  errors.collect(cdk.propertyValidator("volumeId", cdk.validateString)(properties.volumeId));
  return errors.wrap("supplied properties not correct for \"VolumeProperty\"");
}

// @ts-ignore TS6133
function convertCfnInstanceVolumePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnInstanceVolumePropertyValidator(properties).assertSuccess();
  return {
    "Device": cdk.stringToCloudFormation(properties.device),
    "VolumeId": cdk.stringToCloudFormation(properties.volumeId)
  };
}

// @ts-ignore TS6133
function CfnInstanceVolumePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnInstance.VolumeProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnInstance.VolumeProperty>();
  ret.addPropertyResult("device", "Device", (properties.Device != null ? cfn_parse.FromCloudFormation.getString(properties.Device) : undefined));
  ret.addPropertyResult("volumeId", "VolumeId", (properties.VolumeId != null ? cfn_parse.FromCloudFormation.getString(properties.VolumeId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `CfnInstanceProps`
 *
 * @param properties - the TypeScript properties of a `CfnInstanceProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnInstancePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("additionalInfo", cdk.validateString)(properties.additionalInfo));
  errors.collect(cdk.propertyValidator("affinity", cdk.validateString)(properties.affinity));
  errors.collect(cdk.propertyValidator("availabilityZone", cdk.validateString)(properties.availabilityZone));
  errors.collect(cdk.propertyValidator("blockDeviceMappings", cdk.listValidator(CfnInstanceBlockDeviceMappingPropertyValidator))(properties.blockDeviceMappings));
  errors.collect(cdk.propertyValidator("cpuOptions", CfnInstanceCpuOptionsPropertyValidator)(properties.cpuOptions));
  errors.collect(cdk.propertyValidator("creditSpecification", CfnInstanceCreditSpecificationPropertyValidator)(properties.creditSpecification));
  errors.collect(cdk.propertyValidator("disableApiTermination", cdk.validateBoolean)(properties.disableApiTermination));
  errors.collect(cdk.propertyValidator("ebsOptimized", cdk.validateBoolean)(properties.ebsOptimized));
  errors.collect(cdk.propertyValidator("elasticGpuSpecifications", cdk.listValidator(CfnInstanceElasticGpuSpecificationPropertyValidator))(properties.elasticGpuSpecifications));
  errors.collect(cdk.propertyValidator("elasticInferenceAccelerators", cdk.listValidator(CfnInstanceElasticInferenceAcceleratorPropertyValidator))(properties.elasticInferenceAccelerators));
  errors.collect(cdk.propertyValidator("enclaveOptions", CfnInstanceEnclaveOptionsPropertyValidator)(properties.enclaveOptions));
  errors.collect(cdk.propertyValidator("hibernationOptions", CfnInstanceHibernationOptionsPropertyValidator)(properties.hibernationOptions));
  errors.collect(cdk.propertyValidator("hostId", cdk.validateString)(properties.hostId));
  errors.collect(cdk.propertyValidator("hostResourceGroupArn", cdk.validateString)(properties.hostResourceGroupArn));
  errors.collect(cdk.propertyValidator("iamInstanceProfile", cdk.validateString)(properties.iamInstanceProfile));
  errors.collect(cdk.propertyValidator("imageId", cdk.validateString)(properties.imageId));
  errors.collect(cdk.propertyValidator("instanceInitiatedShutdownBehavior", cdk.validateString)(properties.instanceInitiatedShutdownBehavior));
  errors.collect(cdk.propertyValidator("instanceType", cdk.validateString)(properties.instanceType));
  errors.collect(cdk.propertyValidator("ipv6AddressCount", cdk.validateNumber)(properties.ipv6AddressCount));
  errors.collect(cdk.propertyValidator("ipv6Addresses", cdk.listValidator(CfnInstanceInstanceIpv6AddressPropertyValidator))(properties.ipv6Addresses));
  errors.collect(cdk.propertyValidator("kernelId", cdk.validateString)(properties.kernelId));
  errors.collect(cdk.propertyValidator("keyName", cdk.validateString)(properties.keyName));
  errors.collect(cdk.propertyValidator("launchTemplate", CfnInstanceLaunchTemplateSpecificationPropertyValidator)(properties.launchTemplate));
  errors.collect(cdk.propertyValidator("licenseSpecifications", cdk.listValidator(CfnInstanceLicenseSpecificationPropertyValidator))(properties.licenseSpecifications));
  errors.collect(cdk.propertyValidator("monitoring", cdk.validateBoolean)(properties.monitoring));
  errors.collect(cdk.propertyValidator("networkInterfaces", cdk.listValidator(CfnInstanceNetworkInterfacePropertyValidator))(properties.networkInterfaces));
  errors.collect(cdk.propertyValidator("placementGroupName", cdk.validateString)(properties.placementGroupName));
  errors.collect(cdk.propertyValidator("privateDnsNameOptions", CfnInstancePrivateDnsNameOptionsPropertyValidator)(properties.privateDnsNameOptions));
  errors.collect(cdk.propertyValidator("privateIpAddress", cdk.validateString)(properties.privateIpAddress));
  errors.collect(cdk.propertyValidator("propagateTagsToVolumeOnCreation", cdk.validateBoolean)(properties.propagateTagsToVolumeOnCreation));
  errors.collect(cdk.propertyValidator("ramdiskId", cdk.validateString)(properties.ramdiskId));
  errors.collect(cdk.propertyValidator("securityGroupIds", cdk.listValidator(cdk.validateString))(properties.securityGroupIds));
  errors.collect(cdk.propertyValidator("securityGroups", cdk.listValidator(cdk.validateString))(properties.securityGroups));
  errors.collect(cdk.propertyValidator("sourceDestCheck", cdk.validateBoolean)(properties.sourceDestCheck));
  errors.collect(cdk.propertyValidator("ssmAssociations", cdk.listValidator(CfnInstanceSsmAssociationPropertyValidator))(properties.ssmAssociations));
  errors.collect(cdk.propertyValidator("subnetId", cdk.validateString)(properties.subnetId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("tenancy", cdk.validateString)(properties.tenancy));
  errors.collect(cdk.propertyValidator("userData", cdk.validateString)(properties.userData));
  errors.collect(cdk.propertyValidator("volumes", cdk.listValidator(CfnInstanceVolumePropertyValidator))(properties.volumes));
  return errors.wrap("supplied properties not correct for \"CfnInstanceProps\"");
}

// @ts-ignore TS6133
function convertCfnInstancePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnInstancePropsValidator(properties).assertSuccess();
  return {
    "AdditionalInfo": cdk.stringToCloudFormation(properties.additionalInfo),
    "Affinity": cdk.stringToCloudFormation(properties.affinity),
    "AvailabilityZone": cdk.stringToCloudFormation(properties.availabilityZone),
    "BlockDeviceMappings": cdk.listMapper(convertCfnInstanceBlockDeviceMappingPropertyToCloudFormation)(properties.blockDeviceMappings),
    "CpuOptions": convertCfnInstanceCpuOptionsPropertyToCloudFormation(properties.cpuOptions),
    "CreditSpecification": convertCfnInstanceCreditSpecificationPropertyToCloudFormation(properties.creditSpecification),
    "DisableApiTermination": cdk.booleanToCloudFormation(properties.disableApiTermination),
    "EbsOptimized": cdk.booleanToCloudFormation(properties.ebsOptimized),
    "ElasticGpuSpecifications": cdk.listMapper(convertCfnInstanceElasticGpuSpecificationPropertyToCloudFormation)(properties.elasticGpuSpecifications),
    "ElasticInferenceAccelerators": cdk.listMapper(convertCfnInstanceElasticInferenceAcceleratorPropertyToCloudFormation)(properties.elasticInferenceAccelerators),
    "EnclaveOptions": convertCfnInstanceEnclaveOptionsPropertyToCloudFormation(properties.enclaveOptions),
    "HibernationOptions": convertCfnInstanceHibernationOptionsPropertyToCloudFormation(properties.hibernationOptions),
    "HostId": cdk.stringToCloudFormation(properties.hostId),
    "HostResourceGroupArn": cdk.stringToCloudFormation(properties.hostResourceGroupArn),
    "IamInstanceProfile": cdk.stringToCloudFormation(properties.iamInstanceProfile),
    "ImageId": cdk.stringToCloudFormation(properties.imageId),
    "InstanceInitiatedShutdownBehavior": cdk.stringToCloudFormation(properties.instanceInitiatedShutdownBehavior),
    "InstanceType": cdk.stringToCloudFormation(properties.instanceType),
    "Ipv6AddressCount": cdk.numberToCloudFormation(properties.ipv6AddressCount),
    "Ipv6Addresses": cdk.listMapper(convertCfnInstanceInstanceIpv6AddressPropertyToCloudFormation)(properties.ipv6Addresses),
    "KernelId": cdk.stringToCloudFormation(properties.kernelId),
    "KeyName": cdk.stringToCloudFormation(properties.keyName),
    "LaunchTemplate": convertCfnInstanceLaunchTemplateSpecificationPropertyToCloudFormation(properties.launchTemplate),
    "LicenseSpecifications": cdk.listMapper(convertCfnInstanceLicenseSpecificationPropertyToCloudFormation)(properties.licenseSpecifications),
    "Monitoring": cdk.booleanToCloudFormation(properties.monitoring),
    "NetworkInterfaces": cdk.listMapper(convertCfnInstanceNetworkInterfacePropertyToCloudFormation)(properties.networkInterfaces),
    "PlacementGroupName": cdk.stringToCloudFormation(properties.placementGroupName),
    "PrivateDnsNameOptions": convertCfnInstancePrivateDnsNameOptionsPropertyToCloudFormation(properties.privateDnsNameOptions),
    "PrivateIpAddress": cdk.stringToCloudFormation(properties.privateIpAddress),
    "PropagateTagsToVolumeOnCreation": cdk.booleanToCloudFormation(properties.propagateTagsToVolumeOnCreation),
    "RamdiskId": cdk.stringToCloudFormation(properties.ramdiskId),
    "SecurityGroupIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.securityGroupIds),
    "SecurityGroups": cdk.listMapper(cdk.stringToCloudFormation)(properties.securityGroups),
    "SourceDestCheck": cdk.booleanToCloudFormation(properties.sourceDestCheck),
    "SsmAssociations": cdk.listMapper(convertCfnInstanceSsmAssociationPropertyToCloudFormation)(properties.ssmAssociations),
    "SubnetId": cdk.stringToCloudFormation(properties.subnetId),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "Tenancy": cdk.stringToCloudFormation(properties.tenancy),
    "UserData": cdk.stringToCloudFormation(properties.userData),
    "Volumes": cdk.listMapper(convertCfnInstanceVolumePropertyToCloudFormation)(properties.volumes)
  };
}

// @ts-ignore TS6133
function CfnInstancePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnInstanceProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnInstanceProps>();
  ret.addPropertyResult("additionalInfo", "AdditionalInfo", (properties.AdditionalInfo != null ? cfn_parse.FromCloudFormation.getString(properties.AdditionalInfo) : undefined));
  ret.addPropertyResult("affinity", "Affinity", (properties.Affinity != null ? cfn_parse.FromCloudFormation.getString(properties.Affinity) : undefined));
  ret.addPropertyResult("availabilityZone", "AvailabilityZone", (properties.AvailabilityZone != null ? cfn_parse.FromCloudFormation.getString(properties.AvailabilityZone) : undefined));
  ret.addPropertyResult("blockDeviceMappings", "BlockDeviceMappings", (properties.BlockDeviceMappings != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceBlockDeviceMappingPropertyFromCloudFormation)(properties.BlockDeviceMappings) : undefined));
  ret.addPropertyResult("cpuOptions", "CpuOptions", (properties.CpuOptions != null ? CfnInstanceCpuOptionsPropertyFromCloudFormation(properties.CpuOptions) : undefined));
  ret.addPropertyResult("creditSpecification", "CreditSpecification", (properties.CreditSpecification != null ? CfnInstanceCreditSpecificationPropertyFromCloudFormation(properties.CreditSpecification) : undefined));
  ret.addPropertyResult("disableApiTermination", "DisableApiTermination", (properties.DisableApiTermination != null ? cfn_parse.FromCloudFormation.getBoolean(properties.DisableApiTermination) : undefined));
  ret.addPropertyResult("ebsOptimized", "EbsOptimized", (properties.EbsOptimized != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EbsOptimized) : undefined));
  ret.addPropertyResult("elasticGpuSpecifications", "ElasticGpuSpecifications", (properties.ElasticGpuSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceElasticGpuSpecificationPropertyFromCloudFormation)(properties.ElasticGpuSpecifications) : undefined));
  ret.addPropertyResult("elasticInferenceAccelerators", "ElasticInferenceAccelerators", (properties.ElasticInferenceAccelerators != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceElasticInferenceAcceleratorPropertyFromCloudFormation)(properties.ElasticInferenceAccelerators) : undefined));
  ret.addPropertyResult("enclaveOptions", "EnclaveOptions", (properties.EnclaveOptions != null ? CfnInstanceEnclaveOptionsPropertyFromCloudFormation(properties.EnclaveOptions) : undefined));
  ret.addPropertyResult("hibernationOptions", "HibernationOptions", (properties.HibernationOptions != null ? CfnInstanceHibernationOptionsPropertyFromCloudFormation(properties.HibernationOptions) : undefined));
  ret.addPropertyResult("hostId", "HostId", (properties.HostId != null ? cfn_parse.FromCloudFormation.getString(properties.HostId) : undefined));
  ret.addPropertyResult("hostResourceGroupArn", "HostResourceGroupArn", (properties.HostResourceGroupArn != null ? cfn_parse.FromCloudFormation.getString(properties.HostResourceGroupArn) : undefined));
  ret.addPropertyResult("iamInstanceProfile", "IamInstanceProfile", (properties.IamInstanceProfile != null ? cfn_parse.FromCloudFormation.getString(properties.IamInstanceProfile) : undefined));
  ret.addPropertyResult("imageId", "ImageId", (properties.ImageId != null ? cfn_parse.FromCloudFormation.getString(properties.ImageId) : undefined));
  ret.addPropertyResult("instanceInitiatedShutdownBehavior", "InstanceInitiatedShutdownBehavior", (properties.InstanceInitiatedShutdownBehavior != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceInitiatedShutdownBehavior) : undefined));
  ret.addPropertyResult("instanceType", "InstanceType", (properties.InstanceType != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceType) : undefined));
  ret.addPropertyResult("ipv6AddressCount", "Ipv6AddressCount", (properties.Ipv6AddressCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.Ipv6AddressCount) : undefined));
  ret.addPropertyResult("ipv6Addresses", "Ipv6Addresses", (properties.Ipv6Addresses != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceInstanceIpv6AddressPropertyFromCloudFormation)(properties.Ipv6Addresses) : undefined));
  ret.addPropertyResult("kernelId", "KernelId", (properties.KernelId != null ? cfn_parse.FromCloudFormation.getString(properties.KernelId) : undefined));
  ret.addPropertyResult("keyName", "KeyName", (properties.KeyName != null ? cfn_parse.FromCloudFormation.getString(properties.KeyName) : undefined));
  ret.addPropertyResult("launchTemplate", "LaunchTemplate", (properties.LaunchTemplate != null ? CfnInstanceLaunchTemplateSpecificationPropertyFromCloudFormation(properties.LaunchTemplate) : undefined));
  ret.addPropertyResult("licenseSpecifications", "LicenseSpecifications", (properties.LicenseSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceLicenseSpecificationPropertyFromCloudFormation)(properties.LicenseSpecifications) : undefined));
  ret.addPropertyResult("monitoring", "Monitoring", (properties.Monitoring != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Monitoring) : undefined));
  ret.addPropertyResult("networkInterfaces", "NetworkInterfaces", (properties.NetworkInterfaces != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceNetworkInterfacePropertyFromCloudFormation)(properties.NetworkInterfaces) : undefined));
  ret.addPropertyResult("placementGroupName", "PlacementGroupName", (properties.PlacementGroupName != null ? cfn_parse.FromCloudFormation.getString(properties.PlacementGroupName) : undefined));
  ret.addPropertyResult("privateDnsNameOptions", "PrivateDnsNameOptions", (properties.PrivateDnsNameOptions != null ? CfnInstancePrivateDnsNameOptionsPropertyFromCloudFormation(properties.PrivateDnsNameOptions) : undefined));
  ret.addPropertyResult("privateIpAddress", "PrivateIpAddress", (properties.PrivateIpAddress != null ? cfn_parse.FromCloudFormation.getString(properties.PrivateIpAddress) : undefined));
  ret.addPropertyResult("propagateTagsToVolumeOnCreation", "PropagateTagsToVolumeOnCreation", (properties.PropagateTagsToVolumeOnCreation != null ? cfn_parse.FromCloudFormation.getBoolean(properties.PropagateTagsToVolumeOnCreation) : undefined));
  ret.addPropertyResult("ramdiskId", "RamdiskId", (properties.RamdiskId != null ? cfn_parse.FromCloudFormation.getString(properties.RamdiskId) : undefined));
  ret.addPropertyResult("securityGroupIds", "SecurityGroupIds", (properties.SecurityGroupIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecurityGroupIds) : undefined));
  ret.addPropertyResult("securityGroups", "SecurityGroups", (properties.SecurityGroups != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecurityGroups) : undefined));
  ret.addPropertyResult("sourceDestCheck", "SourceDestCheck", (properties.SourceDestCheck != null ? cfn_parse.FromCloudFormation.getBoolean(properties.SourceDestCheck) : undefined));
  ret.addPropertyResult("ssmAssociations", "SsmAssociations", (properties.SsmAssociations != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceSsmAssociationPropertyFromCloudFormation)(properties.SsmAssociations) : undefined));
  ret.addPropertyResult("subnetId", "SubnetId", (properties.SubnetId != null ? cfn_parse.FromCloudFormation.getString(properties.SubnetId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("tenancy", "Tenancy", (properties.Tenancy != null ? cfn_parse.FromCloudFormation.getString(properties.Tenancy) : undefined));
  ret.addPropertyResult("userData", "UserData", (properties.UserData != null ? cfn_parse.FromCloudFormation.getString(properties.UserData) : undefined));
  ret.addPropertyResult("volumes", "Volumes", (properties.Volumes != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceVolumePropertyFromCloudFormation)(properties.Volumes) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Creates an EC2 Instance Connect Endpoint.
 *
 * An EC2 Instance Connect Endpoint allows you to connect to an instance, without requiring the instance to have a public IPv4 address. For more information, see [Connect to your instances without requiring a public IPv4 address using EC2 Instance Connect Endpoint](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Connect-using-EC2-Instance-Connect-Endpoint.html) in the *Amazon EC2 User Guide* .
 *
 * @cloudformationResource AWS::EC2::InstanceConnectEndpoint
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instanceconnectendpoint.html
 */
export class CfnInstanceConnectEndpoint extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::InstanceConnectEndpoint";

  /**
   * Build a CfnInstanceConnectEndpoint from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnInstanceConnectEndpoint {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnInstanceConnectEndpointPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnInstanceConnectEndpoint(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the EC2 Instance Connect Endpoint.
   *
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
   */
  public clientToken?: string;

  /**
   * Indicates whether your client's IP address is preserved as the source. The value is `true` or `false` .
   */
  public preserveClientIp?: boolean | cdk.IResolvable;

  /**
   * One or more security groups to associate with the endpoint.
   */
  public securityGroupIds?: Array<string>;

  /**
   * The ID of the subnet in which to create the EC2 Instance Connect Endpoint.
   */
  public subnetId: string;

  /**
   * The tags to apply to the EC2 Instance Connect Endpoint during creation.
   */
  public tags?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnInstanceConnectEndpointProps) {
    super(scope, id, {
      "type": CfnInstanceConnectEndpoint.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "subnetId", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.clientToken = props.clientToken;
    this.preserveClientIp = props.preserveClientIp;
    this.securityGroupIds = props.securityGroupIds;
    this.subnetId = props.subnetId;
    this.tags = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "clientToken": this.clientToken,
      "preserveClientIp": this.preserveClientIp,
      "securityGroupIds": this.securityGroupIds,
      "subnetId": this.subnetId,
      "tags": this.tags
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnInstanceConnectEndpoint.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnInstanceConnectEndpointPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a `CfnInstanceConnectEndpoint`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instanceconnectendpoint.html
 */
export interface CfnInstanceConnectEndpointProps {
  /**
   * Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instanceconnectendpoint.html#cfn-ec2-instanceconnectendpoint-clienttoken
   */
  readonly clientToken?: string;

  /**
   * Indicates whether your client's IP address is preserved as the source. The value is `true` or `false` .
   *
   * - If `true` , your client's IP address is used when you connect to a resource.
   * - If `false` , the elastic network interface IP address is used when you connect to a resource.
   *
   * Default: `true`
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instanceconnectendpoint.html#cfn-ec2-instanceconnectendpoint-preserveclientip
   */
  readonly preserveClientIp?: boolean | cdk.IResolvable;

  /**
   * One or more security groups to associate with the endpoint.
   *
   * If you don't specify a security group, the default security group for your VPC will be associated with the endpoint.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instanceconnectendpoint.html#cfn-ec2-instanceconnectendpoint-securitygroupids
   */
  readonly securityGroupIds?: Array<string>;

  /**
   * The ID of the subnet in which to create the EC2 Instance Connect Endpoint.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instanceconnectendpoint.html#cfn-ec2-instanceconnectendpoint-subnetid
   */
  readonly subnetId: string;

  /**
   * The tags to apply to the EC2 Instance Connect Endpoint during creation.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instanceconnectendpoint.html#cfn-ec2-instanceconnectendpoint-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a `CfnInstanceConnectEndpointProps`
 *
 * @param properties - the TypeScript properties of a `CfnInstanceConnectEndpointProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnInstanceConnectEndpointPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("clientToken", cdk.validateString)(properties.clientToken));
  errors.collect(cdk.propertyValidator("preserveClientIp", cdk.validateBoolean)(properties.preserveClientIp));
  errors.collect(cdk.propertyValidator("securityGroupIds", cdk.listValidator(cdk.validateString))(properties.securityGroupIds));
  errors.collect(cdk.propertyValidator("subnetId", cdk.requiredValidator)(properties.subnetId));
  errors.collect(cdk.propertyValidator("subnetId", cdk.validateString)(properties.subnetId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \"CfnInstanceConnectEndpointProps\"");
}

// @ts-ignore TS6133
function convertCfnInstanceConnectEndpointPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnInstanceConnectEndpointPropsValidator(properties).assertSuccess();
  return {
    "ClientToken": cdk.stringToCloudFormation(properties.clientToken),
    "PreserveClientIp": cdk.booleanToCloudFormation(properties.preserveClientIp),
    "SecurityGroupIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.securityGroupIds),
    "SubnetId": cdk.stringToCloudFormation(properties.subnetId),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnInstanceConnectEndpointPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnInstanceConnectEndpointProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnInstanceConnectEndpointProps>();
  ret.addPropertyResult("clientToken", "ClientToken", (properties.ClientToken != null ? cfn_parse.FromCloudFormation.getString(properties.ClientToken) : undefined));
  ret.addPropertyResult("preserveClientIp", "PreserveClientIp", (properties.PreserveClientIp != null ? cfn_parse.FromCloudFormation.getBoolean(properties.PreserveClientIp) : undefined));
  ret.addPropertyResult("securityGroupIds", "SecurityGroupIds", (properties.SecurityGroupIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecurityGroupIds) : undefined));
  ret.addPropertyResult("subnetId", "SubnetId", (properties.SubnetId != null ? cfn_parse.FromCloudFormation.getString(properties.SubnetId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Allocates an internet gateway for use with a VPC.
 *
 * After creating the Internet gateway, you then attach it to a VPC.
 *
 * @cloudformationResource AWS::EC2::InternetGateway
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-internetgateway.html
 */
export class CfnInternetGateway extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::InternetGateway";

  /**
   * Build a CfnInternetGateway from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnInternetGateway {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnInternetGatewayPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnInternetGateway(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the internet gateway.
   *
   * @cloudformationAttribute InternetGatewayId
   */
  public readonly attrInternetGatewayId: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * Any tags to assign to the internet gateway.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnInternetGatewayProps = {}) {
    super(scope, id, {
      "type": CfnInternetGateway.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.attrInternetGatewayId = cdk.Token.asString(this.getAtt("InternetGatewayId", cdk.ResolutionTypeHint.STRING));
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::InternetGateway", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnInternetGateway.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnInternetGatewayPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a `CfnInternetGateway`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-internetgateway.html
 */
export interface CfnInternetGatewayProps {
  /**
   * Any tags to assign to the internet gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-internetgateway.html#cfn-ec2-internetgateway-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a `CfnInternetGatewayProps`
 *
 * @param properties - the TypeScript properties of a `CfnInternetGatewayProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnInternetGatewayPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \"CfnInternetGatewayProps\"");
}

// @ts-ignore TS6133
function convertCfnInternetGatewayPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnInternetGatewayPropsValidator(properties).assertSuccess();
  return {
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnInternetGatewayPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnInternetGatewayProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnInternetGatewayProps>();
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a key pair for use with an Amazon Elastic Compute Cloud instance as follows:.
 *
 * - To import an existing key pair, include the `PublicKeyMaterial` property.
 * - To create a new key pair, omit the `PublicKeyMaterial` property.
 *
 * When you import an existing key pair, you specify the public key material for the key. We assume that you have the private key material for the key. AWS CloudFormation does not create or return the private key material when you import a key pair.
 *
 * When you create a new key pair, the private key is saved to AWS Systems Manager Parameter Store, using a parameter with the following name: `/ec2/keypair/{key_pair_id}` . For more information about retrieving private key, and the required permissions, see [Create a key pair using AWS CloudFormation](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/create-key-pairs.html#create-key-pair-cloudformation) in the *Amazon EC2 User Guide* .
 *
 * When AWS CloudFormation deletes a key pair that was created or imported by a stack, it also deletes the parameter that was used to store the private key material in Parameter Store.
 *
 * @cloudformationResource AWS::EC2::KeyPair
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-keypair.html
 */
export class CfnKeyPair extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::KeyPair";

  /**
   * Build a CfnKeyPair from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnKeyPair {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnKeyPairPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnKeyPair(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * If you created the key pair using Amazon EC2:
   *
   * - For RSA key pairs, the key fingerprint is the SHA-1 digest of the DER encoded private key.
   * - For ED25519 key pairs, the key fingerprint is the base64-encoded SHA-256 digest, which is the default for OpenSSH, starting with [OpenSSH 6.8](https://docs.aws.amazon.com/http://www.openssh.com/txt/release-6.8) .
   *
   * If you imported the key pair to Amazon EC2:
   *
   * - For RSA key pairs, the key fingerprint is the MD5 public key fingerprint as specified in section 4 of RFC 4716.
   * - For ED25519 key pairs, the key fingerprint is the base64-encoded SHA-256 digest, which is the default for OpenSSH, starting with [OpenSSH 6.8](https://docs.aws.amazon.com/http://www.openssh.com/txt/release-6.8) .
   *
   * @cloudformationAttribute KeyFingerprint
   */
  public readonly attrKeyFingerprint: string;

  /**
   * The ID of the key pair.
   *
   * @cloudformationAttribute KeyPairId
   */
  public readonly attrKeyPairId: string;

  /**
   * The format of the key pair.
   */
  public keyFormat?: string;

  /**
   * A unique name for the key pair.
   */
  public keyName: string;

  /**
   * The type of key pair. Note that ED25519 keys are not supported for Windows instances.
   */
  public keyType?: string;

  /**
   * The public key material.
   */
  public publicKeyMaterial?: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags to apply to the key pair.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnKeyPairProps) {
    super(scope, id, {
      "type": CfnKeyPair.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "keyName", this);

    this.attrKeyFingerprint = cdk.Token.asString(this.getAtt("KeyFingerprint", cdk.ResolutionTypeHint.STRING));
    this.attrKeyPairId = cdk.Token.asString(this.getAtt("KeyPairId", cdk.ResolutionTypeHint.STRING));
    this.keyFormat = props.keyFormat;
    this.keyName = props.keyName;
    this.keyType = props.keyType;
    this.publicKeyMaterial = props.publicKeyMaterial;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::KeyPair", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "keyFormat": this.keyFormat,
      "keyName": this.keyName,
      "keyType": this.keyType,
      "publicKeyMaterial": this.publicKeyMaterial,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnKeyPair.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnKeyPairPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a `CfnKeyPair`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-keypair.html
 */
export interface CfnKeyPairProps {
  /**
   * The format of the key pair.
   *
   * Default: `pem`
   *
   * @default - "pem"
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-keypair.html#cfn-ec2-keypair-keyformat
   */
  readonly keyFormat?: string;

  /**
   * A unique name for the key pair.
   *
   * Constraints: Up to 255 ASCII characters
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-keypair.html#cfn-ec2-keypair-keyname
   */
  readonly keyName: string;

  /**
   * The type of key pair. Note that ED25519 keys are not supported for Windows instances.
   *
   * If the `PublicKeyMaterial` property is specified, the `KeyType` property is ignored, and the key type is inferred from the `PublicKeyMaterial` value.
   *
   * Default: `rsa`
   *
   * @default - "rsa"
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-keypair.html#cfn-ec2-keypair-keytype
   */
  readonly keyType?: string;

  /**
   * The public key material.
   *
   * The `PublicKeyMaterial` property is used to import a key pair. If this property is not specified, then a new key pair will be created.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-keypair.html#cfn-ec2-keypair-publickeymaterial
   */
  readonly publicKeyMaterial?: string;

  /**
   * The tags to apply to the key pair.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-keypair.html#cfn-ec2-keypair-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a `CfnKeyPairProps`
 *
 * @param properties - the TypeScript properties of a `CfnKeyPairProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnKeyPairPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("keyFormat", cdk.validateString)(properties.keyFormat));
  errors.collect(cdk.propertyValidator("keyName", cdk.requiredValidator)(properties.keyName));
  errors.collect(cdk.propertyValidator("keyName", cdk.validateString)(properties.keyName));
  errors.collect(cdk.propertyValidator("keyType", cdk.validateString)(properties.keyType));
  errors.collect(cdk.propertyValidator("publicKeyMaterial", cdk.validateString)(properties.publicKeyMaterial));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \"CfnKeyPairProps\"");
}

// @ts-ignore TS6133
function convertCfnKeyPairPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnKeyPairPropsValidator(properties).assertSuccess();
  return {
    "KeyFormat": cdk.stringToCloudFormation(properties.keyFormat),
    "KeyName": cdk.stringToCloudFormation(properties.keyName),
    "KeyType": cdk.stringToCloudFormation(properties.keyType),
    "PublicKeyMaterial": cdk.stringToCloudFormation(properties.publicKeyMaterial),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnKeyPairPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnKeyPairProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnKeyPairProps>();
  ret.addPropertyResult("keyFormat", "KeyFormat", (properties.KeyFormat != null ? cfn_parse.FromCloudFormation.getString(properties.KeyFormat) : undefined));
  ret.addPropertyResult("keyName", "KeyName", (properties.KeyName != null ? cfn_parse.FromCloudFormation.getString(properties.KeyName) : undefined));
  ret.addPropertyResult("keyType", "KeyType", (properties.KeyType != null ? cfn_parse.FromCloudFormation.getString(properties.KeyType) : undefined));
  ret.addPropertyResult("publicKeyMaterial", "PublicKeyMaterial", (properties.PublicKeyMaterial != null ? cfn_parse.FromCloudFormation.getString(properties.PublicKeyMaterial) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies the properties for creating a launch template.
 *
 * The minimum required properties for specifying a launch template are as follows:
 *
 * - You must specify at least one property for the launch template data.
 * - You do not need to specify a name for the launch template. If you do not specify a name, AWS CloudFormation creates the name for you.
 *
 * A launch template can contain some or all of the configuration information to launch an instance. When you launch an instance using a launch template, instance properties that are not specified in the launch template use default values, except the `ImageId` property, which has no default value. If you do not specify an AMI ID for the launch template `ImageId` property, you must specify an AMI ID for the instance `ImageId` property.
 *
 * For more information, see [Launch an instance from a launch template](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-templates.html) in the *Amazon EC2 User Guide* .
 *
 * @cloudformationResource AWS::EC2::LaunchTemplate
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html
 */
export class CfnLaunchTemplate extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::LaunchTemplate";

  /**
   * Build a CfnLaunchTemplate from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnLaunchTemplate {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnLaunchTemplatePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnLaunchTemplate(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The default version of the launch template, such as 2.
   *
   * The default version of a launch template cannot be specified in AWS CloudFormation . The default version can be set in the Amazon EC2 console or by using the `modify-launch-template` AWS CLI command.
   *
   * @cloudformationAttribute DefaultVersionNumber
   */
  public readonly attrDefaultVersionNumber: string;

  /**
   * The latest version of the launch template, such as `5` .
   *
   * @cloudformationAttribute LatestVersionNumber
   */
  public readonly attrLatestVersionNumber: string;

  /**
   * The ID of the launch template.
   *
   * @cloudformationAttribute LaunchTemplateId
   */
  public readonly attrLaunchTemplateId: string;

  /**
   * The information for the launch template.
   */
  public launchTemplateData: cdk.IResolvable | CfnLaunchTemplate.LaunchTemplateDataProperty;

  /**
   * A name for the launch template.
   */
  public launchTemplateName?: string;

  /**
   * The tags to apply to the launch template on creation.
   */
  public tagSpecifications?: Array<cdk.IResolvable | CfnLaunchTemplate.LaunchTemplateTagSpecificationProperty> | cdk.IResolvable;

  /**
   * A description for the first version of the launch template.
   */
  public versionDescription?: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnLaunchTemplateProps) {
    super(scope, id, {
      "type": CfnLaunchTemplate.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "launchTemplateData", this);

    this.attrDefaultVersionNumber = cdk.Token.asString(this.getAtt("DefaultVersionNumber", cdk.ResolutionTypeHint.STRING));
    this.attrLatestVersionNumber = cdk.Token.asString(this.getAtt("LatestVersionNumber", cdk.ResolutionTypeHint.STRING));
    this.attrLaunchTemplateId = cdk.Token.asString(this.getAtt("LaunchTemplateId", cdk.ResolutionTypeHint.STRING));
    this.launchTemplateData = props.launchTemplateData;
    this.launchTemplateName = props.launchTemplateName;
    this.tagSpecifications = props.tagSpecifications;
    this.versionDescription = props.versionDescription;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "launchTemplateData": this.launchTemplateData,
      "launchTemplateName": this.launchTemplateName,
      "tagSpecifications": this.tagSpecifications,
      "versionDescription": this.versionDescription
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnLaunchTemplate.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnLaunchTemplatePropsToCloudFormation(props);
  }
}

export namespace CfnLaunchTemplate {
  /**
   * The information to include in the launch template.
   *
   * > You must specify at least one parameter for the launch template data.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html
   */
  export interface LaunchTemplateDataProperty {
    /**
     * The block device mapping.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-blockdevicemappings
     */
    readonly blockDeviceMappings?: Array<CfnLaunchTemplate.BlockDeviceMappingProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The Capacity Reservation targeting option.
     *
     * If you do not specify this parameter, the instance's Capacity Reservation preference defaults to `open` , which enables it to run in any open Capacity Reservation that has matching attributes (instance type, platform, Availability Zone).
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-capacityreservationspecification
     */
    readonly capacityReservationSpecification?: CfnLaunchTemplate.CapacityReservationSpecificationProperty | cdk.IResolvable;

    /**
     * The CPU options for the instance.
     *
     * For more information, see [Optimizing CPU Options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html) in the *Amazon Elastic Compute Cloud User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-cpuoptions
     */
    readonly cpuOptions?: CfnLaunchTemplate.CpuOptionsProperty | cdk.IResolvable;

    /**
     * The credit option for CPU usage of the instance.
     *
     * Valid only for T instances.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-creditspecification
     */
    readonly creditSpecification?: CfnLaunchTemplate.CreditSpecificationProperty | cdk.IResolvable;

    /**
     * Indicates whether to enable the instance for stop protection.
     *
     * For more information, see [Stop protection](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Stop_Start.html#Using_StopProtection) in the *Amazon Elastic Compute Cloud User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-disableapistop
     */
    readonly disableApiStop?: boolean | cdk.IResolvable;

    /**
     * If you set this parameter to `true` , you can't terminate the instance using the Amazon EC2 console, CLI, or API;
     *
     * otherwise, you can. To change this attribute after launch, use [ModifyInstanceAttribute](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceAttribute.html) . Alternatively, if you set `InstanceInitiatedShutdownBehavior` to `terminate` , you can terminate the instance by running the shutdown command from the instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-disableapitermination
     */
    readonly disableApiTermination?: boolean | cdk.IResolvable;

    /**
     * Indicates whether the instance is optimized for Amazon EBS I/O.
     *
     * This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal Amazon EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-ebsoptimized
     */
    readonly ebsOptimized?: boolean | cdk.IResolvable;

    /**
     * An elastic GPU to associate with the instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-elasticgpuspecifications
     */
    readonly elasticGpuSpecifications?: Array<CfnLaunchTemplate.ElasticGpuSpecificationProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * An elastic inference accelerator to associate with the instance.
     *
     * Elastic inference accelerators are a resource you can attach to your Amazon EC2 instances to accelerate your Deep Learning (DL) inference workloads.
     *
     * You cannot specify accelerators from different generations in the same request.
     *
     * > Starting April 15, 2023, AWS will not onboard new customers to Amazon Elastic Inference (EI), and will help current customers migrate their workloads to options that offer better price and performance. After April 15, 2023, new customers will not be able to launch instances with Amazon EI accelerators in Amazon SageMaker, Amazon ECS, or Amazon EC2. However, customers who have used Amazon EI at least once during the past 30-day period are considered current customers and will be able to continue using the service.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-elasticinferenceaccelerators
     */
    readonly elasticInferenceAccelerators?: Array<cdk.IResolvable | CfnLaunchTemplate.LaunchTemplateElasticInferenceAcceleratorProperty> | cdk.IResolvable;

    /**
     * Indicates whether the instance is enabled for AWS Nitro Enclaves.
     *
     * For more information, see [What is AWS Nitro Enclaves?](https://docs.aws.amazon.com/enclaves/latest/user/nitro-enclave.html) in the *AWS Nitro Enclaves User Guide* .
     *
     * You can't enable AWS Nitro Enclaves and hibernation on the same instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-enclaveoptions
     */
    readonly enclaveOptions?: CfnLaunchTemplate.EnclaveOptionsProperty | cdk.IResolvable;

    /**
     * Indicates whether an instance is enabled for hibernation.
     *
     * This parameter is valid only if the instance meets the [hibernation prerequisites](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/hibernating-prerequisites.html) . For more information, see [Hibernate your instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html) in the *Amazon Elastic Compute Cloud User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-hibernationoptions
     */
    readonly hibernationOptions?: CfnLaunchTemplate.HibernationOptionsProperty | cdk.IResolvable;

    /**
     * The name or Amazon Resource Name (ARN) of an IAM instance profile.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-iaminstanceprofile
     */
    readonly iamInstanceProfile?: CfnLaunchTemplate.IamInstanceProfileProperty | cdk.IResolvable;

    /**
     * The ID of the AMI.
     *
     * Alternatively, you can specify a Systems Manager parameter, which will resolve to an AMI ID on launch.
     *
     * Valid formats:
     *
     * - `ami-17characters00000`
     * - `resolve:ssm:parameter-name`
     * - `resolve:ssm:parameter-name:version-number`
     * - `resolve:ssm:parameter-name:label`
     *
     * For more information, see [Use a Systems Manager parameter to find an AMI](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/finding-an-ami.html#using-systems-manager-parameter-to-find-AMI) in the *Amazon Elastic Compute Cloud User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-imageid
     */
    readonly imageId?: string;

    /**
     * Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).
     *
     * Default: `stop`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-instanceinitiatedshutdownbehavior
     */
    readonly instanceInitiatedShutdownBehavior?: string;

    /**
     * The market (purchasing) option for the instances.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-instancemarketoptions
     */
    readonly instanceMarketOptions?: CfnLaunchTemplate.InstanceMarketOptionsProperty | cdk.IResolvable;

    /**
     * The attributes for the instance types.
     *
     * When you specify instance attributes, Amazon EC2 will identify instance types with these attributes.
     *
     * You must specify `VCpuCount` and `MemoryMiB` . All other attributes are optional. Any unspecified optional attribute is set to its default.
     *
     * When you specify multiple attributes, you get instance types that satisfy all of the specified attributes. If you specify multiple values for an attribute, you get instance types that satisfy any of the specified values.
     *
     * To limit the list of instance types from which Amazon EC2 can identify matching instance types, you can use one of the following parameters, but not both in the same request:
     *
     * - `AllowedInstanceTypes` - The instance types to include in the list. All other instance types are ignored, even if they match your specified attributes.
     * - `ExcludedInstanceTypes` - The instance types to exclude from the list, even if they match your specified attributes.
     *
     * > If you specify `InstanceRequirements` , you can't specify `InstanceType` .
     * >
     * > Attribute-based instance type selection is only supported when using Auto Scaling groups, EC2 Fleet, and Spot Fleet to launch instances. If you plan to use the launch template in the [launch instance wizard](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-instance-wizard.html) , or with the [RunInstances](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html) API or [AWS::EC2::Instance](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html) AWS CloudFormation resource, you can't specify `InstanceRequirements` .
     *
     * For more information, see [Attribute-based instance type selection for EC2 Fleet](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html) , [Attribute-based instance type selection for Spot Fleet](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-attribute-based-instance-type-selection.html) , and [Spot placement score](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-placement-score.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-instancerequirements
     */
    readonly instanceRequirements?: CfnLaunchTemplate.InstanceRequirementsProperty | cdk.IResolvable;

    /**
     * The instance type. For more information, see [Instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the *Amazon Elastic Compute Cloud User Guide* .
     *
     * If you specify `InstanceType` , you can't specify `InstanceRequirements` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-instancetype
     */
    readonly instanceType?: string;

    /**
     * The ID of the kernel.
     *
     * We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see [User Provided Kernels](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-kernelid
     */
    readonly kernelId?: string;

    /**
     * The name of the key pair. You can create a key pair using [CreateKeyPair](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateKeyPair.html) or [ImportKeyPair](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportKeyPair.html) .
     *
     * > If you do not specify a key pair, you can't connect to the instance unless you choose an AMI that is configured to allow users another way to log in.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-keyname
     */
    readonly keyName?: string;

    /**
     * The license configurations.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-licensespecifications
     */
    readonly licenseSpecifications?: Array<cdk.IResolvable | CfnLaunchTemplate.LicenseSpecificationProperty> | cdk.IResolvable;

    /**
     * The maintenance options of your instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-maintenanceoptions
     */
    readonly maintenanceOptions?: cdk.IResolvable | CfnLaunchTemplate.MaintenanceOptionsProperty;

    /**
     * The metadata options for the instance.
     *
     * For more information, see [Instance metadata and user data](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html) in the *Amazon Elastic Compute Cloud User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-metadataoptions
     */
    readonly metadataOptions?: cdk.IResolvable | CfnLaunchTemplate.MetadataOptionsProperty;

    /**
     * The monitoring for the instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-monitoring
     */
    readonly monitoring?: cdk.IResolvable | CfnLaunchTemplate.MonitoringProperty;

    /**
     * One or more network interfaces.
     *
     * If you specify a network interface, you must specify any security groups and subnets as part of the network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-networkinterfaces
     */
    readonly networkInterfaces?: Array<cdk.IResolvable | CfnLaunchTemplate.NetworkInterfaceProperty> | cdk.IResolvable;

    /**
     * The placement for the instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-placement
     */
    readonly placement?: cdk.IResolvable | CfnLaunchTemplate.PlacementProperty;

    /**
     * The hostname type for EC2 instances launched into this subnet and how DNS A and AAAA record queries should be handled.
     *
     * For more information, see [Amazon EC2 instance hostname types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html) in the *Amazon Elastic Compute Cloud User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-privatednsnameoptions
     */
    readonly privateDnsNameOptions?: cdk.IResolvable | CfnLaunchTemplate.PrivateDnsNameOptionsProperty;

    /**
     * The ID of the RAM disk.
     *
     * > We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see [User provided kernels](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html) in the *Amazon Elastic Compute Cloud User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-ramdiskid
     */
    readonly ramDiskId?: string;

    /**
     * The IDs of the security groups.
     *
     * You can specify the IDs of existing security groups and references to resources created by the stack template.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-securitygroupids
     */
    readonly securityGroupIds?: Array<string>;

    /**
     * One or more security group names.
     *
     * For a nondefault VPC, you must use security group IDs instead.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-securitygroups
     */
    readonly securityGroups?: Array<string>;

    /**
     * The tags to apply to the resources that are created during instance launch.
     *
     * To tag a resource after it has been created, see [CreateTags](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateTags.html) .
     *
     * To tag the launch template itself, use [TagSpecifications](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#cfn-ec2-launchtemplate-tagspecifications) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-tagspecifications
     */
    readonly tagSpecifications?: Array<cdk.IResolvable | CfnLaunchTemplate.TagSpecificationProperty> | cdk.IResolvable;

    /**
     * The user data to make available to the instance.
     *
     * You must provide base64-encoded text. User data is limited to 16 KB. For more information, see [Run commands on your Linux instance at launch](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html) (Linux) or [Work with instance user data](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/instancedata-add-user-data.html) (Windows) in the *Amazon Elastic Compute Cloud User Guide* .
     *
     * If you are creating the launch template for use with AWS Batch , the user data must be provided in the [MIME multi-part archive format](https://docs.aws.amazon.com/https://cloudinit.readthedocs.io/en/latest/topics/format.html#mime-multi-part-archive) . For more information, see [Amazon EC2 user data in launch templates](https://docs.aws.amazon.com/batch/latest/userguide/launch-templates.html) in the *AWS Batch User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-userdata
     */
    readonly userData?: string;
  }

  /**
   * Specifies the tags to apply to a resource when the resource is created for the launch template.
   *
   * `TagSpecification` is a property type of [`TagSpecifications`](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-tagspecifications) . [`TagSpecifications`](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-tagspecifications) is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html) .
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-tagspecification.html
   */
  export interface TagSpecificationProperty {
    /**
     * The type of resource to tag.
     *
     * Valid Values lists all resource types for Amazon EC2 that can be tagged. When you create a launch template, you can specify tags for the following resource types only: `instance` | `volume` | `elastic-gpu` | `network-interface` | `spot-instances-request` . If the instance does not include the resource type that you specify, the instance launch fails. For example, not all instance types include an Elastic GPU.
     *
     * To tag a resource after it has been created, see [CreateTags](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateTags.html) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-tagspecification.html#cfn-ec2-launchtemplate-tagspecification-resourcetype
     */
    readonly resourceType?: string;

    /**
     * The tags to apply to the resource.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-tagspecification.html#cfn-ec2-launchtemplate-tagspecification-tags
     */
    readonly tags?: Array<cdk.CfnTag>;
  }

  /**
   * Specifies a block device mapping for a launch template.
   *
   * You must specify `DeviceName` plus exactly one of the following properties: `Ebs` , `NoDevice` , or `VirtualName` .
   *
   * `BlockDeviceMapping` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html) .
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-blockdevicemapping.html
   */
  export interface BlockDeviceMappingProperty {
    /**
     * The device name (for example, /dev/sdh or xvdh).
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-blockdevicemapping.html#cfn-ec2-launchtemplate-blockdevicemapping-devicename
     */
    readonly deviceName?: string;

    /**
     * Parameters used to automatically set up EBS volumes when the instance is launched.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-blockdevicemapping.html#cfn-ec2-launchtemplate-blockdevicemapping-ebs
     */
    readonly ebs?: CfnLaunchTemplate.EbsProperty | cdk.IResolvable;

    /**
     * To omit the device from the block device mapping, specify an empty string.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-blockdevicemapping.html#cfn-ec2-launchtemplate-blockdevicemapping-nodevice
     */
    readonly noDevice?: string;

    /**
     * The virtual device name (ephemeralN).
     *
     * Instance store volumes are numbered starting from 0. An instance type with 2 available instance store volumes can specify mappings for ephemeral0 and ephemeral1. The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-blockdevicemapping.html#cfn-ec2-launchtemplate-blockdevicemapping-virtualname
     */
    readonly virtualName?: string;
  }

  /**
   * Parameters for a block device for an EBS volume in an Amazon EC2 launch template.
   *
   * `Ebs` is a property of [AWS::EC2::LaunchTemplate BlockDeviceMapping](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-blockdevicemapping.html) .
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-ebs.html
   */
  export interface EbsProperty {
    /**
     * Indicates whether the EBS volume is deleted on instance termination.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-ebs.html#cfn-ec2-launchtemplate-ebs-deleteontermination
     */
    readonly deleteOnTermination?: boolean | cdk.IResolvable;

    /**
     * Indicates whether the EBS volume is encrypted.
     *
     * Encrypted volumes can only be attached to instances that support Amazon EBS encryption. If you are creating a volume from a snapshot, you can't specify an encryption value.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-ebs.html#cfn-ec2-launchtemplate-ebs-encrypted
     */
    readonly encrypted?: boolean | cdk.IResolvable;

    /**
     * The number of I/O operations per second (IOPS).
     *
     * For `gp3` , `io1` , and `io2` volumes, this represents the number of IOPS that are provisioned for the volume. For `gp2` volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting.
     *
     * The following are the supported values for each volume type:
     *
     * - `gp3` : 3,000 - 16,000 IOPS
     * - `io1` : 100 - 64,000 IOPS
     * - `io2` : 100 - 256,000 IOPS
     *
     * For `io2` volumes, you can achieve up to 256,000 IOPS on [instances built on the Nitro System](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances) . On other instances, you can achieve performance up to 32,000 IOPS.
     *
     * This parameter is supported for `io1` , `io2` , and `gp3` volumes only.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-ebs.html#cfn-ec2-launchtemplate-ebs-iops
     */
    readonly iops?: number;

    /**
     * The ARN of the symmetric AWS Key Management Service ( AWS KMS ) CMK used for encryption.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-ebs.html#cfn-ec2-launchtemplate-ebs-kmskeyid
     */
    readonly kmsKeyId?: string;

    /**
     * The ID of the snapshot.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-ebs.html#cfn-ec2-launchtemplate-ebs-snapshotid
     */
    readonly snapshotId?: string;

    /**
     * The throughput to provision for a `gp3` volume, with a maximum of 1,000 MiB/s.
     *
     * Valid Range: Minimum value of 125. Maximum value of 1000.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-ebs.html#cfn-ec2-launchtemplate-ebs-throughput
     */
    readonly throughput?: number;

    /**
     * The size of the volume, in GiBs.
     *
     * You must specify either a snapshot ID or a volume size. The following are the supported volumes sizes for each volume type:
     *
     * - `gp2` and `gp3` : 1 - 16,384 GiB
     * - `io1` : 4 - 16,384 GiB
     * - `io2` : 4 - 65,536 GiB
     * - `st1` and `sc1` : 125 - 16,384 GiB
     * - `standard` : 1 - 1024 GiB
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-ebs.html#cfn-ec2-launchtemplate-ebs-volumesize
     */
    readonly volumeSize?: number;

    /**
     * The volume type.
     *
     * For more information, see [Amazon EBS volume types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html) in the *Amazon Elastic Compute Cloud User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-ebs.html#cfn-ec2-launchtemplate-ebs-volumetype
     */
    readonly volumeType?: string;
  }

  /**
   * The maintenance options of your instance.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-maintenanceoptions.html
   */
  export interface MaintenanceOptionsProperty {
    /**
     * Disables the automatic recovery behavior of your instance or sets it to default.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-maintenanceoptions.html#cfn-ec2-launchtemplate-maintenanceoptions-autorecovery
     */
    readonly autoRecovery?: string;

    /**
     * Disables the automatic reboot-migration behavior of your instance or sets it to default.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-maintenanceoptions.html#cfn-ec2-launchtemplate-maintenanceoptions-rebootmigration
     */
    readonly rebootMigration?: string;
  }

  /**
   * Specifies an IAM instance profile, which is a container for an IAM role for your instance.
   *
   * You can use an IAM role to distribute your AWS credentials to your instances.
   *
   * If you are creating the launch template for use with an Amazon EC2 Auto Scaling group, you can specify either the name or the ARN of the instance profile, but not both.
   *
   * `IamInstanceProfile` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html) .
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-iaminstanceprofile.html
   */
  export interface IamInstanceProfileProperty {
    /**
     * The Amazon Resource Name (ARN) of the instance profile.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-iaminstanceprofile.html#cfn-ec2-launchtemplate-iaminstanceprofile-arn
     */
    readonly arn?: string;

    /**
     * The name of the instance profile.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-iaminstanceprofile.html#cfn-ec2-launchtemplate-iaminstanceprofile-name
     */
    readonly name?: string;
  }

  /**
   * Specifies a specification for an Elastic GPU for an Amazon EC2 launch template.
   *
   * `ElasticGpuSpecification` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html) .
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-elasticgpuspecification.html
   */
  export interface ElasticGpuSpecificationProperty {
    /**
     * The type of Elastic Graphics accelerator.
     *
     * For more information about the values to specify for `Type` , see [Elastic Graphics Basics](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/elastic-graphics.html#elastic-graphics-basics) , specifically the Elastic Graphics accelerator column, in the *Amazon Elastic Compute Cloud User Guide for Windows Instances* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-elasticgpuspecification.html#cfn-ec2-launchtemplate-elasticgpuspecification-type
     */
    readonly type?: string;
  }

  /**
   * Specifies an elastic inference accelerator.
   *
   * `LaunchTemplateElasticInferenceAccelerator` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html) .
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplateelasticinferenceaccelerator.html
   */
  export interface LaunchTemplateElasticInferenceAcceleratorProperty {
    /**
     * The number of elastic inference accelerators to attach to the instance.
     *
     * Default: 1
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplateelasticinferenceaccelerator.html#cfn-ec2-launchtemplate-launchtemplateelasticinferenceaccelerator-count
     */
    readonly count?: number;

    /**
     * The type of elastic inference accelerator.
     *
     * The possible values are eia1.medium, eia1.large, and eia1.xlarge.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplateelasticinferenceaccelerator.html#cfn-ec2-launchtemplate-launchtemplateelasticinferenceaccelerator-type
     */
    readonly type?: string;
  }

  /**
   * Specifies the placement of an instance.
   *
   * `Placement` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html) .
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-placement.html
   */
  export interface PlacementProperty {
    /**
     * The affinity setting for an instance on a Dedicated Host.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-placement.html#cfn-ec2-launchtemplate-placement-affinity
     */
    readonly affinity?: string;

    /**
     * The Availability Zone for the instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-placement.html#cfn-ec2-launchtemplate-placement-availabilityzone
     */
    readonly availabilityZone?: string;

    /**
     * The Group Id of a placement group.
     *
     * You must specify the Placement Group *Group Id* to launch an instance in a shared placement group.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-placement.html#cfn-ec2-launchtemplate-placement-groupid
     */
    readonly groupId?: string;

    /**
     * The name of the placement group for the instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-placement.html#cfn-ec2-launchtemplate-placement-groupname
     */
    readonly groupName?: string;

    /**
     * The ID of the Dedicated Host for the instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-placement.html#cfn-ec2-launchtemplate-placement-hostid
     */
    readonly hostId?: string;

    /**
     * The ARN of the host resource group in which to launch the instances.
     *
     * If you specify a host resource group ARN, omit the *Tenancy* parameter or set it to `host` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-placement.html#cfn-ec2-launchtemplate-placement-hostresourcegrouparn
     */
    readonly hostResourceGroupArn?: string;

    /**
     * The number of the partition the instance should launch in.
     *
     * Valid only if the placement group strategy is set to `partition` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-placement.html#cfn-ec2-launchtemplate-placement-partitionnumber
     */
    readonly partitionNumber?: number;

    /**
     * Reserved for future use.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-placement.html#cfn-ec2-launchtemplate-placement-spreaddomain
     */
    readonly spreadDomain?: string;

    /**
     * The tenancy of the instance.
     *
     * An instance with a tenancy of dedicated runs on single-tenant hardware.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-placement.html#cfn-ec2-launchtemplate-placement-tenancy
     */
    readonly tenancy?: string;
  }

  /**
   * Specifies the parameters for a network interface.
   *
   * `NetworkInterface` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html) .
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html
   */
  export interface NetworkInterfaceProperty {
    /**
     * Associates a Carrier IP address with eth0 for a new network interface.
     *
     * Use this option when you launch an instance in a Wavelength Zone and want to associate a Carrier IP address with the network interface. For more information about Carrier IP addresses, see [Carrier IP addresses](https://docs.aws.amazon.com/wavelength/latest/developerguide/how-wavelengths-work.html#provider-owned-ip) in the *AWS Wavelength Developer Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-associatecarrieripaddress
     */
    readonly associateCarrierIpAddress?: boolean | cdk.IResolvable;

    /**
     * Associates a public IPv4 address with eth0 for a new network interface.
     *
     * Starting on February 1, 2024, AWS will charge for all public IPv4 addresses, including public IPv4 addresses associated with running instances and Elastic IP addresses. For more information, see the *Public IPv4 Address* tab on the [Amazon VPC pricing page](https://docs.aws.amazon.com/vpc/pricing/) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-associatepublicipaddress
     */
    readonly associatePublicIpAddress?: boolean | cdk.IResolvable;

    /**
     * A connection tracking specification for the network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-connectiontrackingspecification
     */
    readonly connectionTrackingSpecification?: CfnLaunchTemplate.ConnectionTrackingSpecificationProperty | cdk.IResolvable;

    /**
     * Indicates whether the network interface is deleted when the instance is terminated.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-deleteontermination
     */
    readonly deleteOnTermination?: boolean | cdk.IResolvable;

    /**
     * A description for the network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-description
     */
    readonly description?: string;

    /**
     * The device index for the network interface attachment.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-deviceindex
     */
    readonly deviceIndex?: number;

    /**
     * The ENA Express configuration for the network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-enasrdspecification
     */
    readonly enaSrdSpecification?: CfnLaunchTemplate.EnaSrdSpecificationProperty | cdk.IResolvable;

    /**
     * The IDs of one or more security groups.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-groups
     */
    readonly groups?: Array<string>;

    /**
     * The type of network interface.
     *
     * To create an Elastic Fabric Adapter (EFA), specify `efa` . For more information, see [Elastic Fabric Adapter](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/efa.html) in the *Amazon Elastic Compute Cloud User Guide* .
     *
     * If you are not creating an EFA, specify `interface` or omit this parameter.
     *
     * Valid values: `interface` | `efa`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-interfacetype
     */
    readonly interfaceType?: string;

    /**
     * The number of IPv4 prefixes to be automatically assigned to the network interface.
     *
     * You cannot use this option if you use the `Ipv4Prefix` option.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-ipv4prefixcount
     */
    readonly ipv4PrefixCount?: number;

    /**
     * One or more IPv4 prefixes to be assigned to the network interface.
     *
     * You cannot use this option if you use the `Ipv4PrefixCount` option.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-ipv4prefixes
     */
    readonly ipv4Prefixes?: Array<CfnLaunchTemplate.Ipv4PrefixSpecificationProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The number of IPv6 addresses to assign to a network interface.
     *
     * Amazon EC2 automatically selects the IPv6 addresses from the subnet range. You can't use this option if specifying specific IPv6 addresses.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-ipv6addresscount
     */
    readonly ipv6AddressCount?: number;

    /**
     * One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet.
     *
     * You can't use this option if you're specifying a number of IPv6 addresses.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-ipv6addresses
     */
    readonly ipv6Addresses?: Array<CfnLaunchTemplate.Ipv6AddProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The number of IPv6 prefixes to be automatically assigned to the network interface.
     *
     * You cannot use this option if you use the `Ipv6Prefix` option.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-ipv6prefixcount
     */
    readonly ipv6PrefixCount?: number;

    /**
     * One or more IPv6 prefixes to be assigned to the network interface.
     *
     * You cannot use this option if you use the `Ipv6PrefixCount` option.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-ipv6prefixes
     */
    readonly ipv6Prefixes?: Array<CfnLaunchTemplate.Ipv6PrefixSpecificationProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The index of the network card.
     *
     * Some instance types support multiple network cards. The primary network interface must be assigned to network card index 0. The default is network card index 0.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-networkcardindex
     */
    readonly networkCardIndex?: number;

    /**
     * The ID of the network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-networkinterfaceid
     */
    readonly networkInterfaceId?: string;

    /**
     * The primary IPv6 address of the network interface.
     *
     * When you enable an IPv6 GUA address to be a primary IPv6, the first IPv6 GUA will be made the primary IPv6 address until the instance is terminated or the network interface is detached. For more information about primary IPv6 addresses, see [RunInstances](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-primaryipv6
     */
    readonly primaryIpv6?: boolean | cdk.IResolvable;

    /**
     * The primary private IPv4 address of the network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-privateipaddress
     */
    readonly privateIpAddress?: string;

    /**
     * One or more private IPv4 addresses.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-privateipaddresses
     */
    readonly privateIpAddresses?: Array<cdk.IResolvable | CfnLaunchTemplate.PrivateIpAddProperty> | cdk.IResolvable;

    /**
     * The number of secondary private IPv4 addresses to assign to a network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-secondaryprivateipaddresscount
     */
    readonly secondaryPrivateIpAddressCount?: number;

    /**
     * The ID of the subnet for the network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-subnetid
     */
    readonly subnetId?: string;
  }

  /**
   * Specifies a secondary private IPv4 address for a network interface.
   *
   * `PrivateIpAdd` is a property of [AWS::EC2::LaunchTemplate NetworkInterface](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html) .
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-privateipadd.html
   */
  export interface PrivateIpAddProperty {
    /**
     * Indicates whether the private IPv4 address is the primary private IPv4 address.
     *
     * Only one IPv4 address can be designated as primary.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-privateipadd.html#cfn-ec2-launchtemplate-privateipadd-primary
     */
    readonly primary?: boolean | cdk.IResolvable;

    /**
     * The private IPv4 address.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-privateipadd.html#cfn-ec2-launchtemplate-privateipadd-privateipaddress
     */
    readonly privateIpAddress?: string;
  }

  /**
   * Specifies an IPv4 prefix for a network interface.
   *
   * `Ipv4PrefixSpecification` is a property of [AWS::EC2::LaunchTemplate NetworkInterface](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html) .
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-ipv4prefixspecification.html
   */
  export interface Ipv4PrefixSpecificationProperty {
    /**
     * The IPv4 prefix.
     *
     * For information, see [Assigning prefixes to Amazon EC2 network interfaces](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-prefix-eni.html) in the *Amazon Elastic Compute Cloud User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-ipv4prefixspecification.html#cfn-ec2-launchtemplate-ipv4prefixspecification-ipv4prefix
     */
    readonly ipv4Prefix?: string;
  }

  /**
   * Specifies an IPv6 prefix for a network interface.
   *
   * `Ipv6PrefixSpecification` is a property of [AWS::EC2::LaunchTemplate NetworkInterface](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html) .
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-ipv6prefixspecification.html
   */
  export interface Ipv6PrefixSpecificationProperty {
    /**
     * The IPv6 prefix.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-ipv6prefixspecification.html#cfn-ec2-launchtemplate-ipv6prefixspecification-ipv6prefix
     */
    readonly ipv6Prefix?: string;
  }

  /**
   * Specifies an IPv6 address in an Amazon EC2 launch template.
   *
   * `Ipv6Add` is a property of [AWS::EC2::LaunchTemplate NetworkInterface](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html) .
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-ipv6add.html
   */
  export interface Ipv6AddProperty {
    /**
     * One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet.
     *
     * You can't use this option if you're specifying a number of IPv6 addresses.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-ipv6add.html#cfn-ec2-launchtemplate-ipv6add-ipv6address
     */
    readonly ipv6Address?: string;
  }

  /**
   * ENA Express uses AWS Scalable Reliable Datagram (SRD) technology to increase the maximum bandwidth used per stream and minimize tail latency of network traffic between EC2 instances.
   *
   * With ENA Express, you can communicate between two EC2 instances in the same subnet within the same account, or in different accounts. Both sending and receiving instances must have ENA Express enabled.
   *
   * To improve the reliability of network packet delivery, ENA Express reorders network packets on the receiving end by default. However, some UDP-based applications are designed to handle network packets that are out of order to reduce the overhead for packet delivery at the network layer. When ENA Express is enabled, you can specify whether UDP network traffic uses it.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-enasrdspecification.html
   */
  export interface EnaSrdSpecificationProperty {
    /**
     * Indicates whether ENA Express is enabled for the network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-enasrdspecification.html#cfn-ec2-launchtemplate-enasrdspecification-enasrdenabled
     */
    readonly enaSrdEnabled?: boolean | cdk.IResolvable;

    /**
     * Configures ENA Express for UDP network traffic.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-enasrdspecification.html#cfn-ec2-launchtemplate-enasrdspecification-enasrdudpspecification
     */
    readonly enaSrdUdpSpecification?: CfnLaunchTemplate.EnaSrdUdpSpecificationProperty | cdk.IResolvable;
  }

  /**
   * ENA Express is compatible with both TCP and UDP transport protocols.
   *
   * When it's enabled, TCP traffic automatically uses it. However, some UDP-based applications are designed to handle network packets that are out of order, without a need for retransmission, such as live video broadcasting or other near-real-time applications. For UDP traffic, you can specify whether to use ENA Express, based on your application environment needs.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-enasrdudpspecification.html
   */
  export interface EnaSrdUdpSpecificationProperty {
    /**
     * Indicates whether UDP traffic to and from the instance uses ENA Express.
     *
     * To specify this setting, you must first enable ENA Express.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-enasrdudpspecification.html#cfn-ec2-launchtemplate-enasrdudpspecification-enasrdudpenabled
     */
    readonly enaSrdUdpEnabled?: boolean | cdk.IResolvable;
  }

  /**
   * A security group connection tracking specification that enables you to set the idle timeout for connection tracking on an Elastic network interface.
   *
   * For more information, see [Connection tracking timeouts](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-connection-tracking.html#connection-tracking-timeouts) in the *Amazon Elastic Compute Cloud User Guide* .
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-connectiontrackingspecification.html
   */
  export interface ConnectionTrackingSpecificationProperty {
    /**
     * Timeout (in seconds) for idle TCP connections in an established state.
     *
     * Min: 60 seconds. Max: 432000 seconds (5 days). Default: 432000 seconds. Recommended: Less than 432000 seconds.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-connectiontrackingspecification.html#cfn-ec2-launchtemplate-connectiontrackingspecification-tcpestablishedtimeout
     */
    readonly tcpEstablishedTimeout?: number;

    /**
     * Timeout (in seconds) for idle UDP flows classified as streams which have seen more than one request-response transaction.
     *
     * Min: 60 seconds. Max: 180 seconds (3 minutes). Default: 180 seconds.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-connectiontrackingspecification.html#cfn-ec2-launchtemplate-connectiontrackingspecification-udpstreamtimeout
     */
    readonly udpStreamTimeout?: number;

    /**
     * Timeout (in seconds) for idle UDP flows that have seen traffic only in a single direction or a single request-response transaction.
     *
     * Min: 30 seconds. Max: 60 seconds. Default: 30 seconds.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-connectiontrackingspecification.html#cfn-ec2-launchtemplate-connectiontrackingspecification-udptimeout
     */
    readonly udpTimeout?: number;
  }

  /**
   * Indicates whether the instance is enabled for AWS Nitro Enclaves.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-enclaveoptions.html
   */
  export interface EnclaveOptionsProperty {
    /**
     * If this parameter is set to `true` , the instance is enabled for AWS Nitro Enclaves;
     *
     * otherwise, it is not enabled for AWS Nitro Enclaves.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-enclaveoptions.html#cfn-ec2-launchtemplate-enclaveoptions-enabled
     */
    readonly enabled?: boolean | cdk.IResolvable;
  }

  /**
   * Specifies whether detailed monitoring is enabled for an instance.
   *
   * For more information about detailed monitoring, see [Enable or turn off detailed monitoring for your instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-cloudwatch-new.html) in the *Amazon EC2 User Guide* .
   *
   * `Monitoring` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html) .
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-monitoring.html
   */
  export interface MonitoringProperty {
    /**
     * Specify `true` to enable detailed monitoring.
     *
     * Otherwise, basic monitoring is enabled.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-monitoring.html#cfn-ec2-launchtemplate-monitoring-enabled
     */
    readonly enabled?: boolean | cdk.IResolvable;
  }

  /**
   * Specifies whether your instance is configured for hibernation.
   *
   * This parameter is valid only if the instance meets the [hibernation prerequisites](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html#hibernating-prerequisites) . For more information, see [Hibernate Your Instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html) in the *Amazon EC2 User Guide* .
   *
   * `HibernationOptions` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html) .
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-hibernationoptions.html
   */
  export interface HibernationOptionsProperty {
    /**
     * If you set this parameter to `true` , the instance is enabled for hibernation.
     *
     * Default: `false`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-hibernationoptions.html#cfn-ec2-launchtemplate-hibernationoptions-configured
     */
    readonly configured?: boolean | cdk.IResolvable;
  }

  /**
   * The metadata options for the instance.
   *
   * For more information, see [Instance metadata and user data](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html) in the *Amazon EC2 User Guide* .
   *
   * `MetadataOptions` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html) .
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-metadataoptions.html
   */
  export interface MetadataOptionsProperty {
    /**
     * Enables or disables the HTTP metadata endpoint on your instances.
     *
     * If the parameter is not specified, the default state is `enabled` .
     *
     * > If you specify a value of `disabled` , you will not be able to access your instance metadata.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-metadataoptions.html#cfn-ec2-launchtemplate-metadataoptions-httpendpoint
     */
    readonly httpEndpoint?: string;

    /**
     * Enables or disables the IPv6 endpoint for the instance metadata service.
     *
     * Default: `disabled`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-metadataoptions.html#cfn-ec2-launchtemplate-metadataoptions-httpprotocolipv6
     */
    readonly httpProtocolIpv6?: string;

    /**
     * The desired HTTP PUT response hop limit for instance metadata requests.
     *
     * The larger the number, the further instance metadata requests can travel.
     *
     * Default: `1`
     *
     * Possible values: Integers from 1 to 64
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-metadataoptions.html#cfn-ec2-launchtemplate-metadataoptions-httpputresponsehoplimit
     */
    readonly httpPutResponseHopLimit?: number;

    /**
     * Indicates whether IMDSv2 is required.
     *
     * - `optional` - IMDSv2 is optional. You can choose whether to send a session token in your instance metadata retrieval requests. If you retrieve IAM role credentials without a session token, you receive the IMDSv1 role credentials. If you retrieve IAM role credentials using a valid session token, you receive the IMDSv2 role credentials.
     * - `required` - IMDSv2 is required. You must send a session token in your instance metadata retrieval requests. With this option, retrieving the IAM role credentials always returns IMDSv2 credentials; IMDSv1 credentials are not available.
     *
     * Default: If the value of `ImdsSupport` for the Amazon Machine Image (AMI) for your instance is `v2.0` , the default is `required` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-metadataoptions.html#cfn-ec2-launchtemplate-metadataoptions-httptokens
     */
    readonly httpTokens?: string;

    /**
     * Set to `enabled` to allow access to instance tags from the instance metadata.
     *
     * Set to `disabled` to turn off access to instance tags from the instance metadata. For more information, see [Work with instance tags using the instance metadata](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html#work-with-tags-in-IMDS) .
     *
     * Default: `disabled`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-metadataoptions.html#cfn-ec2-launchtemplate-metadataoptions-instancemetadatatags
     */
    readonly instanceMetadataTags?: string;
  }

  /**
   * Specifies a license configuration for an instance.
   *
   * `LicenseSpecification` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html) .
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-licensespecification.html
   */
  export interface LicenseSpecificationProperty {
    /**
     * The Amazon Resource Name (ARN) of the license configuration.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-licensespecification.html#cfn-ec2-launchtemplate-licensespecification-licenseconfigurationarn
     */
    readonly licenseConfigurationArn?: string;
  }

  /**
   * Specifies the CPU options for an instance.
   *
   * For more information, see [Optimize CPU options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html) in the *Amazon Elastic Compute Cloud User Guide* .
   *
   * `CpuOptions` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html) .
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-cpuoptions.html
   */
  export interface CpuOptionsProperty {
    /**
     * Indicates whether to enable the instance for AMD SEV-SNP.
     *
     * AMD SEV-SNP is supported with M6a, R6a, and C6a instance types only. For more information, see [AMD SEV-SNP](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/sev-snp.html) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-cpuoptions.html#cfn-ec2-launchtemplate-cpuoptions-amdsevsnp
     */
    readonly amdSevSnp?: string;

    /**
     * The number of CPU cores for the instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-cpuoptions.html#cfn-ec2-launchtemplate-cpuoptions-corecount
     */
    readonly coreCount?: number;

    /**
     * The number of threads per CPU core.
     *
     * To disable multithreading for the instance, specify a value of `1` . Otherwise, specify the default value of `2` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-cpuoptions.html#cfn-ec2-launchtemplate-cpuoptions-threadspercore
     */
    readonly threadsPerCore?: number;
  }

  /**
   * The hostname type for EC2 instances launched into this subnet and how DNS A and AAAA record queries should be handled.
   *
   * For more information, see [Amazon EC2 instance hostname types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html) in the *Amazon Elastic Compute Cloud User Guide* .
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-privatednsnameoptions.html
   */
  export interface PrivateDnsNameOptionsProperty {
    /**
     * Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-privatednsnameoptions.html#cfn-ec2-launchtemplate-privatednsnameoptions-enableresourcenamednsaaaarecord
     */
    readonly enableResourceNameDnsAaaaRecord?: boolean | cdk.IResolvable;

    /**
     * Indicates whether to respond to DNS queries for instance hostnames with DNS A records.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-privatednsnameoptions.html#cfn-ec2-launchtemplate-privatednsnameoptions-enableresourcenamednsarecord
     */
    readonly enableResourceNameDnsARecord?: boolean | cdk.IResolvable;

    /**
     * The type of hostname for EC2 instances.
     *
     * For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 only subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID. For more information, see [Amazon EC2 instance hostname types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html) in the *Amazon Elastic Compute Cloud User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-privatednsnameoptions.html#cfn-ec2-launchtemplate-privatednsnameoptions-hostnametype
     */
    readonly hostnameType?: string;
  }

  /**
   * Specifies the market (purchasing) option for an instance.
   *
   * `InstanceMarketOptions` is a property of the [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html) .
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancemarketoptions.html
   */
  export interface InstanceMarketOptionsProperty {
    /**
     * The market type.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancemarketoptions.html#cfn-ec2-launchtemplate-instancemarketoptions-markettype
     */
    readonly marketType?: string;

    /**
     * The options for Spot Instances.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancemarketoptions.html#cfn-ec2-launchtemplate-instancemarketoptions-spotoptions
     */
    readonly spotOptions?: cdk.IResolvable | CfnLaunchTemplate.SpotOptionsProperty;
  }

  /**
   * Specifies options for Spot Instances.
   *
   * `SpotOptions` is a property of [AWS::EC2::LaunchTemplate InstanceMarketOptions](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-instancemarketoptions.html) .
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-spotoptions.html
   */
  export interface SpotOptionsProperty {
    /**
     * Deprecated.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-spotoptions.html#cfn-ec2-launchtemplate-spotoptions-blockdurationminutes
     */
    readonly blockDurationMinutes?: number;

    /**
     * The behavior when a Spot Instance is interrupted.
     *
     * The default is `terminate` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-spotoptions.html#cfn-ec2-launchtemplate-spotoptions-instanceinterruptionbehavior
     */
    readonly instanceInterruptionBehavior?: string;

    /**
     * The maximum hourly price you're willing to pay for the Spot Instances.
     *
     * We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price.
     *
     * > If you specify a maximum price, your Spot Instances will be interrupted more frequently than if you do not specify this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-spotoptions.html#cfn-ec2-launchtemplate-spotoptions-maxprice
     */
    readonly maxPrice?: string;

    /**
     * The Spot Instance request type.
     *
     * If you are using Spot Instances with an Auto Scaling group, use `one-time` requests, as the Amazon EC2 Auto Scaling service handles requesting new Spot Instances whenever the group is below its desired capacity.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-spotoptions.html#cfn-ec2-launchtemplate-spotoptions-spotinstancetype
     */
    readonly spotInstanceType?: string;

    /**
     * The end date of the request, in UTC format ( *YYYY-MM-DD* T *HH:MM:SS* Z). Supported only for persistent requests.
     *
     * - For a persistent request, the request remains active until the `ValidUntil` date and time is reached. Otherwise, the request remains active until you cancel it.
     * - For a one-time request, `ValidUntil` is not supported. The request remains active until all instances launch or you cancel the request.
     *
     * Default: 7 days from the current date
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-spotoptions.html#cfn-ec2-launchtemplate-spotoptions-validuntil
     */
    readonly validUntil?: string;
  }

  /**
   * The attributes for the instance types.
   *
   * When you specify instance attributes, Amazon EC2 will identify instance types with these attributes.
   *
   * You must specify `VCpuCount` and `MemoryMiB` . All other attributes are optional. Any unspecified optional attribute is set to its default.
   *
   * When you specify multiple attributes, you get instance types that satisfy all of the specified attributes. If you specify multiple values for an attribute, you get instance types that satisfy any of the specified values.
   *
   * To limit the list of instance types from which Amazon EC2 can identify matching instance types, you can use one of the following parameters, but not both in the same request:
   *
   * - `AllowedInstanceTypes` - The instance types to include in the list. All other instance types are ignored, even if they match your specified attributes.
   * - `ExcludedInstanceTypes` - The instance types to exclude from the list, even if they match your specified attributes.
   *
   * > If you specify `InstanceRequirements` , you can't specify `InstanceType` .
   * >
   * > Attribute-based instance type selection is only supported when using Auto Scaling groups, EC2 Fleet, and Spot Fleet to launch instances. If you plan to use the launch template in the [launch instance wizard](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-instance-wizard.html) , or with the [RunInstances](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html) API or [AWS::EC2::Instance](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html) AWS CloudFormation resource, you can't specify `InstanceRequirements` .
   *
   * For more information, see [Attribute-based instance type selection for EC2 Fleet](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html) , [Attribute-based instance type selection for Spot Fleet](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-attribute-based-instance-type-selection.html) , and [Spot placement score](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-placement-score.html) in the *Amazon EC2 User Guide* .
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html
   */
  export interface InstanceRequirementsProperty {
    /**
     * The minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips) on an instance.
     *
     * To exclude accelerator-enabled instance types, set `Max` to `0` .
     *
     * Default: No minimum or maximum limits
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-acceleratorcount
     */
    readonly acceleratorCount?: CfnLaunchTemplate.AcceleratorCountProperty | cdk.IResolvable;

    /**
     * Indicates whether instance types must have accelerators by specific manufacturers.
     *
     * - For instance types with AWS devices, specify `amazon-web-services` .
     * - For instance types with AMD devices, specify `amd` .
     * - For instance types with Habana devices, specify `habana` .
     * - For instance types with NVIDIA devices, specify `nvidia` .
     * - For instance types with Xilinx devices, specify `xilinx` .
     *
     * Default: Any manufacturer
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-acceleratormanufacturers
     */
    readonly acceleratorManufacturers?: Array<string>;

    /**
     * The accelerators that must be on the instance type.
     *
     * - For instance types with NVIDIA A10G GPUs, specify `a10g` .
     * - For instance types with NVIDIA A100 GPUs, specify `a100` .
     * - For instance types with NVIDIA H100 GPUs, specify `h100` .
     * - For instance types with AWS Inferentia chips, specify `inferentia` .
     * - For instance types with NVIDIA GRID K520 GPUs, specify `k520` .
     * - For instance types with NVIDIA K80 GPUs, specify `k80` .
     * - For instance types with NVIDIA M60 GPUs, specify `m60` .
     * - For instance types with AMD Radeon Pro V520 GPUs, specify `radeon-pro-v520` .
     * - For instance types with NVIDIA T4 GPUs, specify `t4` .
     * - For instance types with NVIDIA T4G GPUs, specify `t4g` .
     * - For instance types with Xilinx VU9P FPGAs, specify `vu9p` .
     * - For instance types with NVIDIA V100 GPUs, specify `v100` .
     *
     * Default: Any accelerator
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-acceleratornames
     */
    readonly acceleratorNames?: Array<string>;

    /**
     * The minimum and maximum amount of total accelerator memory, in MiB.
     *
     * Default: No minimum or maximum limits
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-acceleratortotalmemorymib
     */
    readonly acceleratorTotalMemoryMiB?: CfnLaunchTemplate.AcceleratorTotalMemoryMiBProperty | cdk.IResolvable;

    /**
     * The accelerator types that must be on the instance type.
     *
     * - For instance types with GPU accelerators, specify `gpu` .
     * - For instance types with FPGA accelerators, specify `fpga` .
     * - For instance types with inference accelerators, specify `inference` .
     *
     * Default: Any accelerator type
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-acceleratortypes
     */
    readonly acceleratorTypes?: Array<string>;

    /**
     * The instance types to apply your specified attributes against.
     *
     * All other instance types are ignored, even if they match your specified attributes.
     *
     * You can use strings with one or more wild cards, represented by an asterisk ( `*` ), to allow an instance type, size, or generation. The following are examples: `m5.8xlarge` , `c5*.*` , `m5a.*` , `r*` , `*3*` .
     *
     * For example, if you specify `c5*` ,Amazon EC2 will allow the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*` , Amazon EC2 will allow all the M5a instance types, but not the M5n instance types.
     *
     * > If you specify `AllowedInstanceTypes` , you can't specify `ExcludedInstanceTypes` .
     *
     * Default: All instance types
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-allowedinstancetypes
     */
    readonly allowedInstanceTypes?: Array<string>;

    /**
     * Indicates whether bare metal instance types must be included, excluded, or required.
     *
     * - To include bare metal instance types, specify `included` .
     * - To require only bare metal instance types, specify `required` .
     * - To exclude bare metal instance types, specify `excluded` .
     *
     * Default: `excluded`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-baremetal
     */
    readonly bareMetal?: string;

    /**
     * The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps.
     *
     * For more information, see [Amazon EBSoptimized instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html) in the *Amazon EC2 User Guide* .
     *
     * Default: No minimum or maximum limits
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-baselineebsbandwidthmbps
     */
    readonly baselineEbsBandwidthMbps?: CfnLaunchTemplate.BaselineEbsBandwidthMbpsProperty | cdk.IResolvable;

    /**
     * Indicates whether burstable performance T instance types are included, excluded, or required.
     *
     * For more information, see [Burstable performance instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html) .
     *
     * - To include burstable performance instance types, specify `included` .
     * - To require only burstable performance instance types, specify `required` .
     * - To exclude burstable performance instance types, specify `excluded` .
     *
     * Default: `excluded`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-burstableperformance
     */
    readonly burstablePerformance?: string;

    /**
     * The CPU manufacturers to include.
     *
     * - For instance types with Intel CPUs, specify `intel` .
     * - For instance types with AMD CPUs, specify `amd` .
     * - For instance types with AWS CPUs, specify `amazon-web-services` .
     *
     * > Don't confuse the CPU manufacturer with the CPU architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template.
     *
     * Default: Any manufacturer
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-cpumanufacturers
     */
    readonly cpuManufacturers?: Array<string>;

    /**
     * The instance types to exclude.
     *
     * You can use strings with one or more wild cards, represented by an asterisk ( `*` ), to exclude an instance type, size, or generation. The following are examples: `m5.8xlarge` , `c5*.*` , `m5a.*` , `r*` , `*3*` .
     *
     * For example, if you specify `c5*` ,Amazon EC2 will exclude the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*` , Amazon EC2 will exclude all the M5a instance types, but not the M5n instance types.
     *
     * > If you specify `ExcludedInstanceTypes` , you can't specify `AllowedInstanceTypes` .
     *
     * Default: No excluded instance types
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-excludedinstancetypes
     */
    readonly excludedInstanceTypes?: Array<string>;

    /**
     * Indicates whether current or previous generation instance types are included.
     *
     * The current generation instance types are recommended for use. Current generation instance types are typically the latest two to three generations in each instance family. For more information, see [Instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the *Amazon EC2 User Guide* .
     *
     * For current generation instance types, specify `current` .
     *
     * For previous generation instance types, specify `previous` .
     *
     * Default: Current and previous generation instance types
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-instancegenerations
     */
    readonly instanceGenerations?: Array<string>;

    /**
     * Indicates whether instance types with instance store volumes are included, excluded, or required.
     *
     * For more information, [Amazon EC2 instance store](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html) in the *Amazon EC2 User Guide* .
     *
     * - To include instance types with instance store volumes, specify `included` .
     * - To require only instance types with instance store volumes, specify `required` .
     * - To exclude instance types with instance store volumes, specify `excluded` .
     *
     * Default: `included`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-localstorage
     */
    readonly localStorage?: string;

    /**
     * The type of local storage that is required.
     *
     * - For instance types with hard disk drive (HDD) storage, specify `hdd` .
     * - For instance types with solid state drive (SSD) storage, specify `ssd` .
     *
     * Default: `hdd` and `ssd`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-localstoragetypes
     */
    readonly localStorageTypes?: Array<string>;

    /**
     * The minimum and maximum amount of memory per vCPU, in GiB.
     *
     * Default: No minimum or maximum limits
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-memorygibpervcpu
     */
    readonly memoryGiBPerVCpu?: cdk.IResolvable | CfnLaunchTemplate.MemoryGiBPerVCpuProperty;

    /**
     * The minimum and maximum amount of memory, in MiB.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-memorymib
     */
    readonly memoryMiB?: cdk.IResolvable | CfnLaunchTemplate.MemoryMiBProperty;

    /**
     * The minimum and maximum amount of network bandwidth, in gigabits per second (Gbps).
     *
     * Default: No minimum or maximum limits
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-networkbandwidthgbps
     */
    readonly networkBandwidthGbps?: cdk.IResolvable | CfnLaunchTemplate.NetworkBandwidthGbpsProperty;

    /**
     * The minimum and maximum number of network interfaces.
     *
     * Default: No minimum or maximum limits
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-networkinterfacecount
     */
    readonly networkInterfaceCount?: cdk.IResolvable | CfnLaunchTemplate.NetworkInterfaceCountProperty;

    /**
     * The price protection threshold for On-Demand Instances.
     *
     * This is the maximum youll pay for an On-Demand Instance, expressed as a percentage above the least expensive current generation M, C, or R instance type with your specified attributes. When Amazon EC2 selects instance types with your attributes, it excludes instance types priced above your threshold.
     *
     * The parameter accepts an integer, which Amazon EC2 interprets as a percentage.
     *
     * To turn off price protection, specify a high value, such as `999999` .
     *
     * This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) and [GetInstanceTypesFromInstanceRequirements](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html) .
     *
     * > If you set `TargetCapacityUnitType` to `vcpu` or `memory-mib` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price.
     *
     * Default: `20`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-ondemandmaxpricepercentageoverlowestprice
     */
    readonly onDemandMaxPricePercentageOverLowestPrice?: number;

    /**
     * Indicates whether instance types must support hibernation for On-Demand Instances.
     *
     * This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) .
     *
     * Default: `false`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-requirehibernatesupport
     */
    readonly requireHibernateSupport?: boolean | cdk.IResolvable;

    /**
     * The price protection threshold for Spot Instances.
     *
     * This is the maximum youll pay for a Spot Instance, expressed as a percentage above the least expensive current generation M, C, or R instance type with your specified attributes. When Amazon EC2 selects instance types with your attributes, it excludes instance types priced above your threshold.
     *
     * The parameter accepts an integer, which Amazon EC2 interprets as a percentage.
     *
     * To turn off price protection, specify a high value, such as `999999` .
     *
     * This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) and [GetInstanceTypesFromInstanceRequirements](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html) .
     *
     * > If you set `TargetCapacityUnitType` to `vcpu` or `memory-mib` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price.
     *
     * Default: `100`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-spotmaxpricepercentageoverlowestprice
     */
    readonly spotMaxPricePercentageOverLowestPrice?: number;

    /**
     * The minimum and maximum amount of total local storage, in GB.
     *
     * Default: No minimum or maximum limits
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-totallocalstoragegb
     */
    readonly totalLocalStorageGb?: cdk.IResolvable | CfnLaunchTemplate.TotalLocalStorageGBProperty;

    /**
     * The minimum and maximum number of vCPUs.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-vcpucount
     */
    readonly vCpuCount?: cdk.IResolvable | CfnLaunchTemplate.VCpuCountProperty;
  }

  /**
   * The minimum and maximum number of network interfaces.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterfacecount.html
   */
  export interface NetworkInterfaceCountProperty {
    /**
     * The maximum number of network interfaces.
     *
     * To specify no maximum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterfacecount.html#cfn-ec2-launchtemplate-networkinterfacecount-max
     */
    readonly max?: number;

    /**
     * The minimum number of network interfaces.
     *
     * To specify no minimum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterfacecount.html#cfn-ec2-launchtemplate-networkinterfacecount-min
     */
    readonly min?: number;
  }

  /**
   * The minimum and maximum amount of memory per vCPU, in GiB.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-memorygibpervcpu.html
   */
  export interface MemoryGiBPerVCpuProperty {
    /**
     * The maximum amount of memory per vCPU, in GiB.
     *
     * To specify no maximum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-memorygibpervcpu.html#cfn-ec2-launchtemplate-memorygibpervcpu-max
     */
    readonly max?: number;

    /**
     * The minimum amount of memory per vCPU, in GiB.
     *
     * To specify no minimum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-memorygibpervcpu.html#cfn-ec2-launchtemplate-memorygibpervcpu-min
     */
    readonly min?: number;
  }

  /**
   * The minimum and maximum number of vCPUs.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-vcpucount.html
   */
  export interface VCpuCountProperty {
    /**
     * The maximum number of vCPUs.
     *
     * To specify no maximum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-vcpucount.html#cfn-ec2-launchtemplate-vcpucount-max
     */
    readonly max?: number;

    /**
     * The minimum number of vCPUs.
     *
     * To specify no minimum limit, specify `0` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-vcpucount.html#cfn-ec2-launchtemplate-vcpucount-min
     */
    readonly min?: number;
  }

  /**
   * The minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips) on an instance.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-acceleratorcount.html
   */
  export interface AcceleratorCountProperty {
    /**
     * The maximum number of accelerators.
     *
     * To specify no maximum limit, omit this parameter. To exclude accelerator-enabled instance types, set `Max` to `0` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-acceleratorcount.html#cfn-ec2-launchtemplate-acceleratorcount-max
     */
    readonly max?: number;

    /**
     * The minimum number of accelerators.
     *
     * To specify no minimum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-acceleratorcount.html#cfn-ec2-launchtemplate-acceleratorcount-min
     */
    readonly min?: number;
  }

  /**
   * The minimum and maximum amount of network bandwidth, in gigabits per second (Gbps).
   *
   * > Setting the minimum bandwidth does not guarantee that your instance will achieve the minimum bandwidth. Amazon EC2 will identify instance types that support the specified minimum bandwidth, but the actual bandwidth of your instance might go below the specified minimum at times. For more information, see [Available instance bandwidth](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-network-bandwidth.html#available-instance-bandwidth) in the *Amazon EC2 User Guide* .
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkbandwidthgbps.html
   */
  export interface NetworkBandwidthGbpsProperty {
    /**
     * The maximum amount of network bandwidth, in Gbps.
     *
     * To specify no maximum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkbandwidthgbps.html#cfn-ec2-launchtemplate-networkbandwidthgbps-max
     */
    readonly max?: number;

    /**
     * The minimum amount of network bandwidth, in Gbps.
     *
     * If this parameter is not specified, there is no minimum limit.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkbandwidthgbps.html#cfn-ec2-launchtemplate-networkbandwidthgbps-min
     */
    readonly min?: number;
  }

  /**
   * The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps.
   *
   * For more information, see [Amazon EBSoptimized instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html) in the *Amazon EC2 User Guide* .
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-baselineebsbandwidthmbps.html
   */
  export interface BaselineEbsBandwidthMbpsProperty {
    /**
     * The maximum baseline bandwidth, in Mbps.
     *
     * To specify no maximum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-baselineebsbandwidthmbps.html#cfn-ec2-launchtemplate-baselineebsbandwidthmbps-max
     */
    readonly max?: number;

    /**
     * The minimum baseline bandwidth, in Mbps.
     *
     * To specify no minimum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-baselineebsbandwidthmbps.html#cfn-ec2-launchtemplate-baselineebsbandwidthmbps-min
     */
    readonly min?: number;
  }

  /**
   * The minimum and maximum amount of total accelerator memory, in MiB.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-acceleratortotalmemorymib.html
   */
  export interface AcceleratorTotalMemoryMiBProperty {
    /**
     * The maximum amount of accelerator memory, in MiB.
     *
     * To specify no maximum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-acceleratortotalmemorymib.html#cfn-ec2-launchtemplate-acceleratortotalmemorymib-max
     */
    readonly max?: number;

    /**
     * The minimum amount of accelerator memory, in MiB.
     *
     * To specify no minimum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-acceleratortotalmemorymib.html#cfn-ec2-launchtemplate-acceleratortotalmemorymib-min
     */
    readonly min?: number;
  }

  /**
   * The minimum and maximum amount of memory, in MiB.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-memorymib.html
   */
  export interface MemoryMiBProperty {
    /**
     * The maximum amount of memory, in MiB.
     *
     * To specify no maximum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-memorymib.html#cfn-ec2-launchtemplate-memorymib-max
     */
    readonly max?: number;

    /**
     * The minimum amount of memory, in MiB.
     *
     * To specify no minimum limit, specify `0` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-memorymib.html#cfn-ec2-launchtemplate-memorymib-min
     */
    readonly min?: number;
  }

  /**
   * The minimum and maximum amount of total local storage, in GB.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-totallocalstoragegb.html
   */
  export interface TotalLocalStorageGBProperty {
    /**
     * The maximum amount of total local storage, in GB.
     *
     * To specify no maximum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-totallocalstoragegb.html#cfn-ec2-launchtemplate-totallocalstoragegb-max
     */
    readonly max?: number;

    /**
     * The minimum amount of total local storage, in GB.
     *
     * To specify no minimum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-totallocalstoragegb.html#cfn-ec2-launchtemplate-totallocalstoragegb-min
     */
    readonly min?: number;
  }

  /**
   * Specifies an instance's Capacity Reservation targeting option. You can specify only one option at a time.
   *
   * `CapacityReservationSpecification` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html) .
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-capacityreservationspecification.html
   */
  export interface CapacityReservationSpecificationProperty {
    /**
     * Indicates the instance's Capacity Reservation preferences. Possible preferences include:.
     *
     * - `open` - The instance can run in any `open` Capacity Reservation that has matching attributes (instance type, platform, Availability Zone).
     * - `none` - The instance avoids running in a Capacity Reservation even if one is available. The instance runs in On-Demand capacity.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-capacityreservationspecification.html#cfn-ec2-launchtemplate-capacityreservationspecification-capacityreservationpreference
     */
    readonly capacityReservationPreference?: string;

    /**
     * Information about the target Capacity Reservation or Capacity Reservation group.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-capacityreservationspecification.html#cfn-ec2-launchtemplate-capacityreservationspecification-capacityreservationtarget
     */
    readonly capacityReservationTarget?: CfnLaunchTemplate.CapacityReservationTargetProperty | cdk.IResolvable;
  }

  /**
   * Specifies a target Capacity Reservation.
   *
   * `CapacityReservationTarget` is a property of the [Amazon EC2 LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html) property type.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-capacityreservationtarget.html
   */
  export interface CapacityReservationTargetProperty {
    /**
     * The ID of the Capacity Reservation in which to run the instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-capacityreservationtarget.html#cfn-ec2-launchtemplate-capacityreservationtarget-capacityreservationid
     */
    readonly capacityReservationId?: string;

    /**
     * The ARN of the Capacity Reservation resource group in which to run the instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-capacityreservationtarget.html#cfn-ec2-launchtemplate-capacityreservationtarget-capacityreservationresourcegrouparn
     */
    readonly capacityReservationResourceGroupArn?: string;
  }

  /**
   * Specifies the credit option for CPU usage of a T2, T3, or T3a instance.
   *
   * `CreditSpecification` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html) .
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-creditspecification.html
   */
  export interface CreditSpecificationProperty {
    /**
     * The credit option for CPU usage of a T instance.
     *
     * Valid values: `standard` | `unlimited`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-creditspecification.html#cfn-ec2-launchtemplate-creditspecification-cpucredits
     */
    readonly cpuCredits?: string;
  }

  /**
   * Specifies the tags to apply to the launch template during creation.
   *
   * `LaunchTemplateTagSpecification` is a property of [AWS::EC2::LaunchTemplate](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html) .
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatetagspecification.html
   */
  export interface LaunchTemplateTagSpecificationProperty {
    /**
     * The type of resource.
     *
     * To tag the launch template, `ResourceType` must be `launch-template` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatetagspecification.html#cfn-ec2-launchtemplate-launchtemplatetagspecification-resourcetype
     */
    readonly resourceType?: string;

    /**
     * The tags for the resource.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatetagspecification.html#cfn-ec2-launchtemplate-launchtemplatetagspecification-tags
     */
    readonly tags?: Array<cdk.CfnTag>;
  }
}

/**
 * Properties for defining a `CfnLaunchTemplate`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html
 */
export interface CfnLaunchTemplateProps {
  /**
   * The information for the launch template.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#cfn-ec2-launchtemplate-launchtemplatedata
   */
  readonly launchTemplateData: cdk.IResolvable | CfnLaunchTemplate.LaunchTemplateDataProperty;

  /**
   * A name for the launch template.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#cfn-ec2-launchtemplate-launchtemplatename
   */
  readonly launchTemplateName?: string;

  /**
   * The tags to apply to the launch template on creation.
   *
   * To tag the launch template, the resource type must be `launch-template` .
   *
   * To specify the tags for the resources that are created when an instance is launched, you must use [TagSpecifications](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#cfn-ec2-launchtemplate-tagspecifications) .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#cfn-ec2-launchtemplate-tagspecifications
   */
  readonly tagSpecifications?: Array<cdk.IResolvable | CfnLaunchTemplate.LaunchTemplateTagSpecificationProperty> | cdk.IResolvable;

  /**
   * A description for the first version of the launch template.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#cfn-ec2-launchtemplate-versiondescription
   */
  readonly versionDescription?: string;
}

/**
 * Determine whether the given properties match those of a `TagSpecificationProperty`
 *
 * @param properties - the TypeScript properties of a `TagSpecificationProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateTagSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("resourceType", cdk.validateString)(properties.resourceType));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \"TagSpecificationProperty\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateTagSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateTagSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "ResourceType": cdk.stringToCloudFormation(properties.resourceType),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateTagSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnLaunchTemplate.TagSpecificationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.TagSpecificationProperty>();
  ret.addPropertyResult("resourceType", "ResourceType", (properties.ResourceType != null ? cfn_parse.FromCloudFormation.getString(properties.ResourceType) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `EbsProperty`
 *
 * @param properties - the TypeScript properties of a `EbsProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateEbsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("deleteOnTermination", cdk.validateBoolean)(properties.deleteOnTermination));
  errors.collect(cdk.propertyValidator("encrypted", cdk.validateBoolean)(properties.encrypted));
  errors.collect(cdk.propertyValidator("iops", cdk.validateNumber)(properties.iops));
  errors.collect(cdk.propertyValidator("kmsKeyId", cdk.validateString)(properties.kmsKeyId));
  errors.collect(cdk.propertyValidator("snapshotId", cdk.validateString)(properties.snapshotId));
  errors.collect(cdk.propertyValidator("throughput", cdk.validateNumber)(properties.throughput));
  errors.collect(cdk.propertyValidator("volumeSize", cdk.validateNumber)(properties.volumeSize));
  errors.collect(cdk.propertyValidator("volumeType", cdk.validateString)(properties.volumeType));
  return errors.wrap("supplied properties not correct for \"EbsProperty\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateEbsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateEbsPropertyValidator(properties).assertSuccess();
  return {
    "DeleteOnTermination": cdk.booleanToCloudFormation(properties.deleteOnTermination),
    "Encrypted": cdk.booleanToCloudFormation(properties.encrypted),
    "Iops": cdk.numberToCloudFormation(properties.iops),
    "KmsKeyId": cdk.stringToCloudFormation(properties.kmsKeyId),
    "SnapshotId": cdk.stringToCloudFormation(properties.snapshotId),
    "Throughput": cdk.numberToCloudFormation(properties.throughput),
    "VolumeSize": cdk.numberToCloudFormation(properties.volumeSize),
    "VolumeType": cdk.stringToCloudFormation(properties.volumeType)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateEbsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnLaunchTemplate.EbsProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.EbsProperty>();
  ret.addPropertyResult("deleteOnTermination", "DeleteOnTermination", (properties.DeleteOnTermination != null ? cfn_parse.FromCloudFormation.getBoolean(properties.DeleteOnTermination) : undefined));
  ret.addPropertyResult("encrypted", "Encrypted", (properties.Encrypted != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Encrypted) : undefined));
  ret.addPropertyResult("iops", "Iops", (properties.Iops != null ? cfn_parse.FromCloudFormation.getNumber(properties.Iops) : undefined));
  ret.addPropertyResult("kmsKeyId", "KmsKeyId", (properties.KmsKeyId != null ? cfn_parse.FromCloudFormation.getString(properties.KmsKeyId) : undefined));
  ret.addPropertyResult("snapshotId", "SnapshotId", (properties.SnapshotId != null ? cfn_parse.FromCloudFormation.getString(properties.SnapshotId) : undefined));
  ret.addPropertyResult("throughput", "Throughput", (properties.Throughput != null ? cfn_parse.FromCloudFormation.getNumber(properties.Throughput) : undefined));
  ret.addPropertyResult("volumeSize", "VolumeSize", (properties.VolumeSize != null ? cfn_parse.FromCloudFormation.getNumber(properties.VolumeSize) : undefined));
  ret.addPropertyResult("volumeType", "VolumeType", (properties.VolumeType != null ? cfn_parse.FromCloudFormation.getString(properties.VolumeType) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `BlockDeviceMappingProperty`
 *
 * @param properties - the TypeScript properties of a `BlockDeviceMappingProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateBlockDeviceMappingPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("deviceName", cdk.validateString)(properties.deviceName));
  errors.collect(cdk.propertyValidator("ebs", CfnLaunchTemplateEbsPropertyValidator)(properties.ebs));
  errors.collect(cdk.propertyValidator("noDevice", cdk.validateString)(properties.noDevice));
  errors.collect(cdk.propertyValidator("virtualName", cdk.validateString)(properties.virtualName));
  return errors.wrap("supplied properties not correct for \"BlockDeviceMappingProperty\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateBlockDeviceMappingPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateBlockDeviceMappingPropertyValidator(properties).assertSuccess();
  return {
    "DeviceName": cdk.stringToCloudFormation(properties.deviceName),
    "Ebs": convertCfnLaunchTemplateEbsPropertyToCloudFormation(properties.ebs),
    "NoDevice": cdk.stringToCloudFormation(properties.noDevice),
    "VirtualName": cdk.stringToCloudFormation(properties.virtualName)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateBlockDeviceMappingPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnLaunchTemplate.BlockDeviceMappingProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.BlockDeviceMappingProperty>();
  ret.addPropertyResult("deviceName", "DeviceName", (properties.DeviceName != null ? cfn_parse.FromCloudFormation.getString(properties.DeviceName) : undefined));
  ret.addPropertyResult("ebs", "Ebs", (properties.Ebs != null ? CfnLaunchTemplateEbsPropertyFromCloudFormation(properties.Ebs) : undefined));
  ret.addPropertyResult("noDevice", "NoDevice", (properties.NoDevice != null ? cfn_parse.FromCloudFormation.getString(properties.NoDevice) : undefined));
  ret.addPropertyResult("virtualName", "VirtualName", (properties.VirtualName != null ? cfn_parse.FromCloudFormation.getString(properties.VirtualName) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `MaintenanceOptionsProperty`
 *
 * @param properties - the TypeScript properties of a `MaintenanceOptionsProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateMaintenanceOptionsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("autoRecovery", cdk.validateString)(properties.autoRecovery));
  errors.collect(cdk.propertyValidator("rebootMigration", cdk.validateString)(properties.rebootMigration));
  return errors.wrap("supplied properties not correct for \"MaintenanceOptionsProperty\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateMaintenanceOptionsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateMaintenanceOptionsPropertyValidator(properties).assertSuccess();
  return {
    "AutoRecovery": cdk.stringToCloudFormation(properties.autoRecovery),
    "RebootMigration": cdk.stringToCloudFormation(properties.rebootMigration)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateMaintenanceOptionsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnLaunchTemplate.MaintenanceOptionsProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.MaintenanceOptionsProperty>();
  ret.addPropertyResult("autoRecovery", "AutoRecovery", (properties.AutoRecovery != null ? cfn_parse.FromCloudFormation.getString(properties.AutoRecovery) : undefined));
  ret.addPropertyResult("rebootMigration", "RebootMigration", (properties.RebootMigration != null ? cfn_parse.FromCloudFormation.getString(properties.RebootMigration) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `IamInstanceProfileProperty`
 *
 * @param properties - the TypeScript properties of a `IamInstanceProfileProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateIamInstanceProfilePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("arn", cdk.validateString)(properties.arn));
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  return errors.wrap("supplied properties not correct for \"IamInstanceProfileProperty\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateIamInstanceProfilePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateIamInstanceProfilePropertyValidator(properties).assertSuccess();
  return {
    "Arn": cdk.stringToCloudFormation(properties.arn),
    "Name": cdk.stringToCloudFormation(properties.name)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateIamInstanceProfilePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnLaunchTemplate.IamInstanceProfileProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.IamInstanceProfileProperty>();
  ret.addPropertyResult("arn", "Arn", (properties.Arn != null ? cfn_parse.FromCloudFormation.getString(properties.Arn) : undefined));
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `ElasticGpuSpecificationProperty`
 *
 * @param properties - the TypeScript properties of a `ElasticGpuSpecificationProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateElasticGpuSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  return errors.wrap("supplied properties not correct for \"ElasticGpuSpecificationProperty\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateElasticGpuSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateElasticGpuSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "Type": cdk.stringToCloudFormation(properties.type)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateElasticGpuSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnLaunchTemplate.ElasticGpuSpecificationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.ElasticGpuSpecificationProperty>();
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `LaunchTemplateElasticInferenceAcceleratorProperty`
 *
 * @param properties - the TypeScript properties of a `LaunchTemplateElasticInferenceAcceleratorProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateLaunchTemplateElasticInferenceAcceleratorPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("count", cdk.validateNumber)(properties.count));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  return errors.wrap("supplied properties not correct for \"LaunchTemplateElasticInferenceAcceleratorProperty\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateLaunchTemplateElasticInferenceAcceleratorPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateLaunchTemplateElasticInferenceAcceleratorPropertyValidator(properties).assertSuccess();
  return {
    "Count": cdk.numberToCloudFormation(properties.count),
    "Type": cdk.stringToCloudFormation(properties.type)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateLaunchTemplateElasticInferenceAcceleratorPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnLaunchTemplate.LaunchTemplateElasticInferenceAcceleratorProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.LaunchTemplateElasticInferenceAcceleratorProperty>();
  ret.addPropertyResult("count", "Count", (properties.Count != null ? cfn_parse.FromCloudFormation.getNumber(properties.Count) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `PlacementProperty`
 *
 * @param properties - the TypeScript properties of a `PlacementProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplatePlacementPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("affinity", cdk.validateString)(properties.affinity));
  errors.collect(cdk.propertyValidator("availabilityZone", cdk.validateString)(properties.availabilityZone));
  errors.collect(cdk.propertyValidator("groupId", cdk.validateString)(properties.groupId));
  errors.collect(cdk.propertyValidator("groupName", cdk.validateString)(properties.groupName));
  errors.collect(cdk.propertyValidator("hostId", cdk.validateString)(properties.hostId));
  errors.collect(cdk.propertyValidator("hostResourceGroupArn", cdk.validateString)(properties.hostResourceGroupArn));
  errors.collect(cdk.propertyValidator("partitionNumber", cdk.validateNumber)(properties.partitionNumber));
  errors.collect(cdk.propertyValidator("spreadDomain", cdk.validateString)(properties.spreadDomain));
  errors.collect(cdk.propertyValidator("tenancy", cdk.validateString)(properties.tenancy));
  return errors.wrap("supplied properties not correct for \"PlacementProperty\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplatePlacementPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplatePlacementPropertyValidator(properties).assertSuccess();
  return {
    "Affinity": cdk.stringToCloudFormation(properties.affinity),
    "AvailabilityZone": cdk.stringToCloudFormation(properties.availabilityZone),
    "GroupId": cdk.stringToCloudFormation(properties.groupId),
    "GroupName": cdk.stringToCloudFormation(properties.groupName),
    "HostId": cdk.stringToCloudFormation(properties.hostId),
    "HostResourceGroupArn": cdk.stringToCloudFormation(properties.hostResourceGroupArn),
    "PartitionNumber": cdk.numberToCloudFormation(properties.partitionNumber),
    "SpreadDomain": cdk.stringToCloudFormation(properties.spreadDomain),
    "Tenancy": cdk.stringToCloudFormation(properties.tenancy)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplatePlacementPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnLaunchTemplate.PlacementProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.PlacementProperty>();
  ret.addPropertyResult("affinity", "Affinity", (properties.Affinity != null ? cfn_parse.FromCloudFormation.getString(properties.Affinity) : undefined));
  ret.addPropertyResult("availabilityZone", "AvailabilityZone", (properties.AvailabilityZone != null ? cfn_parse.FromCloudFormation.getString(properties.AvailabilityZone) : undefined));
  ret.addPropertyResult("groupId", "GroupId", (properties.GroupId != null ? cfn_parse.FromCloudFormation.getString(properties.GroupId) : undefined));
  ret.addPropertyResult("groupName", "GroupName", (properties.GroupName != null ? cfn_parse.FromCloudFormation.getString(properties.GroupName) : undefined));
  ret.addPropertyResult("hostId", "HostId", (properties.HostId != null ? cfn_parse.FromCloudFormation.getString(properties.HostId) : undefined));
  ret.addPropertyResult("hostResourceGroupArn", "HostResourceGroupArn", (properties.HostResourceGroupArn != null ? cfn_parse.FromCloudFormation.getString(properties.HostResourceGroupArn) : undefined));
  ret.addPropertyResult("partitionNumber", "PartitionNumber", (properties.PartitionNumber != null ? cfn_parse.FromCloudFormation.getNumber(properties.PartitionNumber) : undefined));
  ret.addPropertyResult("spreadDomain", "SpreadDomain", (properties.SpreadDomain != null ? cfn_parse.FromCloudFormation.getString(properties.SpreadDomain) : undefined));
  ret.addPropertyResult("tenancy", "Tenancy", (properties.Tenancy != null ? cfn_parse.FromCloudFormation.getString(properties.Tenancy) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `PrivateIpAddProperty`
 *
 * @param properties - the TypeScript properties of a `PrivateIpAddProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplatePrivateIpAddPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("primary", cdk.validateBoolean)(properties.primary));
  errors.collect(cdk.propertyValidator("privateIpAddress", cdk.validateString)(properties.privateIpAddress));
  return errors.wrap("supplied properties not correct for \"PrivateIpAddProperty\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplatePrivateIpAddPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplatePrivateIpAddPropertyValidator(properties).assertSuccess();
  return {
    "Primary": cdk.booleanToCloudFormation(properties.primary),
    "PrivateIpAddress": cdk.stringToCloudFormation(properties.privateIpAddress)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplatePrivateIpAddPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnLaunchTemplate.PrivateIpAddProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.PrivateIpAddProperty>();
  ret.addPropertyResult("primary", "Primary", (properties.Primary != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Primary) : undefined));
  ret.addPropertyResult("privateIpAddress", "PrivateIpAddress", (properties.PrivateIpAddress != null ? cfn_parse.FromCloudFormation.getString(properties.PrivateIpAddress) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `Ipv4PrefixSpecificationProperty`
 *
 * @param properties - the TypeScript properties of a `Ipv4PrefixSpecificationProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateIpv4PrefixSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("ipv4Prefix", cdk.validateString)(properties.ipv4Prefix));
  return errors.wrap("supplied properties not correct for \"Ipv4PrefixSpecificationProperty\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateIpv4PrefixSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateIpv4PrefixSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "Ipv4Prefix": cdk.stringToCloudFormation(properties.ipv4Prefix)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateIpv4PrefixSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnLaunchTemplate.Ipv4PrefixSpecificationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.Ipv4PrefixSpecificationProperty>();
  ret.addPropertyResult("ipv4Prefix", "Ipv4Prefix", (properties.Ipv4Prefix != null ? cfn_parse.FromCloudFormation.getString(properties.Ipv4Prefix) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `Ipv6PrefixSpecificationProperty`
 *
 * @param properties - the TypeScript properties of a `Ipv6PrefixSpecificationProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateIpv6PrefixSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("ipv6Prefix", cdk.validateString)(properties.ipv6Prefix));
  return errors.wrap("supplied properties not correct for \"Ipv6PrefixSpecificationProperty\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateIpv6PrefixSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateIpv6PrefixSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "Ipv6Prefix": cdk.stringToCloudFormation(properties.ipv6Prefix)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateIpv6PrefixSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnLaunchTemplate.Ipv6PrefixSpecificationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.Ipv6PrefixSpecificationProperty>();
  ret.addPropertyResult("ipv6Prefix", "Ipv6Prefix", (properties.Ipv6Prefix != null ? cfn_parse.FromCloudFormation.getString(properties.Ipv6Prefix) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `Ipv6AddProperty`
 *
 * @param properties - the TypeScript properties of a `Ipv6AddProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateIpv6AddPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("ipv6Address", cdk.validateString)(properties.ipv6Address));
  return errors.wrap("supplied properties not correct for \"Ipv6AddProperty\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateIpv6AddPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateIpv6AddPropertyValidator(properties).assertSuccess();
  return {
    "Ipv6Address": cdk.stringToCloudFormation(properties.ipv6Address)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateIpv6AddPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnLaunchTemplate.Ipv6AddProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.Ipv6AddProperty>();
  ret.addPropertyResult("ipv6Address", "Ipv6Address", (properties.Ipv6Address != null ? cfn_parse.FromCloudFormation.getString(properties.Ipv6Address) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `EnaSrdUdpSpecificationProperty`
 *
 * @param properties - the TypeScript properties of a `EnaSrdUdpSpecificationProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateEnaSrdUdpSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("enaSrdUdpEnabled", cdk.validateBoolean)(properties.enaSrdUdpEnabled));
  return errors.wrap("supplied properties not correct for \"EnaSrdUdpSpecificationProperty\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateEnaSrdUdpSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateEnaSrdUdpSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "EnaSrdUdpEnabled": cdk.booleanToCloudFormation(properties.enaSrdUdpEnabled)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateEnaSrdUdpSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnLaunchTemplate.EnaSrdUdpSpecificationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.EnaSrdUdpSpecificationProperty>();
  ret.addPropertyResult("enaSrdUdpEnabled", "EnaSrdUdpEnabled", (properties.EnaSrdUdpEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EnaSrdUdpEnabled) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `EnaSrdSpecificationProperty`
 *
 * @param properties - the TypeScript properties of a `EnaSrdSpecificationProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateEnaSrdSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("enaSrdEnabled", cdk.validateBoolean)(properties.enaSrdEnabled));
  errors.collect(cdk.propertyValidator("enaSrdUdpSpecification", CfnLaunchTemplateEnaSrdUdpSpecificationPropertyValidator)(properties.enaSrdUdpSpecification));
  return errors.wrap("supplied properties not correct for \"EnaSrdSpecificationProperty\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateEnaSrdSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateEnaSrdSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "EnaSrdEnabled": cdk.booleanToCloudFormation(properties.enaSrdEnabled),
    "EnaSrdUdpSpecification": convertCfnLaunchTemplateEnaSrdUdpSpecificationPropertyToCloudFormation(properties.enaSrdUdpSpecification)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateEnaSrdSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnLaunchTemplate.EnaSrdSpecificationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.EnaSrdSpecificationProperty>();
  ret.addPropertyResult("enaSrdEnabled", "EnaSrdEnabled", (properties.EnaSrdEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EnaSrdEnabled) : undefined));
  ret.addPropertyResult("enaSrdUdpSpecification", "EnaSrdUdpSpecification", (properties.EnaSrdUdpSpecification != null ? CfnLaunchTemplateEnaSrdUdpSpecificationPropertyFromCloudFormation(properties.EnaSrdUdpSpecification) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `ConnectionTrackingSpecificationProperty`
 *
 * @param properties - the TypeScript properties of a `ConnectionTrackingSpecificationProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateConnectionTrackingSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("tcpEstablishedTimeout", cdk.validateNumber)(properties.tcpEstablishedTimeout));
  errors.collect(cdk.propertyValidator("udpStreamTimeout", cdk.validateNumber)(properties.udpStreamTimeout));
  errors.collect(cdk.propertyValidator("udpTimeout", cdk.validateNumber)(properties.udpTimeout));
  return errors.wrap("supplied properties not correct for \"ConnectionTrackingSpecificationProperty\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateConnectionTrackingSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateConnectionTrackingSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "TcpEstablishedTimeout": cdk.numberToCloudFormation(properties.tcpEstablishedTimeout),
    "UdpStreamTimeout": cdk.numberToCloudFormation(properties.udpStreamTimeout),
    "UdpTimeout": cdk.numberToCloudFormation(properties.udpTimeout)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateConnectionTrackingSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnLaunchTemplate.ConnectionTrackingSpecificationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.ConnectionTrackingSpecificationProperty>();
  ret.addPropertyResult("tcpEstablishedTimeout", "TcpEstablishedTimeout", (properties.TcpEstablishedTimeout != null ? cfn_parse.FromCloudFormation.getNumber(properties.TcpEstablishedTimeout) : undefined));
  ret.addPropertyResult("udpStreamTimeout", "UdpStreamTimeout", (properties.UdpStreamTimeout != null ? cfn_parse.FromCloudFormation.getNumber(properties.UdpStreamTimeout) : undefined));
  ret.addPropertyResult("udpTimeout", "UdpTimeout", (properties.UdpTimeout != null ? cfn_parse.FromCloudFormation.getNumber(properties.UdpTimeout) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `NetworkInterfaceProperty`
 *
 * @param properties - the TypeScript properties of a `NetworkInterfaceProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateNetworkInterfacePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("associateCarrierIpAddress", cdk.validateBoolean)(properties.associateCarrierIpAddress));
  errors.collect(cdk.propertyValidator("associatePublicIpAddress", cdk.validateBoolean)(properties.associatePublicIpAddress));
  errors.collect(cdk.propertyValidator("connectionTrackingSpecification", CfnLaunchTemplateConnectionTrackingSpecificationPropertyValidator)(properties.connectionTrackingSpecification));
  errors.collect(cdk.propertyValidator("deleteOnTermination", cdk.validateBoolean)(properties.deleteOnTermination));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("deviceIndex", cdk.validateNumber)(properties.deviceIndex));
  errors.collect(cdk.propertyValidator("enaSrdSpecification", CfnLaunchTemplateEnaSrdSpecificationPropertyValidator)(properties.enaSrdSpecification));
  errors.collect(cdk.propertyValidator("groups", cdk.listValidator(cdk.validateString))(properties.groups));
  errors.collect(cdk.propertyValidator("interfaceType", cdk.validateString)(properties.interfaceType));
  errors.collect(cdk.propertyValidator("ipv4PrefixCount", cdk.validateNumber)(properties.ipv4PrefixCount));
  errors.collect(cdk.propertyValidator("ipv4Prefixes", cdk.listValidator(CfnLaunchTemplateIpv4PrefixSpecificationPropertyValidator))(properties.ipv4Prefixes));
  errors.collect(cdk.propertyValidator("ipv6AddressCount", cdk.validateNumber)(properties.ipv6AddressCount));
  errors.collect(cdk.propertyValidator("ipv6Addresses", cdk.listValidator(CfnLaunchTemplateIpv6AddPropertyValidator))(properties.ipv6Addresses));
  errors.collect(cdk.propertyValidator("ipv6PrefixCount", cdk.validateNumber)(properties.ipv6PrefixCount));
  errors.collect(cdk.propertyValidator("ipv6Prefixes", cdk.listValidator(CfnLaunchTemplateIpv6PrefixSpecificationPropertyValidator))(properties.ipv6Prefixes));
  errors.collect(cdk.propertyValidator("networkCardIndex", cdk.validateNumber)(properties.networkCardIndex));
  errors.collect(cdk.propertyValidator("networkInterfaceId", cdk.validateString)(properties.networkInterfaceId));
  errors.collect(cdk.propertyValidator("primaryIpv6", cdk.validateBoolean)(properties.primaryIpv6));
  errors.collect(cdk.propertyValidator("privateIpAddress", cdk.validateString)(properties.privateIpAddress));
  errors.collect(cdk.propertyValidator("privateIpAddresses", cdk.listValidator(CfnLaunchTemplatePrivateIpAddPropertyValidator))(properties.privateIpAddresses));
  errors.collect(cdk.propertyValidator("secondaryPrivateIpAddressCount", cdk.validateNumber)(properties.secondaryPrivateIpAddressCount));
  errors.collect(cdk.propertyValidator("subnetId", cdk.validateString)(properties.subnetId));
  return errors.wrap("supplied properties not correct for \"NetworkInterfaceProperty\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateNetworkInterfacePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateNetworkInterfacePropertyValidator(properties).assertSuccess();
  return {
    "AssociateCarrierIpAddress": cdk.booleanToCloudFormation(properties.associateCarrierIpAddress),
    "AssociatePublicIpAddress": cdk.booleanToCloudFormation(properties.associatePublicIpAddress),
    "ConnectionTrackingSpecification": convertCfnLaunchTemplateConnectionTrackingSpecificationPropertyToCloudFormation(properties.connectionTrackingSpecification),
    "DeleteOnTermination": cdk.booleanToCloudFormation(properties.deleteOnTermination),
    "Description": cdk.stringToCloudFormation(properties.description),
    "DeviceIndex": cdk.numberToCloudFormation(properties.deviceIndex),
    "EnaSrdSpecification": convertCfnLaunchTemplateEnaSrdSpecificationPropertyToCloudFormation(properties.enaSrdSpecification),
    "Groups": cdk.listMapper(cdk.stringToCloudFormation)(properties.groups),
    "InterfaceType": cdk.stringToCloudFormation(properties.interfaceType),
    "Ipv4PrefixCount": cdk.numberToCloudFormation(properties.ipv4PrefixCount),
    "Ipv4Prefixes": cdk.listMapper(convertCfnLaunchTemplateIpv4PrefixSpecificationPropertyToCloudFormation)(properties.ipv4Prefixes),
    "Ipv6AddressCount": cdk.numberToCloudFormation(properties.ipv6AddressCount),
    "Ipv6Addresses": cdk.listMapper(convertCfnLaunchTemplateIpv6AddPropertyToCloudFormation)(properties.ipv6Addresses),
    "Ipv6PrefixCount": cdk.numberToCloudFormation(properties.ipv6PrefixCount),
    "Ipv6Prefixes": cdk.listMapper(convertCfnLaunchTemplateIpv6PrefixSpecificationPropertyToCloudFormation)(properties.ipv6Prefixes),
    "NetworkCardIndex": cdk.numberToCloudFormation(properties.networkCardIndex),
    "NetworkInterfaceId": cdk.stringToCloudFormation(properties.networkInterfaceId),
    "PrimaryIpv6": cdk.booleanToCloudFormation(properties.primaryIpv6),
    "PrivateIpAddress": cdk.stringToCloudFormation(properties.privateIpAddress),
    "PrivateIpAddresses": cdk.listMapper(convertCfnLaunchTemplatePrivateIpAddPropertyToCloudFormation)(properties.privateIpAddresses),
    "SecondaryPrivateIpAddressCount": cdk.numberToCloudFormation(properties.secondaryPrivateIpAddressCount),
    "SubnetId": cdk.stringToCloudFormation(properties.subnetId)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateNetworkInterfacePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnLaunchTemplate.NetworkInterfaceProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.NetworkInterfaceProperty>();
  ret.addPropertyResult("associateCarrierIpAddress", "AssociateCarrierIpAddress", (properties.AssociateCarrierIpAddress != null ? cfn_parse.FromCloudFormation.getBoolean(properties.AssociateCarrierIpAddress) : undefined));
  ret.addPropertyResult("associatePublicIpAddress", "AssociatePublicIpAddress", (properties.AssociatePublicIpAddress != null ? cfn_parse.FromCloudFormation.getBoolean(properties.AssociatePublicIpAddress) : undefined));
  ret.addPropertyResult("connectionTrackingSpecification", "ConnectionTrackingSpecification", (properties.ConnectionTrackingSpecification != null ? CfnLaunchTemplateConnectionTrackingSpecificationPropertyFromCloudFormation(properties.ConnectionTrackingSpecification) : undefined));
  ret.addPropertyResult("deleteOnTermination", "DeleteOnTermination", (properties.DeleteOnTermination != null ? cfn_parse.FromCloudFormation.getBoolean(properties.DeleteOnTermination) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("deviceIndex", "DeviceIndex", (properties.DeviceIndex != null ? cfn_parse.FromCloudFormation.getNumber(properties.DeviceIndex) : undefined));
  ret.addPropertyResult("enaSrdSpecification", "EnaSrdSpecification", (properties.EnaSrdSpecification != null ? CfnLaunchTemplateEnaSrdSpecificationPropertyFromCloudFormation(properties.EnaSrdSpecification) : undefined));
  ret.addPropertyResult("groups", "Groups", (properties.Groups != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.Groups) : undefined));
  ret.addPropertyResult("interfaceType", "InterfaceType", (properties.InterfaceType != null ? cfn_parse.FromCloudFormation.getString(properties.InterfaceType) : undefined));
  ret.addPropertyResult("ipv4PrefixCount", "Ipv4PrefixCount", (properties.Ipv4PrefixCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.Ipv4PrefixCount) : undefined));
  ret.addPropertyResult("ipv4Prefixes", "Ipv4Prefixes", (properties.Ipv4Prefixes != null ? cfn_parse.FromCloudFormation.getArray(CfnLaunchTemplateIpv4PrefixSpecificationPropertyFromCloudFormation)(properties.Ipv4Prefixes) : undefined));
  ret.addPropertyResult("ipv6AddressCount", "Ipv6AddressCount", (properties.Ipv6AddressCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.Ipv6AddressCount) : undefined));
  ret.addPropertyResult("ipv6Addresses", "Ipv6Addresses", (properties.Ipv6Addresses != null ? cfn_parse.FromCloudFormation.getArray(CfnLaunchTemplateIpv6AddPropertyFromCloudFormation)(properties.Ipv6Addresses) : undefined));
  ret.addPropertyResult("ipv6PrefixCount", "Ipv6PrefixCount", (properties.Ipv6PrefixCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.Ipv6PrefixCount) : undefined));
  ret.addPropertyResult("ipv6Prefixes", "Ipv6Prefixes", (properties.Ipv6Prefixes != null ? cfn_parse.FromCloudFormation.getArray(CfnLaunchTemplateIpv6PrefixSpecificationPropertyFromCloudFormation)(properties.Ipv6Prefixes) : undefined));
  ret.addPropertyResult("networkCardIndex", "NetworkCardIndex", (properties.NetworkCardIndex != null ? cfn_parse.FromCloudFormation.getNumber(properties.NetworkCardIndex) : undefined));
  ret.addPropertyResult("networkInterfaceId", "NetworkInterfaceId", (properties.NetworkInterfaceId != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkInterfaceId) : undefined));
  ret.addPropertyResult("primaryIpv6", "PrimaryIpv6", (properties.PrimaryIpv6 != null ? cfn_parse.FromCloudFormation.getBoolean(properties.PrimaryIpv6) : undefined));
  ret.addPropertyResult("privateIpAddress", "PrivateIpAddress", (properties.PrivateIpAddress != null ? cfn_parse.FromCloudFormation.getString(properties.PrivateIpAddress) : undefined));
  ret.addPropertyResult("privateIpAddresses", "PrivateIpAddresses", (properties.PrivateIpAddresses != null ? cfn_parse.FromCloudFormation.getArray(CfnLaunchTemplatePrivateIpAddPropertyFromCloudFormation)(properties.PrivateIpAddresses) : undefined));
  ret.addPropertyResult("secondaryPrivateIpAddressCount", "SecondaryPrivateIpAddressCount", (properties.SecondaryPrivateIpAddressCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.SecondaryPrivateIpAddressCount) : undefined));
  ret.addPropertyResult("subnetId", "SubnetId", (properties.SubnetId != null ? cfn_parse.FromCloudFormation.getString(properties.SubnetId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `EnclaveOptionsProperty`
 *
 * @param properties - the TypeScript properties of a `EnclaveOptionsProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateEnclaveOptionsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("enabled", cdk.validateBoolean)(properties.enabled));
  return errors.wrap("supplied properties not correct for \"EnclaveOptionsProperty\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateEnclaveOptionsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateEnclaveOptionsPropertyValidator(properties).assertSuccess();
  return {
    "Enabled": cdk.booleanToCloudFormation(properties.enabled)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateEnclaveOptionsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnLaunchTemplate.EnclaveOptionsProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.EnclaveOptionsProperty>();
  ret.addPropertyResult("enabled", "Enabled", (properties.Enabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Enabled) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `MonitoringProperty`
 *
 * @param properties - the TypeScript properties of a `MonitoringProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateMonitoringPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("enabled", cdk.validateBoolean)(properties.enabled));
  return errors.wrap("supplied properties not correct for \"MonitoringProperty\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateMonitoringPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateMonitoringPropertyValidator(properties).assertSuccess();
  return {
    "Enabled": cdk.booleanToCloudFormation(properties.enabled)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateMonitoringPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnLaunchTemplate.MonitoringProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.MonitoringProperty>();
  ret.addPropertyResult("enabled", "Enabled", (properties.Enabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Enabled) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `HibernationOptionsProperty`
 *
 * @param properties - the TypeScript properties of a `HibernationOptionsProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateHibernationOptionsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("configured", cdk.validateBoolean)(properties.configured));
  return errors.wrap("supplied properties not correct for \"HibernationOptionsProperty\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateHibernationOptionsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateHibernationOptionsPropertyValidator(properties).assertSuccess();
  return {
    "Configured": cdk.booleanToCloudFormation(properties.configured)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateHibernationOptionsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnLaunchTemplate.HibernationOptionsProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.HibernationOptionsProperty>();
  ret.addPropertyResult("configured", "Configured", (properties.Configured != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Configured) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `MetadataOptionsProperty`
 *
 * @param properties - the TypeScript properties of a `MetadataOptionsProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateMetadataOptionsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("httpEndpoint", cdk.validateString)(properties.httpEndpoint));
  errors.collect(cdk.propertyValidator("httpProtocolIpv6", cdk.validateString)(properties.httpProtocolIpv6));
  errors.collect(cdk.propertyValidator("httpPutResponseHopLimit", cdk.validateNumber)(properties.httpPutResponseHopLimit));
  errors.collect(cdk.propertyValidator("httpTokens", cdk.validateString)(properties.httpTokens));
  errors.collect(cdk.propertyValidator("instanceMetadataTags", cdk.validateString)(properties.instanceMetadataTags));
  return errors.wrap("supplied properties not correct for \"MetadataOptionsProperty\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateMetadataOptionsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateMetadataOptionsPropertyValidator(properties).assertSuccess();
  return {
    "HttpEndpoint": cdk.stringToCloudFormation(properties.httpEndpoint),
    "HttpProtocolIpv6": cdk.stringToCloudFormation(properties.httpProtocolIpv6),
    "HttpPutResponseHopLimit": cdk.numberToCloudFormation(properties.httpPutResponseHopLimit),
    "HttpTokens": cdk.stringToCloudFormation(properties.httpTokens),
    "InstanceMetadataTags": cdk.stringToCloudFormation(properties.instanceMetadataTags)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateMetadataOptionsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnLaunchTemplate.MetadataOptionsProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.MetadataOptionsProperty>();
  ret.addPropertyResult("httpEndpoint", "HttpEndpoint", (properties.HttpEndpoint != null ? cfn_parse.FromCloudFormation.getString(properties.HttpEndpoint) : undefined));
  ret.addPropertyResult("httpProtocolIpv6", "HttpProtocolIpv6", (properties.HttpProtocolIpv6 != null ? cfn_parse.FromCloudFormation.getString(properties.HttpProtocolIpv6) : undefined));
  ret.addPropertyResult("httpPutResponseHopLimit", "HttpPutResponseHopLimit", (properties.HttpPutResponseHopLimit != null ? cfn_parse.FromCloudFormation.getNumber(properties.HttpPutResponseHopLimit) : undefined));
  ret.addPropertyResult("httpTokens", "HttpTokens", (properties.HttpTokens != null ? cfn_parse.FromCloudFormation.getString(properties.HttpTokens) : undefined));
  ret.addPropertyResult("instanceMetadataTags", "InstanceMetadataTags", (properties.InstanceMetadataTags != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceMetadataTags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `LicenseSpecificationProperty`
 *
 * @param properties - the TypeScript properties of a `LicenseSpecificationProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateLicenseSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("licenseConfigurationArn", cdk.validateString)(properties.licenseConfigurationArn));
  return errors.wrap("supplied properties not correct for \"LicenseSpecificationProperty\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateLicenseSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateLicenseSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "LicenseConfigurationArn": cdk.stringToCloudFormation(properties.licenseConfigurationArn)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateLicenseSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnLaunchTemplate.LicenseSpecificationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.LicenseSpecificationProperty>();
  ret.addPropertyResult("licenseConfigurationArn", "LicenseConfigurationArn", (properties.LicenseConfigurationArn != null ? cfn_parse.FromCloudFormation.getString(properties.LicenseConfigurationArn) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `CpuOptionsProperty`
 *
 * @param properties - the TypeScript properties of a `CpuOptionsProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateCpuOptionsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("amdSevSnp", cdk.validateString)(properties.amdSevSnp));
  errors.collect(cdk.propertyValidator("coreCount", cdk.validateNumber)(properties.coreCount));
  errors.collect(cdk.propertyValidator("threadsPerCore", cdk.validateNumber)(properties.threadsPerCore));
  return errors.wrap("supplied properties not correct for \"CpuOptionsProperty\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateCpuOptionsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateCpuOptionsPropertyValidator(properties).assertSuccess();
  return {
    "AmdSevSnp": cdk.stringToCloudFormation(properties.amdSevSnp),
    "CoreCount": cdk.numberToCloudFormation(properties.coreCount),
    "ThreadsPerCore": cdk.numberToCloudFormation(properties.threadsPerCore)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateCpuOptionsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnLaunchTemplate.CpuOptionsProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.CpuOptionsProperty>();
  ret.addPropertyResult("amdSevSnp", "AmdSevSnp", (properties.AmdSevSnp != null ? cfn_parse.FromCloudFormation.getString(properties.AmdSevSnp) : undefined));
  ret.addPropertyResult("coreCount", "CoreCount", (properties.CoreCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.CoreCount) : undefined));
  ret.addPropertyResult("threadsPerCore", "ThreadsPerCore", (properties.ThreadsPerCore != null ? cfn_parse.FromCloudFormation.getNumber(properties.ThreadsPerCore) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `PrivateDnsNameOptionsProperty`
 *
 * @param properties - the TypeScript properties of a `PrivateDnsNameOptionsProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplatePrivateDnsNameOptionsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("enableResourceNameDnsAaaaRecord", cdk.validateBoolean)(properties.enableResourceNameDnsAaaaRecord));
  errors.collect(cdk.propertyValidator("enableResourceNameDnsARecord", cdk.validateBoolean)(properties.enableResourceNameDnsARecord));
  errors.collect(cdk.propertyValidator("hostnameType", cdk.validateString)(properties.hostnameType));
  return errors.wrap("supplied properties not correct for \"PrivateDnsNameOptionsProperty\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplatePrivateDnsNameOptionsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplatePrivateDnsNameOptionsPropertyValidator(properties).assertSuccess();
  return {
    "EnableResourceNameDnsAAAARecord": cdk.booleanToCloudFormation(properties.enableResourceNameDnsAaaaRecord),
    "EnableResourceNameDnsARecord": cdk.booleanToCloudFormation(properties.enableResourceNameDnsARecord),
    "HostnameType": cdk.stringToCloudFormation(properties.hostnameType)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplatePrivateDnsNameOptionsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnLaunchTemplate.PrivateDnsNameOptionsProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.PrivateDnsNameOptionsProperty>();
  ret.addPropertyResult("enableResourceNameDnsAaaaRecord", "EnableResourceNameDnsAAAARecord", (properties.EnableResourceNameDnsAAAARecord != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EnableResourceNameDnsAAAARecord) : undefined));
  ret.addPropertyResult("enableResourceNameDnsARecord", "EnableResourceNameDnsARecord", (properties.EnableResourceNameDnsARecord != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EnableResourceNameDnsARecord) : undefined));
  ret.addPropertyResult("hostnameType", "HostnameType", (properties.HostnameType != null ? cfn_parse.FromCloudFormation.getString(properties.HostnameType) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `SpotOptionsProperty`
 *
 * @param properties - the TypeScript properties of a `SpotOptionsProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateSpotOptionsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("blockDurationMinutes", cdk.validateNumber)(properties.blockDurationMinutes));
  errors.collect(cdk.propertyValidator("instanceInterruptionBehavior", cdk.validateString)(properties.instanceInterruptionBehavior));
  errors.collect(cdk.propertyValidator("maxPrice", cdk.validateString)(properties.maxPrice));
  errors.collect(cdk.propertyValidator("spotInstanceType", cdk.validateString)(properties.spotInstanceType));
  errors.collect(cdk.propertyValidator("validUntil", cdk.validateString)(properties.validUntil));
  return errors.wrap("supplied properties not correct for \"SpotOptionsProperty\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateSpotOptionsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateSpotOptionsPropertyValidator(properties).assertSuccess();
  return {
    "BlockDurationMinutes": cdk.numberToCloudFormation(properties.blockDurationMinutes),
    "InstanceInterruptionBehavior": cdk.stringToCloudFormation(properties.instanceInterruptionBehavior),
    "MaxPrice": cdk.stringToCloudFormation(properties.maxPrice),
    "SpotInstanceType": cdk.stringToCloudFormation(properties.spotInstanceType),
    "ValidUntil": cdk.stringToCloudFormation(properties.validUntil)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateSpotOptionsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnLaunchTemplate.SpotOptionsProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.SpotOptionsProperty>();
  ret.addPropertyResult("blockDurationMinutes", "BlockDurationMinutes", (properties.BlockDurationMinutes != null ? cfn_parse.FromCloudFormation.getNumber(properties.BlockDurationMinutes) : undefined));
  ret.addPropertyResult("instanceInterruptionBehavior", "InstanceInterruptionBehavior", (properties.InstanceInterruptionBehavior != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceInterruptionBehavior) : undefined));
  ret.addPropertyResult("maxPrice", "MaxPrice", (properties.MaxPrice != null ? cfn_parse.FromCloudFormation.getString(properties.MaxPrice) : undefined));
  ret.addPropertyResult("spotInstanceType", "SpotInstanceType", (properties.SpotInstanceType != null ? cfn_parse.FromCloudFormation.getString(properties.SpotInstanceType) : undefined));
  ret.addPropertyResult("validUntil", "ValidUntil", (properties.ValidUntil != null ? cfn_parse.FromCloudFormation.getString(properties.ValidUntil) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `InstanceMarketOptionsProperty`
 *
 * @param properties - the TypeScript properties of a `InstanceMarketOptionsProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateInstanceMarketOptionsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("marketType", cdk.validateString)(properties.marketType));
  errors.collect(cdk.propertyValidator("spotOptions", CfnLaunchTemplateSpotOptionsPropertyValidator)(properties.spotOptions));
  return errors.wrap("supplied properties not correct for \"InstanceMarketOptionsProperty\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateInstanceMarketOptionsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateInstanceMarketOptionsPropertyValidator(properties).assertSuccess();
  return {
    "MarketType": cdk.stringToCloudFormation(properties.marketType),
    "SpotOptions": convertCfnLaunchTemplateSpotOptionsPropertyToCloudFormation(properties.spotOptions)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateInstanceMarketOptionsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnLaunchTemplate.InstanceMarketOptionsProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.InstanceMarketOptionsProperty>();
  ret.addPropertyResult("marketType", "MarketType", (properties.MarketType != null ? cfn_parse.FromCloudFormation.getString(properties.MarketType) : undefined));
  ret.addPropertyResult("spotOptions", "SpotOptions", (properties.SpotOptions != null ? CfnLaunchTemplateSpotOptionsPropertyFromCloudFormation(properties.SpotOptions) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `NetworkInterfaceCountProperty`
 *
 * @param properties - the TypeScript properties of a `NetworkInterfaceCountProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateNetworkInterfaceCountPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("max", cdk.validateNumber)(properties.max));
  errors.collect(cdk.propertyValidator("min", cdk.validateNumber)(properties.min));
  return errors.wrap("supplied properties not correct for \"NetworkInterfaceCountProperty\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateNetworkInterfaceCountPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateNetworkInterfaceCountPropertyValidator(properties).assertSuccess();
  return {
    "Max": cdk.numberToCloudFormation(properties.max),
    "Min": cdk.numberToCloudFormation(properties.min)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateNetworkInterfaceCountPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnLaunchTemplate.NetworkInterfaceCountProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.NetworkInterfaceCountProperty>();
  ret.addPropertyResult("max", "Max", (properties.Max != null ? cfn_parse.FromCloudFormation.getNumber(properties.Max) : undefined));
  ret.addPropertyResult("min", "Min", (properties.Min != null ? cfn_parse.FromCloudFormation.getNumber(properties.Min) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `MemoryGiBPerVCpuProperty`
 *
 * @param properties - the TypeScript properties of a `MemoryGiBPerVCpuProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateMemoryGiBPerVCpuPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("max", cdk.validateNumber)(properties.max));
  errors.collect(cdk.propertyValidator("min", cdk.validateNumber)(properties.min));
  return errors.wrap("supplied properties not correct for \"MemoryGiBPerVCpuProperty\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateMemoryGiBPerVCpuPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateMemoryGiBPerVCpuPropertyValidator(properties).assertSuccess();
  return {
    "Max": cdk.numberToCloudFormation(properties.max),
    "Min": cdk.numberToCloudFormation(properties.min)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateMemoryGiBPerVCpuPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnLaunchTemplate.MemoryGiBPerVCpuProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.MemoryGiBPerVCpuProperty>();
  ret.addPropertyResult("max", "Max", (properties.Max != null ? cfn_parse.FromCloudFormation.getNumber(properties.Max) : undefined));
  ret.addPropertyResult("min", "Min", (properties.Min != null ? cfn_parse.FromCloudFormation.getNumber(properties.Min) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `VCpuCountProperty`
 *
 * @param properties - the TypeScript properties of a `VCpuCountProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateVCpuCountPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("max", cdk.validateNumber)(properties.max));
  errors.collect(cdk.propertyValidator("min", cdk.validateNumber)(properties.min));
  return errors.wrap("supplied properties not correct for \"VCpuCountProperty\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateVCpuCountPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateVCpuCountPropertyValidator(properties).assertSuccess();
  return {
    "Max": cdk.numberToCloudFormation(properties.max),
    "Min": cdk.numberToCloudFormation(properties.min)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateVCpuCountPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnLaunchTemplate.VCpuCountProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.VCpuCountProperty>();
  ret.addPropertyResult("max", "Max", (properties.Max != null ? cfn_parse.FromCloudFormation.getNumber(properties.Max) : undefined));
  ret.addPropertyResult("min", "Min", (properties.Min != null ? cfn_parse.FromCloudFormation.getNumber(properties.Min) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `AcceleratorCountProperty`
 *
 * @param properties - the TypeScript properties of a `AcceleratorCountProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateAcceleratorCountPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("max", cdk.validateNumber)(properties.max));
  errors.collect(cdk.propertyValidator("min", cdk.validateNumber)(properties.min));
  return errors.wrap("supplied properties not correct for \"AcceleratorCountProperty\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateAcceleratorCountPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateAcceleratorCountPropertyValidator(properties).assertSuccess();
  return {
    "Max": cdk.numberToCloudFormation(properties.max),
    "Min": cdk.numberToCloudFormation(properties.min)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateAcceleratorCountPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnLaunchTemplate.AcceleratorCountProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.AcceleratorCountProperty>();
  ret.addPropertyResult("max", "Max", (properties.Max != null ? cfn_parse.FromCloudFormation.getNumber(properties.Max) : undefined));
  ret.addPropertyResult("min", "Min", (properties.Min != null ? cfn_parse.FromCloudFormation.getNumber(properties.Min) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `NetworkBandwidthGbpsProperty`
 *
 * @param properties - the TypeScript properties of a `NetworkBandwidthGbpsProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateNetworkBandwidthGbpsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("max", cdk.validateNumber)(properties.max));
  errors.collect(cdk.propertyValidator("min", cdk.validateNumber)(properties.min));
  return errors.wrap("supplied properties not correct for \"NetworkBandwidthGbpsProperty\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateNetworkBandwidthGbpsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateNetworkBandwidthGbpsPropertyValidator(properties).assertSuccess();
  return {
    "Max": cdk.numberToCloudFormation(properties.max),
    "Min": cdk.numberToCloudFormation(properties.min)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateNetworkBandwidthGbpsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnLaunchTemplate.NetworkBandwidthGbpsProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.NetworkBandwidthGbpsProperty>();
  ret.addPropertyResult("max", "Max", (properties.Max != null ? cfn_parse.FromCloudFormation.getNumber(properties.Max) : undefined));
  ret.addPropertyResult("min", "Min", (properties.Min != null ? cfn_parse.FromCloudFormation.getNumber(properties.Min) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `BaselineEbsBandwidthMbpsProperty`
 *
 * @param properties - the TypeScript properties of a `BaselineEbsBandwidthMbpsProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateBaselineEbsBandwidthMbpsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("max", cdk.validateNumber)(properties.max));
  errors.collect(cdk.propertyValidator("min", cdk.validateNumber)(properties.min));
  return errors.wrap("supplied properties not correct for \"BaselineEbsBandwidthMbpsProperty\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateBaselineEbsBandwidthMbpsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateBaselineEbsBandwidthMbpsPropertyValidator(properties).assertSuccess();
  return {
    "Max": cdk.numberToCloudFormation(properties.max),
    "Min": cdk.numberToCloudFormation(properties.min)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateBaselineEbsBandwidthMbpsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnLaunchTemplate.BaselineEbsBandwidthMbpsProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.BaselineEbsBandwidthMbpsProperty>();
  ret.addPropertyResult("max", "Max", (properties.Max != null ? cfn_parse.FromCloudFormation.getNumber(properties.Max) : undefined));
  ret.addPropertyResult("min", "Min", (properties.Min != null ? cfn_parse.FromCloudFormation.getNumber(properties.Min) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `AcceleratorTotalMemoryMiBProperty`
 *
 * @param properties - the TypeScript properties of a `AcceleratorTotalMemoryMiBProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateAcceleratorTotalMemoryMiBPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("max", cdk.validateNumber)(properties.max));
  errors.collect(cdk.propertyValidator("min", cdk.validateNumber)(properties.min));
  return errors.wrap("supplied properties not correct for \"AcceleratorTotalMemoryMiBProperty\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateAcceleratorTotalMemoryMiBPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateAcceleratorTotalMemoryMiBPropertyValidator(properties).assertSuccess();
  return {
    "Max": cdk.numberToCloudFormation(properties.max),
    "Min": cdk.numberToCloudFormation(properties.min)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateAcceleratorTotalMemoryMiBPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnLaunchTemplate.AcceleratorTotalMemoryMiBProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.AcceleratorTotalMemoryMiBProperty>();
  ret.addPropertyResult("max", "Max", (properties.Max != null ? cfn_parse.FromCloudFormation.getNumber(properties.Max) : undefined));
  ret.addPropertyResult("min", "Min", (properties.Min != null ? cfn_parse.FromCloudFormation.getNumber(properties.Min) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `MemoryMiBProperty`
 *
 * @param properties - the TypeScript properties of a `MemoryMiBProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateMemoryMiBPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("max", cdk.validateNumber)(properties.max));
  errors.collect(cdk.propertyValidator("min", cdk.validateNumber)(properties.min));
  return errors.wrap("supplied properties not correct for \"MemoryMiBProperty\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateMemoryMiBPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateMemoryMiBPropertyValidator(properties).assertSuccess();
  return {
    "Max": cdk.numberToCloudFormation(properties.max),
    "Min": cdk.numberToCloudFormation(properties.min)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateMemoryMiBPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnLaunchTemplate.MemoryMiBProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.MemoryMiBProperty>();
  ret.addPropertyResult("max", "Max", (properties.Max != null ? cfn_parse.FromCloudFormation.getNumber(properties.Max) : undefined));
  ret.addPropertyResult("min", "Min", (properties.Min != null ? cfn_parse.FromCloudFormation.getNumber(properties.Min) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `TotalLocalStorageGBProperty`
 *
 * @param properties - the TypeScript properties of a `TotalLocalStorageGBProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateTotalLocalStorageGBPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("max", cdk.validateNumber)(properties.max));
  errors.collect(cdk.propertyValidator("min", cdk.validateNumber)(properties.min));
  return errors.wrap("supplied properties not correct for \"TotalLocalStorageGBProperty\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateTotalLocalStorageGBPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateTotalLocalStorageGBPropertyValidator(properties).assertSuccess();
  return {
    "Max": cdk.numberToCloudFormation(properties.max),
    "Min": cdk.numberToCloudFormation(properties.min)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateTotalLocalStorageGBPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnLaunchTemplate.TotalLocalStorageGBProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.TotalLocalStorageGBProperty>();
  ret.addPropertyResult("max", "Max", (properties.Max != null ? cfn_parse.FromCloudFormation.getNumber(properties.Max) : undefined));
  ret.addPropertyResult("min", "Min", (properties.Min != null ? cfn_parse.FromCloudFormation.getNumber(properties.Min) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `InstanceRequirementsProperty`
 *
 * @param properties - the TypeScript properties of a `InstanceRequirementsProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateInstanceRequirementsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("acceleratorCount", CfnLaunchTemplateAcceleratorCountPropertyValidator)(properties.acceleratorCount));
  errors.collect(cdk.propertyValidator("acceleratorManufacturers", cdk.listValidator(cdk.validateString))(properties.acceleratorManufacturers));
  errors.collect(cdk.propertyValidator("acceleratorNames", cdk.listValidator(cdk.validateString))(properties.acceleratorNames));
  errors.collect(cdk.propertyValidator("acceleratorTotalMemoryMiB", CfnLaunchTemplateAcceleratorTotalMemoryMiBPropertyValidator)(properties.acceleratorTotalMemoryMiB));
  errors.collect(cdk.propertyValidator("acceleratorTypes", cdk.listValidator(cdk.validateString))(properties.acceleratorTypes));
  errors.collect(cdk.propertyValidator("allowedInstanceTypes", cdk.listValidator(cdk.validateString))(properties.allowedInstanceTypes));
  errors.collect(cdk.propertyValidator("bareMetal", cdk.validateString)(properties.bareMetal));
  errors.collect(cdk.propertyValidator("baselineEbsBandwidthMbps", CfnLaunchTemplateBaselineEbsBandwidthMbpsPropertyValidator)(properties.baselineEbsBandwidthMbps));
  errors.collect(cdk.propertyValidator("burstablePerformance", cdk.validateString)(properties.burstablePerformance));
  errors.collect(cdk.propertyValidator("cpuManufacturers", cdk.listValidator(cdk.validateString))(properties.cpuManufacturers));
  errors.collect(cdk.propertyValidator("excludedInstanceTypes", cdk.listValidator(cdk.validateString))(properties.excludedInstanceTypes));
  errors.collect(cdk.propertyValidator("instanceGenerations", cdk.listValidator(cdk.validateString))(properties.instanceGenerations));
  errors.collect(cdk.propertyValidator("localStorage", cdk.validateString)(properties.localStorage));
  errors.collect(cdk.propertyValidator("localStorageTypes", cdk.listValidator(cdk.validateString))(properties.localStorageTypes));
  errors.collect(cdk.propertyValidator("memoryGiBPerVCpu", CfnLaunchTemplateMemoryGiBPerVCpuPropertyValidator)(properties.memoryGiBPerVCpu));
  errors.collect(cdk.propertyValidator("memoryMiB", CfnLaunchTemplateMemoryMiBPropertyValidator)(properties.memoryMiB));
  errors.collect(cdk.propertyValidator("networkBandwidthGbps", CfnLaunchTemplateNetworkBandwidthGbpsPropertyValidator)(properties.networkBandwidthGbps));
  errors.collect(cdk.propertyValidator("networkInterfaceCount", CfnLaunchTemplateNetworkInterfaceCountPropertyValidator)(properties.networkInterfaceCount));
  errors.collect(cdk.propertyValidator("onDemandMaxPricePercentageOverLowestPrice", cdk.validateNumber)(properties.onDemandMaxPricePercentageOverLowestPrice));
  errors.collect(cdk.propertyValidator("requireHibernateSupport", cdk.validateBoolean)(properties.requireHibernateSupport));
  errors.collect(cdk.propertyValidator("spotMaxPricePercentageOverLowestPrice", cdk.validateNumber)(properties.spotMaxPricePercentageOverLowestPrice));
  errors.collect(cdk.propertyValidator("totalLocalStorageGb", CfnLaunchTemplateTotalLocalStorageGBPropertyValidator)(properties.totalLocalStorageGb));
  errors.collect(cdk.propertyValidator("vCpuCount", CfnLaunchTemplateVCpuCountPropertyValidator)(properties.vCpuCount));
  return errors.wrap("supplied properties not correct for \"InstanceRequirementsProperty\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateInstanceRequirementsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateInstanceRequirementsPropertyValidator(properties).assertSuccess();
  return {
    "AcceleratorCount": convertCfnLaunchTemplateAcceleratorCountPropertyToCloudFormation(properties.acceleratorCount),
    "AcceleratorManufacturers": cdk.listMapper(cdk.stringToCloudFormation)(properties.acceleratorManufacturers),
    "AcceleratorNames": cdk.listMapper(cdk.stringToCloudFormation)(properties.acceleratorNames),
    "AcceleratorTotalMemoryMiB": convertCfnLaunchTemplateAcceleratorTotalMemoryMiBPropertyToCloudFormation(properties.acceleratorTotalMemoryMiB),
    "AcceleratorTypes": cdk.listMapper(cdk.stringToCloudFormation)(properties.acceleratorTypes),
    "AllowedInstanceTypes": cdk.listMapper(cdk.stringToCloudFormation)(properties.allowedInstanceTypes),
    "BareMetal": cdk.stringToCloudFormation(properties.bareMetal),
    "BaselineEbsBandwidthMbps": convertCfnLaunchTemplateBaselineEbsBandwidthMbpsPropertyToCloudFormation(properties.baselineEbsBandwidthMbps),
    "BurstablePerformance": cdk.stringToCloudFormation(properties.burstablePerformance),
    "CpuManufacturers": cdk.listMapper(cdk.stringToCloudFormation)(properties.cpuManufacturers),
    "ExcludedInstanceTypes": cdk.listMapper(cdk.stringToCloudFormation)(properties.excludedInstanceTypes),
    "InstanceGenerations": cdk.listMapper(cdk.stringToCloudFormation)(properties.instanceGenerations),
    "LocalStorage": cdk.stringToCloudFormation(properties.localStorage),
    "LocalStorageTypes": cdk.listMapper(cdk.stringToCloudFormation)(properties.localStorageTypes),
    "MemoryGiBPerVCpu": convertCfnLaunchTemplateMemoryGiBPerVCpuPropertyToCloudFormation(properties.memoryGiBPerVCpu),
    "MemoryMiB": convertCfnLaunchTemplateMemoryMiBPropertyToCloudFormation(properties.memoryMiB),
    "NetworkBandwidthGbps": convertCfnLaunchTemplateNetworkBandwidthGbpsPropertyToCloudFormation(properties.networkBandwidthGbps),
    "NetworkInterfaceCount": convertCfnLaunchTemplateNetworkInterfaceCountPropertyToCloudFormation(properties.networkInterfaceCount),
    "OnDemandMaxPricePercentageOverLowestPrice": cdk.numberToCloudFormation(properties.onDemandMaxPricePercentageOverLowestPrice),
    "RequireHibernateSupport": cdk.booleanToCloudFormation(properties.requireHibernateSupport),
    "SpotMaxPricePercentageOverLowestPrice": cdk.numberToCloudFormation(properties.spotMaxPricePercentageOverLowestPrice),
    "TotalLocalStorageGB": convertCfnLaunchTemplateTotalLocalStorageGBPropertyToCloudFormation(properties.totalLocalStorageGb),
    "VCpuCount": convertCfnLaunchTemplateVCpuCountPropertyToCloudFormation(properties.vCpuCount)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateInstanceRequirementsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnLaunchTemplate.InstanceRequirementsProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.InstanceRequirementsProperty>();
  ret.addPropertyResult("acceleratorCount", "AcceleratorCount", (properties.AcceleratorCount != null ? CfnLaunchTemplateAcceleratorCountPropertyFromCloudFormation(properties.AcceleratorCount) : undefined));
  ret.addPropertyResult("acceleratorManufacturers", "AcceleratorManufacturers", (properties.AcceleratorManufacturers != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.AcceleratorManufacturers) : undefined));
  ret.addPropertyResult("acceleratorNames", "AcceleratorNames", (properties.AcceleratorNames != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.AcceleratorNames) : undefined));
  ret.addPropertyResult("acceleratorTotalMemoryMiB", "AcceleratorTotalMemoryMiB", (properties.AcceleratorTotalMemoryMiB != null ? CfnLaunchTemplateAcceleratorTotalMemoryMiBPropertyFromCloudFormation(properties.AcceleratorTotalMemoryMiB) : undefined));
  ret.addPropertyResult("acceleratorTypes", "AcceleratorTypes", (properties.AcceleratorTypes != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.AcceleratorTypes) : undefined));
  ret.addPropertyResult("allowedInstanceTypes", "AllowedInstanceTypes", (properties.AllowedInstanceTypes != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.AllowedInstanceTypes) : undefined));
  ret.addPropertyResult("bareMetal", "BareMetal", (properties.BareMetal != null ? cfn_parse.FromCloudFormation.getString(properties.BareMetal) : undefined));
  ret.addPropertyResult("baselineEbsBandwidthMbps", "BaselineEbsBandwidthMbps", (properties.BaselineEbsBandwidthMbps != null ? CfnLaunchTemplateBaselineEbsBandwidthMbpsPropertyFromCloudFormation(properties.BaselineEbsBandwidthMbps) : undefined));
  ret.addPropertyResult("burstablePerformance", "BurstablePerformance", (properties.BurstablePerformance != null ? cfn_parse.FromCloudFormation.getString(properties.BurstablePerformance) : undefined));
  ret.addPropertyResult("cpuManufacturers", "CpuManufacturers", (properties.CpuManufacturers != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.CpuManufacturers) : undefined));
  ret.addPropertyResult("excludedInstanceTypes", "ExcludedInstanceTypes", (properties.ExcludedInstanceTypes != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.ExcludedInstanceTypes) : undefined));
  ret.addPropertyResult("instanceGenerations", "InstanceGenerations", (properties.InstanceGenerations != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.InstanceGenerations) : undefined));
  ret.addPropertyResult("localStorage", "LocalStorage", (properties.LocalStorage != null ? cfn_parse.FromCloudFormation.getString(properties.LocalStorage) : undefined));
  ret.addPropertyResult("localStorageTypes", "LocalStorageTypes", (properties.LocalStorageTypes != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.LocalStorageTypes) : undefined));
  ret.addPropertyResult("memoryGiBPerVCpu", "MemoryGiBPerVCpu", (properties.MemoryGiBPerVCpu != null ? CfnLaunchTemplateMemoryGiBPerVCpuPropertyFromCloudFormation(properties.MemoryGiBPerVCpu) : undefined));
  ret.addPropertyResult("memoryMiB", "MemoryMiB", (properties.MemoryMiB != null ? CfnLaunchTemplateMemoryMiBPropertyFromCloudFormation(properties.MemoryMiB) : undefined));
  ret.addPropertyResult("networkBandwidthGbps", "NetworkBandwidthGbps", (properties.NetworkBandwidthGbps != null ? CfnLaunchTemplateNetworkBandwidthGbpsPropertyFromCloudFormation(properties.NetworkBandwidthGbps) : undefined));
  ret.addPropertyResult("networkInterfaceCount", "NetworkInterfaceCount", (properties.NetworkInterfaceCount != null ? CfnLaunchTemplateNetworkInterfaceCountPropertyFromCloudFormation(properties.NetworkInterfaceCount) : undefined));
  ret.addPropertyResult("onDemandMaxPricePercentageOverLowestPrice", "OnDemandMaxPricePercentageOverLowestPrice", (properties.OnDemandMaxPricePercentageOverLowestPrice != null ? cfn_parse.FromCloudFormation.getNumber(properties.OnDemandMaxPricePercentageOverLowestPrice) : undefined));
  ret.addPropertyResult("requireHibernateSupport", "RequireHibernateSupport", (properties.RequireHibernateSupport != null ? cfn_parse.FromCloudFormation.getBoolean(properties.RequireHibernateSupport) : undefined));
  ret.addPropertyResult("spotMaxPricePercentageOverLowestPrice", "SpotMaxPricePercentageOverLowestPrice", (properties.SpotMaxPricePercentageOverLowestPrice != null ? cfn_parse.FromCloudFormation.getNumber(properties.SpotMaxPricePercentageOverLowestPrice) : undefined));
  ret.addPropertyResult("totalLocalStorageGb", "TotalLocalStorageGB", (properties.TotalLocalStorageGB != null ? CfnLaunchTemplateTotalLocalStorageGBPropertyFromCloudFormation(properties.TotalLocalStorageGB) : undefined));
  ret.addPropertyResult("vCpuCount", "VCpuCount", (properties.VCpuCount != null ? CfnLaunchTemplateVCpuCountPropertyFromCloudFormation(properties.VCpuCount) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `CapacityReservationTargetProperty`
 *
 * @param properties - the TypeScript properties of a `CapacityReservationTargetProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateCapacityReservationTargetPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("capacityReservationId", cdk.validateString)(properties.capacityReservationId));
  errors.collect(cdk.propertyValidator("capacityReservationResourceGroupArn", cdk.validateString)(properties.capacityReservationResourceGroupArn));
  return errors.wrap("supplied properties not correct for \"CapacityReservationTargetProperty\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateCapacityReservationTargetPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateCapacityReservationTargetPropertyValidator(properties).assertSuccess();
  return {
    "CapacityReservationId": cdk.stringToCloudFormation(properties.capacityReservationId),
    "CapacityReservationResourceGroupArn": cdk.stringToCloudFormation(properties.capacityReservationResourceGroupArn)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateCapacityReservationTargetPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnLaunchTemplate.CapacityReservationTargetProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.CapacityReservationTargetProperty>();
  ret.addPropertyResult("capacityReservationId", "CapacityReservationId", (properties.CapacityReservationId != null ? cfn_parse.FromCloudFormation.getString(properties.CapacityReservationId) : undefined));
  ret.addPropertyResult("capacityReservationResourceGroupArn", "CapacityReservationResourceGroupArn", (properties.CapacityReservationResourceGroupArn != null ? cfn_parse.FromCloudFormation.getString(properties.CapacityReservationResourceGroupArn) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `CapacityReservationSpecificationProperty`
 *
 * @param properties - the TypeScript properties of a `CapacityReservationSpecificationProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateCapacityReservationSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("capacityReservationPreference", cdk.validateString)(properties.capacityReservationPreference));
  errors.collect(cdk.propertyValidator("capacityReservationTarget", CfnLaunchTemplateCapacityReservationTargetPropertyValidator)(properties.capacityReservationTarget));
  return errors.wrap("supplied properties not correct for \"CapacityReservationSpecificationProperty\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateCapacityReservationSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateCapacityReservationSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "CapacityReservationPreference": cdk.stringToCloudFormation(properties.capacityReservationPreference),
    "CapacityReservationTarget": convertCfnLaunchTemplateCapacityReservationTargetPropertyToCloudFormation(properties.capacityReservationTarget)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateCapacityReservationSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnLaunchTemplate.CapacityReservationSpecificationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.CapacityReservationSpecificationProperty>();
  ret.addPropertyResult("capacityReservationPreference", "CapacityReservationPreference", (properties.CapacityReservationPreference != null ? cfn_parse.FromCloudFormation.getString(properties.CapacityReservationPreference) : undefined));
  ret.addPropertyResult("capacityReservationTarget", "CapacityReservationTarget", (properties.CapacityReservationTarget != null ? CfnLaunchTemplateCapacityReservationTargetPropertyFromCloudFormation(properties.CapacityReservationTarget) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `CreditSpecificationProperty`
 *
 * @param properties - the TypeScript properties of a `CreditSpecificationProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateCreditSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("cpuCredits", cdk.validateString)(properties.cpuCredits));
  return errors.wrap("supplied properties not correct for \"CreditSpecificationProperty\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateCreditSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateCreditSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "CpuCredits": cdk.stringToCloudFormation(properties.cpuCredits)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateCreditSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnLaunchTemplate.CreditSpecificationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.CreditSpecificationProperty>();
  ret.addPropertyResult("cpuCredits", "CpuCredits", (properties.CpuCredits != null ? cfn_parse.FromCloudFormation.getString(properties.CpuCredits) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `LaunchTemplateDataProperty`
 *
 * @param properties - the TypeScript properties of a `LaunchTemplateDataProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateLaunchTemplateDataPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("blockDeviceMappings", cdk.listValidator(CfnLaunchTemplateBlockDeviceMappingPropertyValidator))(properties.blockDeviceMappings));
  errors.collect(cdk.propertyValidator("capacityReservationSpecification", CfnLaunchTemplateCapacityReservationSpecificationPropertyValidator)(properties.capacityReservationSpecification));
  errors.collect(cdk.propertyValidator("cpuOptions", CfnLaunchTemplateCpuOptionsPropertyValidator)(properties.cpuOptions));
  errors.collect(cdk.propertyValidator("creditSpecification", CfnLaunchTemplateCreditSpecificationPropertyValidator)(properties.creditSpecification));
  errors.collect(cdk.propertyValidator("disableApiStop", cdk.validateBoolean)(properties.disableApiStop));
  errors.collect(cdk.propertyValidator("disableApiTermination", cdk.validateBoolean)(properties.disableApiTermination));
  errors.collect(cdk.propertyValidator("ebsOptimized", cdk.validateBoolean)(properties.ebsOptimized));
  errors.collect(cdk.propertyValidator("elasticGpuSpecifications", cdk.listValidator(CfnLaunchTemplateElasticGpuSpecificationPropertyValidator))(properties.elasticGpuSpecifications));
  errors.collect(cdk.propertyValidator("elasticInferenceAccelerators", cdk.listValidator(CfnLaunchTemplateLaunchTemplateElasticInferenceAcceleratorPropertyValidator))(properties.elasticInferenceAccelerators));
  errors.collect(cdk.propertyValidator("enclaveOptions", CfnLaunchTemplateEnclaveOptionsPropertyValidator)(properties.enclaveOptions));
  errors.collect(cdk.propertyValidator("hibernationOptions", CfnLaunchTemplateHibernationOptionsPropertyValidator)(properties.hibernationOptions));
  errors.collect(cdk.propertyValidator("iamInstanceProfile", CfnLaunchTemplateIamInstanceProfilePropertyValidator)(properties.iamInstanceProfile));
  errors.collect(cdk.propertyValidator("imageId", cdk.validateString)(properties.imageId));
  errors.collect(cdk.propertyValidator("instanceInitiatedShutdownBehavior", cdk.validateString)(properties.instanceInitiatedShutdownBehavior));
  errors.collect(cdk.propertyValidator("instanceMarketOptions", CfnLaunchTemplateInstanceMarketOptionsPropertyValidator)(properties.instanceMarketOptions));
  errors.collect(cdk.propertyValidator("instanceRequirements", CfnLaunchTemplateInstanceRequirementsPropertyValidator)(properties.instanceRequirements));
  errors.collect(cdk.propertyValidator("instanceType", cdk.validateString)(properties.instanceType));
  errors.collect(cdk.propertyValidator("kernelId", cdk.validateString)(properties.kernelId));
  errors.collect(cdk.propertyValidator("keyName", cdk.validateString)(properties.keyName));
  errors.collect(cdk.propertyValidator("licenseSpecifications", cdk.listValidator(CfnLaunchTemplateLicenseSpecificationPropertyValidator))(properties.licenseSpecifications));
  errors.collect(cdk.propertyValidator("maintenanceOptions", CfnLaunchTemplateMaintenanceOptionsPropertyValidator)(properties.maintenanceOptions));
  errors.collect(cdk.propertyValidator("metadataOptions", CfnLaunchTemplateMetadataOptionsPropertyValidator)(properties.metadataOptions));
  errors.collect(cdk.propertyValidator("monitoring", CfnLaunchTemplateMonitoringPropertyValidator)(properties.monitoring));
  errors.collect(cdk.propertyValidator("networkInterfaces", cdk.listValidator(CfnLaunchTemplateNetworkInterfacePropertyValidator))(properties.networkInterfaces));
  errors.collect(cdk.propertyValidator("placement", CfnLaunchTemplatePlacementPropertyValidator)(properties.placement));
  errors.collect(cdk.propertyValidator("privateDnsNameOptions", CfnLaunchTemplatePrivateDnsNameOptionsPropertyValidator)(properties.privateDnsNameOptions));
  errors.collect(cdk.propertyValidator("ramDiskId", cdk.validateString)(properties.ramDiskId));
  errors.collect(cdk.propertyValidator("securityGroupIds", cdk.listValidator(cdk.validateString))(properties.securityGroupIds));
  errors.collect(cdk.propertyValidator("securityGroups", cdk.listValidator(cdk.validateString))(properties.securityGroups));
  errors.collect(cdk.propertyValidator("tagSpecifications", cdk.listValidator(CfnLaunchTemplateTagSpecificationPropertyValidator))(properties.tagSpecifications));
  errors.collect(cdk.propertyValidator("userData", cdk.validateString)(properties.userData));
  return errors.wrap("supplied properties not correct for \"LaunchTemplateDataProperty\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateLaunchTemplateDataPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateLaunchTemplateDataPropertyValidator(properties).assertSuccess();
  return {
    "BlockDeviceMappings": cdk.listMapper(convertCfnLaunchTemplateBlockDeviceMappingPropertyToCloudFormation)(properties.blockDeviceMappings),
    "CapacityReservationSpecification": convertCfnLaunchTemplateCapacityReservationSpecificationPropertyToCloudFormation(properties.capacityReservationSpecification),
    "CpuOptions": convertCfnLaunchTemplateCpuOptionsPropertyToCloudFormation(properties.cpuOptions),
    "CreditSpecification": convertCfnLaunchTemplateCreditSpecificationPropertyToCloudFormation(properties.creditSpecification),
    "DisableApiStop": cdk.booleanToCloudFormation(properties.disableApiStop),
    "DisableApiTermination": cdk.booleanToCloudFormation(properties.disableApiTermination),
    "EbsOptimized": cdk.booleanToCloudFormation(properties.ebsOptimized),
    "ElasticGpuSpecifications": cdk.listMapper(convertCfnLaunchTemplateElasticGpuSpecificationPropertyToCloudFormation)(properties.elasticGpuSpecifications),
    "ElasticInferenceAccelerators": cdk.listMapper(convertCfnLaunchTemplateLaunchTemplateElasticInferenceAcceleratorPropertyToCloudFormation)(properties.elasticInferenceAccelerators),
    "EnclaveOptions": convertCfnLaunchTemplateEnclaveOptionsPropertyToCloudFormation(properties.enclaveOptions),
    "HibernationOptions": convertCfnLaunchTemplateHibernationOptionsPropertyToCloudFormation(properties.hibernationOptions),
    "IamInstanceProfile": convertCfnLaunchTemplateIamInstanceProfilePropertyToCloudFormation(properties.iamInstanceProfile),
    "ImageId": cdk.stringToCloudFormation(properties.imageId),
    "InstanceInitiatedShutdownBehavior": cdk.stringToCloudFormation(properties.instanceInitiatedShutdownBehavior),
    "InstanceMarketOptions": convertCfnLaunchTemplateInstanceMarketOptionsPropertyToCloudFormation(properties.instanceMarketOptions),
    "InstanceRequirements": convertCfnLaunchTemplateInstanceRequirementsPropertyToCloudFormation(properties.instanceRequirements),
    "InstanceType": cdk.stringToCloudFormation(properties.instanceType),
    "KernelId": cdk.stringToCloudFormation(properties.kernelId),
    "KeyName": cdk.stringToCloudFormation(properties.keyName),
    "LicenseSpecifications": cdk.listMapper(convertCfnLaunchTemplateLicenseSpecificationPropertyToCloudFormation)(properties.licenseSpecifications),
    "MaintenanceOptions": convertCfnLaunchTemplateMaintenanceOptionsPropertyToCloudFormation(properties.maintenanceOptions),
    "MetadataOptions": convertCfnLaunchTemplateMetadataOptionsPropertyToCloudFormation(properties.metadataOptions),
    "Monitoring": convertCfnLaunchTemplateMonitoringPropertyToCloudFormation(properties.monitoring),
    "NetworkInterfaces": cdk.listMapper(convertCfnLaunchTemplateNetworkInterfacePropertyToCloudFormation)(properties.networkInterfaces),
    "Placement": convertCfnLaunchTemplatePlacementPropertyToCloudFormation(properties.placement),
    "PrivateDnsNameOptions": convertCfnLaunchTemplatePrivateDnsNameOptionsPropertyToCloudFormation(properties.privateDnsNameOptions),
    "RamDiskId": cdk.stringToCloudFormation(properties.ramDiskId),
    "SecurityGroupIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.securityGroupIds),
    "SecurityGroups": cdk.listMapper(cdk.stringToCloudFormation)(properties.securityGroups),
    "TagSpecifications": cdk.listMapper(convertCfnLaunchTemplateTagSpecificationPropertyToCloudFormation)(properties.tagSpecifications),
    "UserData": cdk.stringToCloudFormation(properties.userData)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateLaunchTemplateDataPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnLaunchTemplate.LaunchTemplateDataProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.LaunchTemplateDataProperty>();
  ret.addPropertyResult("blockDeviceMappings", "BlockDeviceMappings", (properties.BlockDeviceMappings != null ? cfn_parse.FromCloudFormation.getArray(CfnLaunchTemplateBlockDeviceMappingPropertyFromCloudFormation)(properties.BlockDeviceMappings) : undefined));
  ret.addPropertyResult("capacityReservationSpecification", "CapacityReservationSpecification", (properties.CapacityReservationSpecification != null ? CfnLaunchTemplateCapacityReservationSpecificationPropertyFromCloudFormation(properties.CapacityReservationSpecification) : undefined));
  ret.addPropertyResult("cpuOptions", "CpuOptions", (properties.CpuOptions != null ? CfnLaunchTemplateCpuOptionsPropertyFromCloudFormation(properties.CpuOptions) : undefined));
  ret.addPropertyResult("creditSpecification", "CreditSpecification", (properties.CreditSpecification != null ? CfnLaunchTemplateCreditSpecificationPropertyFromCloudFormation(properties.CreditSpecification) : undefined));
  ret.addPropertyResult("disableApiStop", "DisableApiStop", (properties.DisableApiStop != null ? cfn_parse.FromCloudFormation.getBoolean(properties.DisableApiStop) : undefined));
  ret.addPropertyResult("disableApiTermination", "DisableApiTermination", (properties.DisableApiTermination != null ? cfn_parse.FromCloudFormation.getBoolean(properties.DisableApiTermination) : undefined));
  ret.addPropertyResult("ebsOptimized", "EbsOptimized", (properties.EbsOptimized != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EbsOptimized) : undefined));
  ret.addPropertyResult("elasticGpuSpecifications", "ElasticGpuSpecifications", (properties.ElasticGpuSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnLaunchTemplateElasticGpuSpecificationPropertyFromCloudFormation)(properties.ElasticGpuSpecifications) : undefined));
  ret.addPropertyResult("elasticInferenceAccelerators", "ElasticInferenceAccelerators", (properties.ElasticInferenceAccelerators != null ? cfn_parse.FromCloudFormation.getArray(CfnLaunchTemplateLaunchTemplateElasticInferenceAcceleratorPropertyFromCloudFormation)(properties.ElasticInferenceAccelerators) : undefined));
  ret.addPropertyResult("enclaveOptions", "EnclaveOptions", (properties.EnclaveOptions != null ? CfnLaunchTemplateEnclaveOptionsPropertyFromCloudFormation(properties.EnclaveOptions) : undefined));
  ret.addPropertyResult("hibernationOptions", "HibernationOptions", (properties.HibernationOptions != null ? CfnLaunchTemplateHibernationOptionsPropertyFromCloudFormation(properties.HibernationOptions) : undefined));
  ret.addPropertyResult("iamInstanceProfile", "IamInstanceProfile", (properties.IamInstanceProfile != null ? CfnLaunchTemplateIamInstanceProfilePropertyFromCloudFormation(properties.IamInstanceProfile) : undefined));
  ret.addPropertyResult("imageId", "ImageId", (properties.ImageId != null ? cfn_parse.FromCloudFormation.getString(properties.ImageId) : undefined));
  ret.addPropertyResult("instanceInitiatedShutdownBehavior", "InstanceInitiatedShutdownBehavior", (properties.InstanceInitiatedShutdownBehavior != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceInitiatedShutdownBehavior) : undefined));
  ret.addPropertyResult("instanceMarketOptions", "InstanceMarketOptions", (properties.InstanceMarketOptions != null ? CfnLaunchTemplateInstanceMarketOptionsPropertyFromCloudFormation(properties.InstanceMarketOptions) : undefined));
  ret.addPropertyResult("instanceRequirements", "InstanceRequirements", (properties.InstanceRequirements != null ? CfnLaunchTemplateInstanceRequirementsPropertyFromCloudFormation(properties.InstanceRequirements) : undefined));
  ret.addPropertyResult("instanceType", "InstanceType", (properties.InstanceType != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceType) : undefined));
  ret.addPropertyResult("kernelId", "KernelId", (properties.KernelId != null ? cfn_parse.FromCloudFormation.getString(properties.KernelId) : undefined));
  ret.addPropertyResult("keyName", "KeyName", (properties.KeyName != null ? cfn_parse.FromCloudFormation.getString(properties.KeyName) : undefined));
  ret.addPropertyResult("licenseSpecifications", "LicenseSpecifications", (properties.LicenseSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnLaunchTemplateLicenseSpecificationPropertyFromCloudFormation)(properties.LicenseSpecifications) : undefined));
  ret.addPropertyResult("maintenanceOptions", "MaintenanceOptions", (properties.MaintenanceOptions != null ? CfnLaunchTemplateMaintenanceOptionsPropertyFromCloudFormation(properties.MaintenanceOptions) : undefined));
  ret.addPropertyResult("metadataOptions", "MetadataOptions", (properties.MetadataOptions != null ? CfnLaunchTemplateMetadataOptionsPropertyFromCloudFormation(properties.MetadataOptions) : undefined));
  ret.addPropertyResult("monitoring", "Monitoring", (properties.Monitoring != null ? CfnLaunchTemplateMonitoringPropertyFromCloudFormation(properties.Monitoring) : undefined));
  ret.addPropertyResult("networkInterfaces", "NetworkInterfaces", (properties.NetworkInterfaces != null ? cfn_parse.FromCloudFormation.getArray(CfnLaunchTemplateNetworkInterfacePropertyFromCloudFormation)(properties.NetworkInterfaces) : undefined));
  ret.addPropertyResult("placement", "Placement", (properties.Placement != null ? CfnLaunchTemplatePlacementPropertyFromCloudFormation(properties.Placement) : undefined));
  ret.addPropertyResult("privateDnsNameOptions", "PrivateDnsNameOptions", (properties.PrivateDnsNameOptions != null ? CfnLaunchTemplatePrivateDnsNameOptionsPropertyFromCloudFormation(properties.PrivateDnsNameOptions) : undefined));
  ret.addPropertyResult("ramDiskId", "RamDiskId", (properties.RamDiskId != null ? cfn_parse.FromCloudFormation.getString(properties.RamDiskId) : undefined));
  ret.addPropertyResult("securityGroupIds", "SecurityGroupIds", (properties.SecurityGroupIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecurityGroupIds) : undefined));
  ret.addPropertyResult("securityGroups", "SecurityGroups", (properties.SecurityGroups != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecurityGroups) : undefined));
  ret.addPropertyResult("tagSpecifications", "TagSpecifications", (properties.TagSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnLaunchTemplateTagSpecificationPropertyFromCloudFormation)(properties.TagSpecifications) : undefined));
  ret.addPropertyResult("userData", "UserData", (properties.UserData != null ? cfn_parse.FromCloudFormation.getString(properties.UserData) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `LaunchTemplateTagSpecificationProperty`
 *
 * @param properties - the TypeScript properties of a `LaunchTemplateTagSpecificationProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateLaunchTemplateTagSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("resourceType", cdk.validateString)(properties.resourceType));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \"LaunchTemplateTagSpecificationProperty\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateLaunchTemplateTagSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateLaunchTemplateTagSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "ResourceType": cdk.stringToCloudFormation(properties.resourceType),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateLaunchTemplateTagSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnLaunchTemplate.LaunchTemplateTagSpecificationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.LaunchTemplateTagSpecificationProperty>();
  ret.addPropertyResult("resourceType", "ResourceType", (properties.ResourceType != null ? cfn_parse.FromCloudFormation.getString(properties.ResourceType) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `CfnLaunchTemplateProps`
 *
 * @param properties - the TypeScript properties of a `CfnLaunchTemplateProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplatePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("launchTemplateData", cdk.requiredValidator)(properties.launchTemplateData));
  errors.collect(cdk.propertyValidator("launchTemplateData", CfnLaunchTemplateLaunchTemplateDataPropertyValidator)(properties.launchTemplateData));
  errors.collect(cdk.propertyValidator("launchTemplateName", cdk.validateString)(properties.launchTemplateName));
  errors.collect(cdk.propertyValidator("tagSpecifications", cdk.listValidator(CfnLaunchTemplateLaunchTemplateTagSpecificationPropertyValidator))(properties.tagSpecifications));
  errors.collect(cdk.propertyValidator("versionDescription", cdk.validateString)(properties.versionDescription));
  return errors.wrap("supplied properties not correct for \"CfnLaunchTemplateProps\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplatePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplatePropsValidator(properties).assertSuccess();
  return {
    "LaunchTemplateData": convertCfnLaunchTemplateLaunchTemplateDataPropertyToCloudFormation(properties.launchTemplateData),
    "LaunchTemplateName": cdk.stringToCloudFormation(properties.launchTemplateName),
    "TagSpecifications": cdk.listMapper(convertCfnLaunchTemplateLaunchTemplateTagSpecificationPropertyToCloudFormation)(properties.tagSpecifications),
    "VersionDescription": cdk.stringToCloudFormation(properties.versionDescription)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplatePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnLaunchTemplateProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplateProps>();
  ret.addPropertyResult("launchTemplateData", "LaunchTemplateData", (properties.LaunchTemplateData != null ? CfnLaunchTemplateLaunchTemplateDataPropertyFromCloudFormation(properties.LaunchTemplateData) : undefined));
  ret.addPropertyResult("launchTemplateName", "LaunchTemplateName", (properties.LaunchTemplateName != null ? cfn_parse.FromCloudFormation.getString(properties.LaunchTemplateName) : undefined));
  ret.addPropertyResult("tagSpecifications", "TagSpecifications", (properties.TagSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnLaunchTemplateLaunchTemplateTagSpecificationPropertyFromCloudFormation)(properties.TagSpecifications) : undefined));
  ret.addPropertyResult("versionDescription", "VersionDescription", (properties.VersionDescription != null ? cfn_parse.FromCloudFormation.getString(properties.VersionDescription) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Creates a static route for the specified local gateway route table. You must specify one of the following targets:.
 *
 * - `LocalGatewayVirtualInterfaceGroupId`
 * - `NetworkInterfaceId`
 *
 * @cloudformationResource AWS::EC2::LocalGatewayRoute
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroute.html
 */
export class CfnLocalGatewayRoute extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::LocalGatewayRoute";

  /**
   * Build a CfnLocalGatewayRoute from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnLocalGatewayRoute {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnLocalGatewayRoutePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnLocalGatewayRoute(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The state of the local gateway route table.
   *
   * @cloudformationAttribute State
   */
  public readonly attrState: string;

  /**
   * The type of local gateway route.
   *
   * @cloudformationAttribute Type
   */
  public readonly attrType: string;

  /**
   * The CIDR block used for destination matches.
   */
  public destinationCidrBlock: string;

  /**
   * The ID of the local gateway route table.
   */
  public localGatewayRouteTableId: string;

  /**
   * The ID of the virtual interface group.
   */
  public localGatewayVirtualInterfaceGroupId?: string;

  /**
   * The ID of the network interface.
   */
  public networkInterfaceId?: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnLocalGatewayRouteProps) {
    super(scope, id, {
      "type": CfnLocalGatewayRoute.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "destinationCidrBlock", this);
    cdk.requireProperty(props, "localGatewayRouteTableId", this);

    this.attrState = cdk.Token.asString(this.getAtt("State", cdk.ResolutionTypeHint.STRING));
    this.attrType = cdk.Token.asString(this.getAtt("Type", cdk.ResolutionTypeHint.STRING));
    this.destinationCidrBlock = props.destinationCidrBlock;
    this.localGatewayRouteTableId = props.localGatewayRouteTableId;
    this.localGatewayVirtualInterfaceGroupId = props.localGatewayVirtualInterfaceGroupId;
    this.networkInterfaceId = props.networkInterfaceId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "destinationCidrBlock": this.destinationCidrBlock,
      "localGatewayRouteTableId": this.localGatewayRouteTableId,
      "localGatewayVirtualInterfaceGroupId": this.localGatewayVirtualInterfaceGroupId,
      "networkInterfaceId": this.networkInterfaceId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnLocalGatewayRoute.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnLocalGatewayRoutePropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a `CfnLocalGatewayRoute`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroute.html
 */
export interface CfnLocalGatewayRouteProps {
  /**
   * The CIDR block used for destination matches.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroute.html#cfn-ec2-localgatewayroute-destinationcidrblock
   */
  readonly destinationCidrBlock: string;

  /**
   * The ID of the local gateway route table.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroute.html#cfn-ec2-localgatewayroute-localgatewayroutetableid
   */
  readonly localGatewayRouteTableId: string;

  /**
   * The ID of the virtual interface group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroute.html#cfn-ec2-localgatewayroute-localgatewayvirtualinterfacegroupid
   */
  readonly localGatewayVirtualInterfaceGroupId?: string;

  /**
   * The ID of the network interface.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroute.html#cfn-ec2-localgatewayroute-networkinterfaceid
   */
  readonly networkInterfaceId?: string;
}

/**
 * Determine whether the given properties match those of a `CfnLocalGatewayRouteProps`
 *
 * @param properties - the TypeScript properties of a `CfnLocalGatewayRouteProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLocalGatewayRoutePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("destinationCidrBlock", cdk.requiredValidator)(properties.destinationCidrBlock));
  errors.collect(cdk.propertyValidator("destinationCidrBlock", cdk.validateString)(properties.destinationCidrBlock));
  errors.collect(cdk.propertyValidator("localGatewayRouteTableId", cdk.requiredValidator)(properties.localGatewayRouteTableId));
  errors.collect(cdk.propertyValidator("localGatewayRouteTableId", cdk.validateString)(properties.localGatewayRouteTableId));
  errors.collect(cdk.propertyValidator("localGatewayVirtualInterfaceGroupId", cdk.validateString)(properties.localGatewayVirtualInterfaceGroupId));
  errors.collect(cdk.propertyValidator("networkInterfaceId", cdk.validateString)(properties.networkInterfaceId));
  return errors.wrap("supplied properties not correct for \"CfnLocalGatewayRouteProps\"");
}

// @ts-ignore TS6133
function convertCfnLocalGatewayRoutePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLocalGatewayRoutePropsValidator(properties).assertSuccess();
  return {
    "DestinationCidrBlock": cdk.stringToCloudFormation(properties.destinationCidrBlock),
    "LocalGatewayRouteTableId": cdk.stringToCloudFormation(properties.localGatewayRouteTableId),
    "LocalGatewayVirtualInterfaceGroupId": cdk.stringToCloudFormation(properties.localGatewayVirtualInterfaceGroupId),
    "NetworkInterfaceId": cdk.stringToCloudFormation(properties.networkInterfaceId)
  };
}

// @ts-ignore TS6133
function CfnLocalGatewayRoutePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnLocalGatewayRouteProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLocalGatewayRouteProps>();
  ret.addPropertyResult("destinationCidrBlock", "DestinationCidrBlock", (properties.DestinationCidrBlock != null ? cfn_parse.FromCloudFormation.getString(properties.DestinationCidrBlock) : undefined));
  ret.addPropertyResult("localGatewayRouteTableId", "LocalGatewayRouteTableId", (properties.LocalGatewayRouteTableId != null ? cfn_parse.FromCloudFormation.getString(properties.LocalGatewayRouteTableId) : undefined));
  ret.addPropertyResult("localGatewayVirtualInterfaceGroupId", "LocalGatewayVirtualInterfaceGroupId", (properties.LocalGatewayVirtualInterfaceGroupId != null ? cfn_parse.FromCloudFormation.getString(properties.LocalGatewayVirtualInterfaceGroupId) : undefined));
  ret.addPropertyResult("networkInterfaceId", "NetworkInterfaceId", (properties.NetworkInterfaceId != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkInterfaceId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Describes a local gateway route table.
 *
 * @cloudformationResource AWS::EC2::LocalGatewayRouteTable
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetable.html
 */
export class CfnLocalGatewayRouteTable extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::LocalGatewayRouteTable";

  /**
   * Build a CfnLocalGatewayRouteTable from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnLocalGatewayRouteTable {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnLocalGatewayRouteTablePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnLocalGatewayRouteTable(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The Amazon Resource Name (ARN) of the local gateway route table.
   *
   * @cloudformationAttribute LocalGatewayRouteTableArn
   */
  public readonly attrLocalGatewayRouteTableArn: string;

  /**
   * The ID of the local gateway route table.
   *
   * @cloudformationAttribute LocalGatewayRouteTableId
   */
  public readonly attrLocalGatewayRouteTableId: string;

  /**
   * The Amazon Resource Name (ARN) of the Outpost.
   *
   * @cloudformationAttribute OutpostArn
   */
  public readonly attrOutpostArn: string;

  /**
   * The ID of the AWS account that owns the local gateway route table.
   *
   * @cloudformationAttribute OwnerId
   */
  public readonly attrOwnerId: string;

  /**
   * The state of the local gateway route table.
   *
   * @cloudformationAttribute State
   */
  public readonly attrState: string;

  /**
   * The ID of the local gateway.
   */
  public localGatewayId: string;

  /**
   * The mode of the local gateway route table.
   */
  public mode?: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags assigned to the local gateway route table.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnLocalGatewayRouteTableProps) {
    super(scope, id, {
      "type": CfnLocalGatewayRouteTable.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "localGatewayId", this);

    this.attrLocalGatewayRouteTableArn = cdk.Token.asString(this.getAtt("LocalGatewayRouteTableArn", cdk.ResolutionTypeHint.STRING));
    this.attrLocalGatewayRouteTableId = cdk.Token.asString(this.getAtt("LocalGatewayRouteTableId", cdk.ResolutionTypeHint.STRING));
    this.attrOutpostArn = cdk.Token.asString(this.getAtt("OutpostArn", cdk.ResolutionTypeHint.STRING));
    this.attrOwnerId = cdk.Token.asString(this.getAtt("OwnerId", cdk.ResolutionTypeHint.STRING));
    this.attrState = cdk.Token.asString(this.getAtt("State", cdk.ResolutionTypeHint.STRING));
    this.localGatewayId = props.localGatewayId;
    this.mode = props.mode;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::LocalGatewayRouteTable", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "localGatewayId": this.localGatewayId,
      "mode": this.mode,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnLocalGatewayRouteTable.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnLocalGatewayRouteTablePropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a `CfnLocalGatewayRouteTable`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetable.html
 */
export interface CfnLocalGatewayRouteTableProps {
  /**
   * The ID of the local gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetable.html#cfn-ec2-localgatewayroutetable-localgatewayid
   */
  readonly localGatewayId: string;

  /**
   * The mode of the local gateway route table.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetable.html#cfn-ec2-localgatewayroutetable-mode
   */
  readonly mode?: string;

  /**
   * The tags assigned to the local gateway route table.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetable.html#cfn-ec2-localgatewayroutetable-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a `CfnLocalGatewayRouteTableProps`
 *
 * @param properties - the TypeScript properties of a `CfnLocalGatewayRouteTableProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLocalGatewayRouteTablePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("localGatewayId", cdk.requiredValidator)(properties.localGatewayId));
  errors.collect(cdk.propertyValidator("localGatewayId", cdk.validateString)(properties.localGatewayId));
  errors.collect(cdk.propertyValidator("mode", cdk.validateString)(properties.mode));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \"CfnLocalGatewayRouteTableProps\"");
}

// @ts-ignore TS6133
function convertCfnLocalGatewayRouteTablePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLocalGatewayRouteTablePropsValidator(properties).assertSuccess();
  return {
    "LocalGatewayId": cdk.stringToCloudFormation(properties.localGatewayId),
    "Mode": cdk.stringToCloudFormation(properties.mode),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnLocalGatewayRouteTablePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnLocalGatewayRouteTableProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLocalGatewayRouteTableProps>();
  ret.addPropertyResult("localGatewayId", "LocalGatewayId", (properties.LocalGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.LocalGatewayId) : undefined));
  ret.addPropertyResult("mode", "Mode", (properties.Mode != null ? cfn_parse.FromCloudFormation.getString(properties.Mode) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Associates the specified VPC with the specified local gateway route table.
 *
 * @cloudformationResource AWS::EC2::LocalGatewayRouteTableVPCAssociation
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetablevpcassociation.html
 */
export class CfnLocalGatewayRouteTableVPCAssociation extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::LocalGatewayRouteTableVPCAssociation";

  /**
   * Build a CfnLocalGatewayRouteTableVPCAssociation from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnLocalGatewayRouteTableVPCAssociation {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnLocalGatewayRouteTableVPCAssociationPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnLocalGatewayRouteTableVPCAssociation(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the local gateway.
   *
   * @cloudformationAttribute LocalGatewayId
   */
  public readonly attrLocalGatewayId: string;

  /**
   * The ID of the association.
   *
   * @cloudformationAttribute LocalGatewayRouteTableVpcAssociationId
   */
  public readonly attrLocalGatewayRouteTableVpcAssociationId: string;

  /**
   * The state of the association.
   *
   * @cloudformationAttribute State
   */
  public readonly attrState: string;

  /**
   * The ID of the local gateway route table.
   */
  public localGatewayRouteTableId: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags assigned to the association.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The ID of the VPC.
   */
  public vpcId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnLocalGatewayRouteTableVPCAssociationProps) {
    super(scope, id, {
      "type": CfnLocalGatewayRouteTableVPCAssociation.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "localGatewayRouteTableId", this);
    cdk.requireProperty(props, "vpcId", this);

    this.attrLocalGatewayId = cdk.Token.asString(this.getAtt("LocalGatewayId", cdk.ResolutionTypeHint.STRING));
    this.attrLocalGatewayRouteTableVpcAssociationId = cdk.Token.asString(this.getAtt("LocalGatewayRouteTableVpcAssociationId", cdk.ResolutionTypeHint.STRING));
    this.attrState = cdk.Token.asString(this.getAtt("State", cdk.ResolutionTypeHint.STRING));
    this.localGatewayRouteTableId = props.localGatewayRouteTableId;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::LocalGatewayRouteTableVPCAssociation", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.vpcId = props.vpcId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "localGatewayRouteTableId": this.localGatewayRouteTableId,
      "tags": this.tags.renderTags(),
      "vpcId": this.vpcId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnLocalGatewayRouteTableVPCAssociation.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnLocalGatewayRouteTableVPCAssociationPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a `CfnLocalGatewayRouteTableVPCAssociation`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetablevpcassociation.html
 */
export interface CfnLocalGatewayRouteTableVPCAssociationProps {
  /**
   * The ID of the local gateway route table.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetablevpcassociation.html#cfn-ec2-localgatewayroutetablevpcassociation-localgatewayroutetableid
   */
  readonly localGatewayRouteTableId: string;

  /**
   * The tags assigned to the association.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetablevpcassociation.html#cfn-ec2-localgatewayroutetablevpcassociation-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The ID of the VPC.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetablevpcassociation.html#cfn-ec2-localgatewayroutetablevpcassociation-vpcid
   */
  readonly vpcId: string;
}

/**
 * Determine whether the given properties match those of a `CfnLocalGatewayRouteTableVPCAssociationProps`
 *
 * @param properties - the TypeScript properties of a `CfnLocalGatewayRouteTableVPCAssociationProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLocalGatewayRouteTableVPCAssociationPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("localGatewayRouteTableId", cdk.requiredValidator)(properties.localGatewayRouteTableId));
  errors.collect(cdk.propertyValidator("localGatewayRouteTableId", cdk.validateString)(properties.localGatewayRouteTableId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("vpcId", cdk.requiredValidator)(properties.vpcId));
  errors.collect(cdk.propertyValidator("vpcId", cdk.validateString)(properties.vpcId));
  return errors.wrap("supplied properties not correct for \"CfnLocalGatewayRouteTableVPCAssociationProps\"");
}

// @ts-ignore TS6133
function convertCfnLocalGatewayRouteTableVPCAssociationPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLocalGatewayRouteTableVPCAssociationPropsValidator(properties).assertSuccess();
  return {
    "LocalGatewayRouteTableId": cdk.stringToCloudFormation(properties.localGatewayRouteTableId),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "VpcId": cdk.stringToCloudFormation(properties.vpcId)
  };
}

// @ts-ignore TS6133
function CfnLocalGatewayRouteTableVPCAssociationPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnLocalGatewayRouteTableVPCAssociationProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLocalGatewayRouteTableVPCAssociationProps>();
  ret.addPropertyResult("localGatewayRouteTableId", "LocalGatewayRouteTableId", (properties.LocalGatewayRouteTableId != null ? cfn_parse.FromCloudFormation.getString(properties.LocalGatewayRouteTableId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("vpcId", "VpcId", (properties.VpcId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Describes an association between a local gateway route table and a virtual interface group.
 *
 * @cloudformationResource AWS::EC2::LocalGatewayRouteTableVirtualInterfaceGroupAssociation
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetablevirtualinterfacegroupassociation.html
 */
export class CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociation extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::LocalGatewayRouteTableVirtualInterfaceGroupAssociation";

  /**
   * Build a CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociation from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociation {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociation(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the local gateway.
   *
   * @cloudformationAttribute LocalGatewayId
   */
  public readonly attrLocalGatewayId: string;

  /**
   * The Amazon Resource Name (ARN) of the local gateway route table for the virtual interface group.
   *
   * @cloudformationAttribute LocalGatewayRouteTableArn
   */
  public readonly attrLocalGatewayRouteTableArn: string;

  /**
   * The ID of the association.
   *
   * @cloudformationAttribute LocalGatewayRouteTableVirtualInterfaceGroupAssociationId
   */
  public readonly attrLocalGatewayRouteTableVirtualInterfaceGroupAssociationId: string;

  /**
   * The ID of the AWS account that owns the local gateway virtual interface group association.
   *
   * @cloudformationAttribute OwnerId
   */
  public readonly attrOwnerId: string;

  /**
   * The state of the association.
   *
   * @cloudformationAttribute State
   */
  public readonly attrState: string;

  /**
   * The ID of the local gateway route table.
   */
  public localGatewayRouteTableId: string;

  /**
   * The ID of the virtual interface group.
   */
  public localGatewayVirtualInterfaceGroupId: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags assigned to the association.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationProps) {
    super(scope, id, {
      "type": CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociation.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "localGatewayRouteTableId", this);
    cdk.requireProperty(props, "localGatewayVirtualInterfaceGroupId", this);

    this.attrLocalGatewayId = cdk.Token.asString(this.getAtt("LocalGatewayId", cdk.ResolutionTypeHint.STRING));
    this.attrLocalGatewayRouteTableArn = cdk.Token.asString(this.getAtt("LocalGatewayRouteTableArn", cdk.ResolutionTypeHint.STRING));
    this.attrLocalGatewayRouteTableVirtualInterfaceGroupAssociationId = cdk.Token.asString(this.getAtt("LocalGatewayRouteTableVirtualInterfaceGroupAssociationId", cdk.ResolutionTypeHint.STRING));
    this.attrOwnerId = cdk.Token.asString(this.getAtt("OwnerId", cdk.ResolutionTypeHint.STRING));
    this.attrState = cdk.Token.asString(this.getAtt("State", cdk.ResolutionTypeHint.STRING));
    this.localGatewayRouteTableId = props.localGatewayRouteTableId;
    this.localGatewayVirtualInterfaceGroupId = props.localGatewayVirtualInterfaceGroupId;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::LocalGatewayRouteTableVirtualInterfaceGroupAssociation", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "localGatewayRouteTableId": this.localGatewayRouteTableId,
      "localGatewayVirtualInterfaceGroupId": this.localGatewayVirtualInterfaceGroupId,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociation.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a `CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociation`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetablevirtualinterfacegroupassociation.html
 */
export interface CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationProps {
  /**
   * The ID of the local gateway route table.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetablevirtualinterfacegroupassociation.html#cfn-ec2-localgatewayroutetablevirtualinterfacegroupassociation-localgatewayroutetableid
   */
  readonly localGatewayRouteTableId: string;

  /**
   * The ID of the virtual interface group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetablevirtualinterfacegroupassociation.html#cfn-ec2-localgatewayroutetablevirtualinterfacegroupassociation-localgatewayvirtualinterfacegroupid
   */
  readonly localGatewayVirtualInterfaceGroupId: string;

  /**
   * The tags assigned to the association.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetablevirtualinterfacegroupassociation.html#cfn-ec2-localgatewayroutetablevirtualinterfacegroupassociation-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a `CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationProps`
 *
 * @param properties - the TypeScript properties of a `CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("localGatewayRouteTableId", cdk.requiredValidator)(properties.localGatewayRouteTableId));
  errors.collect(cdk.propertyValidator("localGatewayRouteTableId", cdk.validateString)(properties.localGatewayRouteTableId));
  errors.collect(cdk.propertyValidator("localGatewayVirtualInterfaceGroupId", cdk.requiredValidator)(properties.localGatewayVirtualInterfaceGroupId));
  errors.collect(cdk.propertyValidator("localGatewayVirtualInterfaceGroupId", cdk.validateString)(properties.localGatewayVirtualInterfaceGroupId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \"CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationProps\"");
}

// @ts-ignore TS6133
function convertCfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationPropsValidator(properties).assertSuccess();
  return {
    "LocalGatewayRouteTableId": cdk.stringToCloudFormation(properties.localGatewayRouteTableId),
    "LocalGatewayVirtualInterfaceGroupId": cdk.stringToCloudFormation(properties.localGatewayVirtualInterfaceGroupId),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationProps>();
  ret.addPropertyResult("localGatewayRouteTableId", "LocalGatewayRouteTableId", (properties.LocalGatewayRouteTableId != null ? cfn_parse.FromCloudFormation.getString(properties.LocalGatewayRouteTableId) : undefined));
  ret.addPropertyResult("localGatewayVirtualInterfaceGroupId", "LocalGatewayVirtualInterfaceGroupId", (properties.LocalGatewayVirtualInterfaceGroupId != null ? cfn_parse.FromCloudFormation.getString(properties.LocalGatewayVirtualInterfaceGroupId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a network address translation (NAT) gateway in the specified subnet.
 *
 * You can create either a public NAT gateway or a private NAT gateway. The default is a public NAT gateway. If you create a public NAT gateway, you must specify an elastic IP address.
 *
 * With a NAT gateway, instances in a private subnet can connect to the internet, other AWS services, or an on-premises network using the IP address of the NAT gateway. For more information, see [NAT gateways](https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html) in the *Amazon VPC User Guide* .
 *
 * If you add a default route ( `AWS::EC2::Route` resource) that points to a NAT gateway, specify the NAT gateway ID for the route's `NatGatewayId` property.
 *
 * > When you associate an Elastic IP address or secondary Elastic IP address with a public NAT gateway, the network border group of the Elastic IP address must match the network border group of the Availability Zone (AZ) that the public NAT gateway is in. Otherwise, the NAT gateway fails to launch. You can see the network border group for the AZ by viewing the details of the subnet. Similarly, you can view the network border group for the Elastic IP address by viewing its details. For more information, see [Allocate an Elastic IP address](https://docs.aws.amazon.com/vpc/latest/userguide/vpc-eips.html#allocate-eip) in the *Amazon VPC User Guide* .
 *
 * @cloudformationResource AWS::EC2::NatGateway
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html
 */
export class CfnNatGateway extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::NatGateway";

  /**
   * Build a CfnNatGateway from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnNatGateway {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnNatGatewayPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnNatGateway(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the NAT gateway.
   *
   * @cloudformationAttribute NatGatewayId
   */
  public readonly attrNatGatewayId: string;

  /**
   * [Public NAT gateway only] The allocation ID of the Elastic IP address that's associated with the NAT gateway.
   */
  public allocationId?: string;

  /**
   * Indicates whether the NAT gateway supports public or private connectivity.
   */
  public connectivityType?: string;

  /**
   * The maximum amount of time to wait (in seconds) before forcibly releasing the IP addresses if connections are still in progress.
   */
  public maxDrainDurationSeconds?: number;

  /**
   * The private IPv4 address to assign to the NAT gateway.
   */
  public privateIpAddress?: string;

  /**
   * Secondary EIP allocation IDs.
   */
  public secondaryAllocationIds?: Array<string>;

  /**
   * [Private NAT gateway only] The number of secondary private IPv4 addresses you want to assign to the NAT gateway.
   */
  public secondaryPrivateIpAddressCount?: number;

  /**
   * Secondary private IPv4 addresses.
   */
  public secondaryPrivateIpAddresses?: Array<string>;

  /**
   * The ID of the subnet in which the NAT gateway is located.
   */
  public subnetId: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags for the NAT gateway.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnNatGatewayProps) {
    super(scope, id, {
      "type": CfnNatGateway.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "subnetId", this);

    this.attrNatGatewayId = cdk.Token.asString(this.getAtt("NatGatewayId", cdk.ResolutionTypeHint.STRING));
    this.allocationId = props.allocationId;
    this.connectivityType = props.connectivityType;
    this.maxDrainDurationSeconds = props.maxDrainDurationSeconds;
    this.privateIpAddress = props.privateIpAddress;
    this.secondaryAllocationIds = props.secondaryAllocationIds;
    this.secondaryPrivateIpAddressCount = props.secondaryPrivateIpAddressCount;
    this.secondaryPrivateIpAddresses = props.secondaryPrivateIpAddresses;
    this.subnetId = props.subnetId;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::NatGateway", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "allocationId": this.allocationId,
      "connectivityType": this.connectivityType,
      "maxDrainDurationSeconds": this.maxDrainDurationSeconds,
      "privateIpAddress": this.privateIpAddress,
      "secondaryAllocationIds": this.secondaryAllocationIds,
      "secondaryPrivateIpAddressCount": this.secondaryPrivateIpAddressCount,
      "secondaryPrivateIpAddresses": this.secondaryPrivateIpAddresses,
      "subnetId": this.subnetId,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnNatGateway.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnNatGatewayPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a `CfnNatGateway`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html
 */
export interface CfnNatGatewayProps {
  /**
   * [Public NAT gateway only] The allocation ID of the Elastic IP address that's associated with the NAT gateway.
   *
   * This property is required for a public NAT gateway and cannot be specified with a private NAT gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html#cfn-ec2-natgateway-allocationid
   */
  readonly allocationId?: string;

  /**
   * Indicates whether the NAT gateway supports public or private connectivity.
   *
   * The default is public connectivity.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html#cfn-ec2-natgateway-connectivitytype
   */
  readonly connectivityType?: string;

  /**
   * The maximum amount of time to wait (in seconds) before forcibly releasing the IP addresses if connections are still in progress.
   *
   * Default value is 350 seconds.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html#cfn-ec2-natgateway-maxdraindurationseconds
   */
  readonly maxDrainDurationSeconds?: number;

  /**
   * The private IPv4 address to assign to the NAT gateway.
   *
   * If you don't provide an address, a private IPv4 address will be automatically assigned.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html#cfn-ec2-natgateway-privateipaddress
   */
  readonly privateIpAddress?: string;

  /**
   * Secondary EIP allocation IDs.
   *
   * For more information, see [Create a NAT gateway](https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html#nat-gateway-creating) in the *Amazon VPC User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html#cfn-ec2-natgateway-secondaryallocationids
   */
  readonly secondaryAllocationIds?: Array<string>;

  /**
   * [Private NAT gateway only] The number of secondary private IPv4 addresses you want to assign to the NAT gateway.
   *
   * For more information about secondary addresses, see [Create a NAT gateway](https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html#nat-gateway-creating) in the *Amazon Virtual Private Cloud User Guide* .
   *
   * `SecondaryPrivateIpAddressCount` and `SecondaryPrivateIpAddresses` cannot be set at the same time.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html#cfn-ec2-natgateway-secondaryprivateipaddresscount
   */
  readonly secondaryPrivateIpAddressCount?: number;

  /**
   * Secondary private IPv4 addresses.
   *
   * For more information about secondary addresses, see [Create a NAT gateway](https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html#nat-gateway-creating) in the *Amazon Virtual Private Cloud User Guide* .
   *
   * `SecondaryPrivateIpAddressCount` and `SecondaryPrivateIpAddresses` cannot be set at the same time.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html#cfn-ec2-natgateway-secondaryprivateipaddresses
   */
  readonly secondaryPrivateIpAddresses?: Array<string>;

  /**
   * The ID of the subnet in which the NAT gateway is located.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html#cfn-ec2-natgateway-subnetid
   */
  readonly subnetId: string;

  /**
   * The tags for the NAT gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html#cfn-ec2-natgateway-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a `CfnNatGatewayProps`
 *
 * @param properties - the TypeScript properties of a `CfnNatGatewayProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNatGatewayPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("allocationId", cdk.validateString)(properties.allocationId));
  errors.collect(cdk.propertyValidator("connectivityType", cdk.validateString)(properties.connectivityType));
  errors.collect(cdk.propertyValidator("maxDrainDurationSeconds", cdk.validateNumber)(properties.maxDrainDurationSeconds));
  errors.collect(cdk.propertyValidator("privateIpAddress", cdk.validateString)(properties.privateIpAddress));
  errors.collect(cdk.propertyValidator("secondaryAllocationIds", cdk.listValidator(cdk.validateString))(properties.secondaryAllocationIds));
  errors.collect(cdk.propertyValidator("secondaryPrivateIpAddressCount", cdk.validateNumber)(properties.secondaryPrivateIpAddressCount));
  errors.collect(cdk.propertyValidator("secondaryPrivateIpAddresses", cdk.listValidator(cdk.validateString))(properties.secondaryPrivateIpAddresses));
  errors.collect(cdk.propertyValidator("subnetId", cdk.requiredValidator)(properties.subnetId));
  errors.collect(cdk.propertyValidator("subnetId", cdk.validateString)(properties.subnetId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \"CfnNatGatewayProps\"");
}

// @ts-ignore TS6133
function convertCfnNatGatewayPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNatGatewayPropsValidator(properties).assertSuccess();
  return {
    "AllocationId": cdk.stringToCloudFormation(properties.allocationId),
    "ConnectivityType": cdk.stringToCloudFormation(properties.connectivityType),
    "MaxDrainDurationSeconds": cdk.numberToCloudFormation(properties.maxDrainDurationSeconds),
    "PrivateIpAddress": cdk.stringToCloudFormation(properties.privateIpAddress),
    "SecondaryAllocationIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.secondaryAllocationIds),
    "SecondaryPrivateIpAddressCount": cdk.numberToCloudFormation(properties.secondaryPrivateIpAddressCount),
    "SecondaryPrivateIpAddresses": cdk.listMapper(cdk.stringToCloudFormation)(properties.secondaryPrivateIpAddresses),
    "SubnetId": cdk.stringToCloudFormation(properties.subnetId),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnNatGatewayPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNatGatewayProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNatGatewayProps>();
  ret.addPropertyResult("allocationId", "AllocationId", (properties.AllocationId != null ? cfn_parse.FromCloudFormation.getString(properties.AllocationId) : undefined));
  ret.addPropertyResult("connectivityType", "ConnectivityType", (properties.ConnectivityType != null ? cfn_parse.FromCloudFormation.getString(properties.ConnectivityType) : undefined));
  ret.addPropertyResult("maxDrainDurationSeconds", "MaxDrainDurationSeconds", (properties.MaxDrainDurationSeconds != null ? cfn_parse.FromCloudFormation.getNumber(properties.MaxDrainDurationSeconds) : undefined));
  ret.addPropertyResult("privateIpAddress", "PrivateIpAddress", (properties.PrivateIpAddress != null ? cfn_parse.FromCloudFormation.getString(properties.PrivateIpAddress) : undefined));
  ret.addPropertyResult("secondaryAllocationIds", "SecondaryAllocationIds", (properties.SecondaryAllocationIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecondaryAllocationIds) : undefined));
  ret.addPropertyResult("secondaryPrivateIpAddressCount", "SecondaryPrivateIpAddressCount", (properties.SecondaryPrivateIpAddressCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.SecondaryPrivateIpAddressCount) : undefined));
  ret.addPropertyResult("secondaryPrivateIpAddresses", "SecondaryPrivateIpAddresses", (properties.SecondaryPrivateIpAddresses != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecondaryPrivateIpAddresses) : undefined));
  ret.addPropertyResult("subnetId", "SubnetId", (properties.SubnetId != null ? cfn_parse.FromCloudFormation.getString(properties.SubnetId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a network ACL for your VPC.
 *
 * @cloudformationResource AWS::EC2::NetworkAcl
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkacl.html
 */
export class CfnNetworkAcl extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::NetworkAcl";

  /**
   * Build a CfnNetworkAcl from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnNetworkAcl {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnNetworkAclPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnNetworkAcl(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the network ACL.
   *
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags for the network ACL.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The ID of the VPC for the network ACL.
   */
  public vpcId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnNetworkAclProps) {
    super(scope, id, {
      "type": CfnNetworkAcl.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "vpcId", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::NetworkAcl", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.vpcId = props.vpcId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "tags": this.tags.renderTags(),
      "vpcId": this.vpcId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnNetworkAcl.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnNetworkAclPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a `CfnNetworkAcl`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkacl.html
 */
export interface CfnNetworkAclProps {
  /**
   * The tags for the network ACL.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkacl.html#cfn-ec2-networkacl-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The ID of the VPC for the network ACL.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkacl.html#cfn-ec2-networkacl-vpcid
   */
  readonly vpcId: string;
}

/**
 * Determine whether the given properties match those of a `CfnNetworkAclProps`
 *
 * @param properties - the TypeScript properties of a `CfnNetworkAclProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkAclPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("vpcId", cdk.requiredValidator)(properties.vpcId));
  errors.collect(cdk.propertyValidator("vpcId", cdk.validateString)(properties.vpcId));
  return errors.wrap("supplied properties not correct for \"CfnNetworkAclProps\"");
}

// @ts-ignore TS6133
function convertCfnNetworkAclPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkAclPropsValidator(properties).assertSuccess();
  return {
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "VpcId": cdk.stringToCloudFormation(properties.vpcId)
  };
}

// @ts-ignore TS6133
function CfnNetworkAclPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNetworkAclProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkAclProps>();
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("vpcId", "VpcId", (properties.VpcId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies an entry, known as a rule, in a network ACL with a rule number you specify.
 *
 * Each network ACL has a set of numbered ingress rules and a separate set of numbered egress rules.
 *
 * For information about the protocol value, see [Protocol Numbers](https://docs.aws.amazon.com/https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml) on the Internet Assigned Numbers Authority (IANA) website.
 *
 * @cloudformationResource AWS::EC2::NetworkAclEntry
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html
 */
export class CfnNetworkAclEntry extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::NetworkAclEntry";

  /**
   * Build a CfnNetworkAclEntry from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnNetworkAclEntry {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnNetworkAclEntryPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnNetworkAclEntry(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the network ACL entry.
   *
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The IPv4 CIDR range to allow or deny, in CIDR notation (for example, 172.16.0.0/24). Requirement is conditional: You must specify the `CidrBlock` or `Ipv6CidrBlock` property.
   */
  public cidrBlock?: string;

  /**
   * Whether this rule applies to egress traffic from the subnet ( `true` ) or ingress traffic to the subnet ( `false` ).
   */
  public egress?: boolean | cdk.IResolvable;

  /**
   * The Internet Control Message Protocol (ICMP) code and type.
   */
  public icmp?: CfnNetworkAclEntry.IcmpProperty | cdk.IResolvable;

  /**
   * The IPv6 network range to allow or deny, in CIDR notation.
   */
  public ipv6CidrBlock?: string;

  /**
   * The ID of the ACL for the entry.
   */
  public networkAclId: string;

  /**
   * The range of port numbers for the UDP/TCP protocol.
   */
  public portRange?: cdk.IResolvable | CfnNetworkAclEntry.PortRangeProperty;

  /**
   * The IP protocol that the rule applies to.
   */
  public protocol: number;

  /**
   * Whether to allow or deny traffic that matches the rule;
   */
  public ruleAction: string;

  /**
   * Rule number to assign to the entry, such as 100.
   */
  public ruleNumber: number;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnNetworkAclEntryProps) {
    super(scope, id, {
      "type": CfnNetworkAclEntry.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "networkAclId", this);
    cdk.requireProperty(props, "protocol", this);
    cdk.requireProperty(props, "ruleAction", this);
    cdk.requireProperty(props, "ruleNumber", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.cidrBlock = props.cidrBlock;
    this.egress = props.egress;
    this.icmp = props.icmp;
    this.ipv6CidrBlock = props.ipv6CidrBlock;
    this.networkAclId = props.networkAclId;
    this.portRange = props.portRange;
    this.protocol = props.protocol;
    this.ruleAction = props.ruleAction;
    this.ruleNumber = props.ruleNumber;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "cidrBlock": this.cidrBlock,
      "egress": this.egress,
      "icmp": this.icmp,
      "ipv6CidrBlock": this.ipv6CidrBlock,
      "networkAclId": this.networkAclId,
      "portRange": this.portRange,
      "protocol": this.protocol,
      "ruleAction": this.ruleAction,
      "ruleNumber": this.ruleNumber
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnNetworkAclEntry.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnNetworkAclEntryPropsToCloudFormation(props);
  }
}

export namespace CfnNetworkAclEntry {
  /**
   * Describes the ICMP type and code.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkaclentry-icmp.html
   */
  export interface IcmpProperty {
    /**
     * The Internet Control Message Protocol (ICMP) code.
     *
     * You can use -1 to specify all ICMP codes for the given ICMP type. Requirement is conditional: Required if you specify 1 (ICMP) for the protocol parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkaclentry-icmp.html#cfn-ec2-networkaclentry-icmp-code
     */
    readonly code?: number;

    /**
     * The Internet Control Message Protocol (ICMP) type.
     *
     * You can use -1 to specify all ICMP types. Conditional requirement: Required if you specify 1 (ICMP) for the `CreateNetworkAclEntry` protocol parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkaclentry-icmp.html#cfn-ec2-networkaclentry-icmp-type
     */
    readonly type?: number;
  }

  /**
   * Describes a range of ports.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkaclentry-portrange.html
   */
  export interface PortRangeProperty {
    /**
     * The first port in the range.
     *
     * Required if you specify 6 (TCP) or 17 (UDP) for the protocol parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkaclentry-portrange.html#cfn-ec2-networkaclentry-portrange-from
     */
    readonly from?: number;

    /**
     * The last port in the range.
     *
     * Required if you specify 6 (TCP) or 17 (UDP) for the protocol parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkaclentry-portrange.html#cfn-ec2-networkaclentry-portrange-to
     */
    readonly to?: number;
  }
}

/**
 * Properties for defining a `CfnNetworkAclEntry`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html
 */
export interface CfnNetworkAclEntryProps {
  /**
   * The IPv4 CIDR range to allow or deny, in CIDR notation (for example, 172.16.0.0/24). Requirement is conditional: You must specify the `CidrBlock` or `Ipv6CidrBlock` property.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-cidrblock
   */
  readonly cidrBlock?: string;

  /**
   * Whether this rule applies to egress traffic from the subnet ( `true` ) or ingress traffic to the subnet ( `false` ).
   *
   * By default, AWS CloudFormation specifies `false` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-egress
   */
  readonly egress?: boolean | cdk.IResolvable;

  /**
   * The Internet Control Message Protocol (ICMP) code and type.
   *
   * Requirement is conditional: Required if specifying 1 (ICMP) for the protocol parameter.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-icmp
   */
  readonly icmp?: CfnNetworkAclEntry.IcmpProperty | cdk.IResolvable;

  /**
   * The IPv6 network range to allow or deny, in CIDR notation.
   *
   * Requirement is conditional: You must specify the `CidrBlock` or `Ipv6CidrBlock` property.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-ipv6cidrblock
   */
  readonly ipv6CidrBlock?: string;

  /**
   * The ID of the ACL for the entry.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-networkaclid
   */
  readonly networkAclId: string;

  /**
   * The range of port numbers for the UDP/TCP protocol.
   *
   * Conditional required if specifying 6 (TCP) or 17 (UDP) for the protocol parameter.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-portrange
   */
  readonly portRange?: cdk.IResolvable | CfnNetworkAclEntry.PortRangeProperty;

  /**
   * The IP protocol that the rule applies to.
   *
   * You must specify -1 or a protocol number. You can specify -1 for all protocols.
   *
   * > If you specify -1, all ports are opened and the `PortRange` property is ignored.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-protocol
   */
  readonly protocol: number;

  /**
   * Whether to allow or deny traffic that matches the rule;
   *
   * valid values are "allow" or "deny".
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-ruleaction
   */
  readonly ruleAction: string;

  /**
   * Rule number to assign to the entry, such as 100.
   *
   * ACL entries are processed in ascending order by rule number. Entries can't use the same rule number unless one is an egress rule and the other is an ingress rule.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-rulenumber
   */
  readonly ruleNumber: number;
}

/**
 * Determine whether the given properties match those of a `IcmpProperty`
 *
 * @param properties - the TypeScript properties of a `IcmpProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkAclEntryIcmpPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("code", cdk.validateNumber)(properties.code));
  errors.collect(cdk.propertyValidator("type", cdk.validateNumber)(properties.type));
  return errors.wrap("supplied properties not correct for \"IcmpProperty\"");
}

// @ts-ignore TS6133
function convertCfnNetworkAclEntryIcmpPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkAclEntryIcmpPropertyValidator(properties).assertSuccess();
  return {
    "Code": cdk.numberToCloudFormation(properties.code),
    "Type": cdk.numberToCloudFormation(properties.type)
  };
}

// @ts-ignore TS6133
function CfnNetworkAclEntryIcmpPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNetworkAclEntry.IcmpProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkAclEntry.IcmpProperty>();
  ret.addPropertyResult("code", "Code", (properties.Code != null ? cfn_parse.FromCloudFormation.getNumber(properties.Code) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getNumber(properties.Type) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `PortRangeProperty`
 *
 * @param properties - the TypeScript properties of a `PortRangeProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkAclEntryPortRangePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("from", cdk.validateNumber)(properties.from));
  errors.collect(cdk.propertyValidator("to", cdk.validateNumber)(properties.to));
  return errors.wrap("supplied properties not correct for \"PortRangeProperty\"");
}

// @ts-ignore TS6133
function convertCfnNetworkAclEntryPortRangePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkAclEntryPortRangePropertyValidator(properties).assertSuccess();
  return {
    "From": cdk.numberToCloudFormation(properties.from),
    "To": cdk.numberToCloudFormation(properties.to)
  };
}

// @ts-ignore TS6133
function CfnNetworkAclEntryPortRangePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnNetworkAclEntry.PortRangeProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkAclEntry.PortRangeProperty>();
  ret.addPropertyResult("from", "From", (properties.From != null ? cfn_parse.FromCloudFormation.getNumber(properties.From) : undefined));
  ret.addPropertyResult("to", "To", (properties.To != null ? cfn_parse.FromCloudFormation.getNumber(properties.To) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `CfnNetworkAclEntryProps`
 *
 * @param properties - the TypeScript properties of a `CfnNetworkAclEntryProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkAclEntryPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("cidrBlock", cdk.validateString)(properties.cidrBlock));
  errors.collect(cdk.propertyValidator("egress", cdk.validateBoolean)(properties.egress));
  errors.collect(cdk.propertyValidator("icmp", CfnNetworkAclEntryIcmpPropertyValidator)(properties.icmp));
  errors.collect(cdk.propertyValidator("ipv6CidrBlock", cdk.validateString)(properties.ipv6CidrBlock));
  errors.collect(cdk.propertyValidator("networkAclId", cdk.requiredValidator)(properties.networkAclId));
  errors.collect(cdk.propertyValidator("networkAclId", cdk.validateString)(properties.networkAclId));
  errors.collect(cdk.propertyValidator("portRange", CfnNetworkAclEntryPortRangePropertyValidator)(properties.portRange));
  errors.collect(cdk.propertyValidator("protocol", cdk.requiredValidator)(properties.protocol));
  errors.collect(cdk.propertyValidator("protocol", cdk.validateNumber)(properties.protocol));
  errors.collect(cdk.propertyValidator("ruleAction", cdk.requiredValidator)(properties.ruleAction));
  errors.collect(cdk.propertyValidator("ruleAction", cdk.validateString)(properties.ruleAction));
  errors.collect(cdk.propertyValidator("ruleNumber", cdk.requiredValidator)(properties.ruleNumber));
  errors.collect(cdk.propertyValidator("ruleNumber", cdk.validateNumber)(properties.ruleNumber));
  return errors.wrap("supplied properties not correct for \"CfnNetworkAclEntryProps\"");
}

// @ts-ignore TS6133
function convertCfnNetworkAclEntryPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkAclEntryPropsValidator(properties).assertSuccess();
  return {
    "CidrBlock": cdk.stringToCloudFormation(properties.cidrBlock),
    "Egress": cdk.booleanToCloudFormation(properties.egress),
    "Icmp": convertCfnNetworkAclEntryIcmpPropertyToCloudFormation(properties.icmp),
    "Ipv6CidrBlock": cdk.stringToCloudFormation(properties.ipv6CidrBlock),
    "NetworkAclId": cdk.stringToCloudFormation(properties.networkAclId),
    "PortRange": convertCfnNetworkAclEntryPortRangePropertyToCloudFormation(properties.portRange),
    "Protocol": cdk.numberToCloudFormation(properties.protocol),
    "RuleAction": cdk.stringToCloudFormation(properties.ruleAction),
    "RuleNumber": cdk.numberToCloudFormation(properties.ruleNumber)
  };
}

// @ts-ignore TS6133
function CfnNetworkAclEntryPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNetworkAclEntryProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkAclEntryProps>();
  ret.addPropertyResult("cidrBlock", "CidrBlock", (properties.CidrBlock != null ? cfn_parse.FromCloudFormation.getString(properties.CidrBlock) : undefined));
  ret.addPropertyResult("egress", "Egress", (properties.Egress != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Egress) : undefined));
  ret.addPropertyResult("icmp", "Icmp", (properties.Icmp != null ? CfnNetworkAclEntryIcmpPropertyFromCloudFormation(properties.Icmp) : undefined));
  ret.addPropertyResult("ipv6CidrBlock", "Ipv6CidrBlock", (properties.Ipv6CidrBlock != null ? cfn_parse.FromCloudFormation.getString(properties.Ipv6CidrBlock) : undefined));
  ret.addPropertyResult("networkAclId", "NetworkAclId", (properties.NetworkAclId != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkAclId) : undefined));
  ret.addPropertyResult("portRange", "PortRange", (properties.PortRange != null ? CfnNetworkAclEntryPortRangePropertyFromCloudFormation(properties.PortRange) : undefined));
  ret.addPropertyResult("protocol", "Protocol", (properties.Protocol != null ? cfn_parse.FromCloudFormation.getNumber(properties.Protocol) : undefined));
  ret.addPropertyResult("ruleAction", "RuleAction", (properties.RuleAction != null ? cfn_parse.FromCloudFormation.getString(properties.RuleAction) : undefined));
  ret.addPropertyResult("ruleNumber", "RuleNumber", (properties.RuleNumber != null ? cfn_parse.FromCloudFormation.getNumber(properties.RuleNumber) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Describes a Network Access Scope.
 *
 * A Network Access Scope defines outbound (egress) and inbound (ingress) traffic patterns, including sources, destinations, paths, and traffic types.
 *
 * Network Access Analyzer identifies unintended network access to your resources on AWS . When you start an analysis on a Network Access Scope, Network Access Analyzer produces findings. For more information, see the [Network Access Analyzer User Guide](https://docs.aws.amazon.com/vpc/latest/network-access-analyzer/) .
 *
 * @cloudformationResource AWS::EC2::NetworkInsightsAccessScope
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsaccessscope.html
 */
export class CfnNetworkInsightsAccessScope extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::NetworkInsightsAccessScope";

  /**
   * Build a CfnNetworkInsightsAccessScope from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnNetworkInsightsAccessScope {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnNetworkInsightsAccessScopePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnNetworkInsightsAccessScope(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The creation date.
   *
   * @cloudformationAttribute CreatedDate
   */
  public readonly attrCreatedDate: string;

  /**
   * The ARN of the Network Access Scope.
   *
   * @cloudformationAttribute NetworkInsightsAccessScopeArn
   */
  public readonly attrNetworkInsightsAccessScopeArn: string;

  /**
   * The ID of the Network Access Scope.
   *
   * @cloudformationAttribute NetworkInsightsAccessScopeId
   */
  public readonly attrNetworkInsightsAccessScopeId: string;

  /**
   * The last updated date.
   *
   * @cloudformationAttribute UpdatedDate
   */
  public readonly attrUpdatedDate: string;

  /**
   * The paths to exclude.
   */
  public excludePaths?: Array<CfnNetworkInsightsAccessScope.AccessScopePathRequestProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * The paths to match.
   */
  public matchPaths?: Array<CfnNetworkInsightsAccessScope.AccessScopePathRequestProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnNetworkInsightsAccessScopeProps = {}) {
    super(scope, id, {
      "type": CfnNetworkInsightsAccessScope.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.attrCreatedDate = cdk.Token.asString(this.getAtt("CreatedDate", cdk.ResolutionTypeHint.STRING));
    this.attrNetworkInsightsAccessScopeArn = cdk.Token.asString(this.getAtt("NetworkInsightsAccessScopeArn", cdk.ResolutionTypeHint.STRING));
    this.attrNetworkInsightsAccessScopeId = cdk.Token.asString(this.getAtt("NetworkInsightsAccessScopeId", cdk.ResolutionTypeHint.STRING));
    this.attrUpdatedDate = cdk.Token.asString(this.getAtt("UpdatedDate", cdk.ResolutionTypeHint.STRING));
    this.excludePaths = props.excludePaths;
    this.matchPaths = props.matchPaths;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::NetworkInsightsAccessScope", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "excludePaths": this.excludePaths,
      "matchPaths": this.matchPaths,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnNetworkInsightsAccessScope.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnNetworkInsightsAccessScopePropsToCloudFormation(props);
  }
}

export namespace CfnNetworkInsightsAccessScope {
  /**
   * Describes a path.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-accessscopepathrequest.html
   */
  export interface AccessScopePathRequestProperty {
    /**
     * The destination.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-accessscopepathrequest.html#cfn-ec2-networkinsightsaccessscope-accessscopepathrequest-destination
     */
    readonly destination?: cdk.IResolvable | CfnNetworkInsightsAccessScope.PathStatementRequestProperty;

    /**
     * The source.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-accessscopepathrequest.html#cfn-ec2-networkinsightsaccessscope-accessscopepathrequest-source
     */
    readonly source?: cdk.IResolvable | CfnNetworkInsightsAccessScope.PathStatementRequestProperty;

    /**
     * The through resources.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-accessscopepathrequest.html#cfn-ec2-networkinsightsaccessscope-accessscopepathrequest-throughresources
     */
    readonly throughResources?: Array<cdk.IResolvable | CfnNetworkInsightsAccessScope.ThroughResourcesStatementRequestProperty> | cdk.IResolvable;
  }

  /**
   * Describes a path statement.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-pathstatementrequest.html
   */
  export interface PathStatementRequestProperty {
    /**
     * The packet header statement.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-pathstatementrequest.html#cfn-ec2-networkinsightsaccessscope-pathstatementrequest-packetheaderstatement
     */
    readonly packetHeaderStatement?: cdk.IResolvable | CfnNetworkInsightsAccessScope.PacketHeaderStatementRequestProperty;

    /**
     * The resource statement.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-pathstatementrequest.html#cfn-ec2-networkinsightsaccessscope-pathstatementrequest-resourcestatement
     */
    readonly resourceStatement?: cdk.IResolvable | CfnNetworkInsightsAccessScope.ResourceStatementRequestProperty;
  }

  /**
   * Describes a resource statement.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-resourcestatementrequest.html
   */
  export interface ResourceStatementRequestProperty {
    /**
     * The resources.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-resourcestatementrequest.html#cfn-ec2-networkinsightsaccessscope-resourcestatementrequest-resources
     */
    readonly resources?: Array<string>;

    /**
     * The resource types.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-resourcestatementrequest.html#cfn-ec2-networkinsightsaccessscope-resourcestatementrequest-resourcetypes
     */
    readonly resourceTypes?: Array<string>;
  }

  /**
   * Describes a packet header statement.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-packetheaderstatementrequest.html
   */
  export interface PacketHeaderStatementRequestProperty {
    /**
     * The destination addresses.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-packetheaderstatementrequest.html#cfn-ec2-networkinsightsaccessscope-packetheaderstatementrequest-destinationaddresses
     */
    readonly destinationAddresses?: Array<string>;

    /**
     * The destination ports.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-packetheaderstatementrequest.html#cfn-ec2-networkinsightsaccessscope-packetheaderstatementrequest-destinationports
     */
    readonly destinationPorts?: Array<string>;

    /**
     * The destination prefix lists.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-packetheaderstatementrequest.html#cfn-ec2-networkinsightsaccessscope-packetheaderstatementrequest-destinationprefixlists
     */
    readonly destinationPrefixLists?: Array<string>;

    /**
     * The protocols.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-packetheaderstatementrequest.html#cfn-ec2-networkinsightsaccessscope-packetheaderstatementrequest-protocols
     */
    readonly protocols?: Array<string>;

    /**
     * The source addresses.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-packetheaderstatementrequest.html#cfn-ec2-networkinsightsaccessscope-packetheaderstatementrequest-sourceaddresses
     */
    readonly sourceAddresses?: Array<string>;

    /**
     * The source ports.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-packetheaderstatementrequest.html#cfn-ec2-networkinsightsaccessscope-packetheaderstatementrequest-sourceports
     */
    readonly sourcePorts?: Array<string>;

    /**
     * The source prefix lists.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-packetheaderstatementrequest.html#cfn-ec2-networkinsightsaccessscope-packetheaderstatementrequest-sourceprefixlists
     */
    readonly sourcePrefixLists?: Array<string>;
  }

  /**
   * Describes a through resource statement.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-throughresourcesstatementrequest.html
   */
  export interface ThroughResourcesStatementRequestProperty {
    /**
     * The resource statement.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-throughresourcesstatementrequest.html#cfn-ec2-networkinsightsaccessscope-throughresourcesstatementrequest-resourcestatement
     */
    readonly resourceStatement?: cdk.IResolvable | CfnNetworkInsightsAccessScope.ResourceStatementRequestProperty;
  }
}

/**
 * Properties for defining a `CfnNetworkInsightsAccessScope`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsaccessscope.html
 */
export interface CfnNetworkInsightsAccessScopeProps {
  /**
   * The paths to exclude.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsaccessscope.html#cfn-ec2-networkinsightsaccessscope-excludepaths
   */
  readonly excludePaths?: Array<CfnNetworkInsightsAccessScope.AccessScopePathRequestProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * The paths to match.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsaccessscope.html#cfn-ec2-networkinsightsaccessscope-matchpaths
   */
  readonly matchPaths?: Array<CfnNetworkInsightsAccessScope.AccessScopePathRequestProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * The tags.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsaccessscope.html#cfn-ec2-networkinsightsaccessscope-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a `ResourceStatementRequestProperty`
 *
 * @param properties - the TypeScript properties of a `ResourceStatementRequestProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInsightsAccessScopeResourceStatementRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("resourceTypes", cdk.listValidator(cdk.validateString))(properties.resourceTypes));
  errors.collect(cdk.propertyValidator("resources", cdk.listValidator(cdk.validateString))(properties.resources));
  return errors.wrap("supplied properties not correct for \"ResourceStatementRequestProperty\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInsightsAccessScopeResourceStatementRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInsightsAccessScopeResourceStatementRequestPropertyValidator(properties).assertSuccess();
  return {
    "ResourceTypes": cdk.listMapper(cdk.stringToCloudFormation)(properties.resourceTypes),
    "Resources": cdk.listMapper(cdk.stringToCloudFormation)(properties.resources)
  };
}

// @ts-ignore TS6133
function CfnNetworkInsightsAccessScopeResourceStatementRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnNetworkInsightsAccessScope.ResourceStatementRequestProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInsightsAccessScope.ResourceStatementRequestProperty>();
  ret.addPropertyResult("resources", "Resources", (properties.Resources != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.Resources) : undefined));
  ret.addPropertyResult("resourceTypes", "ResourceTypes", (properties.ResourceTypes != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.ResourceTypes) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `PacketHeaderStatementRequestProperty`
 *
 * @param properties - the TypeScript properties of a `PacketHeaderStatementRequestProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInsightsAccessScopePacketHeaderStatementRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("destinationAddresses", cdk.listValidator(cdk.validateString))(properties.destinationAddresses));
  errors.collect(cdk.propertyValidator("destinationPorts", cdk.listValidator(cdk.validateString))(properties.destinationPorts));
  errors.collect(cdk.propertyValidator("destinationPrefixLists", cdk.listValidator(cdk.validateString))(properties.destinationPrefixLists));
  errors.collect(cdk.propertyValidator("protocols", cdk.listValidator(cdk.validateString))(properties.protocols));
  errors.collect(cdk.propertyValidator("sourceAddresses", cdk.listValidator(cdk.validateString))(properties.sourceAddresses));
  errors.collect(cdk.propertyValidator("sourcePorts", cdk.listValidator(cdk.validateString))(properties.sourcePorts));
  errors.collect(cdk.propertyValidator("sourcePrefixLists", cdk.listValidator(cdk.validateString))(properties.sourcePrefixLists));
  return errors.wrap("supplied properties not correct for \"PacketHeaderStatementRequestProperty\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInsightsAccessScopePacketHeaderStatementRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInsightsAccessScopePacketHeaderStatementRequestPropertyValidator(properties).assertSuccess();
  return {
    "DestinationAddresses": cdk.listMapper(cdk.stringToCloudFormation)(properties.destinationAddresses),
    "DestinationPorts": cdk.listMapper(cdk.stringToCloudFormation)(properties.destinationPorts),
    "DestinationPrefixLists": cdk.listMapper(cdk.stringToCloudFormation)(properties.destinationPrefixLists),
    "Protocols": cdk.listMapper(cdk.stringToCloudFormation)(properties.protocols),
    "SourceAddresses": cdk.listMapper(cdk.stringToCloudFormation)(properties.sourceAddresses),
    "SourcePorts": cdk.listMapper(cdk.stringToCloudFormation)(properties.sourcePorts),
    "SourcePrefixLists": cdk.listMapper(cdk.stringToCloudFormation)(properties.sourcePrefixLists)
  };
}

// @ts-ignore TS6133
function CfnNetworkInsightsAccessScopePacketHeaderStatementRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnNetworkInsightsAccessScope.PacketHeaderStatementRequestProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInsightsAccessScope.PacketHeaderStatementRequestProperty>();
  ret.addPropertyResult("destinationAddresses", "DestinationAddresses", (properties.DestinationAddresses != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.DestinationAddresses) : undefined));
  ret.addPropertyResult("destinationPorts", "DestinationPorts", (properties.DestinationPorts != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.DestinationPorts) : undefined));
  ret.addPropertyResult("destinationPrefixLists", "DestinationPrefixLists", (properties.DestinationPrefixLists != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.DestinationPrefixLists) : undefined));
  ret.addPropertyResult("protocols", "Protocols", (properties.Protocols != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.Protocols) : undefined));
  ret.addPropertyResult("sourceAddresses", "SourceAddresses", (properties.SourceAddresses != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SourceAddresses) : undefined));
  ret.addPropertyResult("sourcePorts", "SourcePorts", (properties.SourcePorts != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SourcePorts) : undefined));
  ret.addPropertyResult("sourcePrefixLists", "SourcePrefixLists", (properties.SourcePrefixLists != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SourcePrefixLists) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `PathStatementRequestProperty`
 *
 * @param properties - the TypeScript properties of a `PathStatementRequestProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInsightsAccessScopePathStatementRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("packetHeaderStatement", CfnNetworkInsightsAccessScopePacketHeaderStatementRequestPropertyValidator)(properties.packetHeaderStatement));
  errors.collect(cdk.propertyValidator("resourceStatement", CfnNetworkInsightsAccessScopeResourceStatementRequestPropertyValidator)(properties.resourceStatement));
  return errors.wrap("supplied properties not correct for \"PathStatementRequestProperty\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInsightsAccessScopePathStatementRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInsightsAccessScopePathStatementRequestPropertyValidator(properties).assertSuccess();
  return {
    "PacketHeaderStatement": convertCfnNetworkInsightsAccessScopePacketHeaderStatementRequestPropertyToCloudFormation(properties.packetHeaderStatement),
    "ResourceStatement": convertCfnNetworkInsightsAccessScopeResourceStatementRequestPropertyToCloudFormation(properties.resourceStatement)
  };
}

// @ts-ignore TS6133
function CfnNetworkInsightsAccessScopePathStatementRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnNetworkInsightsAccessScope.PathStatementRequestProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInsightsAccessScope.PathStatementRequestProperty>();
  ret.addPropertyResult("packetHeaderStatement", "PacketHeaderStatement", (properties.PacketHeaderStatement != null ? CfnNetworkInsightsAccessScopePacketHeaderStatementRequestPropertyFromCloudFormation(properties.PacketHeaderStatement) : undefined));
  ret.addPropertyResult("resourceStatement", "ResourceStatement", (properties.ResourceStatement != null ? CfnNetworkInsightsAccessScopeResourceStatementRequestPropertyFromCloudFormation(properties.ResourceStatement) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `ThroughResourcesStatementRequestProperty`
 *
 * @param properties - the TypeScript properties of a `ThroughResourcesStatementRequestProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInsightsAccessScopeThroughResourcesStatementRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("resourceStatement", CfnNetworkInsightsAccessScopeResourceStatementRequestPropertyValidator)(properties.resourceStatement));
  return errors.wrap("supplied properties not correct for \"ThroughResourcesStatementRequestProperty\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInsightsAccessScopeThroughResourcesStatementRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInsightsAccessScopeThroughResourcesStatementRequestPropertyValidator(properties).assertSuccess();
  return {
    "ResourceStatement": convertCfnNetworkInsightsAccessScopeResourceStatementRequestPropertyToCloudFormation(properties.resourceStatement)
  };
}

// @ts-ignore TS6133
function CfnNetworkInsightsAccessScopeThroughResourcesStatementRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnNetworkInsightsAccessScope.ThroughResourcesStatementRequestProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInsightsAccessScope.ThroughResourcesStatementRequestProperty>();
  ret.addPropertyResult("resourceStatement", "ResourceStatement", (properties.ResourceStatement != null ? CfnNetworkInsightsAccessScopeResourceStatementRequestPropertyFromCloudFormation(properties.ResourceStatement) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `AccessScopePathRequestProperty`
 *
 * @param properties - the TypeScript properties of a `AccessScopePathRequestProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInsightsAccessScopeAccessScopePathRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("destination", CfnNetworkInsightsAccessScopePathStatementRequestPropertyValidator)(properties.destination));
  errors.collect(cdk.propertyValidator("source", CfnNetworkInsightsAccessScopePathStatementRequestPropertyValidator)(properties.source));
  errors.collect(cdk.propertyValidator("throughResources", cdk.listValidator(CfnNetworkInsightsAccessScopeThroughResourcesStatementRequestPropertyValidator))(properties.throughResources));
  return errors.wrap("supplied properties not correct for \"AccessScopePathRequestProperty\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInsightsAccessScopeAccessScopePathRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInsightsAccessScopeAccessScopePathRequestPropertyValidator(properties).assertSuccess();
  return {
    "Destination": convertCfnNetworkInsightsAccessScopePathStatementRequestPropertyToCloudFormation(properties.destination),
    "Source": convertCfnNetworkInsightsAccessScopePathStatementRequestPropertyToCloudFormation(properties.source),
    "ThroughResources": cdk.listMapper(convertCfnNetworkInsightsAccessScopeThroughResourcesStatementRequestPropertyToCloudFormation)(properties.throughResources)
  };
}

// @ts-ignore TS6133
function CfnNetworkInsightsAccessScopeAccessScopePathRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNetworkInsightsAccessScope.AccessScopePathRequestProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInsightsAccessScope.AccessScopePathRequestProperty>();
  ret.addPropertyResult("destination", "Destination", (properties.Destination != null ? CfnNetworkInsightsAccessScopePathStatementRequestPropertyFromCloudFormation(properties.Destination) : undefined));
  ret.addPropertyResult("source", "Source", (properties.Source != null ? CfnNetworkInsightsAccessScopePathStatementRequestPropertyFromCloudFormation(properties.Source) : undefined));
  ret.addPropertyResult("throughResources", "ThroughResources", (properties.ThroughResources != null ? cfn_parse.FromCloudFormation.getArray(CfnNetworkInsightsAccessScopeThroughResourcesStatementRequestPropertyFromCloudFormation)(properties.ThroughResources) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `CfnNetworkInsightsAccessScopeProps`
 *
 * @param properties - the TypeScript properties of a `CfnNetworkInsightsAccessScopeProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInsightsAccessScopePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("excludePaths", cdk.listValidator(CfnNetworkInsightsAccessScopeAccessScopePathRequestPropertyValidator))(properties.excludePaths));
  errors.collect(cdk.propertyValidator("matchPaths", cdk.listValidator(CfnNetworkInsightsAccessScopeAccessScopePathRequestPropertyValidator))(properties.matchPaths));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \"CfnNetworkInsightsAccessScopeProps\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInsightsAccessScopePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInsightsAccessScopePropsValidator(properties).assertSuccess();
  return {
    "ExcludePaths": cdk.listMapper(convertCfnNetworkInsightsAccessScopeAccessScopePathRequestPropertyToCloudFormation)(properties.excludePaths),
    "MatchPaths": cdk.listMapper(convertCfnNetworkInsightsAccessScopeAccessScopePathRequestPropertyToCloudFormation)(properties.matchPaths),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnNetworkInsightsAccessScopePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNetworkInsightsAccessScopeProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInsightsAccessScopeProps>();
  ret.addPropertyResult("excludePaths", "ExcludePaths", (properties.ExcludePaths != null ? cfn_parse.FromCloudFormation.getArray(CfnNetworkInsightsAccessScopeAccessScopePathRequestPropertyFromCloudFormation)(properties.ExcludePaths) : undefined));
  ret.addPropertyResult("matchPaths", "MatchPaths", (properties.MatchPaths != null ? cfn_parse.FromCloudFormation.getArray(CfnNetworkInsightsAccessScopeAccessScopePathRequestPropertyFromCloudFormation)(properties.MatchPaths) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Describes a Network Access Scope analysis.
 *
 * @cloudformationResource AWS::EC2::NetworkInsightsAccessScopeAnalysis
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsaccessscopeanalysis.html
 */
export class CfnNetworkInsightsAccessScopeAnalysis extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::NetworkInsightsAccessScopeAnalysis";

  /**
   * Build a CfnNetworkInsightsAccessScopeAnalysis from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnNetworkInsightsAccessScopeAnalysis {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnNetworkInsightsAccessScopeAnalysisPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnNetworkInsightsAccessScopeAnalysis(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The number of network interfaces analyzed.
   *
   * @cloudformationAttribute AnalyzedEniCount
   */
  public readonly attrAnalyzedEniCount: number;

  /**
   * The end date of the analysis.
   *
   * @cloudformationAttribute EndDate
   */
  public readonly attrEndDate: string;

  /**
   * Indicates whether there are findings (true | false | unknown).
   *
   * @cloudformationAttribute FindingsFound
   */
  public readonly attrFindingsFound: string;

  /**
   * The ARN of the Network Access Scope analysis.
   *
   * @cloudformationAttribute NetworkInsightsAccessScopeAnalysisArn
   */
  public readonly attrNetworkInsightsAccessScopeAnalysisArn: string;

  /**
   * The ID of the Network Access Scope analysis.
   *
   * @cloudformationAttribute NetworkInsightsAccessScopeAnalysisId
   */
  public readonly attrNetworkInsightsAccessScopeAnalysisId: string;

  /**
   * The start date of the analysis.
   *
   * @cloudformationAttribute StartDate
   */
  public readonly attrStartDate: string;

  /**
   * The status of the analysis (running | succeeded | failed).
   *
   * @cloudformationAttribute Status
   */
  public readonly attrStatus: string;

  /**
   * The status message.
   *
   * @cloudformationAttribute StatusMessage
   */
  public readonly attrStatusMessage: string;

  /**
   * The ID of the Network Access Scope.
   */
  public networkInsightsAccessScopeId: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnNetworkInsightsAccessScopeAnalysisProps) {
    super(scope, id, {
      "type": CfnNetworkInsightsAccessScopeAnalysis.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "networkInsightsAccessScopeId", this);

    this.attrAnalyzedEniCount = cdk.Token.asNumber(this.getAtt("AnalyzedEniCount", cdk.ResolutionTypeHint.NUMBER));
    this.attrEndDate = cdk.Token.asString(this.getAtt("EndDate", cdk.ResolutionTypeHint.STRING));
    this.attrFindingsFound = cdk.Token.asString(this.getAtt("FindingsFound", cdk.ResolutionTypeHint.STRING));
    this.attrNetworkInsightsAccessScopeAnalysisArn = cdk.Token.asString(this.getAtt("NetworkInsightsAccessScopeAnalysisArn", cdk.ResolutionTypeHint.STRING));
    this.attrNetworkInsightsAccessScopeAnalysisId = cdk.Token.asString(this.getAtt("NetworkInsightsAccessScopeAnalysisId", cdk.ResolutionTypeHint.STRING));
    this.attrStartDate = cdk.Token.asString(this.getAtt("StartDate", cdk.ResolutionTypeHint.STRING));
    this.attrStatus = cdk.Token.asString(this.getAtt("Status", cdk.ResolutionTypeHint.STRING));
    this.attrStatusMessage = cdk.Token.asString(this.getAtt("StatusMessage", cdk.ResolutionTypeHint.STRING));
    this.networkInsightsAccessScopeId = props.networkInsightsAccessScopeId;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::NetworkInsightsAccessScopeAnalysis", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "networkInsightsAccessScopeId": this.networkInsightsAccessScopeId,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnNetworkInsightsAccessScopeAnalysis.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnNetworkInsightsAccessScopeAnalysisPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a `CfnNetworkInsightsAccessScopeAnalysis`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsaccessscopeanalysis.html
 */
export interface CfnNetworkInsightsAccessScopeAnalysisProps {
  /**
   * The ID of the Network Access Scope.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsaccessscopeanalysis.html#cfn-ec2-networkinsightsaccessscopeanalysis-networkinsightsaccessscopeid
   */
  readonly networkInsightsAccessScopeId: string;

  /**
   * The tags.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsaccessscopeanalysis.html#cfn-ec2-networkinsightsaccessscopeanalysis-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a `CfnNetworkInsightsAccessScopeAnalysisProps`
 *
 * @param properties - the TypeScript properties of a `CfnNetworkInsightsAccessScopeAnalysisProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInsightsAccessScopeAnalysisPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("networkInsightsAccessScopeId", cdk.requiredValidator)(properties.networkInsightsAccessScopeId));
  errors.collect(cdk.propertyValidator("networkInsightsAccessScopeId", cdk.validateString)(properties.networkInsightsAccessScopeId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \"CfnNetworkInsightsAccessScopeAnalysisProps\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInsightsAccessScopeAnalysisPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInsightsAccessScopeAnalysisPropsValidator(properties).assertSuccess();
  return {
    "NetworkInsightsAccessScopeId": cdk.stringToCloudFormation(properties.networkInsightsAccessScopeId),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnNetworkInsightsAccessScopeAnalysisPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNetworkInsightsAccessScopeAnalysisProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInsightsAccessScopeAnalysisProps>();
  ret.addPropertyResult("networkInsightsAccessScopeId", "NetworkInsightsAccessScopeId", (properties.NetworkInsightsAccessScopeId != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkInsightsAccessScopeId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a network insights analysis.
 *
 * @cloudformationResource AWS::EC2::NetworkInsightsAnalysis
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsanalysis.html
 */
export class CfnNetworkInsightsAnalysis extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::NetworkInsightsAnalysis";

  /**
   * Build a CfnNetworkInsightsAnalysis from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnNetworkInsightsAnalysis {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnNetworkInsightsAnalysisPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnNetworkInsightsAnalysis(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * Potential intermediate components.
   *
   * @cloudformationAttribute AlternatePathHints
   */
  public readonly attrAlternatePathHints: cdk.IResolvable;

  /**
   * The explanations. For more information, see [Reachability Analyzer explanation codes](https://docs.aws.amazon.com/vpc/latest/reachability/explanation-codes.html) .
   *
   * @cloudformationAttribute Explanations
   */
  public readonly attrExplanations: cdk.IResolvable;

  /**
   * The components in the path from source to destination.
   *
   * @cloudformationAttribute ForwardPathComponents
   */
  public readonly attrForwardPathComponents: cdk.IResolvable;

  /**
   * The Amazon Resource Name (ARN) of the network insights analysis.
   *
   * @cloudformationAttribute NetworkInsightsAnalysisArn
   */
  public readonly attrNetworkInsightsAnalysisArn: string;

  /**
   * The ID of the network insights analysis.
   *
   * @cloudformationAttribute NetworkInsightsAnalysisId
   */
  public readonly attrNetworkInsightsAnalysisId: string;

  /**
   * Indicates whether the destination is reachable from the source.
   *
   * @cloudformationAttribute NetworkPathFound
   */
  public readonly attrNetworkPathFound: cdk.IResolvable;

  /**
   * The components in the path from destination to source.
   *
   * @cloudformationAttribute ReturnPathComponents
   */
  public readonly attrReturnPathComponents: cdk.IResolvable;

  /**
   * The time the analysis started.
   *
   * @cloudformationAttribute StartDate
   */
  public readonly attrStartDate: string;

  /**
   * The status of the network insights analysis.
   *
   * @cloudformationAttribute Status
   */
  public readonly attrStatus: string;

  /**
   * The status message, if the status is `failed` .
   *
   * @cloudformationAttribute StatusMessage
   */
  public readonly attrStatusMessage: string;

  /**
   * The IDs of potential intermediate accounts.
   *
   * @cloudformationAttribute SuggestedAccounts
   */
  public readonly attrSuggestedAccounts: Array<string>;

  /**
   * The member accounts that contain resources that the path can traverse.
   */
  public additionalAccounts?: Array<string>;

  /**
   * The Amazon Resource Names (ARN) of the resources that the path must traverse.
   */
  public filterInArns?: Array<string>;

  /**
   * The ID of the path.
   */
  public networkInsightsPathId: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags to apply.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnNetworkInsightsAnalysisProps) {
    super(scope, id, {
      "type": CfnNetworkInsightsAnalysis.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "networkInsightsPathId", this);

    this.attrAlternatePathHints = this.getAtt("AlternatePathHints");
    this.attrExplanations = this.getAtt("Explanations");
    this.attrForwardPathComponents = this.getAtt("ForwardPathComponents");
    this.attrNetworkInsightsAnalysisArn = cdk.Token.asString(this.getAtt("NetworkInsightsAnalysisArn", cdk.ResolutionTypeHint.STRING));
    this.attrNetworkInsightsAnalysisId = cdk.Token.asString(this.getAtt("NetworkInsightsAnalysisId", cdk.ResolutionTypeHint.STRING));
    this.attrNetworkPathFound = this.getAtt("NetworkPathFound");
    this.attrReturnPathComponents = this.getAtt("ReturnPathComponents");
    this.attrStartDate = cdk.Token.asString(this.getAtt("StartDate", cdk.ResolutionTypeHint.STRING));
    this.attrStatus = cdk.Token.asString(this.getAtt("Status", cdk.ResolutionTypeHint.STRING));
    this.attrStatusMessage = cdk.Token.asString(this.getAtt("StatusMessage", cdk.ResolutionTypeHint.STRING));
    this.attrSuggestedAccounts = cdk.Token.asList(this.getAtt("SuggestedAccounts", cdk.ResolutionTypeHint.STRING_LIST));
    this.additionalAccounts = props.additionalAccounts;
    this.filterInArns = props.filterInArns;
    this.networkInsightsPathId = props.networkInsightsPathId;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::NetworkInsightsAnalysis", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "additionalAccounts": this.additionalAccounts,
      "filterInArns": this.filterInArns,
      "networkInsightsPathId": this.networkInsightsPathId,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnNetworkInsightsAnalysis.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnNetworkInsightsAnalysisPropsToCloudFormation(props);
  }
}

export namespace CfnNetworkInsightsAnalysis {
  /**
   * Describes a path component.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html
   */
  export interface PathComponentProperty {
    /**
     * The network ACL rule.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-aclrule
     */
    readonly aclRule?: CfnNetworkInsightsAnalysis.AnalysisAclRuleProperty | cdk.IResolvable;

    /**
     * The additional details.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-additionaldetails
     */
    readonly additionalDetails?: Array<CfnNetworkInsightsAnalysis.AdditionalDetailProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The component.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-component
     */
    readonly component?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;

    /**
     * The destination VPC.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-destinationvpc
     */
    readonly destinationVpc?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;

    /**
     * The load balancer listener.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-elasticloadbalancerlistener
     */
    readonly elasticLoadBalancerListener?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;

    /**
     * The explanation codes.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-explanations
     */
    readonly explanations?: Array<CfnNetworkInsightsAnalysis.ExplanationProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The inbound header.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-inboundheader
     */
    readonly inboundHeader?: CfnNetworkInsightsAnalysis.AnalysisPacketHeaderProperty | cdk.IResolvable;

    /**
     * The outbound header.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-outboundheader
     */
    readonly outboundHeader?: CfnNetworkInsightsAnalysis.AnalysisPacketHeaderProperty | cdk.IResolvable;

    /**
     * The route table route.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-routetableroute
     */
    readonly routeTableRoute?: CfnNetworkInsightsAnalysis.AnalysisRouteTableRouteProperty | cdk.IResolvable;

    /**
     * The security group rule.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-securitygrouprule
     */
    readonly securityGroupRule?: CfnNetworkInsightsAnalysis.AnalysisSecurityGroupRuleProperty | cdk.IResolvable;

    /**
     * The sequence number.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-sequencenumber
     */
    readonly sequenceNumber?: number;

    /**
     * The name of the VPC endpoint service.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-servicename
     */
    readonly serviceName?: string;

    /**
     * The source VPC.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-sourcevpc
     */
    readonly sourceVpc?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;

    /**
     * The subnet.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-subnet
     */
    readonly subnet?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;

    /**
     * The transit gateway.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-transitgateway
     */
    readonly transitGateway?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;

    /**
     * The route in a transit gateway route table.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-transitgatewayroutetableroute
     */
    readonly transitGatewayRouteTableRoute?: cdk.IResolvable | CfnNetworkInsightsAnalysis.TransitGatewayRouteTableRouteProperty;

    /**
     * The component VPC.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-vpc
     */
    readonly vpc?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;
  }

  /**
   * Describes an additional detail for a path analysis.
   *
   * For more information, see [Reachability Analyzer additional detail codes](https://docs.aws.amazon.com/vpc/latest/reachability/additional-detail-codes.html) .
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-additionaldetail.html
   */
  export interface AdditionalDetailProperty {
    /**
     * The additional detail code.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-additionaldetail.html#cfn-ec2-networkinsightsanalysis-additionaldetail-additionaldetailtype
     */
    readonly additionalDetailType?: string;

    /**
     * The path component.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-additionaldetail.html#cfn-ec2-networkinsightsanalysis-additionaldetail-component
     */
    readonly component?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;

    /**
     * The load balancers.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-additionaldetail.html#cfn-ec2-networkinsightsanalysis-additionaldetail-loadbalancers
     */
    readonly loadBalancers?: Array<CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The name of the VPC endpoint service.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-additionaldetail.html#cfn-ec2-networkinsightsanalysis-additionaldetail-servicename
     */
    readonly serviceName?: string;
  }

  /**
   * Describes a path component.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysiscomponent.html
   */
  export interface AnalysisComponentProperty {
    /**
     * The Amazon Resource Name (ARN) of the component.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysiscomponent.html#cfn-ec2-networkinsightsanalysis-analysiscomponent-arn
     */
    readonly arn?: string;

    /**
     * The ID of the component.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysiscomponent.html#cfn-ec2-networkinsightsanalysis-analysiscomponent-id
     */
    readonly id?: string;
  }

  /**
   * Describes a header.
   *
   * Reflects any changes made by a component as traffic passes through. The fields of an inbound header are null except for the first component of a path.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysispacketheader.html
   */
  export interface AnalysisPacketHeaderProperty {
    /**
     * The destination addresses.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysispacketheader.html#cfn-ec2-networkinsightsanalysis-analysispacketheader-destinationaddresses
     */
    readonly destinationAddresses?: Array<string>;

    /**
     * The destination port ranges.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysispacketheader.html#cfn-ec2-networkinsightsanalysis-analysispacketheader-destinationportranges
     */
    readonly destinationPortRanges?: Array<cdk.IResolvable | CfnNetworkInsightsAnalysis.PortRangeProperty> | cdk.IResolvable;

    /**
     * The protocol.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysispacketheader.html#cfn-ec2-networkinsightsanalysis-analysispacketheader-protocol
     */
    readonly protocol?: string;

    /**
     * The source addresses.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysispacketheader.html#cfn-ec2-networkinsightsanalysis-analysispacketheader-sourceaddresses
     */
    readonly sourceAddresses?: Array<string>;

    /**
     * The source port ranges.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysispacketheader.html#cfn-ec2-networkinsightsanalysis-analysispacketheader-sourceportranges
     */
    readonly sourcePortRanges?: Array<cdk.IResolvable | CfnNetworkInsightsAnalysis.PortRangeProperty> | cdk.IResolvable;
  }

  /**
   * Describes a range of ports.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-portrange.html
   */
  export interface PortRangeProperty {
    /**
     * The first port in the range.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-portrange.html#cfn-ec2-networkinsightsanalysis-portrange-from
     */
    readonly from?: number;

    /**
     * The last port in the range.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-portrange.html#cfn-ec2-networkinsightsanalysis-portrange-to
     */
    readonly to?: number;
  }

  /**
   * Describes a security group rule.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysissecuritygrouprule.html
   */
  export interface AnalysisSecurityGroupRuleProperty {
    /**
     * The IPv4 address range, in CIDR notation.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysissecuritygrouprule.html#cfn-ec2-networkinsightsanalysis-analysissecuritygrouprule-cidr
     */
    readonly cidr?: string;

    /**
     * The direction. The following are the possible values:.
     *
     * - egress
     * - ingress
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysissecuritygrouprule.html#cfn-ec2-networkinsightsanalysis-analysissecuritygrouprule-direction
     */
    readonly direction?: string;

    /**
     * The port range.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysissecuritygrouprule.html#cfn-ec2-networkinsightsanalysis-analysissecuritygrouprule-portrange
     */
    readonly portRange?: cdk.IResolvable | CfnNetworkInsightsAnalysis.PortRangeProperty;

    /**
     * The prefix list ID.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysissecuritygrouprule.html#cfn-ec2-networkinsightsanalysis-analysissecuritygrouprule-prefixlistid
     */
    readonly prefixListId?: string;

    /**
     * The protocol name.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysissecuritygrouprule.html#cfn-ec2-networkinsightsanalysis-analysissecuritygrouprule-protocol
     */
    readonly protocol?: string;

    /**
     * The security group ID.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysissecuritygrouprule.html#cfn-ec2-networkinsightsanalysis-analysissecuritygrouprule-securitygroupid
     */
    readonly securityGroupId?: string;
  }

  /**
   * Describes an explanation code for an unreachable path.
   *
   * For more information, see [Reachability Analyzer explanation codes](https://docs.aws.amazon.com/vpc/latest/reachability/explanation-codes.html) .
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html
   */
  export interface ExplanationProperty {
    /**
     * The network ACL.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-acl
     */
    readonly acl?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;

    /**
     * The network ACL rule.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-aclrule
     */
    readonly aclRule?: CfnNetworkInsightsAnalysis.AnalysisAclRuleProperty | cdk.IResolvable;

    /**
     * The IPv4 address, in CIDR notation.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-address
     */
    readonly address?: string;

    /**
     * The IPv4 addresses, in CIDR notation.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-addresses
     */
    readonly addresses?: Array<string>;

    /**
     * The resource to which the component is attached.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-attachedto
     */
    readonly attachedTo?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;

    /**
     * The Availability Zones.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-availabilityzones
     */
    readonly availabilityZones?: Array<string>;

    /**
     * The CIDR ranges.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-cidrs
     */
    readonly cidrs?: Array<string>;

    /**
     * The listener for a Classic Load Balancer.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-classicloadbalancerlistener
     */
    readonly classicLoadBalancerListener?: CfnNetworkInsightsAnalysis.AnalysisLoadBalancerListenerProperty | cdk.IResolvable;

    /**
     * The component.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-component
     */
    readonly component?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;

    /**
     * The AWS account for the component.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-componentaccount
     */
    readonly componentAccount?: string;

    /**
     * The Region for the component.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-componentregion
     */
    readonly componentRegion?: string;

    /**
     * The customer gateway.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-customergateway
     */
    readonly customerGateway?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;

    /**
     * The destination.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-destination
     */
    readonly destination?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;

    /**
     * The destination VPC.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-destinationvpc
     */
    readonly destinationVpc?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;

    /**
     * The direction. The following are the possible values:.
     *
     * - egress
     * - ingress
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-direction
     */
    readonly direction?: string;

    /**
     * The load balancer listener.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-elasticloadbalancerlistener
     */
    readonly elasticLoadBalancerListener?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;

    /**
     * The explanation code.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-explanationcode
     */
    readonly explanationCode?: string;

    /**
     * The route table.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-ingressroutetable
     */
    readonly ingressRouteTable?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;

    /**
     * The internet gateway.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-internetgateway
     */
    readonly internetGateway?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;

    /**
     * The Amazon Resource Name (ARN) of the load balancer.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-loadbalancerarn
     */
    readonly loadBalancerArn?: string;

    /**
     * The listener port of the load balancer.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-loadbalancerlistenerport
     */
    readonly loadBalancerListenerPort?: number;

    /**
     * The target.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-loadbalancertarget
     */
    readonly loadBalancerTarget?: CfnNetworkInsightsAnalysis.AnalysisLoadBalancerTargetProperty | cdk.IResolvable;

    /**
     * The target group.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-loadbalancertargetgroup
     */
    readonly loadBalancerTargetGroup?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;

    /**
     * The target groups.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-loadbalancertargetgroups
     */
    readonly loadBalancerTargetGroups?: Array<CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The target port.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-loadbalancertargetport
     */
    readonly loadBalancerTargetPort?: number;

    /**
     * The missing component.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-missingcomponent
     */
    readonly missingComponent?: string;

    /**
     * The NAT gateway.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-natgateway
     */
    readonly natGateway?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;

    /**
     * The network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-networkinterface
     */
    readonly networkInterface?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;

    /**
     * The packet field.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-packetfield
     */
    readonly packetField?: string;

    /**
     * The port.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-port
     */
    readonly port?: number;

    /**
     * The port ranges.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-portranges
     */
    readonly portRanges?: Array<cdk.IResolvable | CfnNetworkInsightsAnalysis.PortRangeProperty> | cdk.IResolvable;

    /**
     * The prefix list.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-prefixlist
     */
    readonly prefixList?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;

    /**
     * The protocols.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-protocols
     */
    readonly protocols?: Array<string>;

    /**
     * The route table.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-routetable
     */
    readonly routeTable?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;

    /**
     * The route table route.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-routetableroute
     */
    readonly routeTableRoute?: CfnNetworkInsightsAnalysis.AnalysisRouteTableRouteProperty | cdk.IResolvable;

    /**
     * The security group.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-securitygroup
     */
    readonly securityGroup?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;

    /**
     * The security group rule.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-securitygrouprule
     */
    readonly securityGroupRule?: CfnNetworkInsightsAnalysis.AnalysisSecurityGroupRuleProperty | cdk.IResolvable;

    /**
     * The security groups.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-securitygroups
     */
    readonly securityGroups?: Array<CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The source VPC.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-sourcevpc
     */
    readonly sourceVpc?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;

    /**
     * The state.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-state
     */
    readonly state?: string;

    /**
     * The subnet.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-subnet
     */
    readonly subnet?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;

    /**
     * The route table for the subnet.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-subnetroutetable
     */
    readonly subnetRouteTable?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;

    /**
     * The transit gateway.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-transitgateway
     */
    readonly transitGateway?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;

    /**
     * The transit gateway attachment.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-transitgatewayattachment
     */
    readonly transitGatewayAttachment?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;

    /**
     * The transit gateway route table.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-transitgatewayroutetable
     */
    readonly transitGatewayRouteTable?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;

    /**
     * The transit gateway route table route.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-transitgatewayroutetableroute
     */
    readonly transitGatewayRouteTableRoute?: cdk.IResolvable | CfnNetworkInsightsAnalysis.TransitGatewayRouteTableRouteProperty;

    /**
     * The component VPC.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-vpc
     */
    readonly vpc?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;

    /**
     * The VPC endpoint.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-vpcendpoint
     */
    readonly vpcEndpoint?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;

    /**
     * The VPC peering connection.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-vpcpeeringconnection
     */
    readonly vpcPeeringConnection?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;

    /**
     * The VPN connection.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-vpnconnection
     */
    readonly vpnConnection?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;

    /**
     * The VPN gateway.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-vpngateway
     */
    readonly vpnGateway?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;
  }

  /**
   * Describes a load balancer listener.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisloadbalancerlistener.html
   */
  export interface AnalysisLoadBalancerListenerProperty {
    /**
     * [Classic Load Balancers] The back-end port for the listener.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisloadbalancerlistener.html#cfn-ec2-networkinsightsanalysis-analysisloadbalancerlistener-instanceport
     */
    readonly instancePort?: number;

    /**
     * The port on which the load balancer is listening.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisloadbalancerlistener.html#cfn-ec2-networkinsightsanalysis-analysisloadbalancerlistener-loadbalancerport
     */
    readonly loadBalancerPort?: number;
  }

  /**
   * Describes a route in a transit gateway route table.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-transitgatewayroutetableroute.html
   */
  export interface TransitGatewayRouteTableRouteProperty {
    /**
     * The ID of the route attachment.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-transitgatewayroutetableroute.html#cfn-ec2-networkinsightsanalysis-transitgatewayroutetableroute-attachmentid
     */
    readonly attachmentId?: string;

    /**
     * The CIDR block used for destination matches.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-transitgatewayroutetableroute.html#cfn-ec2-networkinsightsanalysis-transitgatewayroutetableroute-destinationcidr
     */
    readonly destinationCidr?: string;

    /**
     * The ID of the prefix list.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-transitgatewayroutetableroute.html#cfn-ec2-networkinsightsanalysis-transitgatewayroutetableroute-prefixlistid
     */
    readonly prefixListId?: string;

    /**
     * The ID of the resource for the route attachment.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-transitgatewayroutetableroute.html#cfn-ec2-networkinsightsanalysis-transitgatewayroutetableroute-resourceid
     */
    readonly resourceId?: string;

    /**
     * The resource type for the route attachment.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-transitgatewayroutetableroute.html#cfn-ec2-networkinsightsanalysis-transitgatewayroutetableroute-resourcetype
     */
    readonly resourceType?: string;

    /**
     * The route origin. The following are the possible values:.
     *
     * - static
     * - propagated
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-transitgatewayroutetableroute.html#cfn-ec2-networkinsightsanalysis-transitgatewayroutetableroute-routeorigin
     */
    readonly routeOrigin?: string;

    /**
     * The state of the route.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-transitgatewayroutetableroute.html#cfn-ec2-networkinsightsanalysis-transitgatewayroutetableroute-state
     */
    readonly state?: string;
  }

  /**
   * Describes a load balancer target.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisloadbalancertarget.html
   */
  export interface AnalysisLoadBalancerTargetProperty {
    /**
     * The IP address.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisloadbalancertarget.html#cfn-ec2-networkinsightsanalysis-analysisloadbalancertarget-address
     */
    readonly address?: string;

    /**
     * The Availability Zone.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisloadbalancertarget.html#cfn-ec2-networkinsightsanalysis-analysisloadbalancertarget-availabilityzone
     */
    readonly availabilityZone?: string;

    /**
     * Information about the instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisloadbalancertarget.html#cfn-ec2-networkinsightsanalysis-analysisloadbalancertarget-instance
     */
    readonly instance?: CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable;

    /**
     * The port on which the target is listening.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisloadbalancertarget.html#cfn-ec2-networkinsightsanalysis-analysisloadbalancertarget-port
     */
    readonly port?: number;
  }

  /**
   * Describes a route table route.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisroutetableroute.html
   */
  export interface AnalysisRouteTableRouteProperty {
    /**
     * The destination IPv4 address, in CIDR notation.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisroutetableroute.html#cfn-ec2-networkinsightsanalysis-analysisroutetableroute-destinationcidr
     */
    readonly destinationCidr?: string;

    /**
     * The prefix of the AWS service .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisroutetableroute.html#cfn-ec2-networkinsightsanalysis-analysisroutetableroute-destinationprefixlistid
     */
    readonly destinationPrefixListId?: string;

    /**
     * The ID of an egress-only internet gateway.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisroutetableroute.html#cfn-ec2-networkinsightsanalysis-analysisroutetableroute-egressonlyinternetgatewayid
     */
    readonly egressOnlyInternetGatewayId?: string;

    /**
     * The ID of the gateway, such as an internet gateway or virtual private gateway.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisroutetableroute.html#cfn-ec2-networkinsightsanalysis-analysisroutetableroute-gatewayid
     */
    readonly gatewayId?: string;

    /**
     * The ID of the instance, such as a NAT instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisroutetableroute.html#cfn-ec2-networkinsightsanalysis-analysisroutetableroute-instanceid
     */
    readonly instanceId?: string;

    /**
     * The ID of a NAT gateway.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisroutetableroute.html#cfn-ec2-networkinsightsanalysis-analysisroutetableroute-natgatewayid
     */
    readonly natGatewayId?: string;

    /**
     * The ID of a network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisroutetableroute.html#cfn-ec2-networkinsightsanalysis-analysisroutetableroute-networkinterfaceid
     */
    readonly networkInterfaceId?: string;

    /**
     * Describes how the route was created. The following are the possible values:.
     *
     * - CreateRouteTable - The route was automatically created when the route table was created.
     * - CreateRoute - The route was manually added to the route table.
     * - EnableVgwRoutePropagation - The route was propagated by route propagation.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisroutetableroute.html#cfn-ec2-networkinsightsanalysis-analysisroutetableroute-origin
     */
    readonly origin?: string;

    /**
     * The state. The following are the possible values:.
     *
     * - active
     * - blackhole
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisroutetableroute.html#cfn-ec2-networkinsightsanalysis-analysisroutetableroute-state
     */
    readonly state?: string;

    /**
     * The ID of a transit gateway.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisroutetableroute.html#cfn-ec2-networkinsightsanalysis-analysisroutetableroute-transitgatewayid
     */
    readonly transitGatewayId?: string;

    /**
     * The ID of a VPC peering connection.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisroutetableroute.html#cfn-ec2-networkinsightsanalysis-analysisroutetableroute-vpcpeeringconnectionid
     */
    readonly vpcPeeringConnectionId?: string;
  }

  /**
   * Describes a network access control (ACL) rule.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisaclrule.html
   */
  export interface AnalysisAclRuleProperty {
    /**
     * The IPv4 address range, in CIDR notation.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisaclrule.html#cfn-ec2-networkinsightsanalysis-analysisaclrule-cidr
     */
    readonly cidr?: string;

    /**
     * Indicates whether the rule is an outbound rule.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisaclrule.html#cfn-ec2-networkinsightsanalysis-analysisaclrule-egress
     */
    readonly egress?: boolean | cdk.IResolvable;

    /**
     * The range of ports.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisaclrule.html#cfn-ec2-networkinsightsanalysis-analysisaclrule-portrange
     */
    readonly portRange?: cdk.IResolvable | CfnNetworkInsightsAnalysis.PortRangeProperty;

    /**
     * The protocol.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisaclrule.html#cfn-ec2-networkinsightsanalysis-analysisaclrule-protocol
     */
    readonly protocol?: string;

    /**
     * Indicates whether to allow or deny traffic that matches the rule.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisaclrule.html#cfn-ec2-networkinsightsanalysis-analysisaclrule-ruleaction
     */
    readonly ruleAction?: string;

    /**
     * The rule number.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisaclrule.html#cfn-ec2-networkinsightsanalysis-analysisaclrule-rulenumber
     */
    readonly ruleNumber?: number;
  }

  /**
   * Describes an potential intermediate component of a feasible path.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-alternatepathhint.html
   */
  export interface AlternatePathHintProperty {
    /**
     * The Amazon Resource Name (ARN) of the component.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-alternatepathhint.html#cfn-ec2-networkinsightsanalysis-alternatepathhint-componentarn
     */
    readonly componentArn?: string;

    /**
     * The ID of the component.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-alternatepathhint.html#cfn-ec2-networkinsightsanalysis-alternatepathhint-componentid
     */
    readonly componentId?: string;
  }
}

/**
 * Properties for defining a `CfnNetworkInsightsAnalysis`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsanalysis.html
 */
export interface CfnNetworkInsightsAnalysisProps {
  /**
   * The member accounts that contain resources that the path can traverse.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsanalysis.html#cfn-ec2-networkinsightsanalysis-additionalaccounts
   */
  readonly additionalAccounts?: Array<string>;

  /**
   * The Amazon Resource Names (ARN) of the resources that the path must traverse.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsanalysis.html#cfn-ec2-networkinsightsanalysis-filterinarns
   */
  readonly filterInArns?: Array<string>;

  /**
   * The ID of the path.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsanalysis.html#cfn-ec2-networkinsightsanalysis-networkinsightspathid
   */
  readonly networkInsightsPathId: string;

  /**
   * The tags to apply.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsanalysis.html#cfn-ec2-networkinsightsanalysis-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a `AnalysisComponentProperty`
 *
 * @param properties - the TypeScript properties of a `AnalysisComponentProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("arn", cdk.validateString)(properties.arn));
  errors.collect(cdk.propertyValidator("id", cdk.validateString)(properties.id));
  return errors.wrap("supplied properties not correct for \"AnalysisComponentProperty\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator(properties).assertSuccess();
  return {
    "Arn": cdk.stringToCloudFormation(properties.arn),
    "Id": cdk.stringToCloudFormation(properties.id)
  };
}

// @ts-ignore TS6133
function CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNetworkInsightsAnalysis.AnalysisComponentProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInsightsAnalysis.AnalysisComponentProperty>();
  ret.addPropertyResult("arn", "Arn", (properties.Arn != null ? cfn_parse.FromCloudFormation.getString(properties.Arn) : undefined));
  ret.addPropertyResult("id", "Id", (properties.Id != null ? cfn_parse.FromCloudFormation.getString(properties.Id) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `AdditionalDetailProperty`
 *
 * @param properties - the TypeScript properties of a `AdditionalDetailProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInsightsAnalysisAdditionalDetailPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("additionalDetailType", cdk.validateString)(properties.additionalDetailType));
  errors.collect(cdk.propertyValidator("component", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.component));
  errors.collect(cdk.propertyValidator("loadBalancers", cdk.listValidator(CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator))(properties.loadBalancers));
  errors.collect(cdk.propertyValidator("serviceName", cdk.validateString)(properties.serviceName));
  return errors.wrap("supplied properties not correct for \"AdditionalDetailProperty\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInsightsAnalysisAdditionalDetailPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInsightsAnalysisAdditionalDetailPropertyValidator(properties).assertSuccess();
  return {
    "AdditionalDetailType": cdk.stringToCloudFormation(properties.additionalDetailType),
    "Component": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.component),
    "LoadBalancers": cdk.listMapper(convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation)(properties.loadBalancers),
    "ServiceName": cdk.stringToCloudFormation(properties.serviceName)
  };
}

// @ts-ignore TS6133
function CfnNetworkInsightsAnalysisAdditionalDetailPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNetworkInsightsAnalysis.AdditionalDetailProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInsightsAnalysis.AdditionalDetailProperty>();
  ret.addPropertyResult("additionalDetailType", "AdditionalDetailType", (properties.AdditionalDetailType != null ? cfn_parse.FromCloudFormation.getString(properties.AdditionalDetailType) : undefined));
  ret.addPropertyResult("component", "Component", (properties.Component != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.Component) : undefined));
  ret.addPropertyResult("loadBalancers", "LoadBalancers", (properties.LoadBalancers != null ? cfn_parse.FromCloudFormation.getArray(CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation)(properties.LoadBalancers) : undefined));
  ret.addPropertyResult("serviceName", "ServiceName", (properties.ServiceName != null ? cfn_parse.FromCloudFormation.getString(properties.ServiceName) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `PortRangeProperty`
 *
 * @param properties - the TypeScript properties of a `PortRangeProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInsightsAnalysisPortRangePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("from", cdk.validateNumber)(properties.from));
  errors.collect(cdk.propertyValidator("to", cdk.validateNumber)(properties.to));
  return errors.wrap("supplied properties not correct for \"PortRangeProperty\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInsightsAnalysisPortRangePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInsightsAnalysisPortRangePropertyValidator(properties).assertSuccess();
  return {
    "From": cdk.numberToCloudFormation(properties.from),
    "To": cdk.numberToCloudFormation(properties.to)
  };
}

// @ts-ignore TS6133
function CfnNetworkInsightsAnalysisPortRangePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnNetworkInsightsAnalysis.PortRangeProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInsightsAnalysis.PortRangeProperty>();
  ret.addPropertyResult("from", "From", (properties.From != null ? cfn_parse.FromCloudFormation.getNumber(properties.From) : undefined));
  ret.addPropertyResult("to", "To", (properties.To != null ? cfn_parse.FromCloudFormation.getNumber(properties.To) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `AnalysisPacketHeaderProperty`
 *
 * @param properties - the TypeScript properties of a `AnalysisPacketHeaderProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInsightsAnalysisAnalysisPacketHeaderPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("destinationAddresses", cdk.listValidator(cdk.validateString))(properties.destinationAddresses));
  errors.collect(cdk.propertyValidator("destinationPortRanges", cdk.listValidator(CfnNetworkInsightsAnalysisPortRangePropertyValidator))(properties.destinationPortRanges));
  errors.collect(cdk.propertyValidator("protocol", cdk.validateString)(properties.protocol));
  errors.collect(cdk.propertyValidator("sourceAddresses", cdk.listValidator(cdk.validateString))(properties.sourceAddresses));
  errors.collect(cdk.propertyValidator("sourcePortRanges", cdk.listValidator(CfnNetworkInsightsAnalysisPortRangePropertyValidator))(properties.sourcePortRanges));
  return errors.wrap("supplied properties not correct for \"AnalysisPacketHeaderProperty\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInsightsAnalysisAnalysisPacketHeaderPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInsightsAnalysisAnalysisPacketHeaderPropertyValidator(properties).assertSuccess();
  return {
    "DestinationAddresses": cdk.listMapper(cdk.stringToCloudFormation)(properties.destinationAddresses),
    "DestinationPortRanges": cdk.listMapper(convertCfnNetworkInsightsAnalysisPortRangePropertyToCloudFormation)(properties.destinationPortRanges),
    "Protocol": cdk.stringToCloudFormation(properties.protocol),
    "SourceAddresses": cdk.listMapper(cdk.stringToCloudFormation)(properties.sourceAddresses),
    "SourcePortRanges": cdk.listMapper(convertCfnNetworkInsightsAnalysisPortRangePropertyToCloudFormation)(properties.sourcePortRanges)
  };
}

// @ts-ignore TS6133
function CfnNetworkInsightsAnalysisAnalysisPacketHeaderPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNetworkInsightsAnalysis.AnalysisPacketHeaderProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInsightsAnalysis.AnalysisPacketHeaderProperty>();
  ret.addPropertyResult("destinationAddresses", "DestinationAddresses", (properties.DestinationAddresses != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.DestinationAddresses) : undefined));
  ret.addPropertyResult("destinationPortRanges", "DestinationPortRanges", (properties.DestinationPortRanges != null ? cfn_parse.FromCloudFormation.getArray(CfnNetworkInsightsAnalysisPortRangePropertyFromCloudFormation)(properties.DestinationPortRanges) : undefined));
  ret.addPropertyResult("protocol", "Protocol", (properties.Protocol != null ? cfn_parse.FromCloudFormation.getString(properties.Protocol) : undefined));
  ret.addPropertyResult("sourceAddresses", "SourceAddresses", (properties.SourceAddresses != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SourceAddresses) : undefined));
  ret.addPropertyResult("sourcePortRanges", "SourcePortRanges", (properties.SourcePortRanges != null ? cfn_parse.FromCloudFormation.getArray(CfnNetworkInsightsAnalysisPortRangePropertyFromCloudFormation)(properties.SourcePortRanges) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `AnalysisSecurityGroupRuleProperty`
 *
 * @param properties - the TypeScript properties of a `AnalysisSecurityGroupRuleProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInsightsAnalysisAnalysisSecurityGroupRulePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("cidr", cdk.validateString)(properties.cidr));
  errors.collect(cdk.propertyValidator("direction", cdk.validateString)(properties.direction));
  errors.collect(cdk.propertyValidator("portRange", CfnNetworkInsightsAnalysisPortRangePropertyValidator)(properties.portRange));
  errors.collect(cdk.propertyValidator("prefixListId", cdk.validateString)(properties.prefixListId));
  errors.collect(cdk.propertyValidator("protocol", cdk.validateString)(properties.protocol));
  errors.collect(cdk.propertyValidator("securityGroupId", cdk.validateString)(properties.securityGroupId));
  return errors.wrap("supplied properties not correct for \"AnalysisSecurityGroupRuleProperty\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInsightsAnalysisAnalysisSecurityGroupRulePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInsightsAnalysisAnalysisSecurityGroupRulePropertyValidator(properties).assertSuccess();
  return {
    "Cidr": cdk.stringToCloudFormation(properties.cidr),
    "Direction": cdk.stringToCloudFormation(properties.direction),
    "PortRange": convertCfnNetworkInsightsAnalysisPortRangePropertyToCloudFormation(properties.portRange),
    "PrefixListId": cdk.stringToCloudFormation(properties.prefixListId),
    "Protocol": cdk.stringToCloudFormation(properties.protocol),
    "SecurityGroupId": cdk.stringToCloudFormation(properties.securityGroupId)
  };
}

// @ts-ignore TS6133
function CfnNetworkInsightsAnalysisAnalysisSecurityGroupRulePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNetworkInsightsAnalysis.AnalysisSecurityGroupRuleProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInsightsAnalysis.AnalysisSecurityGroupRuleProperty>();
  ret.addPropertyResult("cidr", "Cidr", (properties.Cidr != null ? cfn_parse.FromCloudFormation.getString(properties.Cidr) : undefined));
  ret.addPropertyResult("direction", "Direction", (properties.Direction != null ? cfn_parse.FromCloudFormation.getString(properties.Direction) : undefined));
  ret.addPropertyResult("portRange", "PortRange", (properties.PortRange != null ? CfnNetworkInsightsAnalysisPortRangePropertyFromCloudFormation(properties.PortRange) : undefined));
  ret.addPropertyResult("prefixListId", "PrefixListId", (properties.PrefixListId != null ? cfn_parse.FromCloudFormation.getString(properties.PrefixListId) : undefined));
  ret.addPropertyResult("protocol", "Protocol", (properties.Protocol != null ? cfn_parse.FromCloudFormation.getString(properties.Protocol) : undefined));
  ret.addPropertyResult("securityGroupId", "SecurityGroupId", (properties.SecurityGroupId != null ? cfn_parse.FromCloudFormation.getString(properties.SecurityGroupId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `AnalysisLoadBalancerListenerProperty`
 *
 * @param properties - the TypeScript properties of a `AnalysisLoadBalancerListenerProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInsightsAnalysisAnalysisLoadBalancerListenerPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("instancePort", cdk.validateNumber)(properties.instancePort));
  errors.collect(cdk.propertyValidator("loadBalancerPort", cdk.validateNumber)(properties.loadBalancerPort));
  return errors.wrap("supplied properties not correct for \"AnalysisLoadBalancerListenerProperty\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInsightsAnalysisAnalysisLoadBalancerListenerPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInsightsAnalysisAnalysisLoadBalancerListenerPropertyValidator(properties).assertSuccess();
  return {
    "InstancePort": cdk.numberToCloudFormation(properties.instancePort),
    "LoadBalancerPort": cdk.numberToCloudFormation(properties.loadBalancerPort)
  };
}

// @ts-ignore TS6133
function CfnNetworkInsightsAnalysisAnalysisLoadBalancerListenerPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNetworkInsightsAnalysis.AnalysisLoadBalancerListenerProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInsightsAnalysis.AnalysisLoadBalancerListenerProperty>();
  ret.addPropertyResult("instancePort", "InstancePort", (properties.InstancePort != null ? cfn_parse.FromCloudFormation.getNumber(properties.InstancePort) : undefined));
  ret.addPropertyResult("loadBalancerPort", "LoadBalancerPort", (properties.LoadBalancerPort != null ? cfn_parse.FromCloudFormation.getNumber(properties.LoadBalancerPort) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `TransitGatewayRouteTableRouteProperty`
 *
 * @param properties - the TypeScript properties of a `TransitGatewayRouteTableRouteProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInsightsAnalysisTransitGatewayRouteTableRoutePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("attachmentId", cdk.validateString)(properties.attachmentId));
  errors.collect(cdk.propertyValidator("destinationCidr", cdk.validateString)(properties.destinationCidr));
  errors.collect(cdk.propertyValidator("prefixListId", cdk.validateString)(properties.prefixListId));
  errors.collect(cdk.propertyValidator("resourceId", cdk.validateString)(properties.resourceId));
  errors.collect(cdk.propertyValidator("resourceType", cdk.validateString)(properties.resourceType));
  errors.collect(cdk.propertyValidator("routeOrigin", cdk.validateString)(properties.routeOrigin));
  errors.collect(cdk.propertyValidator("state", cdk.validateString)(properties.state));
  return errors.wrap("supplied properties not correct for \"TransitGatewayRouteTableRouteProperty\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInsightsAnalysisTransitGatewayRouteTableRoutePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInsightsAnalysisTransitGatewayRouteTableRoutePropertyValidator(properties).assertSuccess();
  return {
    "AttachmentId": cdk.stringToCloudFormation(properties.attachmentId),
    "DestinationCidr": cdk.stringToCloudFormation(properties.destinationCidr),
    "PrefixListId": cdk.stringToCloudFormation(properties.prefixListId),
    "ResourceId": cdk.stringToCloudFormation(properties.resourceId),
    "ResourceType": cdk.stringToCloudFormation(properties.resourceType),
    "RouteOrigin": cdk.stringToCloudFormation(properties.routeOrigin),
    "State": cdk.stringToCloudFormation(properties.state)
  };
}

// @ts-ignore TS6133
function CfnNetworkInsightsAnalysisTransitGatewayRouteTableRoutePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnNetworkInsightsAnalysis.TransitGatewayRouteTableRouteProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInsightsAnalysis.TransitGatewayRouteTableRouteProperty>();
  ret.addPropertyResult("attachmentId", "AttachmentId", (properties.AttachmentId != null ? cfn_parse.FromCloudFormation.getString(properties.AttachmentId) : undefined));
  ret.addPropertyResult("destinationCidr", "DestinationCidr", (properties.DestinationCidr != null ? cfn_parse.FromCloudFormation.getString(properties.DestinationCidr) : undefined));
  ret.addPropertyResult("prefixListId", "PrefixListId", (properties.PrefixListId != null ? cfn_parse.FromCloudFormation.getString(properties.PrefixListId) : undefined));
  ret.addPropertyResult("resourceId", "ResourceId", (properties.ResourceId != null ? cfn_parse.FromCloudFormation.getString(properties.ResourceId) : undefined));
  ret.addPropertyResult("resourceType", "ResourceType", (properties.ResourceType != null ? cfn_parse.FromCloudFormation.getString(properties.ResourceType) : undefined));
  ret.addPropertyResult("routeOrigin", "RouteOrigin", (properties.RouteOrigin != null ? cfn_parse.FromCloudFormation.getString(properties.RouteOrigin) : undefined));
  ret.addPropertyResult("state", "State", (properties.State != null ? cfn_parse.FromCloudFormation.getString(properties.State) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `AnalysisLoadBalancerTargetProperty`
 *
 * @param properties - the TypeScript properties of a `AnalysisLoadBalancerTargetProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInsightsAnalysisAnalysisLoadBalancerTargetPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("address", cdk.validateString)(properties.address));
  errors.collect(cdk.propertyValidator("availabilityZone", cdk.validateString)(properties.availabilityZone));
  errors.collect(cdk.propertyValidator("instance", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.instance));
  errors.collect(cdk.propertyValidator("port", cdk.validateNumber)(properties.port));
  return errors.wrap("supplied properties not correct for \"AnalysisLoadBalancerTargetProperty\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInsightsAnalysisAnalysisLoadBalancerTargetPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInsightsAnalysisAnalysisLoadBalancerTargetPropertyValidator(properties).assertSuccess();
  return {
    "Address": cdk.stringToCloudFormation(properties.address),
    "AvailabilityZone": cdk.stringToCloudFormation(properties.availabilityZone),
    "Instance": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.instance),
    "Port": cdk.numberToCloudFormation(properties.port)
  };
}

// @ts-ignore TS6133
function CfnNetworkInsightsAnalysisAnalysisLoadBalancerTargetPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNetworkInsightsAnalysis.AnalysisLoadBalancerTargetProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInsightsAnalysis.AnalysisLoadBalancerTargetProperty>();
  ret.addPropertyResult("address", "Address", (properties.Address != null ? cfn_parse.FromCloudFormation.getString(properties.Address) : undefined));
  ret.addPropertyResult("availabilityZone", "AvailabilityZone", (properties.AvailabilityZone != null ? cfn_parse.FromCloudFormation.getString(properties.AvailabilityZone) : undefined));
  ret.addPropertyResult("instance", "Instance", (properties.Instance != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.Instance) : undefined));
  ret.addPropertyResult("port", "Port", (properties.Port != null ? cfn_parse.FromCloudFormation.getNumber(properties.Port) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `AnalysisRouteTableRouteProperty`
 *
 * @param properties - the TypeScript properties of a `AnalysisRouteTableRouteProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInsightsAnalysisAnalysisRouteTableRoutePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("natGatewayId", cdk.validateString)(properties.natGatewayId));
  errors.collect(cdk.propertyValidator("networkInterfaceId", cdk.validateString)(properties.networkInterfaceId));
  errors.collect(cdk.propertyValidator("origin", cdk.validateString)(properties.origin));
  errors.collect(cdk.propertyValidator("state", cdk.validateString)(properties.state));
  errors.collect(cdk.propertyValidator("transitGatewayId", cdk.validateString)(properties.transitGatewayId));
  errors.collect(cdk.propertyValidator("vpcPeeringConnectionId", cdk.validateString)(properties.vpcPeeringConnectionId));
  errors.collect(cdk.propertyValidator("destinationCidr", cdk.validateString)(properties.destinationCidr));
  errors.collect(cdk.propertyValidator("destinationPrefixListId", cdk.validateString)(properties.destinationPrefixListId));
  errors.collect(cdk.propertyValidator("egressOnlyInternetGatewayId", cdk.validateString)(properties.egressOnlyInternetGatewayId));
  errors.collect(cdk.propertyValidator("gatewayId", cdk.validateString)(properties.gatewayId));
  errors.collect(cdk.propertyValidator("instanceId", cdk.validateString)(properties.instanceId));
  return errors.wrap("supplied properties not correct for \"AnalysisRouteTableRouteProperty\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInsightsAnalysisAnalysisRouteTableRoutePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInsightsAnalysisAnalysisRouteTableRoutePropertyValidator(properties).assertSuccess();
  return {
    "NatGatewayId": cdk.stringToCloudFormation(properties.natGatewayId),
    "NetworkInterfaceId": cdk.stringToCloudFormation(properties.networkInterfaceId),
    "Origin": cdk.stringToCloudFormation(properties.origin),
    "State": cdk.stringToCloudFormation(properties.state),
    "TransitGatewayId": cdk.stringToCloudFormation(properties.transitGatewayId),
    "VpcPeeringConnectionId": cdk.stringToCloudFormation(properties.vpcPeeringConnectionId),
    "destinationCidr": cdk.stringToCloudFormation(properties.destinationCidr),
    "destinationPrefixListId": cdk.stringToCloudFormation(properties.destinationPrefixListId),
    "egressOnlyInternetGatewayId": cdk.stringToCloudFormation(properties.egressOnlyInternetGatewayId),
    "gatewayId": cdk.stringToCloudFormation(properties.gatewayId),
    "instanceId": cdk.stringToCloudFormation(properties.instanceId)
  };
}

// @ts-ignore TS6133
function CfnNetworkInsightsAnalysisAnalysisRouteTableRoutePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNetworkInsightsAnalysis.AnalysisRouteTableRouteProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInsightsAnalysis.AnalysisRouteTableRouteProperty>();
  ret.addPropertyResult("destinationCidr", "destinationCidr", (properties.destinationCidr != null ? cfn_parse.FromCloudFormation.getString(properties.destinationCidr) : undefined));
  ret.addPropertyResult("destinationPrefixListId", "destinationPrefixListId", (properties.destinationPrefixListId != null ? cfn_parse.FromCloudFormation.getString(properties.destinationPrefixListId) : undefined));
  ret.addPropertyResult("egressOnlyInternetGatewayId", "egressOnlyInternetGatewayId", (properties.egressOnlyInternetGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.egressOnlyInternetGatewayId) : undefined));
  ret.addPropertyResult("gatewayId", "gatewayId", (properties.gatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.gatewayId) : undefined));
  ret.addPropertyResult("instanceId", "instanceId", (properties.instanceId != null ? cfn_parse.FromCloudFormation.getString(properties.instanceId) : undefined));
  ret.addPropertyResult("natGatewayId", "NatGatewayId", (properties.NatGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.NatGatewayId) : undefined));
  ret.addPropertyResult("networkInterfaceId", "NetworkInterfaceId", (properties.NetworkInterfaceId != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkInterfaceId) : undefined));
  ret.addPropertyResult("origin", "Origin", (properties.Origin != null ? cfn_parse.FromCloudFormation.getString(properties.Origin) : undefined));
  ret.addPropertyResult("state", "State", (properties.State != null ? cfn_parse.FromCloudFormation.getString(properties.State) : undefined));
  ret.addPropertyResult("transitGatewayId", "TransitGatewayId", (properties.TransitGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.TransitGatewayId) : undefined));
  ret.addPropertyResult("vpcPeeringConnectionId", "VpcPeeringConnectionId", (properties.VpcPeeringConnectionId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcPeeringConnectionId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `AnalysisAclRuleProperty`
 *
 * @param properties - the TypeScript properties of a `AnalysisAclRuleProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInsightsAnalysisAnalysisAclRulePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("cidr", cdk.validateString)(properties.cidr));
  errors.collect(cdk.propertyValidator("egress", cdk.validateBoolean)(properties.egress));
  errors.collect(cdk.propertyValidator("portRange", CfnNetworkInsightsAnalysisPortRangePropertyValidator)(properties.portRange));
  errors.collect(cdk.propertyValidator("protocol", cdk.validateString)(properties.protocol));
  errors.collect(cdk.propertyValidator("ruleAction", cdk.validateString)(properties.ruleAction));
  errors.collect(cdk.propertyValidator("ruleNumber", cdk.validateNumber)(properties.ruleNumber));
  return errors.wrap("supplied properties not correct for \"AnalysisAclRuleProperty\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInsightsAnalysisAnalysisAclRulePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInsightsAnalysisAnalysisAclRulePropertyValidator(properties).assertSuccess();
  return {
    "Cidr": cdk.stringToCloudFormation(properties.cidr),
    "Egress": cdk.booleanToCloudFormation(properties.egress),
    "PortRange": convertCfnNetworkInsightsAnalysisPortRangePropertyToCloudFormation(properties.portRange),
    "Protocol": cdk.stringToCloudFormation(properties.protocol),
    "RuleAction": cdk.stringToCloudFormation(properties.ruleAction),
    "RuleNumber": cdk.numberToCloudFormation(properties.ruleNumber)
  };
}

// @ts-ignore TS6133
function CfnNetworkInsightsAnalysisAnalysisAclRulePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNetworkInsightsAnalysis.AnalysisAclRuleProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInsightsAnalysis.AnalysisAclRuleProperty>();
  ret.addPropertyResult("cidr", "Cidr", (properties.Cidr != null ? cfn_parse.FromCloudFormation.getString(properties.Cidr) : undefined));
  ret.addPropertyResult("egress", "Egress", (properties.Egress != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Egress) : undefined));
  ret.addPropertyResult("portRange", "PortRange", (properties.PortRange != null ? CfnNetworkInsightsAnalysisPortRangePropertyFromCloudFormation(properties.PortRange) : undefined));
  ret.addPropertyResult("protocol", "Protocol", (properties.Protocol != null ? cfn_parse.FromCloudFormation.getString(properties.Protocol) : undefined));
  ret.addPropertyResult("ruleAction", "RuleAction", (properties.RuleAction != null ? cfn_parse.FromCloudFormation.getString(properties.RuleAction) : undefined));
  ret.addPropertyResult("ruleNumber", "RuleNumber", (properties.RuleNumber != null ? cfn_parse.FromCloudFormation.getNumber(properties.RuleNumber) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `ExplanationProperty`
 *
 * @param properties - the TypeScript properties of a `ExplanationProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInsightsAnalysisExplanationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("acl", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.acl));
  errors.collect(cdk.propertyValidator("aclRule", CfnNetworkInsightsAnalysisAnalysisAclRulePropertyValidator)(properties.aclRule));
  errors.collect(cdk.propertyValidator("address", cdk.validateString)(properties.address));
  errors.collect(cdk.propertyValidator("addresses", cdk.listValidator(cdk.validateString))(properties.addresses));
  errors.collect(cdk.propertyValidator("attachedTo", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.attachedTo));
  errors.collect(cdk.propertyValidator("availabilityZones", cdk.listValidator(cdk.validateString))(properties.availabilityZones));
  errors.collect(cdk.propertyValidator("cidrs", cdk.listValidator(cdk.validateString))(properties.cidrs));
  errors.collect(cdk.propertyValidator("classicLoadBalancerListener", CfnNetworkInsightsAnalysisAnalysisLoadBalancerListenerPropertyValidator)(properties.classicLoadBalancerListener));
  errors.collect(cdk.propertyValidator("component", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.component));
  errors.collect(cdk.propertyValidator("componentAccount", cdk.validateString)(properties.componentAccount));
  errors.collect(cdk.propertyValidator("componentRegion", cdk.validateString)(properties.componentRegion));
  errors.collect(cdk.propertyValidator("customerGateway", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.customerGateway));
  errors.collect(cdk.propertyValidator("destination", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.destination));
  errors.collect(cdk.propertyValidator("destinationVpc", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.destinationVpc));
  errors.collect(cdk.propertyValidator("direction", cdk.validateString)(properties.direction));
  errors.collect(cdk.propertyValidator("elasticLoadBalancerListener", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.elasticLoadBalancerListener));
  errors.collect(cdk.propertyValidator("explanationCode", cdk.validateString)(properties.explanationCode));
  errors.collect(cdk.propertyValidator("ingressRouteTable", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.ingressRouteTable));
  errors.collect(cdk.propertyValidator("internetGateway", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.internetGateway));
  errors.collect(cdk.propertyValidator("loadBalancerArn", cdk.validateString)(properties.loadBalancerArn));
  errors.collect(cdk.propertyValidator("loadBalancerListenerPort", cdk.validateNumber)(properties.loadBalancerListenerPort));
  errors.collect(cdk.propertyValidator("loadBalancerTarget", CfnNetworkInsightsAnalysisAnalysisLoadBalancerTargetPropertyValidator)(properties.loadBalancerTarget));
  errors.collect(cdk.propertyValidator("loadBalancerTargetGroup", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.loadBalancerTargetGroup));
  errors.collect(cdk.propertyValidator("loadBalancerTargetGroups", cdk.listValidator(CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator))(properties.loadBalancerTargetGroups));
  errors.collect(cdk.propertyValidator("loadBalancerTargetPort", cdk.validateNumber)(properties.loadBalancerTargetPort));
  errors.collect(cdk.propertyValidator("missingComponent", cdk.validateString)(properties.missingComponent));
  errors.collect(cdk.propertyValidator("natGateway", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.natGateway));
  errors.collect(cdk.propertyValidator("networkInterface", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.networkInterface));
  errors.collect(cdk.propertyValidator("packetField", cdk.validateString)(properties.packetField));
  errors.collect(cdk.propertyValidator("port", cdk.validateNumber)(properties.port));
  errors.collect(cdk.propertyValidator("portRanges", cdk.listValidator(CfnNetworkInsightsAnalysisPortRangePropertyValidator))(properties.portRanges));
  errors.collect(cdk.propertyValidator("prefixList", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.prefixList));
  errors.collect(cdk.propertyValidator("protocols", cdk.listValidator(cdk.validateString))(properties.protocols));
  errors.collect(cdk.propertyValidator("routeTable", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.routeTable));
  errors.collect(cdk.propertyValidator("routeTableRoute", CfnNetworkInsightsAnalysisAnalysisRouteTableRoutePropertyValidator)(properties.routeTableRoute));
  errors.collect(cdk.propertyValidator("securityGroup", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.securityGroup));
  errors.collect(cdk.propertyValidator("securityGroupRule", CfnNetworkInsightsAnalysisAnalysisSecurityGroupRulePropertyValidator)(properties.securityGroupRule));
  errors.collect(cdk.propertyValidator("securityGroups", cdk.listValidator(CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator))(properties.securityGroups));
  errors.collect(cdk.propertyValidator("sourceVpc", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.sourceVpc));
  errors.collect(cdk.propertyValidator("state", cdk.validateString)(properties.state));
  errors.collect(cdk.propertyValidator("subnet", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.subnet));
  errors.collect(cdk.propertyValidator("subnetRouteTable", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.subnetRouteTable));
  errors.collect(cdk.propertyValidator("transitGateway", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.transitGateway));
  errors.collect(cdk.propertyValidator("transitGatewayAttachment", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.transitGatewayAttachment));
  errors.collect(cdk.propertyValidator("transitGatewayRouteTable", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.transitGatewayRouteTable));
  errors.collect(cdk.propertyValidator("transitGatewayRouteTableRoute", CfnNetworkInsightsAnalysisTransitGatewayRouteTableRoutePropertyValidator)(properties.transitGatewayRouteTableRoute));
  errors.collect(cdk.propertyValidator("vpc", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.vpc));
  errors.collect(cdk.propertyValidator("vpcPeeringConnection", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.vpcPeeringConnection));
  errors.collect(cdk.propertyValidator("vpnConnection", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.vpnConnection));
  errors.collect(cdk.propertyValidator("vpnGateway", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.vpnGateway));
  errors.collect(cdk.propertyValidator("vpcEndpoint", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.vpcEndpoint));
  return errors.wrap("supplied properties not correct for \"ExplanationProperty\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInsightsAnalysisExplanationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInsightsAnalysisExplanationPropertyValidator(properties).assertSuccess();
  return {
    "Acl": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.acl),
    "AclRule": convertCfnNetworkInsightsAnalysisAnalysisAclRulePropertyToCloudFormation(properties.aclRule),
    "Address": cdk.stringToCloudFormation(properties.address),
    "Addresses": cdk.listMapper(cdk.stringToCloudFormation)(properties.addresses),
    "AttachedTo": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.attachedTo),
    "AvailabilityZones": cdk.listMapper(cdk.stringToCloudFormation)(properties.availabilityZones),
    "Cidrs": cdk.listMapper(cdk.stringToCloudFormation)(properties.cidrs),
    "ClassicLoadBalancerListener": convertCfnNetworkInsightsAnalysisAnalysisLoadBalancerListenerPropertyToCloudFormation(properties.classicLoadBalancerListener),
    "Component": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.component),
    "ComponentAccount": cdk.stringToCloudFormation(properties.componentAccount),
    "ComponentRegion": cdk.stringToCloudFormation(properties.componentRegion),
    "CustomerGateway": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.customerGateway),
    "Destination": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.destination),
    "DestinationVpc": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.destinationVpc),
    "Direction": cdk.stringToCloudFormation(properties.direction),
    "ElasticLoadBalancerListener": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.elasticLoadBalancerListener),
    "ExplanationCode": cdk.stringToCloudFormation(properties.explanationCode),
    "IngressRouteTable": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.ingressRouteTable),
    "InternetGateway": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.internetGateway),
    "LoadBalancerArn": cdk.stringToCloudFormation(properties.loadBalancerArn),
    "LoadBalancerListenerPort": cdk.numberToCloudFormation(properties.loadBalancerListenerPort),
    "LoadBalancerTarget": convertCfnNetworkInsightsAnalysisAnalysisLoadBalancerTargetPropertyToCloudFormation(properties.loadBalancerTarget),
    "LoadBalancerTargetGroup": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.loadBalancerTargetGroup),
    "LoadBalancerTargetGroups": cdk.listMapper(convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation)(properties.loadBalancerTargetGroups),
    "LoadBalancerTargetPort": cdk.numberToCloudFormation(properties.loadBalancerTargetPort),
    "MissingComponent": cdk.stringToCloudFormation(properties.missingComponent),
    "NatGateway": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.natGateway),
    "NetworkInterface": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.networkInterface),
    "PacketField": cdk.stringToCloudFormation(properties.packetField),
    "Port": cdk.numberToCloudFormation(properties.port),
    "PortRanges": cdk.listMapper(convertCfnNetworkInsightsAnalysisPortRangePropertyToCloudFormation)(properties.portRanges),
    "PrefixList": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.prefixList),
    "Protocols": cdk.listMapper(cdk.stringToCloudFormation)(properties.protocols),
    "RouteTable": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.routeTable),
    "RouteTableRoute": convertCfnNetworkInsightsAnalysisAnalysisRouteTableRoutePropertyToCloudFormation(properties.routeTableRoute),
    "SecurityGroup": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.securityGroup),
    "SecurityGroupRule": convertCfnNetworkInsightsAnalysisAnalysisSecurityGroupRulePropertyToCloudFormation(properties.securityGroupRule),
    "SecurityGroups": cdk.listMapper(convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation)(properties.securityGroups),
    "SourceVpc": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.sourceVpc),
    "State": cdk.stringToCloudFormation(properties.state),
    "Subnet": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.subnet),
    "SubnetRouteTable": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.subnetRouteTable),
    "TransitGateway": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.transitGateway),
    "TransitGatewayAttachment": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.transitGatewayAttachment),
    "TransitGatewayRouteTable": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.transitGatewayRouteTable),
    "TransitGatewayRouteTableRoute": convertCfnNetworkInsightsAnalysisTransitGatewayRouteTableRoutePropertyToCloudFormation(properties.transitGatewayRouteTableRoute),
    "Vpc": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.vpc),
    "VpcPeeringConnection": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.vpcPeeringConnection),
    "VpnConnection": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.vpnConnection),
    "VpnGateway": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.vpnGateway),
    "vpcEndpoint": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.vpcEndpoint)
  };
}

// @ts-ignore TS6133
function CfnNetworkInsightsAnalysisExplanationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNetworkInsightsAnalysis.ExplanationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInsightsAnalysis.ExplanationProperty>();
  ret.addPropertyResult("acl", "Acl", (properties.Acl != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.Acl) : undefined));
  ret.addPropertyResult("aclRule", "AclRule", (properties.AclRule != null ? CfnNetworkInsightsAnalysisAnalysisAclRulePropertyFromCloudFormation(properties.AclRule) : undefined));
  ret.addPropertyResult("address", "Address", (properties.Address != null ? cfn_parse.FromCloudFormation.getString(properties.Address) : undefined));
  ret.addPropertyResult("addresses", "Addresses", (properties.Addresses != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.Addresses) : undefined));
  ret.addPropertyResult("attachedTo", "AttachedTo", (properties.AttachedTo != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.AttachedTo) : undefined));
  ret.addPropertyResult("availabilityZones", "AvailabilityZones", (properties.AvailabilityZones != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.AvailabilityZones) : undefined));
  ret.addPropertyResult("cidrs", "Cidrs", (properties.Cidrs != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.Cidrs) : undefined));
  ret.addPropertyResult("classicLoadBalancerListener", "ClassicLoadBalancerListener", (properties.ClassicLoadBalancerListener != null ? CfnNetworkInsightsAnalysisAnalysisLoadBalancerListenerPropertyFromCloudFormation(properties.ClassicLoadBalancerListener) : undefined));
  ret.addPropertyResult("component", "Component", (properties.Component != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.Component) : undefined));
  ret.addPropertyResult("componentAccount", "ComponentAccount", (properties.ComponentAccount != null ? cfn_parse.FromCloudFormation.getString(properties.ComponentAccount) : undefined));
  ret.addPropertyResult("componentRegion", "ComponentRegion", (properties.ComponentRegion != null ? cfn_parse.FromCloudFormation.getString(properties.ComponentRegion) : undefined));
  ret.addPropertyResult("customerGateway", "CustomerGateway", (properties.CustomerGateway != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.CustomerGateway) : undefined));
  ret.addPropertyResult("destination", "Destination", (properties.Destination != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.Destination) : undefined));
  ret.addPropertyResult("destinationVpc", "DestinationVpc", (properties.DestinationVpc != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.DestinationVpc) : undefined));
  ret.addPropertyResult("direction", "Direction", (properties.Direction != null ? cfn_parse.FromCloudFormation.getString(properties.Direction) : undefined));
  ret.addPropertyResult("elasticLoadBalancerListener", "ElasticLoadBalancerListener", (properties.ElasticLoadBalancerListener != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.ElasticLoadBalancerListener) : undefined));
  ret.addPropertyResult("explanationCode", "ExplanationCode", (properties.ExplanationCode != null ? cfn_parse.FromCloudFormation.getString(properties.ExplanationCode) : undefined));
  ret.addPropertyResult("ingressRouteTable", "IngressRouteTable", (properties.IngressRouteTable != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.IngressRouteTable) : undefined));
  ret.addPropertyResult("internetGateway", "InternetGateway", (properties.InternetGateway != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.InternetGateway) : undefined));
  ret.addPropertyResult("loadBalancerArn", "LoadBalancerArn", (properties.LoadBalancerArn != null ? cfn_parse.FromCloudFormation.getString(properties.LoadBalancerArn) : undefined));
  ret.addPropertyResult("loadBalancerListenerPort", "LoadBalancerListenerPort", (properties.LoadBalancerListenerPort != null ? cfn_parse.FromCloudFormation.getNumber(properties.LoadBalancerListenerPort) : undefined));
  ret.addPropertyResult("loadBalancerTarget", "LoadBalancerTarget", (properties.LoadBalancerTarget != null ? CfnNetworkInsightsAnalysisAnalysisLoadBalancerTargetPropertyFromCloudFormation(properties.LoadBalancerTarget) : undefined));
  ret.addPropertyResult("loadBalancerTargetGroup", "LoadBalancerTargetGroup", (properties.LoadBalancerTargetGroup != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.LoadBalancerTargetGroup) : undefined));
  ret.addPropertyResult("loadBalancerTargetGroups", "LoadBalancerTargetGroups", (properties.LoadBalancerTargetGroups != null ? cfn_parse.FromCloudFormation.getArray(CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation)(properties.LoadBalancerTargetGroups) : undefined));
  ret.addPropertyResult("loadBalancerTargetPort", "LoadBalancerTargetPort", (properties.LoadBalancerTargetPort != null ? cfn_parse.FromCloudFormation.getNumber(properties.LoadBalancerTargetPort) : undefined));
  ret.addPropertyResult("missingComponent", "MissingComponent", (properties.MissingComponent != null ? cfn_parse.FromCloudFormation.getString(properties.MissingComponent) : undefined));
  ret.addPropertyResult("natGateway", "NatGateway", (properties.NatGateway != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.NatGateway) : undefined));
  ret.addPropertyResult("networkInterface", "NetworkInterface", (properties.NetworkInterface != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.NetworkInterface) : undefined));
  ret.addPropertyResult("packetField", "PacketField", (properties.PacketField != null ? cfn_parse.FromCloudFormation.getString(properties.PacketField) : undefined));
  ret.addPropertyResult("port", "Port", (properties.Port != null ? cfn_parse.FromCloudFormation.getNumber(properties.Port) : undefined));
  ret.addPropertyResult("portRanges", "PortRanges", (properties.PortRanges != null ? cfn_parse.FromCloudFormation.getArray(CfnNetworkInsightsAnalysisPortRangePropertyFromCloudFormation)(properties.PortRanges) : undefined));
  ret.addPropertyResult("prefixList", "PrefixList", (properties.PrefixList != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.PrefixList) : undefined));
  ret.addPropertyResult("protocols", "Protocols", (properties.Protocols != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.Protocols) : undefined));
  ret.addPropertyResult("routeTable", "RouteTable", (properties.RouteTable != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.RouteTable) : undefined));
  ret.addPropertyResult("routeTableRoute", "RouteTableRoute", (properties.RouteTableRoute != null ? CfnNetworkInsightsAnalysisAnalysisRouteTableRoutePropertyFromCloudFormation(properties.RouteTableRoute) : undefined));
  ret.addPropertyResult("securityGroup", "SecurityGroup", (properties.SecurityGroup != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.SecurityGroup) : undefined));
  ret.addPropertyResult("securityGroupRule", "SecurityGroupRule", (properties.SecurityGroupRule != null ? CfnNetworkInsightsAnalysisAnalysisSecurityGroupRulePropertyFromCloudFormation(properties.SecurityGroupRule) : undefined));
  ret.addPropertyResult("securityGroups", "SecurityGroups", (properties.SecurityGroups != null ? cfn_parse.FromCloudFormation.getArray(CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation)(properties.SecurityGroups) : undefined));
  ret.addPropertyResult("sourceVpc", "SourceVpc", (properties.SourceVpc != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.SourceVpc) : undefined));
  ret.addPropertyResult("state", "State", (properties.State != null ? cfn_parse.FromCloudFormation.getString(properties.State) : undefined));
  ret.addPropertyResult("subnet", "Subnet", (properties.Subnet != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.Subnet) : undefined));
  ret.addPropertyResult("subnetRouteTable", "SubnetRouteTable", (properties.SubnetRouteTable != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.SubnetRouteTable) : undefined));
  ret.addPropertyResult("transitGateway", "TransitGateway", (properties.TransitGateway != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.TransitGateway) : undefined));
  ret.addPropertyResult("transitGatewayAttachment", "TransitGatewayAttachment", (properties.TransitGatewayAttachment != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.TransitGatewayAttachment) : undefined));
  ret.addPropertyResult("transitGatewayRouteTable", "TransitGatewayRouteTable", (properties.TransitGatewayRouteTable != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.TransitGatewayRouteTable) : undefined));
  ret.addPropertyResult("transitGatewayRouteTableRoute", "TransitGatewayRouteTableRoute", (properties.TransitGatewayRouteTableRoute != null ? CfnNetworkInsightsAnalysisTransitGatewayRouteTableRoutePropertyFromCloudFormation(properties.TransitGatewayRouteTableRoute) : undefined));
  ret.addPropertyResult("vpc", "Vpc", (properties.Vpc != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.Vpc) : undefined));
  ret.addPropertyResult("vpcEndpoint", "vpcEndpoint", (properties.vpcEndpoint != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.vpcEndpoint) : undefined));
  ret.addPropertyResult("vpcPeeringConnection", "VpcPeeringConnection", (properties.VpcPeeringConnection != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.VpcPeeringConnection) : undefined));
  ret.addPropertyResult("vpnConnection", "VpnConnection", (properties.VpnConnection != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.VpnConnection) : undefined));
  ret.addPropertyResult("vpnGateway", "VpnGateway", (properties.VpnGateway != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.VpnGateway) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `PathComponentProperty`
 *
 * @param properties - the TypeScript properties of a `PathComponentProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInsightsAnalysisPathComponentPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("aclRule", CfnNetworkInsightsAnalysisAnalysisAclRulePropertyValidator)(properties.aclRule));
  errors.collect(cdk.propertyValidator("additionalDetails", cdk.listValidator(CfnNetworkInsightsAnalysisAdditionalDetailPropertyValidator))(properties.additionalDetails));
  errors.collect(cdk.propertyValidator("component", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.component));
  errors.collect(cdk.propertyValidator("destinationVpc", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.destinationVpc));
  errors.collect(cdk.propertyValidator("elasticLoadBalancerListener", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.elasticLoadBalancerListener));
  errors.collect(cdk.propertyValidator("explanations", cdk.listValidator(CfnNetworkInsightsAnalysisExplanationPropertyValidator))(properties.explanations));
  errors.collect(cdk.propertyValidator("inboundHeader", CfnNetworkInsightsAnalysisAnalysisPacketHeaderPropertyValidator)(properties.inboundHeader));
  errors.collect(cdk.propertyValidator("outboundHeader", CfnNetworkInsightsAnalysisAnalysisPacketHeaderPropertyValidator)(properties.outboundHeader));
  errors.collect(cdk.propertyValidator("routeTableRoute", CfnNetworkInsightsAnalysisAnalysisRouteTableRoutePropertyValidator)(properties.routeTableRoute));
  errors.collect(cdk.propertyValidator("securityGroupRule", CfnNetworkInsightsAnalysisAnalysisSecurityGroupRulePropertyValidator)(properties.securityGroupRule));
  errors.collect(cdk.propertyValidator("sequenceNumber", cdk.validateNumber)(properties.sequenceNumber));
  errors.collect(cdk.propertyValidator("serviceName", cdk.validateString)(properties.serviceName));
  errors.collect(cdk.propertyValidator("sourceVpc", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.sourceVpc));
  errors.collect(cdk.propertyValidator("subnet", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.subnet));
  errors.collect(cdk.propertyValidator("transitGateway", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.transitGateway));
  errors.collect(cdk.propertyValidator("transitGatewayRouteTableRoute", CfnNetworkInsightsAnalysisTransitGatewayRouteTableRoutePropertyValidator)(properties.transitGatewayRouteTableRoute));
  errors.collect(cdk.propertyValidator("vpc", CfnNetworkInsightsAnalysisAnalysisComponentPropertyValidator)(properties.vpc));
  return errors.wrap("supplied properties not correct for \"PathComponentProperty\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInsightsAnalysisPathComponentPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInsightsAnalysisPathComponentPropertyValidator(properties).assertSuccess();
  return {
    "AclRule": convertCfnNetworkInsightsAnalysisAnalysisAclRulePropertyToCloudFormation(properties.aclRule),
    "AdditionalDetails": cdk.listMapper(convertCfnNetworkInsightsAnalysisAdditionalDetailPropertyToCloudFormation)(properties.additionalDetails),
    "Component": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.component),
    "DestinationVpc": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.destinationVpc),
    "ElasticLoadBalancerListener": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.elasticLoadBalancerListener),
    "Explanations": cdk.listMapper(convertCfnNetworkInsightsAnalysisExplanationPropertyToCloudFormation)(properties.explanations),
    "InboundHeader": convertCfnNetworkInsightsAnalysisAnalysisPacketHeaderPropertyToCloudFormation(properties.inboundHeader),
    "OutboundHeader": convertCfnNetworkInsightsAnalysisAnalysisPacketHeaderPropertyToCloudFormation(properties.outboundHeader),
    "RouteTableRoute": convertCfnNetworkInsightsAnalysisAnalysisRouteTableRoutePropertyToCloudFormation(properties.routeTableRoute),
    "SecurityGroupRule": convertCfnNetworkInsightsAnalysisAnalysisSecurityGroupRulePropertyToCloudFormation(properties.securityGroupRule),
    "SequenceNumber": cdk.numberToCloudFormation(properties.sequenceNumber),
    "ServiceName": cdk.stringToCloudFormation(properties.serviceName),
    "SourceVpc": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.sourceVpc),
    "Subnet": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.subnet),
    "TransitGateway": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.transitGateway),
    "TransitGatewayRouteTableRoute": convertCfnNetworkInsightsAnalysisTransitGatewayRouteTableRoutePropertyToCloudFormation(properties.transitGatewayRouteTableRoute),
    "Vpc": convertCfnNetworkInsightsAnalysisAnalysisComponentPropertyToCloudFormation(properties.vpc)
  };
}

// @ts-ignore TS6133
function CfnNetworkInsightsAnalysisPathComponentPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnNetworkInsightsAnalysis.PathComponentProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInsightsAnalysis.PathComponentProperty>();
  ret.addPropertyResult("aclRule", "AclRule", (properties.AclRule != null ? CfnNetworkInsightsAnalysisAnalysisAclRulePropertyFromCloudFormation(properties.AclRule) : undefined));
  ret.addPropertyResult("additionalDetails", "AdditionalDetails", (properties.AdditionalDetails != null ? cfn_parse.FromCloudFormation.getArray(CfnNetworkInsightsAnalysisAdditionalDetailPropertyFromCloudFormation)(properties.AdditionalDetails) : undefined));
  ret.addPropertyResult("component", "Component", (properties.Component != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.Component) : undefined));
  ret.addPropertyResult("destinationVpc", "DestinationVpc", (properties.DestinationVpc != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.DestinationVpc) : undefined));
  ret.addPropertyResult("elasticLoadBalancerListener", "ElasticLoadBalancerListener", (properties.ElasticLoadBalancerListener != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.ElasticLoadBalancerListener) : undefined));
  ret.addPropertyResult("explanations", "Explanations", (properties.Explanations != null ? cfn_parse.FromCloudFormation.getArray(CfnNetworkInsightsAnalysisExplanationPropertyFromCloudFormation)(properties.Explanations) : undefined));
  ret.addPropertyResult("inboundHeader", "InboundHeader", (properties.InboundHeader != null ? CfnNetworkInsightsAnalysisAnalysisPacketHeaderPropertyFromCloudFormation(properties.InboundHeader) : undefined));
  ret.addPropertyResult("outboundHeader", "OutboundHeader", (properties.OutboundHeader != null ? CfnNetworkInsightsAnalysisAnalysisPacketHeaderPropertyFromCloudFormation(properties.OutboundHeader) : undefined));
  ret.addPropertyResult("routeTableRoute", "RouteTableRoute", (properties.RouteTableRoute != null ? CfnNetworkInsightsAnalysisAnalysisRouteTableRoutePropertyFromCloudFormation(properties.RouteTableRoute) : undefined));
  ret.addPropertyResult("securityGroupRule", "SecurityGroupRule", (properties.SecurityGroupRule != null ? CfnNetworkInsightsAnalysisAnalysisSecurityGroupRulePropertyFromCloudFormation(properties.SecurityGroupRule) : undefined));
  ret.addPropertyResult("sequenceNumber", "SequenceNumber", (properties.SequenceNumber != null ? cfn_parse.FromCloudFormation.getNumber(properties.SequenceNumber) : undefined));
  ret.addPropertyResult("serviceName", "ServiceName", (properties.ServiceName != null ? cfn_parse.FromCloudFormation.getString(properties.ServiceName) : undefined));
  ret.addPropertyResult("sourceVpc", "SourceVpc", (properties.SourceVpc != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.SourceVpc) : undefined));
  ret.addPropertyResult("subnet", "Subnet", (properties.Subnet != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.Subnet) : undefined));
  ret.addPropertyResult("transitGateway", "TransitGateway", (properties.TransitGateway != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.TransitGateway) : undefined));
  ret.addPropertyResult("transitGatewayRouteTableRoute", "TransitGatewayRouteTableRoute", (properties.TransitGatewayRouteTableRoute != null ? CfnNetworkInsightsAnalysisTransitGatewayRouteTableRoutePropertyFromCloudFormation(properties.TransitGatewayRouteTableRoute) : undefined));
  ret.addPropertyResult("vpc", "Vpc", (properties.Vpc != null ? CfnNetworkInsightsAnalysisAnalysisComponentPropertyFromCloudFormation(properties.Vpc) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `AlternatePathHintProperty`
 *
 * @param properties - the TypeScript properties of a `AlternatePathHintProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInsightsAnalysisAlternatePathHintPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("componentArn", cdk.validateString)(properties.componentArn));
  errors.collect(cdk.propertyValidator("componentId", cdk.validateString)(properties.componentId));
  return errors.wrap("supplied properties not correct for \"AlternatePathHintProperty\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInsightsAnalysisAlternatePathHintPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInsightsAnalysisAlternatePathHintPropertyValidator(properties).assertSuccess();
  return {
    "ComponentArn": cdk.stringToCloudFormation(properties.componentArn),
    "ComponentId": cdk.stringToCloudFormation(properties.componentId)
  };
}

// @ts-ignore TS6133
function CfnNetworkInsightsAnalysisAlternatePathHintPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNetworkInsightsAnalysis.AlternatePathHintProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInsightsAnalysis.AlternatePathHintProperty>();
  ret.addPropertyResult("componentArn", "ComponentArn", (properties.ComponentArn != null ? cfn_parse.FromCloudFormation.getString(properties.ComponentArn) : undefined));
  ret.addPropertyResult("componentId", "ComponentId", (properties.ComponentId != null ? cfn_parse.FromCloudFormation.getString(properties.ComponentId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `CfnNetworkInsightsAnalysisProps`
 *
 * @param properties - the TypeScript properties of a `CfnNetworkInsightsAnalysisProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInsightsAnalysisPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("additionalAccounts", cdk.listValidator(cdk.validateString))(properties.additionalAccounts));
  errors.collect(cdk.propertyValidator("filterInArns", cdk.listValidator(cdk.validateString))(properties.filterInArns));
  errors.collect(cdk.propertyValidator("networkInsightsPathId", cdk.requiredValidator)(properties.networkInsightsPathId));
  errors.collect(cdk.propertyValidator("networkInsightsPathId", cdk.validateString)(properties.networkInsightsPathId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \"CfnNetworkInsightsAnalysisProps\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInsightsAnalysisPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInsightsAnalysisPropsValidator(properties).assertSuccess();
  return {
    "AdditionalAccounts": cdk.listMapper(cdk.stringToCloudFormation)(properties.additionalAccounts),
    "FilterInArns": cdk.listMapper(cdk.stringToCloudFormation)(properties.filterInArns),
    "NetworkInsightsPathId": cdk.stringToCloudFormation(properties.networkInsightsPathId),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnNetworkInsightsAnalysisPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNetworkInsightsAnalysisProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInsightsAnalysisProps>();
  ret.addPropertyResult("additionalAccounts", "AdditionalAccounts", (properties.AdditionalAccounts != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.AdditionalAccounts) : undefined));
  ret.addPropertyResult("filterInArns", "FilterInArns", (properties.FilterInArns != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.FilterInArns) : undefined));
  ret.addPropertyResult("networkInsightsPathId", "NetworkInsightsPathId", (properties.NetworkInsightsPathId != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkInsightsPathId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a path to analyze for reachability.
 *
 * VPC Reachability Analyzer enables you to analyze and debug network reachability between two resources in your virtual private cloud (VPC). For more information, see the [Reachability Analyzer User Guide](https://docs.aws.amazon.com/vpc/latest/reachability/what-is-reachability-analyzer.html) .
 *
 * @cloudformationResource AWS::EC2::NetworkInsightsPath
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html
 */
export class CfnNetworkInsightsPath extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::NetworkInsightsPath";

  /**
   * Build a CfnNetworkInsightsPath from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnNetworkInsightsPath {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnNetworkInsightsPathPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnNetworkInsightsPath(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The time stamp when the path was created.
   *
   * @cloudformationAttribute CreatedDate
   */
  public readonly attrCreatedDate: string;

  /**
   * The Amazon Resource Name (ARN) of the destination.
   *
   * @cloudformationAttribute DestinationArn
   */
  public readonly attrDestinationArn: string;

  /**
   * The Amazon Resource Name (ARN) of the path.
   *
   * @cloudformationAttribute NetworkInsightsPathArn
   */
  public readonly attrNetworkInsightsPathArn: string;

  /**
   * The ID of the path.
   *
   * @cloudformationAttribute NetworkInsightsPathId
   */
  public readonly attrNetworkInsightsPathId: string;

  /**
   * The Amazon Resource Name (ARN) of the source.
   *
   * @cloudformationAttribute SourceArn
   */
  public readonly attrSourceArn: string;

  /**
   * The ID or ARN of the destination.
   */
  public destination?: string;

  /**
   * The IP address of the destination.
   */
  public destinationIp?: string;

  /**
   * The destination port.
   */
  public destinationPort?: number;

  /**
   * Scopes the analysis to network paths that match specific filters at the destination.
   */
  public filterAtDestination?: cdk.IResolvable | CfnNetworkInsightsPath.PathFilterProperty;

  /**
   * Scopes the analysis to network paths that match specific filters at the source.
   */
  public filterAtSource?: cdk.IResolvable | CfnNetworkInsightsPath.PathFilterProperty;

  /**
   * The protocol.
   */
  public protocol: string;

  /**
   * The ID or ARN of the source.
   */
  public source: string;

  /**
   * The IP address of the source.
   */
  public sourceIp?: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags to add to the path.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnNetworkInsightsPathProps) {
    super(scope, id, {
      "type": CfnNetworkInsightsPath.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "protocol", this);
    cdk.requireProperty(props, "source", this);

    this.attrCreatedDate = cdk.Token.asString(this.getAtt("CreatedDate", cdk.ResolutionTypeHint.STRING));
    this.attrDestinationArn = cdk.Token.asString(this.getAtt("DestinationArn", cdk.ResolutionTypeHint.STRING));
    this.attrNetworkInsightsPathArn = cdk.Token.asString(this.getAtt("NetworkInsightsPathArn", cdk.ResolutionTypeHint.STRING));
    this.attrNetworkInsightsPathId = cdk.Token.asString(this.getAtt("NetworkInsightsPathId", cdk.ResolutionTypeHint.STRING));
    this.attrSourceArn = cdk.Token.asString(this.getAtt("SourceArn", cdk.ResolutionTypeHint.STRING));
    this.destination = props.destination;
    this.destinationIp = props.destinationIp;
    this.destinationPort = props.destinationPort;
    this.filterAtDestination = props.filterAtDestination;
    this.filterAtSource = props.filterAtSource;
    this.protocol = props.protocol;
    this.source = props.source;
    this.sourceIp = props.sourceIp;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::NetworkInsightsPath", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "destination": this.destination,
      "destinationIp": this.destinationIp,
      "destinationPort": this.destinationPort,
      "filterAtDestination": this.filterAtDestination,
      "filterAtSource": this.filterAtSource,
      "protocol": this.protocol,
      "source": this.source,
      "sourceIp": this.sourceIp,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnNetworkInsightsPath.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnNetworkInsightsPathPropsToCloudFormation(props);
  }
}

export namespace CfnNetworkInsightsPath {
  /**
   * Describes a set of filters for a path analysis.
   *
   * Use path filters to scope the analysis when there can be multiple resulting paths.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightspath-pathfilter.html
   */
  export interface PathFilterProperty {
    /**
     * The destination IPv4 address.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightspath-pathfilter.html#cfn-ec2-networkinsightspath-pathfilter-destinationaddress
     */
    readonly destinationAddress?: string;

    /**
     * The destination port range.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightspath-pathfilter.html#cfn-ec2-networkinsightspath-pathfilter-destinationportrange
     */
    readonly destinationPortRange?: CfnNetworkInsightsPath.FilterPortRangeProperty | cdk.IResolvable;

    /**
     * The source IPv4 address.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightspath-pathfilter.html#cfn-ec2-networkinsightspath-pathfilter-sourceaddress
     */
    readonly sourceAddress?: string;

    /**
     * The source port range.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightspath-pathfilter.html#cfn-ec2-networkinsightspath-pathfilter-sourceportrange
     */
    readonly sourcePortRange?: CfnNetworkInsightsPath.FilterPortRangeProperty | cdk.IResolvable;
  }

  /**
   * Describes a port range.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightspath-filterportrange.html
   */
  export interface FilterPortRangeProperty {
    /**
     * The first port in the range.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightspath-filterportrange.html#cfn-ec2-networkinsightspath-filterportrange-fromport
     */
    readonly fromPort?: number;

    /**
     * The last port in the range.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightspath-filterportrange.html#cfn-ec2-networkinsightspath-filterportrange-toport
     */
    readonly toPort?: number;
  }
}

/**
 * Properties for defining a `CfnNetworkInsightsPath`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html
 */
export interface CfnNetworkInsightsPathProps {
  /**
   * The ID or ARN of the destination.
   *
   * If the resource is in another account, you must specify an ARN.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-destination
   */
  readonly destination?: string;

  /**
   * The IP address of the destination.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-destinationip
   */
  readonly destinationIp?: string;

  /**
   * The destination port.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-destinationport
   */
  readonly destinationPort?: number;

  /**
   * Scopes the analysis to network paths that match specific filters at the destination.
   *
   * If you specify this parameter, you can't specify the parameter for the destination IP address.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-filteratdestination
   */
  readonly filterAtDestination?: cdk.IResolvable | CfnNetworkInsightsPath.PathFilterProperty;

  /**
   * Scopes the analysis to network paths that match specific filters at the source.
   *
   * If you specify this parameter, you can't specify the parameters for the source IP address or the destination port.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-filteratsource
   */
  readonly filterAtSource?: cdk.IResolvable | CfnNetworkInsightsPath.PathFilterProperty;

  /**
   * The protocol.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-protocol
   */
  readonly protocol: string;

  /**
   * The ID or ARN of the source.
   *
   * If the resource is in another account, you must specify an ARN.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-source
   */
  readonly source: string;

  /**
   * The IP address of the source.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-sourceip
   */
  readonly sourceIp?: string;

  /**
   * The tags to add to the path.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a `FilterPortRangeProperty`
 *
 * @param properties - the TypeScript properties of a `FilterPortRangeProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInsightsPathFilterPortRangePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("fromPort", cdk.validateNumber)(properties.fromPort));
  errors.collect(cdk.propertyValidator("toPort", cdk.validateNumber)(properties.toPort));
  return errors.wrap("supplied properties not correct for \"FilterPortRangeProperty\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInsightsPathFilterPortRangePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInsightsPathFilterPortRangePropertyValidator(properties).assertSuccess();
  return {
    "FromPort": cdk.numberToCloudFormation(properties.fromPort),
    "ToPort": cdk.numberToCloudFormation(properties.toPort)
  };
}

// @ts-ignore TS6133
function CfnNetworkInsightsPathFilterPortRangePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNetworkInsightsPath.FilterPortRangeProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInsightsPath.FilterPortRangeProperty>();
  ret.addPropertyResult("fromPort", "FromPort", (properties.FromPort != null ? cfn_parse.FromCloudFormation.getNumber(properties.FromPort) : undefined));
  ret.addPropertyResult("toPort", "ToPort", (properties.ToPort != null ? cfn_parse.FromCloudFormation.getNumber(properties.ToPort) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `PathFilterProperty`
 *
 * @param properties - the TypeScript properties of a `PathFilterProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInsightsPathPathFilterPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("destinationAddress", cdk.validateString)(properties.destinationAddress));
  errors.collect(cdk.propertyValidator("destinationPortRange", CfnNetworkInsightsPathFilterPortRangePropertyValidator)(properties.destinationPortRange));
  errors.collect(cdk.propertyValidator("sourceAddress", cdk.validateString)(properties.sourceAddress));
  errors.collect(cdk.propertyValidator("sourcePortRange", CfnNetworkInsightsPathFilterPortRangePropertyValidator)(properties.sourcePortRange));
  return errors.wrap("supplied properties not correct for \"PathFilterProperty\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInsightsPathPathFilterPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInsightsPathPathFilterPropertyValidator(properties).assertSuccess();
  return {
    "DestinationAddress": cdk.stringToCloudFormation(properties.destinationAddress),
    "DestinationPortRange": convertCfnNetworkInsightsPathFilterPortRangePropertyToCloudFormation(properties.destinationPortRange),
    "SourceAddress": cdk.stringToCloudFormation(properties.sourceAddress),
    "SourcePortRange": convertCfnNetworkInsightsPathFilterPortRangePropertyToCloudFormation(properties.sourcePortRange)
  };
}

// @ts-ignore TS6133
function CfnNetworkInsightsPathPathFilterPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnNetworkInsightsPath.PathFilterProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInsightsPath.PathFilterProperty>();
  ret.addPropertyResult("destinationAddress", "DestinationAddress", (properties.DestinationAddress != null ? cfn_parse.FromCloudFormation.getString(properties.DestinationAddress) : undefined));
  ret.addPropertyResult("destinationPortRange", "DestinationPortRange", (properties.DestinationPortRange != null ? CfnNetworkInsightsPathFilterPortRangePropertyFromCloudFormation(properties.DestinationPortRange) : undefined));
  ret.addPropertyResult("sourceAddress", "SourceAddress", (properties.SourceAddress != null ? cfn_parse.FromCloudFormation.getString(properties.SourceAddress) : undefined));
  ret.addPropertyResult("sourcePortRange", "SourcePortRange", (properties.SourcePortRange != null ? CfnNetworkInsightsPathFilterPortRangePropertyFromCloudFormation(properties.SourcePortRange) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `CfnNetworkInsightsPathProps`
 *
 * @param properties - the TypeScript properties of a `CfnNetworkInsightsPathProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInsightsPathPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("destination", cdk.validateString)(properties.destination));
  errors.collect(cdk.propertyValidator("destinationIp", cdk.validateString)(properties.destinationIp));
  errors.collect(cdk.propertyValidator("destinationPort", cdk.validateNumber)(properties.destinationPort));
  errors.collect(cdk.propertyValidator("filterAtDestination", CfnNetworkInsightsPathPathFilterPropertyValidator)(properties.filterAtDestination));
  errors.collect(cdk.propertyValidator("filterAtSource", CfnNetworkInsightsPathPathFilterPropertyValidator)(properties.filterAtSource));
  errors.collect(cdk.propertyValidator("protocol", cdk.requiredValidator)(properties.protocol));
  errors.collect(cdk.propertyValidator("protocol", cdk.validateString)(properties.protocol));
  errors.collect(cdk.propertyValidator("source", cdk.requiredValidator)(properties.source));
  errors.collect(cdk.propertyValidator("source", cdk.validateString)(properties.source));
  errors.collect(cdk.propertyValidator("sourceIp", cdk.validateString)(properties.sourceIp));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \"CfnNetworkInsightsPathProps\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInsightsPathPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInsightsPathPropsValidator(properties).assertSuccess();
  return {
    "Destination": cdk.stringToCloudFormation(properties.destination),
    "DestinationIp": cdk.stringToCloudFormation(properties.destinationIp),
    "DestinationPort": cdk.numberToCloudFormation(properties.destinationPort),
    "FilterAtDestination": convertCfnNetworkInsightsPathPathFilterPropertyToCloudFormation(properties.filterAtDestination),
    "FilterAtSource": convertCfnNetworkInsightsPathPathFilterPropertyToCloudFormation(properties.filterAtSource),
    "Protocol": cdk.stringToCloudFormation(properties.protocol),
    "Source": cdk.stringToCloudFormation(properties.source),
    "SourceIp": cdk.stringToCloudFormation(properties.sourceIp),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnNetworkInsightsPathPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNetworkInsightsPathProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInsightsPathProps>();
  ret.addPropertyResult("destination", "Destination", (properties.Destination != null ? cfn_parse.FromCloudFormation.getString(properties.Destination) : undefined));
  ret.addPropertyResult("destinationIp", "DestinationIp", (properties.DestinationIp != null ? cfn_parse.FromCloudFormation.getString(properties.DestinationIp) : undefined));
  ret.addPropertyResult("destinationPort", "DestinationPort", (properties.DestinationPort != null ? cfn_parse.FromCloudFormation.getNumber(properties.DestinationPort) : undefined));
  ret.addPropertyResult("filterAtDestination", "FilterAtDestination", (properties.FilterAtDestination != null ? CfnNetworkInsightsPathPathFilterPropertyFromCloudFormation(properties.FilterAtDestination) : undefined));
  ret.addPropertyResult("filterAtSource", "FilterAtSource", (properties.FilterAtSource != null ? CfnNetworkInsightsPathPathFilterPropertyFromCloudFormation(properties.FilterAtSource) : undefined));
  ret.addPropertyResult("protocol", "Protocol", (properties.Protocol != null ? cfn_parse.FromCloudFormation.getString(properties.Protocol) : undefined));
  ret.addPropertyResult("source", "Source", (properties.Source != null ? cfn_parse.FromCloudFormation.getString(properties.Source) : undefined));
  ret.addPropertyResult("sourceIp", "SourceIp", (properties.SourceIp != null ? cfn_parse.FromCloudFormation.getString(properties.SourceIp) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Describes a network interface in an Amazon EC2 instance for AWS CloudFormation .
 *
 * @cloudformationResource AWS::EC2::NetworkInterface
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html
 */
export class CfnNetworkInterface extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::NetworkInterface";

  /**
   * Build a CfnNetworkInterface from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnNetworkInterface {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnNetworkInterfacePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnNetworkInterface(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the network interface.
   *
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The primary IPv6 address of the network interface. When you enable an IPv6 GUA address to be a primary IPv6, the first IPv6 GUA will be made the primary IPv6 address until the instance is terminated or the network interface is detached.
   *
   * @cloudformationAttribute PrimaryIpv6Address
   */
  public readonly attrPrimaryIpv6Address: string;

  /**
   * The primary private IP address of the network interface. For example, `10.0.0.192` .
   *
   * @cloudformationAttribute PrimaryPrivateIpAddress
   */
  public readonly attrPrimaryPrivateIpAddress: string;

  /**
   * The secondary private IP addresses of the network interface. For example, `["10.0.0.161", "10.0.0.162", "10.0.0.163"]` .
   *
   * @cloudformationAttribute SecondaryPrivateIpAddresses
   */
  public readonly attrSecondaryPrivateIpAddresses: Array<string>;

  /**
   * A connection tracking specification for the network interface.
   */
  public connectionTrackingSpecification?: CfnNetworkInterface.ConnectionTrackingSpecificationProperty | cdk.IResolvable;

  /**
   * A description for the network interface.
   */
  public description?: string;

  /**
   * If youre modifying a network interface in a dual-stack or IPv6-only subnet, you have the option to assign a primary IPv6 IP address.
   */
  public enablePrimaryIpv6?: boolean | cdk.IResolvable;

  /**
   * The security group IDs associated with this network interface.
   */
  public groupSet?: Array<string>;

  /**
   * The type of network interface.
   */
  public interfaceType?: string;

  /**
   * The number of IPv4 prefixes to be automatically assigned to the network interface.
   */
  public ipv4PrefixCount?: number;

  /**
   * The IPv4 delegated prefixes that are assigned to the network interface.
   */
  public ipv4Prefixes?: Array<CfnNetworkInterface.Ipv4PrefixSpecificationProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * The number of IPv6 addresses to assign to a network interface.
   */
  public ipv6AddressCount?: number;

  /**
   * One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet to associate with the network interface.
   */
  public ipv6Addresses?: Array<CfnNetworkInterface.InstanceIpv6AddressProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * The number of IPv6 prefixes to be automatically assigned to the network interface.
   */
  public ipv6PrefixCount?: number;

  /**
   * The IPv6 delegated prefixes that are assigned to the network interface.
   */
  public ipv6Prefixes?: Array<CfnNetworkInterface.Ipv6PrefixSpecificationProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * Assigns a single private IP address to the network interface, which is used as the primary private IP address.
   */
  public privateIpAddress?: string;

  /**
   * Assigns private IP addresses to the network interface.
   */
  public privateIpAddresses?: Array<cdk.IResolvable | CfnNetworkInterface.PrivateIpAddressSpecificationProperty> | cdk.IResolvable;

  /**
   * The number of secondary private IPv4 addresses to assign to a network interface.
   */
  public secondaryPrivateIpAddressCount?: number;

  /**
   * Enable or disable source/destination checks, which ensure that the instance is either the source or the destination of any traffic that it receives.
   */
  public sourceDestCheck?: boolean | cdk.IResolvable;

  /**
   * The ID of the subnet to associate with the network interface.
   */
  public subnetId: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * An arbitrary set of tags (key-value pairs) for this network interface.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnNetworkInterfaceProps) {
    super(scope, id, {
      "type": CfnNetworkInterface.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "subnetId", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.attrPrimaryIpv6Address = cdk.Token.asString(this.getAtt("PrimaryIpv6Address", cdk.ResolutionTypeHint.STRING));
    this.attrPrimaryPrivateIpAddress = cdk.Token.asString(this.getAtt("PrimaryPrivateIpAddress", cdk.ResolutionTypeHint.STRING));
    this.attrSecondaryPrivateIpAddresses = cdk.Token.asList(this.getAtt("SecondaryPrivateIpAddresses", cdk.ResolutionTypeHint.STRING_LIST));
    this.connectionTrackingSpecification = props.connectionTrackingSpecification;
    this.description = props.description;
    this.enablePrimaryIpv6 = props.enablePrimaryIpv6;
    this.groupSet = props.groupSet;
    this.interfaceType = props.interfaceType;
    this.ipv4PrefixCount = props.ipv4PrefixCount;
    this.ipv4Prefixes = props.ipv4Prefixes;
    this.ipv6AddressCount = props.ipv6AddressCount;
    this.ipv6Addresses = props.ipv6Addresses;
    this.ipv6PrefixCount = props.ipv6PrefixCount;
    this.ipv6Prefixes = props.ipv6Prefixes;
    this.privateIpAddress = props.privateIpAddress;
    this.privateIpAddresses = props.privateIpAddresses;
    this.secondaryPrivateIpAddressCount = props.secondaryPrivateIpAddressCount;
    this.sourceDestCheck = props.sourceDestCheck;
    this.subnetId = props.subnetId;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::NetworkInterface", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "connectionTrackingSpecification": this.connectionTrackingSpecification,
      "description": this.description,
      "enablePrimaryIpv6": this.enablePrimaryIpv6,
      "groupSet": this.groupSet,
      "interfaceType": this.interfaceType,
      "ipv4PrefixCount": this.ipv4PrefixCount,
      "ipv4Prefixes": this.ipv4Prefixes,
      "ipv6AddressCount": this.ipv6AddressCount,
      "ipv6Addresses": this.ipv6Addresses,
      "ipv6PrefixCount": this.ipv6PrefixCount,
      "ipv6Prefixes": this.ipv6Prefixes,
      "privateIpAddress": this.privateIpAddress,
      "privateIpAddresses": this.privateIpAddresses,
      "secondaryPrivateIpAddressCount": this.secondaryPrivateIpAddressCount,
      "sourceDestCheck": this.sourceDestCheck,
      "subnetId": this.subnetId,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnNetworkInterface.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnNetworkInterfacePropsToCloudFormation(props);
  }
}

export namespace CfnNetworkInterface {
  /**
   * Describes a secondary private IPv4 address for a network interface.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-privateipaddressspecification.html
   */
  export interface PrivateIpAddressSpecificationProperty {
    /**
     * Sets the private IP address as the primary private address.
     *
     * You can set only one primary private IP address. If you don't specify a primary private IP address, Amazon EC2 automatically assigns a primary private IP address.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-privateipaddressspecification.html#cfn-ec2-networkinterface-privateipaddressspecification-primary
     */
    readonly primary: boolean | cdk.IResolvable;

    /**
     * The private IP address of the network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-privateipaddressspecification.html#cfn-ec2-networkinterface-privateipaddressspecification-privateipaddress
     */
    readonly privateIpAddress: string;
  }

  /**
   * Describes an IPv4 prefix.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-ipv4prefixspecification.html
   */
  export interface Ipv4PrefixSpecificationProperty {
    /**
     * The IPv4 prefix.
     *
     * For information, see [Assigning prefixes to Amazon EC2 network interfaces](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-prefix-eni.html) in the *Amazon Elastic Compute Cloud User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-ipv4prefixspecification.html#cfn-ec2-networkinterface-ipv4prefixspecification-ipv4prefix
     */
    readonly ipv4Prefix: string;
  }

  /**
   * Describes the IPv6 addresses to associate with the network interface.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-instanceipv6address.html
   */
  export interface InstanceIpv6AddressProperty {
    /**
     * An IPv6 address to associate with the network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-instanceipv6address.html#cfn-ec2-networkinterface-instanceipv6address-ipv6address
     */
    readonly ipv6Address: string;
  }

  /**
   * Describes the IPv6 prefix.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-ipv6prefixspecification.html
   */
  export interface Ipv6PrefixSpecificationProperty {
    /**
     * The IPv6 prefix.
     *
     * For information, see [Assigning prefixes to Amazon EC2 network interfaces](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-prefix-eni.html) in the *Amazon Elastic Compute Cloud User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-ipv6prefixspecification.html#cfn-ec2-networkinterface-ipv6prefixspecification-ipv6prefix
     */
    readonly ipv6Prefix: string;
  }

  /**
   * Configurable options for connection tracking on a network interface.
   *
   * For more information, see [Connection tracking timeouts](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-connection-tracking.html#connection-tracking-timeouts) in the *Amazon Elastic Compute Cloud User Guide* .
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-connectiontrackingspecification.html
   */
  export interface ConnectionTrackingSpecificationProperty {
    /**
     * Timeout (in seconds) for idle TCP connections in an established state.
     *
     * Min: 60 seconds. Max: 432000 seconds (5 days). Default: 432000 seconds. Recommended: Less than 432000 seconds.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-connectiontrackingspecification.html#cfn-ec2-networkinterface-connectiontrackingspecification-tcpestablishedtimeout
     */
    readonly tcpEstablishedTimeout?: number;

    /**
     * Timeout (in seconds) for idle UDP flows classified as streams which have seen more than one request-response transaction.
     *
     * Min: 60 seconds. Max: 180 seconds (3 minutes). Default: 180 seconds.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-connectiontrackingspecification.html#cfn-ec2-networkinterface-connectiontrackingspecification-udpstreamtimeout
     */
    readonly udpStreamTimeout?: number;

    /**
     * Timeout (in seconds) for idle UDP flows that have seen traffic only in a single direction or a single request-response transaction.
     *
     * Min: 30 seconds. Max: 60 seconds. Default: 30 seconds.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-connectiontrackingspecification.html#cfn-ec2-networkinterface-connectiontrackingspecification-udptimeout
     */
    readonly udpTimeout?: number;
  }
}

/**
 * Properties for defining a `CfnNetworkInterface`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html
 */
export interface CfnNetworkInterfaceProps {
  /**
   * A connection tracking specification for the network interface.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-connectiontrackingspecification
   */
  readonly connectionTrackingSpecification?: CfnNetworkInterface.ConnectionTrackingSpecificationProperty | cdk.IResolvable;

  /**
   * A description for the network interface.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-description
   */
  readonly description?: string;

  /**
   * If youre modifying a network interface in a dual-stack or IPv6-only subnet, you have the option to assign a primary IPv6 IP address.
   *
   * A primary IPv6 address is an IPv6 GUA address associated with an ENI that you have enabled to use a primary IPv6 address. Use this option if the instance that this ENI will be attached to relies on its IPv6 address not changing. AWS will automatically assign an IPv6 address associated with the ENI attached to your instance to be the primary IPv6 address. Once you enable an IPv6 GUA address to be a primary IPv6, you cannot disable it. When you enable an IPv6 GUA address to be a primary IPv6, the first IPv6 GUA will be made the primary IPv6 address until the instance is terminated or the network interface is detached. If you have multiple IPv6 addresses associated with an ENI attached to your instance and you enable a primary IPv6 address, the first IPv6 GUA address associated with the ENI becomes the primary IPv6 address.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-enableprimaryipv6
   */
  readonly enablePrimaryIpv6?: boolean | cdk.IResolvable;

  /**
   * The security group IDs associated with this network interface.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-groupset
   */
  readonly groupSet?: Array<string>;

  /**
   * The type of network interface.
   *
   * The default is `interface` . The supported values are `efa` and `trunk` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-interfacetype
   */
  readonly interfaceType?: string;

  /**
   * The number of IPv4 prefixes to be automatically assigned to the network interface.
   *
   * When creating a network interface, you can't specify a count of IPv4 prefixes if you've specified one of the following: specific IPv4 prefixes, specific private IPv4 addresses, or a count of private IPv4 addresses.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-ipv4prefixcount
   */
  readonly ipv4PrefixCount?: number;

  /**
   * The IPv4 delegated prefixes that are assigned to the network interface.
   *
   * When creating a network interface, you can't specify IPv4 prefixes if you've specified one of the following: a count of IPv4 prefixes, specific private IPv4 addresses, or a count of private IPv4 addresses.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-ipv4prefixes
   */
  readonly ipv4Prefixes?: Array<CfnNetworkInterface.Ipv4PrefixSpecificationProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * The number of IPv6 addresses to assign to a network interface.
   *
   * Amazon EC2 automatically selects the IPv6 addresses from the subnet range. To specify specific IPv6 addresses, use the `Ipv6Addresses` property and don't specify this property.
   *
   * When creating a network interface, you can't specify a count of IPv6 addresses if you've specified one of the following: specific IPv6 addresses, specific IPv6 prefixes, or a count of IPv6 prefixes.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-ipv6addresscount
   */
  readonly ipv6AddressCount?: number;

  /**
   * One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet to associate with the network interface.
   *
   * If you're specifying a number of IPv6 addresses, use the `Ipv6AddressCount` property and don't specify this property.
   *
   * When creating a network interface, you can't specify IPv6 addresses if you've specified one of the following: a count of IPv6 addresses, specific IPv6 prefixes, or a count of IPv6 prefixes.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-ipv6addresses
   */
  readonly ipv6Addresses?: Array<CfnNetworkInterface.InstanceIpv6AddressProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * The number of IPv6 prefixes to be automatically assigned to the network interface.
   *
   * When creating a network interface, you can't specify a count of IPv6 prefixes if you've specified one of the following: specific IPv6 prefixes, specific IPv6 addresses, or a count of IPv6 addresses.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-ipv6prefixcount
   */
  readonly ipv6PrefixCount?: number;

  /**
   * The IPv6 delegated prefixes that are assigned to the network interface.
   *
   * When creating a network interface, you can't specify IPv6 prefixes if you've specified one of the following: a count of IPv6 prefixes, specific IPv6 addresses, or a count of IPv6 addresses.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-ipv6prefixes
   */
  readonly ipv6Prefixes?: Array<CfnNetworkInterface.Ipv6PrefixSpecificationProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * Assigns a single private IP address to the network interface, which is used as the primary private IP address.
   *
   * If you want to specify multiple private IP address, use the `PrivateIpAddresses` property.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-privateipaddress
   */
  readonly privateIpAddress?: string;

  /**
   * Assigns private IP addresses to the network interface.
   *
   * You can specify a primary private IP address by setting the value of the `Primary` property to `true` in the `PrivateIpAddressSpecification` property. If you want EC2 to automatically assign private IP addresses, use the `SecondaryPrivateIpAddressCount` property and do not specify this property.
   *
   * When creating a network interface, you can't specify private IPv4 addresses if you've specified one of the following: a count of private IPv4 addresses, specific IPv4 prefixes, or a count of IPv4 prefixes.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-privateipaddresses
   */
  readonly privateIpAddresses?: Array<cdk.IResolvable | CfnNetworkInterface.PrivateIpAddressSpecificationProperty> | cdk.IResolvable;

  /**
   * The number of secondary private IPv4 addresses to assign to a network interface.
   *
   * When you specify a number of secondary IPv4 addresses, Amazon EC2 selects these IP addresses within the subnet's IPv4 CIDR range. You can't specify this option and specify more than one private IP address using `privateIpAddresses` .
   *
   * When creating a Network Interface, you can't specify a count of private IPv4 addresses if you've specified one of the following: specific private IPv4 addresses, specific IPv4 prefixes, or a count of IPv4 prefixes.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-secondaryprivateipaddresscount
   */
  readonly secondaryPrivateIpAddressCount?: number;

  /**
   * Enable or disable source/destination checks, which ensure that the instance is either the source or the destination of any traffic that it receives.
   *
   * If the value is `true` , source/destination checks are enabled; otherwise, they are disabled. The default value is `true` . You must disable source/destination checks if the instance runs services such as network address translation, routing, or firewalls.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-sourcedestcheck
   */
  readonly sourceDestCheck?: boolean | cdk.IResolvable;

  /**
   * The ID of the subnet to associate with the network interface.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-subnetid
   */
  readonly subnetId: string;

  /**
   * An arbitrary set of tags (key-value pairs) for this network interface.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a `PrivateIpAddressSpecificationProperty`
 *
 * @param properties - the TypeScript properties of a `PrivateIpAddressSpecificationProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInterfacePrivateIpAddressSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("primary", cdk.requiredValidator)(properties.primary));
  errors.collect(cdk.propertyValidator("primary", cdk.validateBoolean)(properties.primary));
  errors.collect(cdk.propertyValidator("privateIpAddress", cdk.requiredValidator)(properties.privateIpAddress));
  errors.collect(cdk.propertyValidator("privateIpAddress", cdk.validateString)(properties.privateIpAddress));
  return errors.wrap("supplied properties not correct for \"PrivateIpAddressSpecificationProperty\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInterfacePrivateIpAddressSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInterfacePrivateIpAddressSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "Primary": cdk.booleanToCloudFormation(properties.primary),
    "PrivateIpAddress": cdk.stringToCloudFormation(properties.privateIpAddress)
  };
}

// @ts-ignore TS6133
function CfnNetworkInterfacePrivateIpAddressSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnNetworkInterface.PrivateIpAddressSpecificationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInterface.PrivateIpAddressSpecificationProperty>();
  ret.addPropertyResult("primary", "Primary", (properties.Primary != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Primary) : undefined));
  ret.addPropertyResult("privateIpAddress", "PrivateIpAddress", (properties.PrivateIpAddress != null ? cfn_parse.FromCloudFormation.getString(properties.PrivateIpAddress) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `Ipv4PrefixSpecificationProperty`
 *
 * @param properties - the TypeScript properties of a `Ipv4PrefixSpecificationProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInterfaceIpv4PrefixSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("ipv4Prefix", cdk.requiredValidator)(properties.ipv4Prefix));
  errors.collect(cdk.propertyValidator("ipv4Prefix", cdk.validateString)(properties.ipv4Prefix));
  return errors.wrap("supplied properties not correct for \"Ipv4PrefixSpecificationProperty\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInterfaceIpv4PrefixSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInterfaceIpv4PrefixSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "Ipv4Prefix": cdk.stringToCloudFormation(properties.ipv4Prefix)
  };
}

// @ts-ignore TS6133
function CfnNetworkInterfaceIpv4PrefixSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNetworkInterface.Ipv4PrefixSpecificationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInterface.Ipv4PrefixSpecificationProperty>();
  ret.addPropertyResult("ipv4Prefix", "Ipv4Prefix", (properties.Ipv4Prefix != null ? cfn_parse.FromCloudFormation.getString(properties.Ipv4Prefix) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `InstanceIpv6AddressProperty`
 *
 * @param properties - the TypeScript properties of a `InstanceIpv6AddressProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInterfaceInstanceIpv6AddressPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("ipv6Address", cdk.requiredValidator)(properties.ipv6Address));
  errors.collect(cdk.propertyValidator("ipv6Address", cdk.validateString)(properties.ipv6Address));
  return errors.wrap("supplied properties not correct for \"InstanceIpv6AddressProperty\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInterfaceInstanceIpv6AddressPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInterfaceInstanceIpv6AddressPropertyValidator(properties).assertSuccess();
  return {
    "Ipv6Address": cdk.stringToCloudFormation(properties.ipv6Address)
  };
}

// @ts-ignore TS6133
function CfnNetworkInterfaceInstanceIpv6AddressPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNetworkInterface.InstanceIpv6AddressProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInterface.InstanceIpv6AddressProperty>();
  ret.addPropertyResult("ipv6Address", "Ipv6Address", (properties.Ipv6Address != null ? cfn_parse.FromCloudFormation.getString(properties.Ipv6Address) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `Ipv6PrefixSpecificationProperty`
 *
 * @param properties - the TypeScript properties of a `Ipv6PrefixSpecificationProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInterfaceIpv6PrefixSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("ipv6Prefix", cdk.requiredValidator)(properties.ipv6Prefix));
  errors.collect(cdk.propertyValidator("ipv6Prefix", cdk.validateString)(properties.ipv6Prefix));
  return errors.wrap("supplied properties not correct for \"Ipv6PrefixSpecificationProperty\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInterfaceIpv6PrefixSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInterfaceIpv6PrefixSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "Ipv6Prefix": cdk.stringToCloudFormation(properties.ipv6Prefix)
  };
}

// @ts-ignore TS6133
function CfnNetworkInterfaceIpv6PrefixSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNetworkInterface.Ipv6PrefixSpecificationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInterface.Ipv6PrefixSpecificationProperty>();
  ret.addPropertyResult("ipv6Prefix", "Ipv6Prefix", (properties.Ipv6Prefix != null ? cfn_parse.FromCloudFormation.getString(properties.Ipv6Prefix) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `ConnectionTrackingSpecificationProperty`
 *
 * @param properties - the TypeScript properties of a `ConnectionTrackingSpecificationProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInterfaceConnectionTrackingSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("tcpEstablishedTimeout", cdk.validateNumber)(properties.tcpEstablishedTimeout));
  errors.collect(cdk.propertyValidator("udpStreamTimeout", cdk.validateNumber)(properties.udpStreamTimeout));
  errors.collect(cdk.propertyValidator("udpTimeout", cdk.validateNumber)(properties.udpTimeout));
  return errors.wrap("supplied properties not correct for \"ConnectionTrackingSpecificationProperty\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInterfaceConnectionTrackingSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInterfaceConnectionTrackingSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "TcpEstablishedTimeout": cdk.numberToCloudFormation(properties.tcpEstablishedTimeout),
    "UdpStreamTimeout": cdk.numberToCloudFormation(properties.udpStreamTimeout),
    "UdpTimeout": cdk.numberToCloudFormation(properties.udpTimeout)
  };
}

// @ts-ignore TS6133
function CfnNetworkInterfaceConnectionTrackingSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNetworkInterface.ConnectionTrackingSpecificationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInterface.ConnectionTrackingSpecificationProperty>();
  ret.addPropertyResult("tcpEstablishedTimeout", "TcpEstablishedTimeout", (properties.TcpEstablishedTimeout != null ? cfn_parse.FromCloudFormation.getNumber(properties.TcpEstablishedTimeout) : undefined));
  ret.addPropertyResult("udpStreamTimeout", "UdpStreamTimeout", (properties.UdpStreamTimeout != null ? cfn_parse.FromCloudFormation.getNumber(properties.UdpStreamTimeout) : undefined));
  ret.addPropertyResult("udpTimeout", "UdpTimeout", (properties.UdpTimeout != null ? cfn_parse.FromCloudFormation.getNumber(properties.UdpTimeout) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `CfnNetworkInterfaceProps`
 *
 * @param properties - the TypeScript properties of a `CfnNetworkInterfaceProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInterfacePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("connectionTrackingSpecification", CfnNetworkInterfaceConnectionTrackingSpecificationPropertyValidator)(properties.connectionTrackingSpecification));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("enablePrimaryIpv6", cdk.validateBoolean)(properties.enablePrimaryIpv6));
  errors.collect(cdk.propertyValidator("groupSet", cdk.listValidator(cdk.validateString))(properties.groupSet));
  errors.collect(cdk.propertyValidator("interfaceType", cdk.validateString)(properties.interfaceType));
  errors.collect(cdk.propertyValidator("ipv4PrefixCount", cdk.validateNumber)(properties.ipv4PrefixCount));
  errors.collect(cdk.propertyValidator("ipv4Prefixes", cdk.listValidator(CfnNetworkInterfaceIpv4PrefixSpecificationPropertyValidator))(properties.ipv4Prefixes));
  errors.collect(cdk.propertyValidator("ipv6AddressCount", cdk.validateNumber)(properties.ipv6AddressCount));
  errors.collect(cdk.propertyValidator("ipv6Addresses", cdk.listValidator(CfnNetworkInterfaceInstanceIpv6AddressPropertyValidator))(properties.ipv6Addresses));
  errors.collect(cdk.propertyValidator("ipv6PrefixCount", cdk.validateNumber)(properties.ipv6PrefixCount));
  errors.collect(cdk.propertyValidator("ipv6Prefixes", cdk.listValidator(CfnNetworkInterfaceIpv6PrefixSpecificationPropertyValidator))(properties.ipv6Prefixes));
  errors.collect(cdk.propertyValidator("privateIpAddress", cdk.validateString)(properties.privateIpAddress));
  errors.collect(cdk.propertyValidator("privateIpAddresses", cdk.listValidator(CfnNetworkInterfacePrivateIpAddressSpecificationPropertyValidator))(properties.privateIpAddresses));
  errors.collect(cdk.propertyValidator("secondaryPrivateIpAddressCount", cdk.validateNumber)(properties.secondaryPrivateIpAddressCount));
  errors.collect(cdk.propertyValidator("sourceDestCheck", cdk.validateBoolean)(properties.sourceDestCheck));
  errors.collect(cdk.propertyValidator("subnetId", cdk.requiredValidator)(properties.subnetId));
  errors.collect(cdk.propertyValidator("subnetId", cdk.validateString)(properties.subnetId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \"CfnNetworkInterfaceProps\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInterfacePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInterfacePropsValidator(properties).assertSuccess();
  return {
    "ConnectionTrackingSpecification": convertCfnNetworkInterfaceConnectionTrackingSpecificationPropertyToCloudFormation(properties.connectionTrackingSpecification),
    "Description": cdk.stringToCloudFormation(properties.description),
    "EnablePrimaryIpv6": cdk.booleanToCloudFormation(properties.enablePrimaryIpv6),
    "GroupSet": cdk.listMapper(cdk.stringToCloudFormation)(properties.groupSet),
    "InterfaceType": cdk.stringToCloudFormation(properties.interfaceType),
    "Ipv4PrefixCount": cdk.numberToCloudFormation(properties.ipv4PrefixCount),
    "Ipv4Prefixes": cdk.listMapper(convertCfnNetworkInterfaceIpv4PrefixSpecificationPropertyToCloudFormation)(properties.ipv4Prefixes),
    "Ipv6AddressCount": cdk.numberToCloudFormation(properties.ipv6AddressCount),
    "Ipv6Addresses": cdk.listMapper(convertCfnNetworkInterfaceInstanceIpv6AddressPropertyToCloudFormation)(properties.ipv6Addresses),
    "Ipv6PrefixCount": cdk.numberToCloudFormation(properties.ipv6PrefixCount),
    "Ipv6Prefixes": cdk.listMapper(convertCfnNetworkInterfaceIpv6PrefixSpecificationPropertyToCloudFormation)(properties.ipv6Prefixes),
    "PrivateIpAddress": cdk.stringToCloudFormation(properties.privateIpAddress),
    "PrivateIpAddresses": cdk.listMapper(convertCfnNetworkInterfacePrivateIpAddressSpecificationPropertyToCloudFormation)(properties.privateIpAddresses),
    "SecondaryPrivateIpAddressCount": cdk.numberToCloudFormation(properties.secondaryPrivateIpAddressCount),
    "SourceDestCheck": cdk.booleanToCloudFormation(properties.sourceDestCheck),
    "SubnetId": cdk.stringToCloudFormation(properties.subnetId),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnNetworkInterfacePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNetworkInterfaceProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInterfaceProps>();
  ret.addPropertyResult("connectionTrackingSpecification", "ConnectionTrackingSpecification", (properties.ConnectionTrackingSpecification != null ? CfnNetworkInterfaceConnectionTrackingSpecificationPropertyFromCloudFormation(properties.ConnectionTrackingSpecification) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("enablePrimaryIpv6", "EnablePrimaryIpv6", (properties.EnablePrimaryIpv6 != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EnablePrimaryIpv6) : undefined));
  ret.addPropertyResult("groupSet", "GroupSet", (properties.GroupSet != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.GroupSet) : undefined));
  ret.addPropertyResult("interfaceType", "InterfaceType", (properties.InterfaceType != null ? cfn_parse.FromCloudFormation.getString(properties.InterfaceType) : undefined));
  ret.addPropertyResult("ipv4PrefixCount", "Ipv4PrefixCount", (properties.Ipv4PrefixCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.Ipv4PrefixCount) : undefined));
  ret.addPropertyResult("ipv4Prefixes", "Ipv4Prefixes", (properties.Ipv4Prefixes != null ? cfn_parse.FromCloudFormation.getArray(CfnNetworkInterfaceIpv4PrefixSpecificationPropertyFromCloudFormation)(properties.Ipv4Prefixes) : undefined));
  ret.addPropertyResult("ipv6AddressCount", "Ipv6AddressCount", (properties.Ipv6AddressCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.Ipv6AddressCount) : undefined));
  ret.addPropertyResult("ipv6Addresses", "Ipv6Addresses", (properties.Ipv6Addresses != null ? cfn_parse.FromCloudFormation.getArray(CfnNetworkInterfaceInstanceIpv6AddressPropertyFromCloudFormation)(properties.Ipv6Addresses) : undefined));
  ret.addPropertyResult("ipv6PrefixCount", "Ipv6PrefixCount", (properties.Ipv6PrefixCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.Ipv6PrefixCount) : undefined));
  ret.addPropertyResult("ipv6Prefixes", "Ipv6Prefixes", (properties.Ipv6Prefixes != null ? cfn_parse.FromCloudFormation.getArray(CfnNetworkInterfaceIpv6PrefixSpecificationPropertyFromCloudFormation)(properties.Ipv6Prefixes) : undefined));
  ret.addPropertyResult("privateIpAddress", "PrivateIpAddress", (properties.PrivateIpAddress != null ? cfn_parse.FromCloudFormation.getString(properties.PrivateIpAddress) : undefined));
  ret.addPropertyResult("privateIpAddresses", "PrivateIpAddresses", (properties.PrivateIpAddresses != null ? cfn_parse.FromCloudFormation.getArray(CfnNetworkInterfacePrivateIpAddressSpecificationPropertyFromCloudFormation)(properties.PrivateIpAddresses) : undefined));
  ret.addPropertyResult("secondaryPrivateIpAddressCount", "SecondaryPrivateIpAddressCount", (properties.SecondaryPrivateIpAddressCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.SecondaryPrivateIpAddressCount) : undefined));
  ret.addPropertyResult("sourceDestCheck", "SourceDestCheck", (properties.SourceDestCheck != null ? cfn_parse.FromCloudFormation.getBoolean(properties.SourceDestCheck) : undefined));
  ret.addPropertyResult("subnetId", "SubnetId", (properties.SubnetId != null ? cfn_parse.FromCloudFormation.getString(properties.SubnetId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Attaches an elastic network interface (ENI) to an Amazon EC2 instance.
 *
 * You can use this resource type to attach additional network interfaces to an instance without interruption.
 *
 * @cloudformationResource AWS::EC2::NetworkInterfaceAttachment
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfaceattachment.html
 */
export class CfnNetworkInterfaceAttachment extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::NetworkInterfaceAttachment";

  /**
   * Build a CfnNetworkInterfaceAttachment from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnNetworkInterfaceAttachment {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnNetworkInterfaceAttachmentPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnNetworkInterfaceAttachment(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the network interface attachment.
   *
   * @cloudformationAttribute AttachmentId
   */
  public readonly attrAttachmentId: string;

  /**
   * Whether to delete the network interface when the instance terminates.
   */
  public deleteOnTermination?: boolean | cdk.IResolvable;

  /**
   * The network interface's position in the attachment order.
   */
  public deviceIndex: string;

  /**
   * The ID of the instance to which you will attach the ENI.
   */
  public instanceId: string;

  /**
   * The ID of the ENI that you want to attach.
   */
  public networkInterfaceId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnNetworkInterfaceAttachmentProps) {
    super(scope, id, {
      "type": CfnNetworkInterfaceAttachment.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "deviceIndex", this);
    cdk.requireProperty(props, "instanceId", this);
    cdk.requireProperty(props, "networkInterfaceId", this);

    this.attrAttachmentId = cdk.Token.asString(this.getAtt("AttachmentId", cdk.ResolutionTypeHint.STRING));
    this.deleteOnTermination = props.deleteOnTermination;
    this.deviceIndex = props.deviceIndex;
    this.instanceId = props.instanceId;
    this.networkInterfaceId = props.networkInterfaceId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "deleteOnTermination": this.deleteOnTermination,
      "deviceIndex": this.deviceIndex,
      "instanceId": this.instanceId,
      "networkInterfaceId": this.networkInterfaceId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnNetworkInterfaceAttachment.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnNetworkInterfaceAttachmentPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a `CfnNetworkInterfaceAttachment`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfaceattachment.html
 */
export interface CfnNetworkInterfaceAttachmentProps {
  /**
   * Whether to delete the network interface when the instance terminates.
   *
   * By default, this value is set to `true` .
   *
   * @default - true
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfaceattachment.html#cfn-ec2-networkinterfaceattachment-deleteontermination
   */
  readonly deleteOnTermination?: boolean | cdk.IResolvable;

  /**
   * The network interface's position in the attachment order.
   *
   * For example, the first attached network interface has a `DeviceIndex` of 0.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfaceattachment.html#cfn-ec2-networkinterfaceattachment-deviceindex
   */
  readonly deviceIndex: string;

  /**
   * The ID of the instance to which you will attach the ENI.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfaceattachment.html#cfn-ec2-networkinterfaceattachment-instanceid
   */
  readonly instanceId: string;

  /**
   * The ID of the ENI that you want to attach.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfaceattachment.html#cfn-ec2-networkinterfaceattachment-networkinterfaceid
   */
  readonly networkInterfaceId: string;
}

/**
 * Determine whether the given properties match those of a `CfnNetworkInterfaceAttachmentProps`
 *
 * @param properties - the TypeScript properties of a `CfnNetworkInterfaceAttachmentProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInterfaceAttachmentPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("deleteOnTermination", cdk.validateBoolean)(properties.deleteOnTermination));
  errors.collect(cdk.propertyValidator("deviceIndex", cdk.requiredValidator)(properties.deviceIndex));
  errors.collect(cdk.propertyValidator("deviceIndex", cdk.validateString)(properties.deviceIndex));
  errors.collect(cdk.propertyValidator("instanceId", cdk.requiredValidator)(properties.instanceId));
  errors.collect(cdk.propertyValidator("instanceId", cdk.validateString)(properties.instanceId));
  errors.collect(cdk.propertyValidator("networkInterfaceId", cdk.requiredValidator)(properties.networkInterfaceId));
  errors.collect(cdk.propertyValidator("networkInterfaceId", cdk.validateString)(properties.networkInterfaceId));
  return errors.wrap("supplied properties not correct for \"CfnNetworkInterfaceAttachmentProps\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInterfaceAttachmentPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInterfaceAttachmentPropsValidator(properties).assertSuccess();
  return {
    "DeleteOnTermination": cdk.booleanToCloudFormation(properties.deleteOnTermination),
    "DeviceIndex": cdk.stringToCloudFormation(properties.deviceIndex),
    "InstanceId": cdk.stringToCloudFormation(properties.instanceId),
    "NetworkInterfaceId": cdk.stringToCloudFormation(properties.networkInterfaceId)
  };
}

// @ts-ignore TS6133
function CfnNetworkInterfaceAttachmentPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNetworkInterfaceAttachmentProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInterfaceAttachmentProps>();
  ret.addPropertyResult("deleteOnTermination", "DeleteOnTermination", (properties.DeleteOnTermination != null ? cfn_parse.FromCloudFormation.getBoolean(properties.DeleteOnTermination) : undefined));
  ret.addPropertyResult("deviceIndex", "DeviceIndex", (properties.DeviceIndex != null ? cfn_parse.FromCloudFormation.getString(properties.DeviceIndex) : undefined));
  ret.addPropertyResult("instanceId", "InstanceId", (properties.InstanceId != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceId) : undefined));
  ret.addPropertyResult("networkInterfaceId", "NetworkInterfaceId", (properties.NetworkInterfaceId != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkInterfaceId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a permission for an Amazon EC2 network interface.
 *
 * For example, you can grant an AWS authorized partner account permission to attach the specified network interface to an instance in their account.
 *
 * @cloudformationResource AWS::EC2::NetworkInterfacePermission
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfacepermission.html
 */
export class CfnNetworkInterfacePermission extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::NetworkInterfacePermission";

  /**
   * Build a CfnNetworkInterfacePermission from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnNetworkInterfacePermission {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnNetworkInterfacePermissionPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnNetworkInterfacePermission(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The AWS account ID.
   */
  public awsAccountId: string;

  /**
   * The ID of the network interface.
   */
  public networkInterfaceId: string;

  /**
   * The type of permission to grant: `INSTANCE-ATTACH` or `EIP-ASSOCIATE` .
   */
  public permission: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnNetworkInterfacePermissionProps) {
    super(scope, id, {
      "type": CfnNetworkInterfacePermission.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "awsAccountId", this);
    cdk.requireProperty(props, "networkInterfaceId", this);
    cdk.requireProperty(props, "permission", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.awsAccountId = props.awsAccountId;
    this.networkInterfaceId = props.networkInterfaceId;
    this.permission = props.permission;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "awsAccountId": this.awsAccountId,
      "networkInterfaceId": this.networkInterfaceId,
      "permission": this.permission
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnNetworkInterfacePermission.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnNetworkInterfacePermissionPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a `CfnNetworkInterfacePermission`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfacepermission.html
 */
export interface CfnNetworkInterfacePermissionProps {
  /**
   * The AWS account ID.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfacepermission.html#cfn-ec2-networkinterfacepermission-awsaccountid
   */
  readonly awsAccountId: string;

  /**
   * The ID of the network interface.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfacepermission.html#cfn-ec2-networkinterfacepermission-networkinterfaceid
   */
  readonly networkInterfaceId: string;

  /**
   * The type of permission to grant: `INSTANCE-ATTACH` or `EIP-ASSOCIATE` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfacepermission.html#cfn-ec2-networkinterfacepermission-permission
   */
  readonly permission: string;
}

/**
 * Determine whether the given properties match those of a `CfnNetworkInterfacePermissionProps`
 *
 * @param properties - the TypeScript properties of a `CfnNetworkInterfacePermissionProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInterfacePermissionPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("awsAccountId", cdk.requiredValidator)(properties.awsAccountId));
  errors.collect(cdk.propertyValidator("awsAccountId", cdk.validateString)(properties.awsAccountId));
  errors.collect(cdk.propertyValidator("networkInterfaceId", cdk.requiredValidator)(properties.networkInterfaceId));
  errors.collect(cdk.propertyValidator("networkInterfaceId", cdk.validateString)(properties.networkInterfaceId));
  errors.collect(cdk.propertyValidator("permission", cdk.requiredValidator)(properties.permission));
  errors.collect(cdk.propertyValidator("permission", cdk.validateString)(properties.permission));
  return errors.wrap("supplied properties not correct for \"CfnNetworkInterfacePermissionProps\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInterfacePermissionPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInterfacePermissionPropsValidator(properties).assertSuccess();
  return {
    "AwsAccountId": cdk.stringToCloudFormation(properties.awsAccountId),
    "NetworkInterfaceId": cdk.stringToCloudFormation(properties.networkInterfaceId),
    "Permission": cdk.stringToCloudFormation(properties.permission)
  };
}

// @ts-ignore TS6133
function CfnNetworkInterfacePermissionPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNetworkInterfacePermissionProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInterfacePermissionProps>();
  ret.addPropertyResult("awsAccountId", "AwsAccountId", (properties.AwsAccountId != null ? cfn_parse.FromCloudFormation.getString(properties.AwsAccountId) : undefined));
  ret.addPropertyResult("networkInterfaceId", "NetworkInterfaceId", (properties.NetworkInterfaceId != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkInterfaceId) : undefined));
  ret.addPropertyResult("permission", "Permission", (properties.Permission != null ? cfn_parse.FromCloudFormation.getString(properties.Permission) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Describes Infrastructure Performance subscriptions.
 *
 * @cloudformationResource AWS::EC2::NetworkPerformanceMetricSubscription
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkperformancemetricsubscription.html
 */
export class CfnNetworkPerformanceMetricSubscription extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::NetworkPerformanceMetricSubscription";

  /**
   * Build a CfnNetworkPerformanceMetricSubscription from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnNetworkPerformanceMetricSubscription {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnNetworkPerformanceMetricSubscriptionPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnNetworkPerformanceMetricSubscription(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The Region or Availability Zone that's the target for the subscription.
   */
  public destination: string;

  /**
   * The metric used for the subscription.
   */
  public metric: string;

  /**
   * The Region or Availability Zone that's the source for the subscription.
   */
  public source: string;

  /**
   * The statistic used for the subscription.
   */
  public statistic: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnNetworkPerformanceMetricSubscriptionProps) {
    super(scope, id, {
      "type": CfnNetworkPerformanceMetricSubscription.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "destination", this);
    cdk.requireProperty(props, "metric", this);
    cdk.requireProperty(props, "source", this);
    cdk.requireProperty(props, "statistic", this);

    this.destination = props.destination;
    this.metric = props.metric;
    this.source = props.source;
    this.statistic = props.statistic;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "destination": this.destination,
      "metric": this.metric,
      "source": this.source,
      "statistic": this.statistic
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnNetworkPerformanceMetricSubscription.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnNetworkPerformanceMetricSubscriptionPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a `CfnNetworkPerformanceMetricSubscription`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkperformancemetricsubscription.html
 */
export interface CfnNetworkPerformanceMetricSubscriptionProps {
  /**
   * The Region or Availability Zone that's the target for the subscription.
   *
   * For example, `eu-west-1` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkperformancemetricsubscription.html#cfn-ec2-networkperformancemetricsubscription-destination
   */
  readonly destination: string;

  /**
   * The metric used for the subscription.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkperformancemetricsubscription.html#cfn-ec2-networkperformancemetricsubscription-metric
   */
  readonly metric: string;

  /**
   * The Region or Availability Zone that's the source for the subscription.
   *
   * For example, `us-east-1` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkperformancemetricsubscription.html#cfn-ec2-networkperformancemetricsubscription-source
   */
  readonly source: string;

  /**
   * The statistic used for the subscription.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkperformancemetricsubscription.html#cfn-ec2-networkperformancemetricsubscription-statistic
   */
  readonly statistic: string;
}

/**
 * Determine whether the given properties match those of a `CfnNetworkPerformanceMetricSubscriptionProps`
 *
 * @param properties - the TypeScript properties of a `CfnNetworkPerformanceMetricSubscriptionProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkPerformanceMetricSubscriptionPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("destination", cdk.requiredValidator)(properties.destination));
  errors.collect(cdk.propertyValidator("destination", cdk.validateString)(properties.destination));
  errors.collect(cdk.propertyValidator("metric", cdk.requiredValidator)(properties.metric));
  errors.collect(cdk.propertyValidator("metric", cdk.validateString)(properties.metric));
  errors.collect(cdk.propertyValidator("source", cdk.requiredValidator)(properties.source));
  errors.collect(cdk.propertyValidator("source", cdk.validateString)(properties.source));
  errors.collect(cdk.propertyValidator("statistic", cdk.requiredValidator)(properties.statistic));
  errors.collect(cdk.propertyValidator("statistic", cdk.validateString)(properties.statistic));
  return errors.wrap("supplied properties not correct for \"CfnNetworkPerformanceMetricSubscriptionProps\"");
}

// @ts-ignore TS6133
function convertCfnNetworkPerformanceMetricSubscriptionPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkPerformanceMetricSubscriptionPropsValidator(properties).assertSuccess();
  return {
    "Destination": cdk.stringToCloudFormation(properties.destination),
    "Metric": cdk.stringToCloudFormation(properties.metric),
    "Source": cdk.stringToCloudFormation(properties.source),
    "Statistic": cdk.stringToCloudFormation(properties.statistic)
  };
}

// @ts-ignore TS6133
function CfnNetworkPerformanceMetricSubscriptionPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNetworkPerformanceMetricSubscriptionProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkPerformanceMetricSubscriptionProps>();
  ret.addPropertyResult("destination", "Destination", (properties.Destination != null ? cfn_parse.FromCloudFormation.getString(properties.Destination) : undefined));
  ret.addPropertyResult("metric", "Metric", (properties.Metric != null ? cfn_parse.FromCloudFormation.getString(properties.Metric) : undefined));
  ret.addPropertyResult("source", "Source", (properties.Source != null ? cfn_parse.FromCloudFormation.getString(properties.Source) : undefined));
  ret.addPropertyResult("statistic", "Statistic", (properties.Statistic != null ? cfn_parse.FromCloudFormation.getString(properties.Statistic) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a placement group in which to launch instances.
 *
 * The strategy of the placement group determines how the instances are organized within the group.
 *
 * A `cluster` placement group is a logical grouping of instances within a single Availability Zone that benefit from low network latency, high network throughput. A `spread` placement group places instances on distinct hardware. A `partition` placement group places groups of instances in different partitions, where instances in one partition do not share the same hardware with instances in another partition.
 *
 * For more information, see [Placement Groups](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/placement-groups.html) in the *Amazon EC2 User Guide* .
 *
 * @cloudformationResource AWS::EC2::PlacementGroup
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-placementgroup.html
 */
export class CfnPlacementGroup extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::PlacementGroup";

  /**
   * Build a CfnPlacementGroup from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnPlacementGroup {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnPlacementGroupPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnPlacementGroup(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The name of the placement group.
   *
   * @cloudformationAttribute GroupName
   */
  public readonly attrGroupName: string;

  /**
   * The number of partitions.
   */
  public partitionCount?: number;

  /**
   * Determines how placement groups spread instances.
   */
  public spreadLevel?: string;

  /**
   * The placement strategy.
   */
  public strategy?: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags to apply to the new placement group.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnPlacementGroupProps = {}) {
    super(scope, id, {
      "type": CfnPlacementGroup.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.attrGroupName = cdk.Token.asString(this.getAtt("GroupName", cdk.ResolutionTypeHint.STRING));
    this.partitionCount = props.partitionCount;
    this.spreadLevel = props.spreadLevel;
    this.strategy = props.strategy;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::PlacementGroup", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "partitionCount": this.partitionCount,
      "spreadLevel": this.spreadLevel,
      "strategy": this.strategy,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnPlacementGroup.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnPlacementGroupPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a `CfnPlacementGroup`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-placementgroup.html
 */
export interface CfnPlacementGroupProps {
  /**
   * The number of partitions.
   *
   * Valid only when *Strategy* is set to `partition` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-placementgroup.html#cfn-ec2-placementgroup-partitioncount
   */
  readonly partitionCount?: number;

  /**
   * Determines how placement groups spread instances.
   *
   * - Host  You can use `host` only with Outpost placement groups.
   * - Rack  No usage restrictions.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-placementgroup.html#cfn-ec2-placementgroup-spreadlevel
   */
  readonly spreadLevel?: string;

  /**
   * The placement strategy.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-placementgroup.html#cfn-ec2-placementgroup-strategy
   */
  readonly strategy?: string;

  /**
   * The tags to apply to the new placement group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-placementgroup.html#cfn-ec2-placementgroup-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a `CfnPlacementGroupProps`
 *
 * @param properties - the TypeScript properties of a `CfnPlacementGroupProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnPlacementGroupPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("partitionCount", cdk.validateNumber)(properties.partitionCount));
  errors.collect(cdk.propertyValidator("spreadLevel", cdk.validateString)(properties.spreadLevel));
  errors.collect(cdk.propertyValidator("strategy", cdk.validateString)(properties.strategy));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \"CfnPlacementGroupProps\"");
}

// @ts-ignore TS6133
function convertCfnPlacementGroupPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnPlacementGroupPropsValidator(properties).assertSuccess();
  return {
    "PartitionCount": cdk.numberToCloudFormation(properties.partitionCount),
    "SpreadLevel": cdk.stringToCloudFormation(properties.spreadLevel),
    "Strategy": cdk.stringToCloudFormation(properties.strategy),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnPlacementGroupPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnPlacementGroupProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnPlacementGroupProps>();
  ret.addPropertyResult("partitionCount", "PartitionCount", (properties.PartitionCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.PartitionCount) : undefined));
  ret.addPropertyResult("spreadLevel", "SpreadLevel", (properties.SpreadLevel != null ? cfn_parse.FromCloudFormation.getString(properties.SpreadLevel) : undefined));
  ret.addPropertyResult("strategy", "Strategy", (properties.Strategy != null ? cfn_parse.FromCloudFormation.getString(properties.Strategy) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a managed prefix list.
 *
 * You can add one or more entries to the prefix list. Each entry consists of a CIDR block and an optional description.
 *
 * @cloudformationResource AWS::EC2::PrefixList
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-prefixlist.html
 */
export class CfnPrefixList extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::PrefixList";

  /**
   * Build a CfnPrefixList from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnPrefixList {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnPrefixListPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnPrefixList(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ARN of the prefix list. For example, `arn:aws:ec2:us-east-1:123456789012:prefix-list/pl-0123123123123abcd` .
   *
   * @cloudformationAttribute Arn
   */
  public readonly attrArn: string;

  /**
   * The ID of the owner of the prefix list. For example, `123456789012` .
   *
   * @cloudformationAttribute OwnerId
   */
  public readonly attrOwnerId: string;

  /**
   * The ID of the prefix list. For example, `pl-0123123123123abcd` .
   *
   * @cloudformationAttribute PrefixListId
   */
  public readonly attrPrefixListId: string;

  /**
   * The version of the prefix list. For example, `1` .
   *
   * @cloudformationAttribute Version
   */
  public readonly attrVersion: number;

  /**
   * The IP address type.
   */
  public addressFamily: string;

  /**
   * One or more entries for the prefix list.
   */
  public entries?: Array<CfnPrefixList.EntryProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * The maximum number of entries for the prefix list.
   */
  public maxEntries: number;

  /**
   * A name for the prefix list.
   */
  public prefixListName: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags for the prefix list.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnPrefixListProps) {
    super(scope, id, {
      "type": CfnPrefixList.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "addressFamily", this);
    cdk.requireProperty(props, "maxEntries", this);
    cdk.requireProperty(props, "prefixListName", this);

    this.attrArn = cdk.Token.asString(this.getAtt("Arn", cdk.ResolutionTypeHint.STRING));
    this.attrOwnerId = cdk.Token.asString(this.getAtt("OwnerId", cdk.ResolutionTypeHint.STRING));
    this.attrPrefixListId = cdk.Token.asString(this.getAtt("PrefixListId", cdk.ResolutionTypeHint.STRING));
    this.attrVersion = cdk.Token.asNumber(this.getAtt("Version", cdk.ResolutionTypeHint.NUMBER));
    this.addressFamily = props.addressFamily;
    this.entries = props.entries;
    this.maxEntries = props.maxEntries;
    this.prefixListName = props.prefixListName;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::PrefixList", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "addressFamily": this.addressFamily,
      "entries": this.entries,
      "maxEntries": this.maxEntries,
      "prefixListName": this.prefixListName,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnPrefixList.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnPrefixListPropsToCloudFormation(props);
  }
}

export namespace CfnPrefixList {
  /**
   * An entry for a prefix list.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-prefixlist-entry.html
   */
  export interface EntryProperty {
    /**
     * The CIDR block.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-prefixlist-entry.html#cfn-ec2-prefixlist-entry-cidr
     */
    readonly cidr: string;

    /**
     * A description for the entry.
     *
     * Constraints: Up to 255 characters in length.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-prefixlist-entry.html#cfn-ec2-prefixlist-entry-description
     */
    readonly description?: string;
  }
}

/**
 * Properties for defining a `CfnPrefixList`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-prefixlist.html
 */
export interface CfnPrefixListProps {
  /**
   * The IP address type.
   *
   * Valid Values: `IPv4` | `IPv6`
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-prefixlist.html#cfn-ec2-prefixlist-addressfamily
   */
  readonly addressFamily: string;

  /**
   * One or more entries for the prefix list.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-prefixlist.html#cfn-ec2-prefixlist-entries
   */
  readonly entries?: Array<CfnPrefixList.EntryProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * The maximum number of entries for the prefix list.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-prefixlist.html#cfn-ec2-prefixlist-maxentries
   */
  readonly maxEntries: number;

  /**
   * A name for the prefix list.
   *
   * Constraints: Up to 255 characters in length. The name cannot start with `com.amazonaws` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-prefixlist.html#cfn-ec2-prefixlist-prefixlistname
   */
  readonly prefixListName: string;

  /**
   * The tags for the prefix list.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-prefixlist.html#cfn-ec2-prefixlist-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a `EntryProperty`
 *
 * @param properties - the TypeScript properties of a `EntryProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnPrefixListEntryPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("cidr", cdk.requiredValidator)(properties.cidr));
  errors.collect(cdk.propertyValidator("cidr", cdk.validateString)(properties.cidr));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  return errors.wrap("supplied properties not correct for \"EntryProperty\"");
}

// @ts-ignore TS6133
function convertCfnPrefixListEntryPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnPrefixListEntryPropertyValidator(properties).assertSuccess();
  return {
    "Cidr": cdk.stringToCloudFormation(properties.cidr),
    "Description": cdk.stringToCloudFormation(properties.description)
  };
}

// @ts-ignore TS6133
function CfnPrefixListEntryPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnPrefixList.EntryProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnPrefixList.EntryProperty>();
  ret.addPropertyResult("cidr", "Cidr", (properties.Cidr != null ? cfn_parse.FromCloudFormation.getString(properties.Cidr) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `CfnPrefixListProps`
 *
 * @param properties - the TypeScript properties of a `CfnPrefixListProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnPrefixListPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("addressFamily", cdk.requiredValidator)(properties.addressFamily));
  errors.collect(cdk.propertyValidator("addressFamily", cdk.validateString)(properties.addressFamily));
  errors.collect(cdk.propertyValidator("entries", cdk.listValidator(CfnPrefixListEntryPropertyValidator))(properties.entries));
  errors.collect(cdk.propertyValidator("maxEntries", cdk.requiredValidator)(properties.maxEntries));
  errors.collect(cdk.propertyValidator("maxEntries", cdk.validateNumber)(properties.maxEntries));
  errors.collect(cdk.propertyValidator("prefixListName", cdk.requiredValidator)(properties.prefixListName));
  errors.collect(cdk.propertyValidator("prefixListName", cdk.validateString)(properties.prefixListName));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \"CfnPrefixListProps\"");
}

// @ts-ignore TS6133
function convertCfnPrefixListPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnPrefixListPropsValidator(properties).assertSuccess();
  return {
    "AddressFamily": cdk.stringToCloudFormation(properties.addressFamily),
    "Entries": cdk.listMapper(convertCfnPrefixListEntryPropertyToCloudFormation)(properties.entries),
    "MaxEntries": cdk.numberToCloudFormation(properties.maxEntries),
    "PrefixListName": cdk.stringToCloudFormation(properties.prefixListName),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnPrefixListPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnPrefixListProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnPrefixListProps>();
  ret.addPropertyResult("addressFamily", "AddressFamily", (properties.AddressFamily != null ? cfn_parse.FromCloudFormation.getString(properties.AddressFamily) : undefined));
  ret.addPropertyResult("entries", "Entries", (properties.Entries != null ? cfn_parse.FromCloudFormation.getArray(CfnPrefixListEntryPropertyFromCloudFormation)(properties.Entries) : undefined));
  ret.addPropertyResult("maxEntries", "MaxEntries", (properties.MaxEntries != null ? cfn_parse.FromCloudFormation.getNumber(properties.MaxEntries) : undefined));
  ret.addPropertyResult("prefixListName", "PrefixListName", (properties.PrefixListName != null ? cfn_parse.FromCloudFormation.getString(properties.PrefixListName) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a route in a route table. For more information, see [Routes](https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Route_Tables.html#route-table-routes) in the *Amazon VPC User Guide* .
 *
 * You must specify either a destination CIDR block or prefix list ID. You must also specify exactly one of the resources as the target.
 *
 * If you create a route that references a transit gateway in the same template where you create the transit gateway, you must declare a dependency on the transit gateway attachment. The route table cannot use the transit gateway until it has successfully attached to the VPC. Add a [DependsOn Attribute](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-dependson.html) in the `AWS::EC2::Route` resource to explicitly declare a dependency on the `AWS::EC2::TransitGatewayAttachment` resource.
 *
 * @cloudformationResource AWS::EC2::Route
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html
 */
export class CfnRoute extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::Route";

  /**
   * Build a CfnRoute from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnRoute {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnRoutePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnRoute(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The IPv4 CIDR block.
   *
   * @cloudformationAttribute CidrBlock
   */
  public readonly attrCidrBlock: string;

  /**
   * The ID of the carrier gateway.
   */
  public carrierGatewayId?: string;

  /**
   * The Amazon Resource Name (ARN) of the core network.
   */
  public coreNetworkArn?: string;

  /**
   * The IPv4 CIDR address block used for the destination match.
   */
  public destinationCidrBlock?: string;

  /**
   * The IPv6 CIDR block used for the destination match.
   */
  public destinationIpv6CidrBlock?: string;

  /**
   * The ID of a prefix list used for the destination match.
   */
  public destinationPrefixListId?: string;

  /**
   * [IPv6 traffic only] The ID of an egress-only internet gateway.
   */
  public egressOnlyInternetGatewayId?: string;

  /**
   * The ID of an internet gateway or virtual private gateway attached to your VPC.
   */
  public gatewayId?: string;

  /**
   * The ID of a NAT instance in your VPC.
   */
  public instanceId?: string;

  /**
   * The ID of the local gateway.
   */
  public localGatewayId?: string;

  /**
   * [IPv4 traffic only] The ID of a NAT gateway.
   */
  public natGatewayId?: string;

  /**
   * The ID of a network interface.
   */
  public networkInterfaceId?: string;

  /**
   * The ID of the route table for the route.
   */
  public routeTableId: string;

  /**
   * The ID of a transit gateway.
   */
  public transitGatewayId?: string;

  /**
   * The ID of a VPC endpoint.
   */
  public vpcEndpointId?: string;

  /**
   * The ID of a VPC peering connection.
   */
  public vpcPeeringConnectionId?: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnRouteProps) {
    super(scope, id, {
      "type": CfnRoute.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "routeTableId", this);

    this.attrCidrBlock = cdk.Token.asString(this.getAtt("CidrBlock", cdk.ResolutionTypeHint.STRING));
    this.carrierGatewayId = props.carrierGatewayId;
    this.coreNetworkArn = props.coreNetworkArn;
    this.destinationCidrBlock = props.destinationCidrBlock;
    this.destinationIpv6CidrBlock = props.destinationIpv6CidrBlock;
    this.destinationPrefixListId = props.destinationPrefixListId;
    this.egressOnlyInternetGatewayId = props.egressOnlyInternetGatewayId;
    this.gatewayId = props.gatewayId;
    this.instanceId = props.instanceId;
    this.localGatewayId = props.localGatewayId;
    this.natGatewayId = props.natGatewayId;
    this.networkInterfaceId = props.networkInterfaceId;
    this.routeTableId = props.routeTableId;
    this.transitGatewayId = props.transitGatewayId;
    this.vpcEndpointId = props.vpcEndpointId;
    this.vpcPeeringConnectionId = props.vpcPeeringConnectionId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "carrierGatewayId": this.carrierGatewayId,
      "coreNetworkArn": this.coreNetworkArn,
      "destinationCidrBlock": this.destinationCidrBlock,
      "destinationIpv6CidrBlock": this.destinationIpv6CidrBlock,
      "destinationPrefixListId": this.destinationPrefixListId,
      "egressOnlyInternetGatewayId": this.egressOnlyInternetGatewayId,
      "gatewayId": this.gatewayId,
      "instanceId": this.instanceId,
      "localGatewayId": this.localGatewayId,
      "natGatewayId": this.natGatewayId,
      "networkInterfaceId": this.networkInterfaceId,
      "routeTableId": this.routeTableId,
      "transitGatewayId": this.transitGatewayId,
      "vpcEndpointId": this.vpcEndpointId,
      "vpcPeeringConnectionId": this.vpcPeeringConnectionId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnRoute.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnRoutePropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a `CfnRoute`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html
 */
export interface CfnRouteProps {
  /**
   * The ID of the carrier gateway.
   *
   * You can only use this option when the VPC contains a subnet which is associated with a Wavelength Zone.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-carriergatewayid
   */
  readonly carrierGatewayId?: string;

  /**
   * The Amazon Resource Name (ARN) of the core network.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-corenetworkarn
   */
  readonly coreNetworkArn?: string;

  /**
   * The IPv4 CIDR address block used for the destination match.
   *
   * Routing decisions are based on the most specific match. We modify the specified CIDR block to its canonical form; for example, if you specify `100.68.0.18/18` , we modify it to `100.68.0.0/18` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-destinationcidrblock
   */
  readonly destinationCidrBlock?: string;

  /**
   * The IPv6 CIDR block used for the destination match.
   *
   * Routing decisions are based on the most specific match.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-destinationipv6cidrblock
   */
  readonly destinationIpv6CidrBlock?: string;

  /**
   * The ID of a prefix list used for the destination match.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-destinationprefixlistid
   */
  readonly destinationPrefixListId?: string;

  /**
   * [IPv6 traffic only] The ID of an egress-only internet gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-egressonlyinternetgatewayid
   */
  readonly egressOnlyInternetGatewayId?: string;

  /**
   * The ID of an internet gateway or virtual private gateway attached to your VPC.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-gatewayid
   */
  readonly gatewayId?: string;

  /**
   * The ID of a NAT instance in your VPC.
   *
   * The operation fails if you specify an instance ID unless exactly one network interface is attached.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-instanceid
   */
  readonly instanceId?: string;

  /**
   * The ID of the local gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-localgatewayid
   */
  readonly localGatewayId?: string;

  /**
   * [IPv4 traffic only] The ID of a NAT gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-natgatewayid
   */
  readonly natGatewayId?: string;

  /**
   * The ID of a network interface.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-networkinterfaceid
   */
  readonly networkInterfaceId?: string;

  /**
   * The ID of the route table for the route.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-routetableid
   */
  readonly routeTableId: string;

  /**
   * The ID of a transit gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-transitgatewayid
   */
  readonly transitGatewayId?: string;

  /**
   * The ID of a VPC endpoint.
   *
   * Supported for Gateway Load Balancer endpoints only.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-vpcendpointid
   */
  readonly vpcEndpointId?: string;

  /**
   * The ID of a VPC peering connection.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-vpcpeeringconnectionid
   */
  readonly vpcPeeringConnectionId?: string;
}

/**
 * Determine whether the given properties match those of a `CfnRouteProps`
 *
 * @param properties - the TypeScript properties of a `CfnRouteProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnRoutePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("carrierGatewayId", cdk.validateString)(properties.carrierGatewayId));
  errors.collect(cdk.propertyValidator("coreNetworkArn", cdk.validateString)(properties.coreNetworkArn));
  errors.collect(cdk.propertyValidator("destinationCidrBlock", cdk.validateString)(properties.destinationCidrBlock));
  errors.collect(cdk.propertyValidator("destinationIpv6CidrBlock", cdk.validateString)(properties.destinationIpv6CidrBlock));
  errors.collect(cdk.propertyValidator("destinationPrefixListId", cdk.validateString)(properties.destinationPrefixListId));
  errors.collect(cdk.propertyValidator("egressOnlyInternetGatewayId", cdk.validateString)(properties.egressOnlyInternetGatewayId));
  errors.collect(cdk.propertyValidator("gatewayId", cdk.validateString)(properties.gatewayId));
  errors.collect(cdk.propertyValidator("instanceId", cdk.validateString)(properties.instanceId));
  errors.collect(cdk.propertyValidator("localGatewayId", cdk.validateString)(properties.localGatewayId));
  errors.collect(cdk.propertyValidator("natGatewayId", cdk.validateString)(properties.natGatewayId));
  errors.collect(cdk.propertyValidator("networkInterfaceId", cdk.validateString)(properties.networkInterfaceId));
  errors.collect(cdk.propertyValidator("routeTableId", cdk.requiredValidator)(properties.routeTableId));
  errors.collect(cdk.propertyValidator("routeTableId", cdk.validateString)(properties.routeTableId));
  errors.collect(cdk.propertyValidator("transitGatewayId", cdk.validateString)(properties.transitGatewayId));
  errors.collect(cdk.propertyValidator("vpcEndpointId", cdk.validateString)(properties.vpcEndpointId));
  errors.collect(cdk.propertyValidator("vpcPeeringConnectionId", cdk.validateString)(properties.vpcPeeringConnectionId));
  return errors.wrap("supplied properties not correct for \"CfnRouteProps\"");
}

// @ts-ignore TS6133
function convertCfnRoutePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnRoutePropsValidator(properties).assertSuccess();
  return {
    "CarrierGatewayId": cdk.stringToCloudFormation(properties.carrierGatewayId),
    "CoreNetworkArn": cdk.stringToCloudFormation(properties.coreNetworkArn),
    "DestinationCidrBlock": cdk.stringToCloudFormation(properties.destinationCidrBlock),
    "DestinationIpv6CidrBlock": cdk.stringToCloudFormation(properties.destinationIpv6CidrBlock),
    "DestinationPrefixListId": cdk.stringToCloudFormation(properties.destinationPrefixListId),
    "EgressOnlyInternetGatewayId": cdk.stringToCloudFormation(properties.egressOnlyInternetGatewayId),
    "GatewayId": cdk.stringToCloudFormation(properties.gatewayId),
    "InstanceId": cdk.stringToCloudFormation(properties.instanceId),
    "LocalGatewayId": cdk.stringToCloudFormation(properties.localGatewayId),
    "NatGatewayId": cdk.stringToCloudFormation(properties.natGatewayId),
    "NetworkInterfaceId": cdk.stringToCloudFormation(properties.networkInterfaceId),
    "RouteTableId": cdk.stringToCloudFormation(properties.routeTableId),
    "TransitGatewayId": cdk.stringToCloudFormation(properties.transitGatewayId),
    "VpcEndpointId": cdk.stringToCloudFormation(properties.vpcEndpointId),
    "VpcPeeringConnectionId": cdk.stringToCloudFormation(properties.vpcPeeringConnectionId)
  };
}

// @ts-ignore TS6133
function CfnRoutePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnRouteProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnRouteProps>();
  ret.addPropertyResult("carrierGatewayId", "CarrierGatewayId", (properties.CarrierGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.CarrierGatewayId) : undefined));
  ret.addPropertyResult("coreNetworkArn", "CoreNetworkArn", (properties.CoreNetworkArn != null ? cfn_parse.FromCloudFormation.getString(properties.CoreNetworkArn) : undefined));
  ret.addPropertyResult("destinationCidrBlock", "DestinationCidrBlock", (properties.DestinationCidrBlock != null ? cfn_parse.FromCloudFormation.getString(properties.DestinationCidrBlock) : undefined));
  ret.addPropertyResult("destinationIpv6CidrBlock", "DestinationIpv6CidrBlock", (properties.DestinationIpv6CidrBlock != null ? cfn_parse.FromCloudFormation.getString(properties.DestinationIpv6CidrBlock) : undefined));
  ret.addPropertyResult("destinationPrefixListId", "DestinationPrefixListId", (properties.DestinationPrefixListId != null ? cfn_parse.FromCloudFormation.getString(properties.DestinationPrefixListId) : undefined));
  ret.addPropertyResult("egressOnlyInternetGatewayId", "EgressOnlyInternetGatewayId", (properties.EgressOnlyInternetGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.EgressOnlyInternetGatewayId) : undefined));
  ret.addPropertyResult("gatewayId", "GatewayId", (properties.GatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.GatewayId) : undefined));
  ret.addPropertyResult("instanceId", "InstanceId", (properties.InstanceId != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceId) : undefined));
  ret.addPropertyResult("localGatewayId", "LocalGatewayId", (properties.LocalGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.LocalGatewayId) : undefined));
  ret.addPropertyResult("natGatewayId", "NatGatewayId", (properties.NatGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.NatGatewayId) : undefined));
  ret.addPropertyResult("networkInterfaceId", "NetworkInterfaceId", (properties.NetworkInterfaceId != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkInterfaceId) : undefined));
  ret.addPropertyResult("routeTableId", "RouteTableId", (properties.RouteTableId != null ? cfn_parse.FromCloudFormation.getString(properties.RouteTableId) : undefined));
  ret.addPropertyResult("transitGatewayId", "TransitGatewayId", (properties.TransitGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.TransitGatewayId) : undefined));
  ret.addPropertyResult("vpcEndpointId", "VpcEndpointId", (properties.VpcEndpointId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcEndpointId) : undefined));
  ret.addPropertyResult("vpcPeeringConnectionId", "VpcPeeringConnectionId", (properties.VpcPeeringConnectionId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcPeeringConnectionId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a route table for the specified VPC.
 *
 * After you create a route table, you can add routes and associate the table with a subnet.
 *
 * For more information, see [Route tables](https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Route_Tables.html) in the *Amazon VPC User Guide* .
 *
 * @cloudformationResource AWS::EC2::RouteTable
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-routetable.html
 */
export class CfnRouteTable extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::RouteTable";

  /**
   * Build a CfnRouteTable from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnRouteTable {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnRouteTablePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnRouteTable(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the route table.
   *
   * @cloudformationAttribute RouteTableId
   */
  public readonly attrRouteTableId: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * Any tags assigned to the route table.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The ID of the VPC.
   */
  public vpcId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnRouteTableProps) {
    super(scope, id, {
      "type": CfnRouteTable.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "vpcId", this);

    this.attrRouteTableId = cdk.Token.asString(this.getAtt("RouteTableId", cdk.ResolutionTypeHint.STRING));
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::RouteTable", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.vpcId = props.vpcId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "tags": this.tags.renderTags(),
      "vpcId": this.vpcId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnRouteTable.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnRouteTablePropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a `CfnRouteTable`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-routetable.html
 */
export interface CfnRouteTableProps {
  /**
   * Any tags assigned to the route table.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-routetable.html#cfn-ec2-routetable-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The ID of the VPC.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-routetable.html#cfn-ec2-routetable-vpcid
   */
  readonly vpcId: string;
}

/**
 * Determine whether the given properties match those of a `CfnRouteTableProps`
 *
 * @param properties - the TypeScript properties of a `CfnRouteTableProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnRouteTablePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("vpcId", cdk.requiredValidator)(properties.vpcId));
  errors.collect(cdk.propertyValidator("vpcId", cdk.validateString)(properties.vpcId));
  return errors.wrap("supplied properties not correct for \"CfnRouteTableProps\"");
}

// @ts-ignore TS6133
function convertCfnRouteTablePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnRouteTablePropsValidator(properties).assertSuccess();
  return {
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "VpcId": cdk.stringToCloudFormation(properties.vpcId)
  };
}

// @ts-ignore TS6133
function CfnRouteTablePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnRouteTableProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnRouteTableProps>();
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("vpcId", "VpcId", (properties.VpcId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a security group.
 *
 * To create a security group, use the [VpcId](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group.html#cfn-ec2-securitygroup-vpcid) property to specify the VPC for which to create the security group.
 *
 * If you do not specify an egress rule, we add egress rules that allow IPv4 and IPv6 traffic on all ports and protocols to any destination. We do not add these rules if you specify your own egress rules. If you later remove your egress rules, we restore the default egress rules.
 *
 * This type supports updates. For more information about updating stacks, see [AWS CloudFormation Stacks Updates](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks.html) .
 *
 * > To cross-reference two security groups in the ingress and egress rules of those security groups, use the [AWS::EC2::SecurityGroupEgress](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-security-group-egress.html) and [AWS::EC2::SecurityGroupIngress](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-security-group-ingress.html) resources to define your rules. Do not use the embedded ingress and egress rules in the `AWS::EC2::SecurityGroup` . Doing so creates a circular dependency, which AWS CloudFormation doesn't allow.
 *
 * @cloudformationResource AWS::EC2::SecurityGroup
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroup.html
 */
export class CfnSecurityGroup extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::SecurityGroup";

  /**
   * Build a CfnSecurityGroup from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnSecurityGroup {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnSecurityGroupPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnSecurityGroup(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The group ID of the specified security group, such as `sg-94b3a1f6` .
   *
   * @cloudformationAttribute GroupId
   */
  public readonly attrGroupId: string;

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The physical ID of the VPC. You can obtain the physical ID by using a reference to an [AWS::EC2::VPC](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html) , such as: `{ "Ref" : "myVPC" }` .
   *
   * @cloudformationAttribute VpcId
   */
  public readonly attrVpcId: string;

  /**
   * A description for the security group.
   */
  public groupDescription: string;

  /**
   * The name of the security group.
   */
  public groupName?: string;

  /**
   * The outbound rules associated with the security group.
   */
  public securityGroupEgress?: Array<CfnSecurityGroup.EgressProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * The inbound rules associated with the security group.
   */
  public securityGroupIngress?: Array<CfnSecurityGroup.IngressProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * Any tags assigned to the security group.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The ID of the VPC for the security group.
   */
  public vpcId?: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnSecurityGroupProps) {
    super(scope, id, {
      "type": CfnSecurityGroup.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "groupDescription", this);

    this.attrGroupId = cdk.Token.asString(this.getAtt("GroupId", cdk.ResolutionTypeHint.STRING));
    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.attrVpcId = cdk.Token.asString(this.getAtt("VpcId", cdk.ResolutionTypeHint.STRING));
    this.groupDescription = props.groupDescription;
    this.groupName = props.groupName;
    this.securityGroupEgress = props.securityGroupEgress;
    this.securityGroupIngress = props.securityGroupIngress;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::SecurityGroup", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.vpcId = props.vpcId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "groupDescription": this.groupDescription,
      "groupName": this.groupName,
      "securityGroupEgress": this.securityGroupEgress,
      "securityGroupIngress": this.securityGroupIngress,
      "tags": this.tags.renderTags(),
      "vpcId": this.vpcId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnSecurityGroup.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnSecurityGroupPropsToCloudFormation(props);
  }
}

export namespace CfnSecurityGroup {
  /**
   * Adds the specified egress rules to a security group for use with a VPC.
   *
   * An outbound rule permits instances to send traffic to the specified destination IPv4 or IPv6 CIDR address ranges, or to the specified destination security groups for the same VPC.
   *
   * You specify a protocol for each rule (for example, TCP). For the TCP and UDP protocols, you must also specify the destination port or port range. For the ICMP protocol, you must also specify the ICMP type and code. You can use -1 for the type or code to mean all types or all codes.
   *
   * You must specify only one of the following properties: `CidrIp` , `CidrIpv6` , `DestinationPrefixListId` , or `DestinationSecurityGroupId` .
   *
   * You must specify a destination security group ( `DestinationPrefixListId` or `DestinationSecurityGroupId` ) or a CIDR range ( `CidrIp` or `CidrIpv6` ). If you do not specify one of these parameters, the stack will launch successfully but the rule will not be added to the security group.
   *
   * Rule changes are propagated to affected instances as quickly as possible. However, a small delay might occur.
   *
   * For more information about VPC security group limits, see [Amazon VPC Limits](https://docs.aws.amazon.com/vpc/latest/userguide/amazon-vpc-limits.html) .
   *
   * Use `SecurityGroup.Ingress` and `SecurityGroup.Egress` only when necessary, typically to allow security groups to reference each other in ingress and egress rules. Otherwise, use the embedded ingress and egress rules of the security group. For more information, see [Amazon EC2 Security Groups](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-network-security.html) .
   *
   * The EC2 Security Group Rule is an embedded property of the `AWS::EC2::SecurityGroup` type.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-egress.html
   */
  export interface EgressProperty {
    /**
     * The IPv4 address range, in CIDR format.
     *
     * You must specify a destination security group ( `DestinationPrefixListId` or `DestinationSecurityGroupId` ) or a CIDR range ( `CidrIp` or `CidrIpv6` ).
     *
     * For examples of rules that you can add to security groups for specific access scenarios, see [Security group rules for different use cases](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-egress.html#cfn-ec2-securitygroup-egress-cidrip
     */
    readonly cidrIp?: string;

    /**
     * The IPv6 address range, in CIDR format.
     *
     * You must specify a destination security group ( `DestinationPrefixListId` or `DestinationSecurityGroupId` ) or a CIDR range ( `CidrIp` or `CidrIpv6` ).
     *
     * For examples of rules that you can add to security groups for specific access scenarios, see [Security group rules for different use cases](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-egress.html#cfn-ec2-securitygroup-egress-cidripv6
     */
    readonly cidrIpv6?: string;

    /**
     * A description for the security group rule.
     *
     * Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-egress.html#cfn-ec2-securitygroup-egress-description
     */
    readonly description?: string;

    /**
     * The prefix list IDs for the destination AWS service.
     *
     * This is the AWS service that you want to access through a VPC endpoint from instances associated with the security group.
     *
     * You must specify a destination security group ( `DestinationPrefixListId` or `DestinationSecurityGroupId` ) or a CIDR range ( `CidrIp` or `CidrIpv6` ).
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-egress.html#cfn-ec2-securitygroup-egress-destinationprefixlistid
     */
    readonly destinationPrefixListId?: string;

    /**
     * The ID of the destination VPC security group.
     *
     * You must specify a destination security group ( `DestinationPrefixListId` or `DestinationSecurityGroupId` ) or a CIDR range ( `CidrIp` or `CidrIpv6` ).
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-egress.html#cfn-ec2-securitygroup-egress-destinationsecuritygroupid
     */
    readonly destinationSecurityGroupId?: string;

    /**
     * If the protocol is TCP or UDP, this is the start of the port range.
     *
     * If the protocol is ICMP or ICMPv6, this is the type number. A value of -1 indicates all ICMP/ICMPv6 types. If you specify all ICMP/ICMPv6 types, you must specify all ICMP/ICMPv6 codes.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-egress.html#cfn-ec2-securitygroup-egress-fromport
     */
    readonly fromPort?: number;

    /**
     * The IP protocol name ( `tcp` , `udp` , `icmp` , `icmpv6` ) or number (see [Protocol Numbers](https://docs.aws.amazon.com/http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml) ).
     *
     * Use `-1` to specify all protocols. When authorizing security group rules, specifying `-1` or a protocol number other than `tcp` , `udp` , `icmp` , or `icmpv6` allows traffic on all ports, regardless of any port range you specify. For `tcp` , `udp` , and `icmp` , you must specify a port range. For `icmpv6` , the port range is optional; if you omit the port range, traffic for all types and codes is allowed.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-egress.html#cfn-ec2-securitygroup-egress-ipprotocol
     */
    readonly ipProtocol: string;

    /**
     * If the protocol is TCP or UDP, this is the end of the port range.
     *
     * If the protocol is ICMP or ICMPv6, this is the code. A value of -1 indicates all ICMP/ICMPv6 codes. If you specify all ICMP/ICMPv6 types, you must specify all ICMP/ICMPv6 codes.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-egress.html#cfn-ec2-securitygroup-egress-toport
     */
    readonly toPort?: number;
  }

  /**
   * Adds an inbound rule to a security group.
   *
   * An inbound rule permits instances to receive traffic from the specified IPv4 or IPv6 CIDR address range, or from the instances associated with the specified security group.
   *
   * You must specify only one of the following properties: `CidrIp` , `CidrIpv6` , `SourcePrefixListId` , `SourceSecurityGroupId` , or `SourceSecurityGroupName` .
   *
   * You specify a protocol for each rule (for example, TCP). For TCP and UDP, you must also specify a port or port range. For ICMP/ICMPv6, you must also specify the ICMP/ICMPv6 type and code. You can use -1 to mean all types or all codes.
   *
   * You must specify a source security group ( `SourcePrefixListId` , `SourceSecurityGroupId` , or `SourceSecurityGroupName` ) or a CIDR range ( `CidrIp` or `CidrIpv6` ). If you do not specify one of these parameters, the stack will launch successfully but the rule will not be added to the security group.
   *
   * Rule changes are propagated to instances within the security group as quickly as possible. However, a small delay might occur.
   *
   * The EC2 Security Group Rule is an embedded property of the `AWS::EC2::SecurityGroup` type.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-ingress.html
   */
  export interface IngressProperty {
    /**
     * The IPv4 address range, in CIDR format.
     *
     * You must specify a source security group ( `SourcePrefixListId` or `SourceSecurityGroupId` ) or a CIDR range ( `CidrIp` or `CidrIpv6` ).
     *
     * For examples of rules that you can add to security groups for specific access scenarios, see [Security group rules for different use cases](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-ingress.html#cfn-ec2-securitygroup-ingress-cidrip
     */
    readonly cidrIp?: string;

    /**
     * The IPv6 address range, in CIDR format.
     *
     * You must specify a source security group ( `SourcePrefixListId` or `SourceSecurityGroupId` ) or a CIDR range ( `CidrIp` or `CidrIpv6` ).
     *
     * For examples of rules that you can add to security groups for specific access scenarios, see [Security group rules for different use cases](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-ingress.html#cfn-ec2-securitygroup-ingress-cidripv6
     */
    readonly cidrIpv6?: string;

    /**
     * Updates the description of an ingress (inbound) security group rule.
     *
     * You can replace an existing description, or add a description to a rule that did not have one previously.
     *
     * Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-ingress.html#cfn-ec2-securitygroup-ingress-description
     */
    readonly description?: string;

    /**
     * If the protocol is TCP or UDP, this is the start of the port range.
     *
     * If the protocol is ICMP or ICMPv6, this is the type number. A value of -1 indicates all ICMP/ICMPv6 types. If you specify all ICMP/ICMPv6 types, you must specify all ICMP/ICMPv6 codes.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-ingress.html#cfn-ec2-securitygroup-ingress-fromport
     */
    readonly fromPort?: number;

    /**
     * The IP protocol name ( `tcp` , `udp` , `icmp` , `icmpv6` ) or number (see [Protocol Numbers](https://docs.aws.amazon.com/http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml) ).
     *
     * Use `-1` to specify all protocols. When authorizing security group rules, specifying `-1` or a protocol number other than `tcp` , `udp` , `icmp` , or `icmpv6` allows traffic on all ports, regardless of any port range you specify. For `tcp` , `udp` , and `icmp` , you must specify a port range. For `icmpv6` , the port range is optional; if you omit the port range, traffic for all types and codes is allowed.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-ingress.html#cfn-ec2-securitygroup-ingress-ipprotocol
     */
    readonly ipProtocol: string;

    /**
     * The ID of a prefix list.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-ingress.html#cfn-ec2-securitygroup-ingress-sourceprefixlistid
     */
    readonly sourcePrefixListId?: string;

    /**
     * The ID of the security group.
     *
     * You must specify either the security group ID or the security group name in the request. For security groups in a nondefault VPC, you must specify the security group ID.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-ingress.html#cfn-ec2-securitygroup-ingress-sourcesecuritygroupid
     */
    readonly sourceSecurityGroupId?: string;

    /**
     * [Default VPC] The name of the source security group.
     *
     * You must specify either the security group ID or the security group name. You can't specify the group name in combination with an IP address range. Creates rules that grant full ICMP, UDP, and TCP access.
     *
     * For security groups in a nondefault VPC, you must specify the group ID.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-ingress.html#cfn-ec2-securitygroup-ingress-sourcesecuritygroupname
     */
    readonly sourceSecurityGroupName?: string;

    /**
     * [nondefault VPC] The AWS account ID for the source security group, if the source security group is in a different account.
     *
     * You can't specify this property with an IP address range. Creates rules that grant full ICMP, UDP, and TCP access.
     *
     * If you specify `SourceSecurityGroupName` or `SourceSecurityGroupId` and that security group is owned by a different account than the account creating the stack, you must specify the `SourceSecurityGroupOwnerId` ; otherwise, this property is optional.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-ingress.html#cfn-ec2-securitygroup-ingress-sourcesecuritygroupownerid
     */
    readonly sourceSecurityGroupOwnerId?: string;

    /**
     * If the protocol is TCP or UDP, this is the end of the port range.
     *
     * If the protocol is ICMP or ICMPv6, this is the code. A value of -1 indicates all ICMP/ICMPv6 codes. If you specify all ICMP/ICMPv6 types, you must specify all ICMP/ICMPv6 codes.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-ingress.html#cfn-ec2-securitygroup-ingress-toport
     */
    readonly toPort?: number;
  }
}

/**
 * Properties for defining a `CfnSecurityGroup`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroup.html
 */
export interface CfnSecurityGroupProps {
  /**
   * A description for the security group.
   *
   * Constraints: Up to 255 characters in length
   *
   * Valid characters: a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&;{}!$*
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroup.html#cfn-ec2-securitygroup-groupdescription
   */
  readonly groupDescription: string;

  /**
   * The name of the security group.
   *
   * Constraints: Up to 255 characters in length. Cannot start with `sg-` .
   *
   * Valid characters: a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&;{}!$*
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroup.html#cfn-ec2-securitygroup-groupname
   */
  readonly groupName?: string;

  /**
   * The outbound rules associated with the security group.
   *
   * There is a short interruption during which you cannot connect to the security group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroup.html#cfn-ec2-securitygroup-securitygroupegress
   */
  readonly securityGroupEgress?: Array<CfnSecurityGroup.EgressProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * The inbound rules associated with the security group.
   *
   * There is a short interruption during which you cannot connect to the security group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroup.html#cfn-ec2-securitygroup-securitygroupingress
   */
  readonly securityGroupIngress?: Array<CfnSecurityGroup.IngressProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * Any tags assigned to the security group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroup.html#cfn-ec2-securitygroup-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The ID of the VPC for the security group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroup.html#cfn-ec2-securitygroup-vpcid
   */
  readonly vpcId?: string;
}

/**
 * Determine whether the given properties match those of a `EgressProperty`
 *
 * @param properties - the TypeScript properties of a `EgressProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSecurityGroupEgressPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("cidrIp", cdk.validateString)(properties.cidrIp));
  errors.collect(cdk.propertyValidator("cidrIpv6", cdk.validateString)(properties.cidrIpv6));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("destinationPrefixListId", cdk.validateString)(properties.destinationPrefixListId));
  errors.collect(cdk.propertyValidator("destinationSecurityGroupId", cdk.validateString)(properties.destinationSecurityGroupId));
  errors.collect(cdk.propertyValidator("fromPort", cdk.validateNumber)(properties.fromPort));
  errors.collect(cdk.propertyValidator("ipProtocol", cdk.requiredValidator)(properties.ipProtocol));
  errors.collect(cdk.propertyValidator("ipProtocol", cdk.validateString)(properties.ipProtocol));
  errors.collect(cdk.propertyValidator("toPort", cdk.validateNumber)(properties.toPort));
  return errors.wrap("supplied properties not correct for \"EgressProperty\"");
}

// @ts-ignore TS6133
function convertCfnSecurityGroupEgressPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSecurityGroupEgressPropertyValidator(properties).assertSuccess();
  return {
    "CidrIp": cdk.stringToCloudFormation(properties.cidrIp),
    "CidrIpv6": cdk.stringToCloudFormation(properties.cidrIpv6),
    "Description": cdk.stringToCloudFormation(properties.description),
    "DestinationPrefixListId": cdk.stringToCloudFormation(properties.destinationPrefixListId),
    "DestinationSecurityGroupId": cdk.stringToCloudFormation(properties.destinationSecurityGroupId),
    "FromPort": cdk.numberToCloudFormation(properties.fromPort),
    "IpProtocol": cdk.stringToCloudFormation(properties.ipProtocol),
    "ToPort": cdk.numberToCloudFormation(properties.toPort)
  };
}

// @ts-ignore TS6133
function CfnSecurityGroupEgressPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSecurityGroup.EgressProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSecurityGroup.EgressProperty>();
  ret.addPropertyResult("cidrIp", "CidrIp", (properties.CidrIp != null ? cfn_parse.FromCloudFormation.getString(properties.CidrIp) : undefined));
  ret.addPropertyResult("cidrIpv6", "CidrIpv6", (properties.CidrIpv6 != null ? cfn_parse.FromCloudFormation.getString(properties.CidrIpv6) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("destinationPrefixListId", "DestinationPrefixListId", (properties.DestinationPrefixListId != null ? cfn_parse.FromCloudFormation.getString(properties.DestinationPrefixListId) : undefined));
  ret.addPropertyResult("destinationSecurityGroupId", "DestinationSecurityGroupId", (properties.DestinationSecurityGroupId != null ? cfn_parse.FromCloudFormation.getString(properties.DestinationSecurityGroupId) : undefined));
  ret.addPropertyResult("fromPort", "FromPort", (properties.FromPort != null ? cfn_parse.FromCloudFormation.getNumber(properties.FromPort) : undefined));
  ret.addPropertyResult("ipProtocol", "IpProtocol", (properties.IpProtocol != null ? cfn_parse.FromCloudFormation.getString(properties.IpProtocol) : undefined));
  ret.addPropertyResult("toPort", "ToPort", (properties.ToPort != null ? cfn_parse.FromCloudFormation.getNumber(properties.ToPort) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `IngressProperty`
 *
 * @param properties - the TypeScript properties of a `IngressProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSecurityGroupIngressPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("cidrIp", cdk.validateString)(properties.cidrIp));
  errors.collect(cdk.propertyValidator("cidrIpv6", cdk.validateString)(properties.cidrIpv6));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("fromPort", cdk.validateNumber)(properties.fromPort));
  errors.collect(cdk.propertyValidator("ipProtocol", cdk.requiredValidator)(properties.ipProtocol));
  errors.collect(cdk.propertyValidator("ipProtocol", cdk.validateString)(properties.ipProtocol));
  errors.collect(cdk.propertyValidator("sourcePrefixListId", cdk.validateString)(properties.sourcePrefixListId));
  errors.collect(cdk.propertyValidator("sourceSecurityGroupId", cdk.validateString)(properties.sourceSecurityGroupId));
  errors.collect(cdk.propertyValidator("sourceSecurityGroupName", cdk.validateString)(properties.sourceSecurityGroupName));
  errors.collect(cdk.propertyValidator("sourceSecurityGroupOwnerId", cdk.validateString)(properties.sourceSecurityGroupOwnerId));
  errors.collect(cdk.propertyValidator("toPort", cdk.validateNumber)(properties.toPort));
  return errors.wrap("supplied properties not correct for \"IngressProperty\"");
}

// @ts-ignore TS6133
function convertCfnSecurityGroupIngressPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSecurityGroupIngressPropertyValidator(properties).assertSuccess();
  return {
    "CidrIp": cdk.stringToCloudFormation(properties.cidrIp),
    "CidrIpv6": cdk.stringToCloudFormation(properties.cidrIpv6),
    "Description": cdk.stringToCloudFormation(properties.description),
    "FromPort": cdk.numberToCloudFormation(properties.fromPort),
    "IpProtocol": cdk.stringToCloudFormation(properties.ipProtocol),
    "SourcePrefixListId": cdk.stringToCloudFormation(properties.sourcePrefixListId),
    "SourceSecurityGroupId": cdk.stringToCloudFormation(properties.sourceSecurityGroupId),
    "SourceSecurityGroupName": cdk.stringToCloudFormation(properties.sourceSecurityGroupName),
    "SourceSecurityGroupOwnerId": cdk.stringToCloudFormation(properties.sourceSecurityGroupOwnerId),
    "ToPort": cdk.numberToCloudFormation(properties.toPort)
  };
}

// @ts-ignore TS6133
function CfnSecurityGroupIngressPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSecurityGroup.IngressProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSecurityGroup.IngressProperty>();
  ret.addPropertyResult("cidrIp", "CidrIp", (properties.CidrIp != null ? cfn_parse.FromCloudFormation.getString(properties.CidrIp) : undefined));
  ret.addPropertyResult("cidrIpv6", "CidrIpv6", (properties.CidrIpv6 != null ? cfn_parse.FromCloudFormation.getString(properties.CidrIpv6) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("fromPort", "FromPort", (properties.FromPort != null ? cfn_parse.FromCloudFormation.getNumber(properties.FromPort) : undefined));
  ret.addPropertyResult("ipProtocol", "IpProtocol", (properties.IpProtocol != null ? cfn_parse.FromCloudFormation.getString(properties.IpProtocol) : undefined));
  ret.addPropertyResult("sourcePrefixListId", "SourcePrefixListId", (properties.SourcePrefixListId != null ? cfn_parse.FromCloudFormation.getString(properties.SourcePrefixListId) : undefined));
  ret.addPropertyResult("sourceSecurityGroupId", "SourceSecurityGroupId", (properties.SourceSecurityGroupId != null ? cfn_parse.FromCloudFormation.getString(properties.SourceSecurityGroupId) : undefined));
  ret.addPropertyResult("sourceSecurityGroupName", "SourceSecurityGroupName", (properties.SourceSecurityGroupName != null ? cfn_parse.FromCloudFormation.getString(properties.SourceSecurityGroupName) : undefined));
  ret.addPropertyResult("sourceSecurityGroupOwnerId", "SourceSecurityGroupOwnerId", (properties.SourceSecurityGroupOwnerId != null ? cfn_parse.FromCloudFormation.getString(properties.SourceSecurityGroupOwnerId) : undefined));
  ret.addPropertyResult("toPort", "ToPort", (properties.ToPort != null ? cfn_parse.FromCloudFormation.getNumber(properties.ToPort) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `CfnSecurityGroupProps`
 *
 * @param properties - the TypeScript properties of a `CfnSecurityGroupProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSecurityGroupPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("groupDescription", cdk.requiredValidator)(properties.groupDescription));
  errors.collect(cdk.propertyValidator("groupDescription", cdk.validateString)(properties.groupDescription));
  errors.collect(cdk.propertyValidator("groupName", cdk.validateString)(properties.groupName));
  errors.collect(cdk.propertyValidator("securityGroupEgress", cdk.listValidator(CfnSecurityGroupEgressPropertyValidator))(properties.securityGroupEgress));
  errors.collect(cdk.propertyValidator("securityGroupIngress", cdk.listValidator(CfnSecurityGroupIngressPropertyValidator))(properties.securityGroupIngress));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("vpcId", cdk.validateString)(properties.vpcId));
  return errors.wrap("supplied properties not correct for \"CfnSecurityGroupProps\"");
}

// @ts-ignore TS6133
function convertCfnSecurityGroupPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSecurityGroupPropsValidator(properties).assertSuccess();
  return {
    "GroupDescription": cdk.stringToCloudFormation(properties.groupDescription),
    "GroupName": cdk.stringToCloudFormation(properties.groupName),
    "SecurityGroupEgress": cdk.listMapper(convertCfnSecurityGroupEgressPropertyToCloudFormation)(properties.securityGroupEgress),
    "SecurityGroupIngress": cdk.listMapper(convertCfnSecurityGroupIngressPropertyToCloudFormation)(properties.securityGroupIngress),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "VpcId": cdk.stringToCloudFormation(properties.vpcId)
  };
}

// @ts-ignore TS6133
function CfnSecurityGroupPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSecurityGroupProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSecurityGroupProps>();
  ret.addPropertyResult("groupDescription", "GroupDescription", (properties.GroupDescription != null ? cfn_parse.FromCloudFormation.getString(properties.GroupDescription) : undefined));
  ret.addPropertyResult("groupName", "GroupName", (properties.GroupName != null ? cfn_parse.FromCloudFormation.getString(properties.GroupName) : undefined));
  ret.addPropertyResult("securityGroupEgress", "SecurityGroupEgress", (properties.SecurityGroupEgress != null ? cfn_parse.FromCloudFormation.getArray(CfnSecurityGroupEgressPropertyFromCloudFormation)(properties.SecurityGroupEgress) : undefined));
  ret.addPropertyResult("securityGroupIngress", "SecurityGroupIngress", (properties.SecurityGroupIngress != null ? cfn_parse.FromCloudFormation.getArray(CfnSecurityGroupIngressPropertyFromCloudFormation)(properties.SecurityGroupIngress) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("vpcId", "VpcId", (properties.VpcId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Adds the specified egress rules to a security group.
 *
 * An outbound rule permits instances to send traffic to the specified destination IPv4 or IPv6 CIDR address ranges, or to the specified destination security groups for the same VPC.
 *
 * You specify a protocol for each rule (for example, TCP). For the TCP and UDP protocols, you must also specify the destination port or port range. For the ICMP protocol, you must also specify the ICMP type and code. You can use -1 for the type or code to mean all types or all codes.
 *
 * You must specify only one of the following properties: `CidrIp` , `CidrIpv6` , `DestinationPrefixListId` , or `DestinationSecurityGroupId` .
 *
 * You must specify a destination security group ( `DestinationPrefixListId` or `DestinationSecurityGroupId` ) or a CIDR range ( `CidrIp` or `CidrIpv6` ). If you do not specify one of these parameters, the stack will launch successfully but the rule will not be added to the security group.
 *
 * Rule changes are propagated to affected instances as quickly as possible. However, a small delay might occur.
 *
 * For more information about VPC security group limits, see [Amazon VPC Limits](https://docs.aws.amazon.com/vpc/latest/userguide/amazon-vpc-limits.html) .
 *
 * Use `AWS::EC2::SecurityGroupIngress` and `AWS::EC2::SecurityGroupEgress` only when necessary, typically to allow security groups to reference each other in ingress and egress rules. Otherwise, use the embedded ingress and egress rules of the security group. For more information, see [Amazon EC2 Security Groups](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-network-security.html) .
 *
 * @cloudformationResource AWS::EC2::SecurityGroupEgress
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupegress.html
 */
export class CfnSecurityGroupEgress extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::SecurityGroupEgress";

  /**
   * Build a CfnSecurityGroupEgress from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnSecurityGroupEgress {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnSecurityGroupEgressPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnSecurityGroupEgress(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The Security Group Rule Id
   *
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The IPv4 address range, in CIDR format.
   */
  public cidrIp?: string;

  /**
   * The IPv6 address range, in CIDR format.
   */
  public cidrIpv6?: string;

  /**
   * The description of an egress (outbound) security group rule.
   */
  public description?: string;

  /**
   * The prefix list IDs for an AWS service.
   */
  public destinationPrefixListId?: string;

  /**
   * The ID of the security group.
   */
  public destinationSecurityGroupId?: string;

  /**
   * If the protocol is TCP or UDP, this is the start of the port range.
   */
  public fromPort?: number;

  /**
   * The ID of the security group.
   */
  public groupId: string;

  /**
   * The IP protocol name ( `tcp` , `udp` , `icmp` , `icmpv6` ) or number (see [Protocol Numbers](https://docs.aws.amazon.com/http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml) ).
   */
  public ipProtocol: string;

  /**
   * If the protocol is TCP or UDP, this is the end of the port range.
   */
  public toPort?: number;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnSecurityGroupEgressProps) {
    super(scope, id, {
      "type": CfnSecurityGroupEgress.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "groupId", this);
    cdk.requireProperty(props, "ipProtocol", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.cidrIp = props.cidrIp;
    this.cidrIpv6 = props.cidrIpv6;
    this.description = props.description;
    this.destinationPrefixListId = props.destinationPrefixListId;
    this.destinationSecurityGroupId = props.destinationSecurityGroupId;
    this.fromPort = props.fromPort;
    this.groupId = props.groupId;
    this.ipProtocol = props.ipProtocol;
    this.toPort = props.toPort;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "cidrIp": this.cidrIp,
      "cidrIpv6": this.cidrIpv6,
      "description": this.description,
      "destinationPrefixListId": this.destinationPrefixListId,
      "destinationSecurityGroupId": this.destinationSecurityGroupId,
      "fromPort": this.fromPort,
      "groupId": this.groupId,
      "ipProtocol": this.ipProtocol,
      "toPort": this.toPort
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnSecurityGroupEgress.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnSecurityGroupEgressPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a `CfnSecurityGroupEgress`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupegress.html
 */
export interface CfnSecurityGroupEgressProps {
  /**
   * The IPv4 address range, in CIDR format.
   *
   * You must specify a destination security group ( `DestinationPrefixListId` or `DestinationSecurityGroupId` ) or a CIDR range ( `CidrIp` or `CidrIpv6` ).
   *
   * For examples of rules that you can add to security groups for specific access scenarios, see [Security group rules for different use cases](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html) in the *Amazon EC2 User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupegress.html#cfn-ec2-securitygroupegress-cidrip
   */
  readonly cidrIp?: string;

  /**
   * The IPv6 address range, in CIDR format.
   *
   * You must specify a destination security group ( `DestinationPrefixListId` or `DestinationSecurityGroupId` ) or a CIDR range ( `CidrIp` or `CidrIpv6` ).
   *
   * For examples of rules that you can add to security groups for specific access scenarios, see [Security group rules for different use cases](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html) in the *Amazon EC2 User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupegress.html#cfn-ec2-securitygroupegress-cidripv6
   */
  readonly cidrIpv6?: string;

  /**
   * The description of an egress (outbound) security group rule.
   *
   * Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupegress.html#cfn-ec2-securitygroupegress-description
   */
  readonly description?: string;

  /**
   * The prefix list IDs for an AWS service.
   *
   * This is the AWS service that you want to access through a VPC endpoint from instances associated with the security group.
   *
   * You must specify a destination security group ( `DestinationPrefixListId` or `DestinationSecurityGroupId` ) or a CIDR range ( `CidrIp` or `CidrIpv6` ).
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupegress.html#cfn-ec2-securitygroupegress-destinationprefixlistid
   */
  readonly destinationPrefixListId?: string;

  /**
   * The ID of the security group.
   *
   * You must specify a destination security group ( `DestinationPrefixListId` or `DestinationSecurityGroupId` ) or a CIDR range ( `CidrIp` or `CidrIpv6` ).
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupegress.html#cfn-ec2-securitygroupegress-destinationsecuritygroupid
   */
  readonly destinationSecurityGroupId?: string;

  /**
   * If the protocol is TCP or UDP, this is the start of the port range.
   *
   * If the protocol is ICMP or ICMPv6, this is the type number. A value of -1 indicates all ICMP/ICMPv6 types. If you specify all ICMP/ICMPv6 types, you must specify all ICMP/ICMPv6 codes.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupegress.html#cfn-ec2-securitygroupegress-fromport
   */
  readonly fromPort?: number;

  /**
   * The ID of the security group.
   *
   * You must specify either the security group ID or the security group name in the request. For security groups in a nondefault VPC, you must specify the security group ID.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupegress.html#cfn-ec2-securitygroupegress-groupid
   */
  readonly groupId: string;

  /**
   * The IP protocol name ( `tcp` , `udp` , `icmp` , `icmpv6` ) or number (see [Protocol Numbers](https://docs.aws.amazon.com/http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml) ).
   *
   * Use `-1` to specify all protocols. When authorizing security group rules, specifying `-1` or a protocol number other than `tcp` , `udp` , `icmp` , or `icmpv6` allows traffic on all ports, regardless of any port range you specify. For `tcp` , `udp` , and `icmp` , you must specify a port range. For `icmpv6` , the port range is optional; if you omit the port range, traffic for all types and codes is allowed.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupegress.html#cfn-ec2-securitygroupegress-ipprotocol
   */
  readonly ipProtocol: string;

  /**
   * If the protocol is TCP or UDP, this is the end of the port range.
   *
   * If the protocol is ICMP or ICMPv6, this is the code. A value of -1 indicates all ICMP/ICMPv6 codes. If you specify all ICMP/ICMPv6 types, you must specify all ICMP/ICMPv6 codes.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupegress.html#cfn-ec2-securitygroupegress-toport
   */
  readonly toPort?: number;
}

/**
 * Determine whether the given properties match those of a `CfnSecurityGroupEgressProps`
 *
 * @param properties - the TypeScript properties of a `CfnSecurityGroupEgressProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSecurityGroupEgressPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("cidrIp", cdk.validateString)(properties.cidrIp));
  errors.collect(cdk.propertyValidator("cidrIpv6", cdk.validateString)(properties.cidrIpv6));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("destinationPrefixListId", cdk.validateString)(properties.destinationPrefixListId));
  errors.collect(cdk.propertyValidator("destinationSecurityGroupId", cdk.validateString)(properties.destinationSecurityGroupId));
  errors.collect(cdk.propertyValidator("fromPort", cdk.validateNumber)(properties.fromPort));
  errors.collect(cdk.propertyValidator("groupId", cdk.requiredValidator)(properties.groupId));
  errors.collect(cdk.propertyValidator("groupId", cdk.validateString)(properties.groupId));
  errors.collect(cdk.propertyValidator("ipProtocol", cdk.requiredValidator)(properties.ipProtocol));
  errors.collect(cdk.propertyValidator("ipProtocol", cdk.validateString)(properties.ipProtocol));
  errors.collect(cdk.propertyValidator("toPort", cdk.validateNumber)(properties.toPort));
  return errors.wrap("supplied properties not correct for \"CfnSecurityGroupEgressProps\"");
}

// @ts-ignore TS6133
function convertCfnSecurityGroupEgressPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSecurityGroupEgressPropsValidator(properties).assertSuccess();
  return {
    "CidrIp": cdk.stringToCloudFormation(properties.cidrIp),
    "CidrIpv6": cdk.stringToCloudFormation(properties.cidrIpv6),
    "Description": cdk.stringToCloudFormation(properties.description),
    "DestinationPrefixListId": cdk.stringToCloudFormation(properties.destinationPrefixListId),
    "DestinationSecurityGroupId": cdk.stringToCloudFormation(properties.destinationSecurityGroupId),
    "FromPort": cdk.numberToCloudFormation(properties.fromPort),
    "GroupId": cdk.stringToCloudFormation(properties.groupId),
    "IpProtocol": cdk.stringToCloudFormation(properties.ipProtocol),
    "ToPort": cdk.numberToCloudFormation(properties.toPort)
  };
}

// @ts-ignore TS6133
function CfnSecurityGroupEgressPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSecurityGroupEgressProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSecurityGroupEgressProps>();
  ret.addPropertyResult("cidrIp", "CidrIp", (properties.CidrIp != null ? cfn_parse.FromCloudFormation.getString(properties.CidrIp) : undefined));
  ret.addPropertyResult("cidrIpv6", "CidrIpv6", (properties.CidrIpv6 != null ? cfn_parse.FromCloudFormation.getString(properties.CidrIpv6) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("destinationPrefixListId", "DestinationPrefixListId", (properties.DestinationPrefixListId != null ? cfn_parse.FromCloudFormation.getString(properties.DestinationPrefixListId) : undefined));
  ret.addPropertyResult("destinationSecurityGroupId", "DestinationSecurityGroupId", (properties.DestinationSecurityGroupId != null ? cfn_parse.FromCloudFormation.getString(properties.DestinationSecurityGroupId) : undefined));
  ret.addPropertyResult("fromPort", "FromPort", (properties.FromPort != null ? cfn_parse.FromCloudFormation.getNumber(properties.FromPort) : undefined));
  ret.addPropertyResult("groupId", "GroupId", (properties.GroupId != null ? cfn_parse.FromCloudFormation.getString(properties.GroupId) : undefined));
  ret.addPropertyResult("ipProtocol", "IpProtocol", (properties.IpProtocol != null ? cfn_parse.FromCloudFormation.getString(properties.IpProtocol) : undefined));
  ret.addPropertyResult("toPort", "ToPort", (properties.ToPort != null ? cfn_parse.FromCloudFormation.getNumber(properties.ToPort) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Adds an inbound rule to a security group.
 *
 * An inbound rule permits instances to receive traffic from the specified IPv4 or IPv6 CIDR address range, or from the instances associated with the specified security group.
 *
 * You must specify only one of the following properties: `CidrIp` , `CidrIpv6` , `SourcePrefixListId` , `SourceSecurityGroupId` , or `SourceSecurityGroupName` .
 *
 * You specify a protocol for each rule (for example, TCP). For TCP and UDP, you must also specify a port or port range. For ICMP/ICMPv6, you must also specify the ICMP/ICMPv6 type and code. You can use -1 to mean all types or all codes.
 *
 * You must specify a source security group ( `SourcePrefixListId` , `SourceSecurityGroupId` , or `SourceSecurityGroupName` ) or a CIDR range ( `CidrIp` or `CidrIpv6` ). If you do not specify one of these parameters, the stack will launch successfully but the rule will not be added to the security group.
 *
 * Rule changes are propagated to instances within the security group as quickly as possible. However, a small delay might occur.
 *
 * @cloudformationResource AWS::EC2::SecurityGroupIngress
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html
 */
export class CfnSecurityGroupIngress extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::SecurityGroupIngress";

  /**
   * Build a CfnSecurityGroupIngress from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnSecurityGroupIngress {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnSecurityGroupIngressPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnSecurityGroupIngress(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The IPv4 address range, in CIDR format.
   */
  public cidrIp?: string;

  /**
   * The IPv6 address range, in CIDR format.
   */
  public cidrIpv6?: string;

  /**
   * Updates the description of an ingress (inbound) security group rule.
   */
  public description?: string;

  /**
   * The start of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 type number.
   */
  public fromPort?: number;

  /**
   * The ID of the security group.
   */
  public groupId?: string;

  /**
   * The name of the security group.
   */
  public groupName?: string;

  /**
   * The IP protocol name ( `tcp` , `udp` , `icmp` , `icmpv6` ) or number (see [Protocol Numbers](https://docs.aws.amazon.com/http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml) ).
   */
  public ipProtocol: string;

  /**
   * The ID of a prefix list.
   */
  public sourcePrefixListId?: string;

  /**
   * The ID of the security group.
   */
  public sourceSecurityGroupId?: string;

  /**
   * [Default VPC] The name of the source security group.
   */
  public sourceSecurityGroupName?: string;

  /**
   * [nondefault VPC] The AWS account ID for the source security group, if the source security group is in a different account.
   */
  public sourceSecurityGroupOwnerId?: string;

  /**
   * The end of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 code.
   */
  public toPort?: number;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnSecurityGroupIngressProps) {
    super(scope, id, {
      "type": CfnSecurityGroupIngress.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "ipProtocol", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.cidrIp = props.cidrIp;
    this.cidrIpv6 = props.cidrIpv6;
    this.description = props.description;
    this.fromPort = props.fromPort;
    this.groupId = props.groupId;
    this.groupName = props.groupName;
    this.ipProtocol = props.ipProtocol;
    this.sourcePrefixListId = props.sourcePrefixListId;
    this.sourceSecurityGroupId = props.sourceSecurityGroupId;
    this.sourceSecurityGroupName = props.sourceSecurityGroupName;
    this.sourceSecurityGroupOwnerId = props.sourceSecurityGroupOwnerId;
    this.toPort = props.toPort;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "cidrIp": this.cidrIp,
      "cidrIpv6": this.cidrIpv6,
      "description": this.description,
      "fromPort": this.fromPort,
      "groupId": this.groupId,
      "groupName": this.groupName,
      "ipProtocol": this.ipProtocol,
      "sourcePrefixListId": this.sourcePrefixListId,
      "sourceSecurityGroupId": this.sourceSecurityGroupId,
      "sourceSecurityGroupName": this.sourceSecurityGroupName,
      "sourceSecurityGroupOwnerId": this.sourceSecurityGroupOwnerId,
      "toPort": this.toPort
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnSecurityGroupIngress.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnSecurityGroupIngressPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a `CfnSecurityGroupIngress`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html
 */
export interface CfnSecurityGroupIngressProps {
  /**
   * The IPv4 address range, in CIDR format.
   *
   * You must specify a source security group ( `SourcePrefixListId` or `SourceSecurityGroupId` ) or a CIDR range ( `CidrIp` or `CidrIpv6` ).
   *
   * For examples of rules that you can add to security groups for specific access scenarios, see [Security group rules for different use cases](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html) in the *Amazon EC2 User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html#cfn-ec2-securitygroupingress-cidrip
   */
  readonly cidrIp?: string;

  /**
   * The IPv6 address range, in CIDR format.
   *
   * You must specify a source security group ( `SourcePrefixListId` or `SourceSecurityGroupId` ) or a CIDR range ( `CidrIp` or `CidrIpv6` ).
   *
   * For examples of rules that you can add to security groups for specific access scenarios, see [Security group rules for different use cases](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html) in the *Amazon EC2 User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html#cfn-ec2-securitygroupingress-cidripv6
   */
  readonly cidrIpv6?: string;

  /**
   * Updates the description of an ingress (inbound) security group rule.
   *
   * You can replace an existing description, or add a description to a rule that did not have one previously.
   *
   * Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html#cfn-ec2-securitygroupingress-description
   */
  readonly description?: string;

  /**
   * The start of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 type number.
   *
   * A value of `-1` indicates all ICMP/ICMPv6 types. If you specify all ICMP/ICMPv6 types, you must specify all codes.
   *
   * Use this for ICMP and any protocol that uses ports.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html#cfn-ec2-securitygroupingress-fromport
   */
  readonly fromPort?: number;

  /**
   * The ID of the security group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html#cfn-ec2-securitygroupingress-groupid
   */
  readonly groupId?: string;

  /**
   * The name of the security group.
   *
   * Constraints: Up to 255 characters in length. Cannot start with `sg-` .
   *
   * Valid characters: a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&;{}!$*
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html#cfn-ec2-securitygroupingress-groupname
   */
  readonly groupName?: string;

  /**
   * The IP protocol name ( `tcp` , `udp` , `icmp` , `icmpv6` ) or number (see [Protocol Numbers](https://docs.aws.amazon.com/http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml) ).
   *
   * Use `-1` to specify all protocols. When authorizing security group rules, specifying `-1` or a protocol number other than `tcp` , `udp` , `icmp` , or `icmpv6` allows traffic on all ports, regardless of any port range you specify. For `tcp` , `udp` , and `icmp` , you must specify a port range. For `icmpv6` , the port range is optional; if you omit the port range, traffic for all types and codes is allowed.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html#cfn-ec2-securitygroupingress-ipprotocol
   */
  readonly ipProtocol: string;

  /**
   * The ID of a prefix list.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html#cfn-ec2-securitygroupingress-sourceprefixlistid
   */
  readonly sourcePrefixListId?: string;

  /**
   * The ID of the security group.
   *
   * You must specify either the security group ID or the security group name. For security groups in a nondefault VPC, you must specify the security group ID.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html#cfn-ec2-securitygroupingress-sourcesecuritygroupid
   */
  readonly sourceSecurityGroupId?: string;

  /**
   * [Default VPC] The name of the source security group.
   *
   * You must specify either the security group ID or the security group name. You can't specify the group name in combination with an IP address range. Creates rules that grant full ICMP, UDP, and TCP access.
   *
   * For security groups in a nondefault VPC, you must specify the group ID.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html#cfn-ec2-securitygroupingress-sourcesecuritygroupname
   */
  readonly sourceSecurityGroupName?: string;

  /**
   * [nondefault VPC] The AWS account ID for the source security group, if the source security group is in a different account.
   *
   * You can't specify this property with an IP address range. Creates rules that grant full ICMP, UDP, and TCP access.
   *
   * If you specify `SourceSecurityGroupName` or `SourceSecurityGroupId` and that security group is owned by a different account than the account creating the stack, you must specify `SourceSecurityGroupOwnerId` ; otherwise, this property is optional.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html#cfn-ec2-securitygroupingress-sourcesecuritygroupownerid
   */
  readonly sourceSecurityGroupOwnerId?: string;

  /**
   * The end of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 code.
   *
   * A value of `-1` indicates all ICMP/ICMPv6 codes for the specified ICMP type. If you specify all ICMP/ICMPv6 types, you must specify all codes.
   *
   * Use this for ICMP and any protocol that uses ports.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html#cfn-ec2-securitygroupingress-toport
   */
  readonly toPort?: number;
}

/**
 * Determine whether the given properties match those of a `CfnSecurityGroupIngressProps`
 *
 * @param properties - the TypeScript properties of a `CfnSecurityGroupIngressProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSecurityGroupIngressPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("cidrIp", cdk.validateString)(properties.cidrIp));
  errors.collect(cdk.propertyValidator("cidrIpv6", cdk.validateString)(properties.cidrIpv6));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("fromPort", cdk.validateNumber)(properties.fromPort));
  errors.collect(cdk.propertyValidator("groupId", cdk.validateString)(properties.groupId));
  errors.collect(cdk.propertyValidator("groupName", cdk.validateString)(properties.groupName));
  errors.collect(cdk.propertyValidator("ipProtocol", cdk.requiredValidator)(properties.ipProtocol));
  errors.collect(cdk.propertyValidator("ipProtocol", cdk.validateString)(properties.ipProtocol));
  errors.collect(cdk.propertyValidator("sourcePrefixListId", cdk.validateString)(properties.sourcePrefixListId));
  errors.collect(cdk.propertyValidator("sourceSecurityGroupId", cdk.validateString)(properties.sourceSecurityGroupId));
  errors.collect(cdk.propertyValidator("sourceSecurityGroupName", cdk.validateString)(properties.sourceSecurityGroupName));
  errors.collect(cdk.propertyValidator("sourceSecurityGroupOwnerId", cdk.validateString)(properties.sourceSecurityGroupOwnerId));
  errors.collect(cdk.propertyValidator("toPort", cdk.validateNumber)(properties.toPort));
  return errors.wrap("supplied properties not correct for \"CfnSecurityGroupIngressProps\"");
}

// @ts-ignore TS6133
function convertCfnSecurityGroupIngressPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSecurityGroupIngressPropsValidator(properties).assertSuccess();
  return {
    "CidrIp": cdk.stringToCloudFormation(properties.cidrIp),
    "CidrIpv6": cdk.stringToCloudFormation(properties.cidrIpv6),
    "Description": cdk.stringToCloudFormation(properties.description),
    "FromPort": cdk.numberToCloudFormation(properties.fromPort),
    "GroupId": cdk.stringToCloudFormation(properties.groupId),
    "GroupName": cdk.stringToCloudFormation(properties.groupName),
    "IpProtocol": cdk.stringToCloudFormation(properties.ipProtocol),
    "SourcePrefixListId": cdk.stringToCloudFormation(properties.sourcePrefixListId),
    "SourceSecurityGroupId": cdk.stringToCloudFormation(properties.sourceSecurityGroupId),
    "SourceSecurityGroupName": cdk.stringToCloudFormation(properties.sourceSecurityGroupName),
    "SourceSecurityGroupOwnerId": cdk.stringToCloudFormation(properties.sourceSecurityGroupOwnerId),
    "ToPort": cdk.numberToCloudFormation(properties.toPort)
  };
}

// @ts-ignore TS6133
function CfnSecurityGroupIngressPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSecurityGroupIngressProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSecurityGroupIngressProps>();
  ret.addPropertyResult("cidrIp", "CidrIp", (properties.CidrIp != null ? cfn_parse.FromCloudFormation.getString(properties.CidrIp) : undefined));
  ret.addPropertyResult("cidrIpv6", "CidrIpv6", (properties.CidrIpv6 != null ? cfn_parse.FromCloudFormation.getString(properties.CidrIpv6) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("fromPort", "FromPort", (properties.FromPort != null ? cfn_parse.FromCloudFormation.getNumber(properties.FromPort) : undefined));
  ret.addPropertyResult("groupId", "GroupId", (properties.GroupId != null ? cfn_parse.FromCloudFormation.getString(properties.GroupId) : undefined));
  ret.addPropertyResult("groupName", "GroupName", (properties.GroupName != null ? cfn_parse.FromCloudFormation.getString(properties.GroupName) : undefined));
  ret.addPropertyResult("ipProtocol", "IpProtocol", (properties.IpProtocol != null ? cfn_parse.FromCloudFormation.getString(properties.IpProtocol) : undefined));
  ret.addPropertyResult("sourcePrefixListId", "SourcePrefixListId", (properties.SourcePrefixListId != null ? cfn_parse.FromCloudFormation.getString(properties.SourcePrefixListId) : undefined));
  ret.addPropertyResult("sourceSecurityGroupId", "SourceSecurityGroupId", (properties.SourceSecurityGroupId != null ? cfn_parse.FromCloudFormation.getString(properties.SourceSecurityGroupId) : undefined));
  ret.addPropertyResult("sourceSecurityGroupName", "SourceSecurityGroupName", (properties.SourceSecurityGroupName != null ? cfn_parse.FromCloudFormation.getString(properties.SourceSecurityGroupName) : undefined));
  ret.addPropertyResult("sourceSecurityGroupOwnerId", "SourceSecurityGroupOwnerId", (properties.SourceSecurityGroupOwnerId != null ? cfn_parse.FromCloudFormation.getString(properties.SourceSecurityGroupOwnerId) : undefined));
  ret.addPropertyResult("toPort", "ToPort", (properties.ToPort != null ? cfn_parse.FromCloudFormation.getNumber(properties.ToPort) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a Spot Fleet request.
 *
 * The Spot Fleet request specifies the total target capacity and the On-Demand target capacity. Amazon EC2 calculates the difference between the total capacity and On-Demand capacity, and launches the difference as Spot capacity.
 *
 * You can submit a single request that includes multiple launch specifications that vary by instance type, AMI, Availability Zone, or subnet.
 *
 * By default, the Spot Fleet requests Spot Instances in the Spot Instance pool where the price per unit is the lowest. Each launch specification can include its own instance weighting that reflects the value of the instance type to your application workload.
 *
 * Alternatively, you can specify that the Spot Fleet distribute the target capacity across the Spot pools included in its launch specifications. By ensuring that the Spot Instances in your Spot Fleet are in different Spot pools, you can improve the availability of your fleet.
 *
 * You can specify tags for the Spot Fleet request and instances launched by the fleet. You cannot tag other resource types in a Spot Fleet request because only the `spot-fleet-request` and `instance` resource types are supported.
 *
 * For more information, see [Spot Fleet](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet.html) in the *Amazon EC2 User Guide for Linux Instances* .
 *
 * > We strongly discourage using the RequestSpotFleet API because it is a legacy API with no planned investment. For options for requesting Spot Instances, see [Which is the best Spot request method to use?](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-best-practices.html#which-spot-request-method-to-use) in the *Amazon EC2 User Guide for Linux Instances* .
 *
 * @cloudformationResource AWS::EC2::SpotFleet
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-spotfleet.html
 */
export class CfnSpotFleet extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::SpotFleet";

  /**
   * Build a CfnSpotFleet from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnSpotFleet {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnSpotFleetPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnSpotFleet(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the Spot Fleet.
   *
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * Describes the configuration of a Spot Fleet request.
   */
  public spotFleetRequestConfigData: cdk.IResolvable | CfnSpotFleet.SpotFleetRequestConfigDataProperty;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnSpotFleetProps) {
    super(scope, id, {
      "type": CfnSpotFleet.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "spotFleetRequestConfigData", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.spotFleetRequestConfigData = props.spotFleetRequestConfigData;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "spotFleetRequestConfigData": this.spotFleetRequestConfigData
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnSpotFleet.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnSpotFleetPropsToCloudFormation(props);
  }
}

export namespace CfnSpotFleet {
  /**
   * Specifies the configuration of a Spot Fleet request.
   *
   * For more information, see [Spot Fleet](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet.html) in the *Amazon EC2 User Guide* .
   *
   * You must specify either `LaunchSpecifications` or `LaunchTemplateConfigs` .
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html
   */
  export interface SpotFleetRequestConfigDataProperty {
    /**
     * The strategy that determines how to allocate the target Spot Instance capacity across the Spot Instance pools specified by the Spot Fleet launch configuration.
     *
     * For more information, see [Allocation strategies for Spot Instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-allocation-strategy.html) in the *Amazon EC2 User Guide* .
     *
     * - **priceCapacityOptimized (recommended)** - Spot Fleet identifies the pools with the highest capacity availability for the number of instances that are launching. This means that we will request Spot Instances from the pools that we believe have the lowest chance of interruption in the near term. Spot Fleet then requests Spot Instances from the lowest priced of these pools.
     * - **capacityOptimized** - Spot Fleet identifies the pools with the highest capacity availability for the number of instances that are launching. This means that we will request Spot Instances from the pools that we believe have the lowest chance of interruption in the near term. To give certain instance types a higher chance of launching first, use `capacityOptimizedPrioritized` . Set a priority for each instance type by using the `Priority` parameter for `LaunchTemplateOverrides` . You can assign the same priority to different `LaunchTemplateOverrides` . EC2 implements the priorities on a best-effort basis, but optimizes for capacity first. `capacityOptimizedPrioritized` is supported only if your Spot Fleet uses a launch template. Note that if the `OnDemandAllocationStrategy` is set to `prioritized` , the same priority is applied when fulfilling On-Demand capacity.
     * - **diversified** - Spot Fleet requests instances from all of the Spot Instance pools that you specify.
     * - **lowestPrice** - Spot Fleet requests instances from the lowest priced Spot Instance pool that has available capacity. If the lowest priced pool doesn't have available capacity, the Spot Instances come from the next lowest priced pool that has available capacity. If a pool runs out of capacity before fulfilling your desired capacity, Spot Fleet will continue to fulfill your request by drawing from the next lowest priced pool. To ensure that your desired capacity is met, you might receive Spot Instances from several pools. Because this strategy only considers instance price and not capacity availability, it might lead to high interruption rates.
     *
     * Default: `lowestPrice`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-allocationstrategy
     */
    readonly allocationStrategy?: string;

    /**
     * Reserved.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-context
     */
    readonly context?: string;

    /**
     * Indicates whether running Spot Instances should be terminated if you decrease the target capacity of the Spot Fleet request below the current size of the Spot Fleet.
     *
     * Supported only for fleets of type `maintain` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-excesscapacityterminationpolicy
     */
    readonly excessCapacityTerminationPolicy?: string;

    /**
     * The Amazon Resource Name (ARN) of an AWS Identity and Access Management (IAM) role that grants the Spot Fleet the permission to request, launch, terminate, and tag instances on your behalf.
     *
     * For more information, see [Spot Fleet Prerequisites](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-requests.html#spot-fleet-prerequisites) in the *Amazon EC2 User Guide for Linux Instances* . Spot Fleet can terminate Spot Instances on your behalf when you cancel its Spot Fleet request or when the Spot Fleet request expires, if you set `TerminateInstancesWithExpiration` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-iamfleetrole
     */
    readonly iamFleetRole: string;

    /**
     * The behavior when a Spot Instance is interrupted.
     *
     * The default is `terminate` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-instanceinterruptionbehavior
     */
    readonly instanceInterruptionBehavior?: string;

    /**
     * The number of Spot pools across which to allocate your target Spot capacity.
     *
     * Valid only when Spot *AllocationStrategy* is set to `lowest-price` . Spot Fleet selects the cheapest Spot pools and evenly allocates your target Spot capacity across the number of Spot pools that you specify.
     *
     * Note that Spot Fleet attempts to draw Spot Instances from the number of pools that you specify on a best effort basis. If a pool runs out of Spot capacity before fulfilling your target capacity, Spot Fleet will continue to fulfill your request by drawing from the next cheapest pool. To ensure that your target capacity is met, you might receive Spot Instances from more than the number of pools that you specified. Similarly, if most of the pools have no Spot capacity, you might receive your full target capacity from fewer than the number of pools that you specified.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-instancepoolstousecount
     */
    readonly instancePoolsToUseCount?: number;

    /**
     * The launch specifications for the Spot Fleet request.
     *
     * If you specify `LaunchSpecifications` , you can't specify `LaunchTemplateConfigs` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-launchspecifications
     */
    readonly launchSpecifications?: Array<cdk.IResolvable | CfnSpotFleet.SpotFleetLaunchSpecificationProperty> | cdk.IResolvable;

    /**
     * The launch template and overrides.
     *
     * If you specify `LaunchTemplateConfigs` , you can't specify `LaunchSpecifications` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-launchtemplateconfigs
     */
    readonly launchTemplateConfigs?: Array<cdk.IResolvable | CfnSpotFleet.LaunchTemplateConfigProperty> | cdk.IResolvable;

    /**
     * One or more Classic Load Balancers and target groups to attach to the Spot Fleet request.
     *
     * Spot Fleet registers the running Spot Instances with the specified Classic Load Balancers and target groups.
     *
     * With Network Load Balancers, Spot Fleet cannot register instances that have the following instance types: C1, CC1, CC2, CG1, CG2, CR1, CS1, G1, G2, HI1, HS1, M1, M2, M3, and T1.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-loadbalancersconfig
     */
    readonly loadBalancersConfig?: cdk.IResolvable | CfnSpotFleet.LoadBalancersConfigProperty;

    /**
     * The order of the launch template overrides to use in fulfilling On-Demand capacity.
     *
     * If you specify `lowestPrice` , Spot Fleet uses price to determine the order, launching the lowest price first. If you specify `prioritized` , Spot Fleet uses the priority that you assign to each Spot Fleet launch template override, launching the highest priority first. If you do not specify a value, Spot Fleet defaults to `lowestPrice` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-ondemandallocationstrategy
     */
    readonly onDemandAllocationStrategy?: string;

    /**
     * The maximum amount per hour for On-Demand Instances that you're willing to pay.
     *
     * You can use the `onDemandMaxTotalPrice` parameter, the `spotMaxTotalPrice` parameter, or both parameters to ensure that your fleet cost does not exceed your budget. If you set a maximum price per hour for the On-Demand Instances and Spot Instances in your request, Spot Fleet will launch instances until it reaches the maximum amount you're willing to pay. When the maximum amount you're willing to pay is reached, the fleet stops launching instances even if it hasnt met the target capacity.
     *
     * > If your fleet includes T instances that are configured as `unlimited` , and if their average CPU usage exceeds the baseline utilization, you will incur a charge for surplus credits. The `onDemandMaxTotalPrice` does not account for surplus credits, and, if you use surplus credits, your final cost might be higher than what you specified for `onDemandMaxTotalPrice` . For more information, see [Surplus credits can incur charges](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances-unlimited-mode-concepts.html#unlimited-mode-surplus-credits) in the *EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-ondemandmaxtotalprice
     */
    readonly onDemandMaxTotalPrice?: string;

    /**
     * The number of On-Demand units to request.
     *
     * You can choose to set the target capacity in terms of instances or a performance characteristic that is important to your application workload, such as vCPUs, memory, or I/O. If the request type is `maintain` , you can specify a target capacity of 0 and add capacity later.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-ondemandtargetcapacity
     */
    readonly onDemandTargetCapacity?: number;

    /**
     * Indicates whether Spot Fleet should replace unhealthy instances.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-replaceunhealthyinstances
     */
    readonly replaceUnhealthyInstances?: boolean | cdk.IResolvable;

    /**
     * The strategies for managing your Spot Instances that are at an elevated risk of being interrupted.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-spotmaintenancestrategies
     */
    readonly spotMaintenanceStrategies?: cdk.IResolvable | CfnSpotFleet.SpotMaintenanceStrategiesProperty;

    /**
     * The maximum amount per hour for Spot Instances that you're willing to pay.
     *
     * You can use the `spotMaxTotalPrice` parameter, the `onDemandMaxTotalPrice` parameter, or both parameters to ensure that your fleet cost does not exceed your budget. If you set a maximum price per hour for the On-Demand Instances and Spot Instances in your request, Spot Fleet will launch instances until it reaches the maximum amount you're willing to pay. When the maximum amount you're willing to pay is reached, the fleet stops launching instances even if it hasnt met the target capacity.
     *
     * > If your fleet includes T instances that are configured as `unlimited` , and if their average CPU usage exceeds the baseline utilization, you will incur a charge for surplus credits. The `spotMaxTotalPrice` does not account for surplus credits, and, if you use surplus credits, your final cost might be higher than what you specified for `spotMaxTotalPrice` . For more information, see [Surplus credits can incur charges](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances-unlimited-mode-concepts.html#unlimited-mode-surplus-credits) in the *EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-spotmaxtotalprice
     */
    readonly spotMaxTotalPrice?: string;

    /**
     * The maximum price per unit hour that you are willing to pay for a Spot Instance.
     *
     * We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price.
     *
     * > If you specify a maximum price, your instances will be interrupted more frequently than if you do not specify this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-spotprice
     */
    readonly spotPrice?: string;

    /**
     * The key-value pair for tagging the Spot Fleet request on creation.
     *
     * The value for `ResourceType` must be `spot-fleet-request` , otherwise the Spot Fleet request fails. To tag instances at launch, specify the tags in the [launch template](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-templates.html#create-launch-template) (valid only if you use `LaunchTemplateConfigs` ) or in the `[SpotFleetTagSpecification](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_SpotFleetTagSpecification.html)` (valid only if you use `LaunchSpecifications` ). For information about tagging after launch, see [Tag your resources](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html#tag-resources) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-tagspecifications
     */
    readonly tagSpecifications?: Array<cdk.IResolvable | CfnSpotFleet.SpotFleetTagSpecificationProperty> | cdk.IResolvable;

    /**
     * The number of units to request for the Spot Fleet.
     *
     * You can choose to set the target capacity in terms of instances or a performance characteristic that is important to your application workload, such as vCPUs, memory, or I/O. If the request type is `maintain` , you can specify a target capacity of 0 and add capacity later.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-targetcapacity
     */
    readonly targetCapacity: number;

    /**
     * The unit for the target capacity. You can specify this parameter only when using attribute-based instance type selection.
     *
     * Default: `units` (the number of instances)
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-targetcapacityunittype
     */
    readonly targetCapacityUnitType?: string;

    /**
     * Indicates whether running Spot Instances are terminated when the Spot Fleet request expires.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-terminateinstanceswithexpiration
     */
    readonly terminateInstancesWithExpiration?: boolean | cdk.IResolvable;

    /**
     * The type of request.
     *
     * Indicates whether the Spot Fleet only requests the target capacity or also attempts to maintain it. When this value is `request` , the Spot Fleet only places the required requests. It does not attempt to replenish Spot Instances if capacity is diminished, nor does it submit requests in alternative Spot pools if capacity is not available. When this value is `maintain` , the Spot Fleet maintains the target capacity. The Spot Fleet places the required requests to meet capacity and automatically replenishes any interrupted instances. Default: `maintain` . `instant` is listed but is not used by Spot Fleet.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-type
     */
    readonly type?: string;

    /**
     * The start date and time of the request, in UTC format ( *YYYY* - *MM* - *DD* T *HH* : *MM* : *SS* Z).
     *
     * By default, Amazon EC2 starts fulfilling the request immediately.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-validfrom
     */
    readonly validFrom?: string;

    /**
     * The end date and time of the request, in UTC format ( *YYYY* - *MM* - *DD* T *HH* : *MM* : *SS* Z).
     *
     * After the end date and time, no new Spot Instance requests are placed or able to fulfill the request. If no value is specified, the Spot Fleet request remains until you cancel it.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-validuntil
     */
    readonly validUntil?: string;
  }

  /**
   * The tags for a Spot Fleet resource.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleettagspecification.html
   */
  export interface SpotFleetTagSpecificationProperty {
    /**
     * The type of resource.
     *
     * Currently, the only resource type that is supported is `instance` . To tag the Spot Fleet request on creation, use the `TagSpecifications` parameter in `[SpotFleetRequestConfigData](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_SpotFleetRequestConfigData.html)` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleettagspecification.html#cfn-ec2-spotfleet-spotfleettagspecification-resourcetype
     */
    readonly resourceType?: string;

    /**
     * The tags.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleettagspecification.html#cfn-ec2-spotfleet-spotfleettagspecification-tags
     */
    readonly tags?: Array<cdk.CfnTag>;
  }

  /**
   * Specifies a launch template and overrides.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-launchtemplateconfig.html
   */
  export interface LaunchTemplateConfigProperty {
    /**
     * The launch template to use.
     *
     * Make sure that the launch template does not contain the `NetworkInterfaceId` parameter because you can't specify a network interface ID in a Spot Fleet.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-launchtemplateconfig.html#cfn-ec2-spotfleet-launchtemplateconfig-launchtemplatespecification
     */
    readonly launchTemplateSpecification?: CfnSpotFleet.FleetLaunchTemplateSpecificationProperty | cdk.IResolvable;

    /**
     * Any parameters that you specify override the same parameters in the launch template.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-launchtemplateconfig.html#cfn-ec2-spotfleet-launchtemplateconfig-overrides
     */
    readonly overrides?: Array<cdk.IResolvable | CfnSpotFleet.LaunchTemplateOverridesProperty> | cdk.IResolvable;
  }

  /**
   * Specifies the launch template to be used by the Spot Fleet request for configuring Amazon EC2 instances.
   *
   * You must specify the following:
   *
   * - The ID or the name of the launch template, but not both.
   * - The version of the launch template.
   *
   * `FleetLaunchTemplateSpecification` is a property of the [AWS::EC2::SpotFleet](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-spotfleet.html) resource.
   *
   * For information about creating a launch template, see [AWS::EC2::LaunchTemplate](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html) and [Create a launch template](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-templates.html#create-launch-template) in the *Amazon EC2 User Guide* .
   *
   * For examples of launch templates, see [Examples](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#aws-resource-ec2-launchtemplate--examples) .
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-fleetlaunchtemplatespecification.html
   */
  export interface FleetLaunchTemplateSpecificationProperty {
    /**
     * The ID of the launch template.
     *
     * You must specify the `LaunchTemplateId` or the `LaunchTemplateName` , but not both.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-fleetlaunchtemplatespecification.html#cfn-ec2-spotfleet-fleetlaunchtemplatespecification-launchtemplateid
     */
    readonly launchTemplateId?: string;

    /**
     * The name of the launch template.
     *
     * You must specify the `LaunchTemplateName` or the `LaunchTemplateId` , but not both.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-fleetlaunchtemplatespecification.html#cfn-ec2-spotfleet-fleetlaunchtemplatespecification-launchtemplatename
     */
    readonly launchTemplateName?: string;

    /**
     * The version number of the launch template.
     *
     * Specifying `$Latest` or `$Default` for the template version number is not supported. However, you can specify `LatestVersionNumber` or `DefaultVersionNumber` using the `Fn::GetAtt` intrinsic function. For more information, see [Fn::GetAtt](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#aws-resource-ec2-launchtemplate-return-values-fn--getatt) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-fleetlaunchtemplatespecification.html#cfn-ec2-spotfleet-fleetlaunchtemplatespecification-version
     */
    readonly version: string;
  }

  /**
   * Specifies overrides for a launch template.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-launchtemplateoverrides.html
   */
  export interface LaunchTemplateOverridesProperty {
    /**
     * The Availability Zone in which to launch the instances.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-launchtemplateoverrides.html#cfn-ec2-spotfleet-launchtemplateoverrides-availabilityzone
     */
    readonly availabilityZone?: string;

    /**
     * The instance requirements.
     *
     * When you specify instance requirements, Amazon EC2 will identify instance types with the provided requirements, and then use your On-Demand and Spot allocation strategies to launch instances from these instance types, in the same way as when you specify a list of instance types.
     *
     * > If you specify `InstanceRequirements` , you can't specify `InstanceType` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-launchtemplateoverrides.html#cfn-ec2-spotfleet-launchtemplateoverrides-instancerequirements
     */
    readonly instanceRequirements?: CfnSpotFleet.InstanceRequirementsRequestProperty | cdk.IResolvable;

    /**
     * The instance type.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-launchtemplateoverrides.html#cfn-ec2-spotfleet-launchtemplateoverrides-instancetype
     */
    readonly instanceType?: string;

    /**
     * The priority for the launch template override. The highest priority is launched first.
     *
     * If `OnDemandAllocationStrategy` is set to `prioritized` , Spot Fleet uses priority to determine which launch template override to use first in fulfilling On-Demand capacity.
     *
     * If the Spot `AllocationStrategy` is set to `capacityOptimizedPrioritized` , Spot Fleet uses priority on a best-effort basis to determine which launch template override to use in fulfilling Spot capacity, but optimizes for capacity first.
     *
     * Valid values are whole numbers starting at `0` . The lower the number, the higher the priority. If no number is set, the launch template override has the lowest priority. You can set the same priority for different launch template overrides.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-launchtemplateoverrides.html#cfn-ec2-spotfleet-launchtemplateoverrides-priority
     */
    readonly priority?: number;

    /**
     * The maximum price per unit hour that you are willing to pay for a Spot Instance.
     *
     * We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price.
     *
     * > If you specify a maximum price, your instances will be interrupted more frequently than if you do not specify this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-launchtemplateoverrides.html#cfn-ec2-spotfleet-launchtemplateoverrides-spotprice
     */
    readonly spotPrice?: string;

    /**
     * The ID of the subnet in which to launch the instances.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-launchtemplateoverrides.html#cfn-ec2-spotfleet-launchtemplateoverrides-subnetid
     */
    readonly subnetId?: string;

    /**
     * The number of units provided by the specified instance type.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-launchtemplateoverrides.html#cfn-ec2-spotfleet-launchtemplateoverrides-weightedcapacity
     */
    readonly weightedCapacity?: number;
  }

  /**
   * The attributes for the instance types.
   *
   * When you specify instance attributes, Amazon EC2 will identify instance types with these attributes.
   *
   * You must specify `VCpuCount` and `MemoryMiB` . All other attributes are optional. Any unspecified optional attribute is set to its default.
   *
   * When you specify multiple attributes, you get instance types that satisfy all of the specified attributes. If you specify multiple values for an attribute, you get instance types that satisfy any of the specified values.
   *
   * To limit the list of instance types from which Amazon EC2 can identify matching instance types, you can use one of the following parameters, but not both in the same request:
   *
   * - `AllowedInstanceTypes` - The instance types to include in the list. All other instance types are ignored, even if they match your specified attributes.
   * - `ExcludedInstanceTypes` - The instance types to exclude from the list, even if they match your specified attributes.
   *
   * > If you specify `InstanceRequirements` , you can't specify `InstanceType` .
   * >
   * > Attribute-based instance type selection is only supported when using Auto Scaling groups, EC2 Fleet, and Spot Fleet to launch instances. If you plan to use the launch template in the [launch instance wizard](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-instance-wizard.html) , or with the [RunInstances](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html) API or [AWS::EC2::Instance](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html) AWS CloudFormation resource, you can't specify `InstanceRequirements` .
   *
   * For more information, see [Attribute-based instance type selection for EC2 Fleet](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html) , [Attribute-based instance type selection for Spot Fleet](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-attribute-based-instance-type-selection.html) , and [Spot placement score](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-placement-score.html) in the *Amazon EC2 User Guide* .
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html
   */
  export interface InstanceRequirementsRequestProperty {
    /**
     * The minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips) on an instance.
     *
     * To exclude accelerator-enabled instance types, set `Max` to `0` .
     *
     * Default: No minimum or maximum limits
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-acceleratorcount
     */
    readonly acceleratorCount?: CfnSpotFleet.AcceleratorCountRequestProperty | cdk.IResolvable;

    /**
     * Indicates whether instance types must have accelerators by specific manufacturers.
     *
     * - For instance types with AWS devices, specify `amazon-web-services` .
     * - For instance types with AMD devices, specify `amd` .
     * - For instance types with Habana devices, specify `habana` .
     * - For instance types with NVIDIA devices, specify `nvidia` .
     * - For instance types with Xilinx devices, specify `xilinx` .
     *
     * Default: Any manufacturer
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-acceleratormanufacturers
     */
    readonly acceleratorManufacturers?: Array<string>;

    /**
     * The accelerators that must be on the instance type.
     *
     * - For instance types with NVIDIA A10G GPUs, specify `a10g` .
     * - For instance types with NVIDIA A100 GPUs, specify `a100` .
     * - For instance types with NVIDIA H100 GPUs, specify `h100` .
     * - For instance types with AWS Inferentia chips, specify `inferentia` .
     * - For instance types with NVIDIA GRID K520 GPUs, specify `k520` .
     * - For instance types with NVIDIA K80 GPUs, specify `k80` .
     * - For instance types with NVIDIA M60 GPUs, specify `m60` .
     * - For instance types with AMD Radeon Pro V520 GPUs, specify `radeon-pro-v520` .
     * - For instance types with NVIDIA T4 GPUs, specify `t4` .
     * - For instance types with NVIDIA T4G GPUs, specify `t4g` .
     * - For instance types with Xilinx VU9P FPGAs, specify `vu9p` .
     * - For instance types with NVIDIA V100 GPUs, specify `v100` .
     *
     * Default: Any accelerator
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-acceleratornames
     */
    readonly acceleratorNames?: Array<string>;

    /**
     * The minimum and maximum amount of total accelerator memory, in MiB.
     *
     * Default: No minimum or maximum limits
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-acceleratortotalmemorymib
     */
    readonly acceleratorTotalMemoryMiB?: CfnSpotFleet.AcceleratorTotalMemoryMiBRequestProperty | cdk.IResolvable;

    /**
     * The accelerator types that must be on the instance type.
     *
     * - To include instance types with GPU hardware, specify `gpu` .
     * - To include instance types with FPGA hardware, specify `fpga` .
     * - To include instance types with inference hardware, specify `inference` .
     *
     * Default: Any accelerator type
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-acceleratortypes
     */
    readonly acceleratorTypes?: Array<string>;

    /**
     * The instance types to apply your specified attributes against.
     *
     * All other instance types are ignored, even if they match your specified attributes.
     *
     * You can use strings with one or more wild cards, represented by an asterisk ( `*` ), to allow an instance type, size, or generation. The following are examples: `m5.8xlarge` , `c5*.*` , `m5a.*` , `r*` , `*3*` .
     *
     * For example, if you specify `c5*` ,Amazon EC2 will allow the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*` , Amazon EC2 will allow all the M5a instance types, but not the M5n instance types.
     *
     * > If you specify `AllowedInstanceTypes` , you can't specify `ExcludedInstanceTypes` .
     *
     * Default: All instance types
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-allowedinstancetypes
     */
    readonly allowedInstanceTypes?: Array<string>;

    /**
     * Indicates whether bare metal instance types must be included, excluded, or required.
     *
     * - To include bare metal instance types, specify `included` .
     * - To require only bare metal instance types, specify `required` .
     * - To exclude bare metal instance types, specify `excluded` .
     *
     * Default: `excluded`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-baremetal
     */
    readonly bareMetal?: string;

    /**
     * The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps.
     *
     * For more information, see [Amazon EBSoptimized instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html) in the *Amazon EC2 User Guide* .
     *
     * Default: No minimum or maximum limits
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-baselineebsbandwidthmbps
     */
    readonly baselineEbsBandwidthMbps?: CfnSpotFleet.BaselineEbsBandwidthMbpsRequestProperty | cdk.IResolvable;

    /**
     * Indicates whether burstable performance T instance types are included, excluded, or required.
     *
     * For more information, see [Burstable performance instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html) .
     *
     * - To include burstable performance instance types, specify `included` .
     * - To require only burstable performance instance types, specify `required` .
     * - To exclude burstable performance instance types, specify `excluded` .
     *
     * Default: `excluded`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-burstableperformance
     */
    readonly burstablePerformance?: string;

    /**
     * The CPU manufacturers to include.
     *
     * - For instance types with Intel CPUs, specify `intel` .
     * - For instance types with AMD CPUs, specify `amd` .
     * - For instance types with AWS CPUs, specify `amazon-web-services` .
     *
     * > Don't confuse the CPU manufacturer with the CPU architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template.
     *
     * Default: Any manufacturer
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-cpumanufacturers
     */
    readonly cpuManufacturers?: Array<string>;

    /**
     * The instance types to exclude.
     *
     * You can use strings with one or more wild cards, represented by an asterisk ( `*` ), to exclude an instance family, type, size, or generation. The following are examples: `m5.8xlarge` , `c5*.*` , `m5a.*` , `r*` , `*3*` .
     *
     * For example, if you specify `c5*` ,Amazon EC2 will exclude the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*` , Amazon EC2 will exclude all the M5a instance types, but not the M5n instance types.
     *
     * > If you specify `ExcludedInstanceTypes` , you can't specify `AllowedInstanceTypes` .
     *
     * Default: No excluded instance types
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-excludedinstancetypes
     */
    readonly excludedInstanceTypes?: Array<string>;

    /**
     * Indicates whether current or previous generation instance types are included.
     *
     * The current generation instance types are recommended for use. Current generation instance types are typically the latest two to three generations in each instance family. For more information, see [Instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the *Amazon EC2 User Guide* .
     *
     * For current generation instance types, specify `current` .
     *
     * For previous generation instance types, specify `previous` .
     *
     * Default: Current and previous generation instance types
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-instancegenerations
     */
    readonly instanceGenerations?: Array<string>;

    /**
     * Indicates whether instance types with instance store volumes are included, excluded, or required.
     *
     * For more information, [Amazon EC2 instance store](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html) in the *Amazon EC2 User Guide* .
     *
     * - To include instance types with instance store volumes, specify `included` .
     * - To require only instance types with instance store volumes, specify `required` .
     * - To exclude instance types with instance store volumes, specify `excluded` .
     *
     * Default: `included`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-localstorage
     */
    readonly localStorage?: string;

    /**
     * The type of local storage that is required.
     *
     * - For instance types with hard disk drive (HDD) storage, specify `hdd` .
     * - For instance types with solid state drive (SSD) storage, specify `ssd` .
     *
     * Default: `hdd` and `ssd`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-localstoragetypes
     */
    readonly localStorageTypes?: Array<string>;

    /**
     * The minimum and maximum amount of memory per vCPU, in GiB.
     *
     * Default: No minimum or maximum limits
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-memorygibpervcpu
     */
    readonly memoryGiBPerVCpu?: cdk.IResolvable | CfnSpotFleet.MemoryGiBPerVCpuRequestProperty;

    /**
     * The minimum and maximum amount of memory, in MiB.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-memorymib
     */
    readonly memoryMiB?: cdk.IResolvable | CfnSpotFleet.MemoryMiBRequestProperty;

    /**
     * The minimum and maximum amount of baseline network bandwidth, in gigabits per second (Gbps).
     *
     * For more information, see [Amazon EC2 instance network bandwidth](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-network-bandwidth.html) in the *Amazon EC2 User Guide* .
     *
     * Default: No minimum or maximum limits
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-networkbandwidthgbps
     */
    readonly networkBandwidthGbps?: cdk.IResolvable | CfnSpotFleet.NetworkBandwidthGbpsRequestProperty;

    /**
     * The minimum and maximum number of network interfaces.
     *
     * Default: No minimum or maximum limits
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-networkinterfacecount
     */
    readonly networkInterfaceCount?: cdk.IResolvable | CfnSpotFleet.NetworkInterfaceCountRequestProperty;

    /**
     * The price protection threshold for On-Demand Instances.
     *
     * This is the maximum youll pay for an On-Demand Instance, expressed as a percentage above the least expensive current generation M, C, or R instance type with your specified attributes. When Amazon EC2 selects instance types with your attributes, it excludes instance types priced above your threshold.
     *
     * The parameter accepts an integer, which Amazon EC2 interprets as a percentage.
     *
     * To turn off price protection, specify a high value, such as `999999` .
     *
     * This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) and [GetInstanceTypesFromInstanceRequirements](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html) .
     *
     * > If you set `TargetCapacityUnitType` to `vcpu` or `memory-mib` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price.
     *
     * Default: `20`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-ondemandmaxpricepercentageoverlowestprice
     */
    readonly onDemandMaxPricePercentageOverLowestPrice?: number;

    /**
     * Indicates whether instance types must support hibernation for On-Demand Instances.
     *
     * This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) .
     *
     * Default: `false`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-requirehibernatesupport
     */
    readonly requireHibernateSupport?: boolean | cdk.IResolvable;

    /**
     * The price protection threshold for Spot Instance.
     *
     * This is the maximum youll pay for an Spot Instance, expressed as a percentage above the least expensive current generation M, C, or R instance type with your specified attributes. When Amazon EC2 selects instance types with your attributes, it excludes instance types priced above your threshold.
     *
     * The parameter accepts an integer, which Amazon EC2 interprets as a percentage.
     *
     * To turn off price protection, specify a high value, such as `999999` .
     *
     * This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) and [GetInstanceTypesFromInstanceRequirements](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html) .
     *
     * > If you set `TargetCapacityUnitType` to `vcpu` or `memory-mib` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price.
     *
     * Default: `100`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-spotmaxpricepercentageoverlowestprice
     */
    readonly spotMaxPricePercentageOverLowestPrice?: number;

    /**
     * The minimum and maximum amount of total local storage, in GB.
     *
     * Default: No minimum or maximum limits
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-totallocalstoragegb
     */
    readonly totalLocalStorageGb?: cdk.IResolvable | CfnSpotFleet.TotalLocalStorageGBRequestProperty;

    /**
     * The minimum and maximum number of vCPUs.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-vcpucount
     */
    readonly vCpuCount?: cdk.IResolvable | CfnSpotFleet.VCpuCountRangeRequestProperty;
  }

  /**
   * The minimum and maximum number of network interfaces.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-networkinterfacecountrequest.html
   */
  export interface NetworkInterfaceCountRequestProperty {
    /**
     * The maximum number of network interfaces.
     *
     * To specify no maximum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-networkinterfacecountrequest.html#cfn-ec2-spotfleet-networkinterfacecountrequest-max
     */
    readonly max?: number;

    /**
     * The minimum number of network interfaces.
     *
     * To specify no minimum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-networkinterfacecountrequest.html#cfn-ec2-spotfleet-networkinterfacecountrequest-min
     */
    readonly min?: number;
  }

  /**
   * The minimum and maximum amount of memory per vCPU, in GiB.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-memorygibpervcpurequest.html
   */
  export interface MemoryGiBPerVCpuRequestProperty {
    /**
     * The maximum amount of memory per vCPU, in GiB.
     *
     * To specify no maximum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-memorygibpervcpurequest.html#cfn-ec2-spotfleet-memorygibpervcpurequest-max
     */
    readonly max?: number;

    /**
     * The minimum amount of memory per vCPU, in GiB.
     *
     * To specify no minimum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-memorygibpervcpurequest.html#cfn-ec2-spotfleet-memorygibpervcpurequest-min
     */
    readonly min?: number;
  }

  /**
   * The minimum and maximum number of vCPUs.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-vcpucountrangerequest.html
   */
  export interface VCpuCountRangeRequestProperty {
    /**
     * The maximum number of vCPUs.
     *
     * To specify no maximum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-vcpucountrangerequest.html#cfn-ec2-spotfleet-vcpucountrangerequest-max
     */
    readonly max?: number;

    /**
     * The minimum number of vCPUs.
     *
     * To specify no minimum limit, specify `0` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-vcpucountrangerequest.html#cfn-ec2-spotfleet-vcpucountrangerequest-min
     */
    readonly min?: number;
  }

  /**
   * The minimum and maximum amount of baseline network bandwidth, in gigabits per second (Gbps).
   *
   * For more information, see [Amazon EC2 instance network bandwidth](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-network-bandwidth.html) in the *Amazon EC2 User Guide* .
   *
   * Default: No minimum or maximum limits
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-networkbandwidthgbpsrequest.html
   */
  export interface NetworkBandwidthGbpsRequestProperty {
    /**
     * The maximum amount of network bandwidth, in Gbps.
     *
     * To specify no maximum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-networkbandwidthgbpsrequest.html#cfn-ec2-spotfleet-networkbandwidthgbpsrequest-max
     */
    readonly max?: number;

    /**
     * The minimum amount of network bandwidth, in Gbps.
     *
     * To specify no minimum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-networkbandwidthgbpsrequest.html#cfn-ec2-spotfleet-networkbandwidthgbpsrequest-min
     */
    readonly min?: number;
  }

  /**
   * The minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips) on an instance.
   *
   * To exclude accelerator-enabled instance types, set `Max` to `0` .
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-acceleratorcountrequest.html
   */
  export interface AcceleratorCountRequestProperty {
    /**
     * The maximum number of accelerators.
     *
     * To specify no maximum limit, omit this parameter. To exclude accelerator-enabled instance types, set `Max` to `0` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-acceleratorcountrequest.html#cfn-ec2-spotfleet-acceleratorcountrequest-max
     */
    readonly max?: number;

    /**
     * The minimum number of accelerators.
     *
     * To specify no minimum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-acceleratorcountrequest.html#cfn-ec2-spotfleet-acceleratorcountrequest-min
     */
    readonly min?: number;
  }

  /**
   * The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps.
   *
   * For more information, see [Amazon EBSoptimized instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html) in the *Amazon EC2 User Guide* .
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-baselineebsbandwidthmbpsrequest.html
   */
  export interface BaselineEbsBandwidthMbpsRequestProperty {
    /**
     * The maximum baseline bandwidth, in Mbps.
     *
     * To specify no maximum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-baselineebsbandwidthmbpsrequest.html#cfn-ec2-spotfleet-baselineebsbandwidthmbpsrequest-max
     */
    readonly max?: number;

    /**
     * The minimum baseline bandwidth, in Mbps.
     *
     * To specify no minimum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-baselineebsbandwidthmbpsrequest.html#cfn-ec2-spotfleet-baselineebsbandwidthmbpsrequest-min
     */
    readonly min?: number;
  }

  /**
   * The minimum and maximum amount of total accelerator memory, in MiB.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-acceleratortotalmemorymibrequest.html
   */
  export interface AcceleratorTotalMemoryMiBRequestProperty {
    /**
     * The maximum amount of accelerator memory, in MiB.
     *
     * To specify no maximum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-acceleratortotalmemorymibrequest.html#cfn-ec2-spotfleet-acceleratortotalmemorymibrequest-max
     */
    readonly max?: number;

    /**
     * The minimum amount of accelerator memory, in MiB.
     *
     * To specify no minimum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-acceleratortotalmemorymibrequest.html#cfn-ec2-spotfleet-acceleratortotalmemorymibrequest-min
     */
    readonly min?: number;
  }

  /**
   * The minimum and maximum amount of memory, in MiB.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-memorymibrequest.html
   */
  export interface MemoryMiBRequestProperty {
    /**
     * The maximum amount of memory, in MiB.
     *
     * To specify no maximum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-memorymibrequest.html#cfn-ec2-spotfleet-memorymibrequest-max
     */
    readonly max?: number;

    /**
     * The minimum amount of memory, in MiB.
     *
     * To specify no minimum limit, specify `0` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-memorymibrequest.html#cfn-ec2-spotfleet-memorymibrequest-min
     */
    readonly min?: number;
  }

  /**
   * The minimum and maximum amount of total local storage, in GB.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-totallocalstoragegbrequest.html
   */
  export interface TotalLocalStorageGBRequestProperty {
    /**
     * The maximum amount of total local storage, in GB.
     *
     * To specify no maximum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-totallocalstoragegbrequest.html#cfn-ec2-spotfleet-totallocalstoragegbrequest-max
     */
    readonly max?: number;

    /**
     * The minimum amount of total local storage, in GB.
     *
     * To specify no minimum limit, omit this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-totallocalstoragegbrequest.html#cfn-ec2-spotfleet-totallocalstoragegbrequest-min
     */
    readonly min?: number;
  }

  /**
   * The strategies for managing your Spot Instances that are at an elevated risk of being interrupted.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotmaintenancestrategies.html
   */
  export interface SpotMaintenanceStrategiesProperty {
    /**
     * The Spot Instance replacement strategy to use when Amazon EC2 emits a signal that your Spot Instance is at an elevated risk of being interrupted.
     *
     * For more information, see [Capacity rebalancing](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-capacity-rebalance.html) in the *Amazon EC2 User Guide for Linux Instances* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotmaintenancestrategies.html#cfn-ec2-spotfleet-spotmaintenancestrategies-capacityrebalance
     */
    readonly capacityRebalance?: cdk.IResolvable | CfnSpotFleet.SpotCapacityRebalanceProperty;
  }

  /**
   * The Spot Instance replacement strategy to use when Amazon EC2 emits a signal that your Spot Instance is at an elevated risk of being interrupted.
   *
   * For more information, see [Capacity rebalancing](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-capacity-rebalance.html) in the *Amazon EC2 User Guide for Linux Instances* .
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotcapacityrebalance.html
   */
  export interface SpotCapacityRebalanceProperty {
    /**
     * The replacement strategy to use. Only available for fleets of type `maintain` .
     *
     * `launch` - Spot Fleet launches a new replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet. Spot Fleet does not terminate the instances that receive a rebalance notification. You can terminate the old instances, or you can leave them running. You are charged for all instances while they are running.
     *
     * `launch-before-terminate` - Spot Fleet launches a new replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet, and then, after a delay that you specify (in `TerminationDelay` ), terminates the instances that received a rebalance notification.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotcapacityrebalance.html#cfn-ec2-spotfleet-spotcapacityrebalance-replacementstrategy
     */
    readonly replacementStrategy?: string;

    /**
     * The amount of time (in seconds) that Amazon EC2 waits before terminating the old Spot Instance after launching a new replacement Spot Instance.
     *
     * Required when `ReplacementStrategy` is set to `launch-before-terminate` .
     *
     * Not valid when `ReplacementStrategy` is set to `launch` .
     *
     * Valid values: Minimum value of `120` seconds. Maximum value of `7200` seconds.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotcapacityrebalance.html#cfn-ec2-spotfleet-spotcapacityrebalance-terminationdelay
     */
    readonly terminationDelay?: number;
  }

  /**
   * Specifies the launch specification for one or more Spot Instances.
   *
   * If you include On-Demand capacity in your fleet request, you can't use `SpotFleetLaunchSpecification` ; you must use [LaunchTemplateConfig](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-launchtemplateconfig.html) .
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html
   */
  export interface SpotFleetLaunchSpecificationProperty {
    /**
     * One or more block devices that are mapped to the Spot Instances.
     *
     * You can't specify both a snapshot ID and an encryption value. This is because only blank volumes can be encrypted on creation. If a snapshot is the basis for a volume, it is not blank and its encryption status is used for the volume encryption status.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-blockdevicemappings
     */
    readonly blockDeviceMappings?: Array<CfnSpotFleet.BlockDeviceMappingProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * Indicates whether the instances are optimized for EBS I/O.
     *
     * This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance.
     *
     * Default: `false`
     *
     * @default - false
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-ebsoptimized
     */
    readonly ebsOptimized?: boolean | cdk.IResolvable;

    /**
     * The IAM instance profile.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-iaminstanceprofile
     */
    readonly iamInstanceProfile?: CfnSpotFleet.IamInstanceProfileSpecificationProperty | cdk.IResolvable;

    /**
     * The ID of the AMI.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-imageid
     */
    readonly imageId: string;

    /**
     * The attributes for the instance types.
     *
     * When you specify instance attributes, Amazon EC2 will identify instance types with those attributes.
     *
     * > If you specify `InstanceRequirements` , you can't specify `InstanceType` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-instancerequirements
     */
    readonly instanceRequirements?: CfnSpotFleet.InstanceRequirementsRequestProperty | cdk.IResolvable;

    /**
     * The instance type.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-instancetype
     */
    readonly instanceType?: string;

    /**
     * The ID of the kernel.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-kernelid
     */
    readonly kernelId?: string;

    /**
     * The name of the key pair.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-keyname
     */
    readonly keyName?: string;

    /**
     * Enable or disable monitoring for the instances.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-monitoring
     */
    readonly monitoring?: cdk.IResolvable | CfnSpotFleet.SpotFleetMonitoringProperty;

    /**
     * One or more network interfaces.
     *
     * If you specify a network interface, you must specify subnet IDs and security group IDs using the network interface.
     *
     * > `SpotFleetLaunchSpecification` currently does not support Elastic Fabric Adapter (EFA). To specify an EFA, you must use [LaunchTemplateConfig](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_LaunchTemplateConfig.html) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-networkinterfaces
     */
    readonly networkInterfaces?: Array<CfnSpotFleet.InstanceNetworkInterfaceSpecificationProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The placement information.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-placement
     */
    readonly placement?: cdk.IResolvable | CfnSpotFleet.SpotPlacementProperty;

    /**
     * The ID of the RAM disk.
     *
     * Some kernels require additional drivers at launch. Check the kernel requirements for information about whether you need to specify a RAM disk. To find kernel requirements, refer to the AWS Resource Center and search for the kernel ID.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-ramdiskid
     */
    readonly ramdiskId?: string;

    /**
     * The security groups.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-securitygroups
     */
    readonly securityGroups?: Array<CfnSpotFleet.GroupIdentifierProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The maximum price per unit hour that you are willing to pay for a Spot Instance.
     *
     * We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price.
     *
     * > If you specify a maximum price, your instances will be interrupted more frequently than if you do not specify this parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-spotprice
     */
    readonly spotPrice?: string;

    /**
     * The IDs of the subnets in which to launch the instances.
     *
     * To specify multiple subnets, separate them using commas; for example, "subnet-1234abcdeexample1, subnet-0987cdef6example2".
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-subnetid
     */
    readonly subnetId?: string;

    /**
     * The tags to apply during creation.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-tagspecifications
     */
    readonly tagSpecifications?: Array<cdk.IResolvable | CfnSpotFleet.SpotFleetTagSpecificationProperty> | cdk.IResolvable;

    /**
     * The base64-encoded user data that instances use when starting up.
     *
     * User data is limited to 16 KB.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-userdata
     */
    readonly userData?: string;

    /**
     * The number of units provided by the specified instance type.
     *
     * These are the same units that you chose to set the target capacity in terms of instances, or a performance characteristic such as vCPUs, memory, or I/O.
     *
     * If the target capacity divided by this value is not a whole number, Amazon EC2 rounds the number of instances to the next whole number. If this value is not specified, the default is 1.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-weightedcapacity
     */
    readonly weightedCapacity?: number;
  }

  /**
   * Describes a security group.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-groupidentifier.html
   */
  export interface GroupIdentifierProperty {
    /**
     * The ID of the security group.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-groupidentifier.html#cfn-ec2-spotfleet-groupidentifier-groupid
     */
    readonly groupId: string;
  }

  /**
   * Specifies a block device mapping.
   *
   * You can specify `Ebs` or `VirtualName` , but not both.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-blockdevicemapping.html
   */
  export interface BlockDeviceMappingProperty {
    /**
     * The device name (for example, `/dev/sdh` or `xvdh` ).
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-blockdevicemapping.html#cfn-ec2-spotfleet-blockdevicemapping-devicename
     */
    readonly deviceName: string;

    /**
     * Parameters used to automatically set up EBS volumes when the instance is launched.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-blockdevicemapping.html#cfn-ec2-spotfleet-blockdevicemapping-ebs
     */
    readonly ebs?: CfnSpotFleet.EbsBlockDeviceProperty | cdk.IResolvable;

    /**
     * To omit the device from the block device mapping, specify an empty string.
     *
     * When this property is specified, the device is removed from the block device mapping regardless of the assigned value.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-blockdevicemapping.html#cfn-ec2-spotfleet-blockdevicemapping-nodevice
     */
    readonly noDevice?: string;

    /**
     * The virtual device name ( `ephemeral` N).
     *
     * Instance store volumes are numbered starting from 0. An instance type with 2 available instance store volumes can specify mappings for `ephemeral0` and `ephemeral1` . The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume.
     *
     * NVMe instance store volumes are automatically enumerated and assigned a device name. Including them in your block device mapping has no effect.
     *
     * Constraints: For M3 instances, you must specify instance store volumes in the block device mapping for the instance. When you launch an M3 instance, we ignore any instance store volumes specified in the block device mapping for the AMI.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-blockdevicemapping.html#cfn-ec2-spotfleet-blockdevicemapping-virtualname
     */
    readonly virtualName?: string;
  }

  /**
   * Describes a block device for an EBS volume.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-ebsblockdevice.html
   */
  export interface EbsBlockDeviceProperty {
    /**
     * Indicates whether the EBS volume is deleted on instance termination.
     *
     * For more information, see [Preserving Amazon EBS volumes on instance termination](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/terminating-instances.html#preserving-volumes-on-termination) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-ebsblockdevice.html#cfn-ec2-spotfleet-ebsblockdevice-deleteontermination
     */
    readonly deleteOnTermination?: boolean | cdk.IResolvable;

    /**
     * Indicates whether the encryption state of an EBS volume is changed while being restored from a backing snapshot.
     *
     * The effect of setting the encryption state to `true` depends on the volume origin (new or from a snapshot), starting encryption state, ownership, and whether encryption by default is enabled. For more information, see [Amazon EBS Encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#encryption-parameters) in the *Amazon EC2 User Guide* .
     *
     * In no case can you remove encryption from an encrypted volume.
     *
     * Encrypted volumes can only be attached to instances that support Amazon EBS encryption. For more information, see [Supported Instance Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#EBSEncryption_supported_instances) .
     *
     * This parameter is not returned by [DescribeImageAttribute](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeImageAttribute.html) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-ebsblockdevice.html#cfn-ec2-spotfleet-ebsblockdevice-encrypted
     */
    readonly encrypted?: boolean | cdk.IResolvable;

    /**
     * The number of I/O operations per second (IOPS).
     *
     * For `gp3` , `io1` , and `io2` volumes, this represents the number of IOPS that are provisioned for the volume. For `gp2` volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting.
     *
     * The following are the supported values for each volume type:
     *
     * - `gp3` : 3,000 - 16,000 IOPS
     * - `io1` : 100 - 64,000 IOPS
     * - `io2` : 100 - 256,000 IOPS
     *
     * For `io2` volumes, you can achieve up to 256,000 IOPS on [instances built on the Nitro System](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances) . On other instances, you can achieve performance up to 32,000 IOPS.
     *
     * This parameter is required for `io1` and `io2` volumes. The default for `gp3` volumes is 3,000 IOPS.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-ebsblockdevice.html#cfn-ec2-spotfleet-ebsblockdevice-iops
     */
    readonly iops?: number;

    /**
     * The ID of the snapshot.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-ebsblockdevice.html#cfn-ec2-spotfleet-ebsblockdevice-snapshotid
     */
    readonly snapshotId?: string;

    /**
     * The size of the volume, in GiBs.
     *
     * You must specify either a snapshot ID or a volume size. If you specify a snapshot, the default is the snapshot size. You can specify a volume size that is equal to or larger than the snapshot size.
     *
     * The following are the supported sizes for each volume type:
     *
     * - `gp2` and `gp3` : 1 - 16,384 GiB
     * - `io1` : 4 - 16,384 GiB
     * - `io2` : 4 - 65,536 GiB
     * - `st1` and `sc1` : 125 - 16,384 GiB
     * - `standard` : 1 - 1024 GiB
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-ebsblockdevice.html#cfn-ec2-spotfleet-ebsblockdevice-volumesize
     */
    readonly volumeSize?: number;

    /**
     * The volume type.
     *
     * For more information, see [Amazon EBS volume types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-ebsblockdevice.html#cfn-ec2-spotfleet-ebsblockdevice-volumetype
     */
    readonly volumeType?: string;
  }

  /**
   * Describes an IAM instance profile.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-iaminstanceprofilespecification.html
   */
  export interface IamInstanceProfileSpecificationProperty {
    /**
     * The Amazon Resource Name (ARN) of the instance profile.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-iaminstanceprofilespecification.html#cfn-ec2-spotfleet-iaminstanceprofilespecification-arn
     */
    readonly arn?: string;
  }

  /**
   * Describes Spot Instance placement.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotplacement.html
   */
  export interface SpotPlacementProperty {
    /**
     * The Availability Zone.
     *
     * To specify multiple Availability Zones, separate them using commas; for example, "us-west-2a, us-west-2b".
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotplacement.html#cfn-ec2-spotfleet-spotplacement-availabilityzone
     */
    readonly availabilityZone?: string;

    /**
     * The name of the placement group.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotplacement.html#cfn-ec2-spotfleet-spotplacement-groupname
     */
    readonly groupName?: string;

    /**
     * The tenancy of the instance (if the instance is running in a VPC).
     *
     * An instance with a tenancy of `dedicated` runs on single-tenant hardware. The `host` tenancy is not supported for Spot Instances.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotplacement.html#cfn-ec2-spotfleet-spotplacement-tenancy
     */
    readonly tenancy?: string;
  }

  /**
   * Describes a network interface.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancenetworkinterfacespecification.html
   */
  export interface InstanceNetworkInterfaceSpecificationProperty {
    /**
     * Indicates whether to assign a public IPv4 address to an instance you launch in a VPC.
     *
     * The public IP address can only be assigned to a network interface for eth0, and can only be assigned to a new network interface, not an existing one. You cannot specify more than one network interface in the request. If launching into a default subnet, the default value is `true` .
     *
     * Starting on February 1, 2024, AWS will charge for all public IPv4 addresses, including public IPv4 addresses associated with running instances and Elastic IP addresses. For more information, see the *Public IPv4 Address* tab on the [Amazon VPC pricing page](https://docs.aws.amazon.com/vpc/pricing/) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancenetworkinterfacespecification.html#cfn-ec2-spotfleet-instancenetworkinterfacespecification-associatepublicipaddress
     */
    readonly associatePublicIpAddress?: boolean | cdk.IResolvable;

    /**
     * Indicates whether the network interface is deleted when the instance is terminated.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancenetworkinterfacespecification.html#cfn-ec2-spotfleet-instancenetworkinterfacespecification-deleteontermination
     */
    readonly deleteOnTermination?: boolean | cdk.IResolvable;

    /**
     * The description of the network interface.
     *
     * Applies only if creating a network interface when launching an instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancenetworkinterfacespecification.html#cfn-ec2-spotfleet-instancenetworkinterfacespecification-description
     */
    readonly description?: string;

    /**
     * The position of the network interface in the attachment order.
     *
     * A primary network interface has a device index of 0.
     *
     * If you specify a network interface when launching an instance, you must specify the device index.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancenetworkinterfacespecification.html#cfn-ec2-spotfleet-instancenetworkinterfacespecification-deviceindex
     */
    readonly deviceIndex?: number;

    /**
     * The IDs of the security groups for the network interface.
     *
     * Applies only if creating a network interface when launching an instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancenetworkinterfacespecification.html#cfn-ec2-spotfleet-instancenetworkinterfacespecification-groups
     */
    readonly groups?: Array<string>;

    /**
     * A number of IPv6 addresses to assign to the network interface.
     *
     * Amazon EC2 chooses the IPv6 addresses from the range of the subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancenetworkinterfacespecification.html#cfn-ec2-spotfleet-instancenetworkinterfacespecification-ipv6addresscount
     */
    readonly ipv6AddressCount?: number;

    /**
     * The IPv6 addresses to assign to the network interface.
     *
     * You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancenetworkinterfacespecification.html#cfn-ec2-spotfleet-instancenetworkinterfacespecification-ipv6addresses
     */
    readonly ipv6Addresses?: Array<CfnSpotFleet.InstanceIpv6AddressProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The ID of the network interface.
     *
     * If you are creating a Spot Fleet, omit this parameter because you cant specify a network interface ID in a launch specification.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancenetworkinterfacespecification.html#cfn-ec2-spotfleet-instancenetworkinterfacespecification-networkinterfaceid
     */
    readonly networkInterfaceId?: string;

    /**
     * The private IPv4 addresses to assign to the network interface.
     *
     * Only one private IPv4 address can be designated as primary. You cannot specify this option if you're launching more than one instance in a [RunInstances](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html) request.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancenetworkinterfacespecification.html#cfn-ec2-spotfleet-instancenetworkinterfacespecification-privateipaddresses
     */
    readonly privateIpAddresses?: Array<cdk.IResolvable | CfnSpotFleet.PrivateIpAddressSpecificationProperty> | cdk.IResolvable;

    /**
     * The number of secondary private IPv4 addresses.
     *
     * You can't specify this option and specify more than one private IP address using the private IP addresses option. You cannot specify this option if you're launching more than one instance in a [RunInstances](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html) request.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancenetworkinterfacespecification.html#cfn-ec2-spotfleet-instancenetworkinterfacespecification-secondaryprivateipaddresscount
     */
    readonly secondaryPrivateIpAddressCount?: number;

    /**
     * The ID of the subnet associated with the network interface.
     *
     * Applies only if creating a network interface when launching an instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancenetworkinterfacespecification.html#cfn-ec2-spotfleet-instancenetworkinterfacespecification-subnetid
     */
    readonly subnetId?: string;
  }

  /**
   * Describes a secondary private IPv4 address for a network interface.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-privateipaddressspecification.html
   */
  export interface PrivateIpAddressSpecificationProperty {
    /**
     * Indicates whether the private IPv4 address is the primary private IPv4 address.
     *
     * Only one IPv4 address can be designated as primary.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-privateipaddressspecification.html#cfn-ec2-spotfleet-privateipaddressspecification-primary
     */
    readonly primary?: boolean | cdk.IResolvable;

    /**
     * The private IPv4 address.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-privateipaddressspecification.html#cfn-ec2-spotfleet-privateipaddressspecification-privateipaddress
     */
    readonly privateIpAddress: string;
  }

  /**
   * Describes an IPv6 address.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instanceipv6address.html
   */
  export interface InstanceIpv6AddressProperty {
    /**
     * The IPv6 address.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instanceipv6address.html#cfn-ec2-spotfleet-instanceipv6address-ipv6address
     */
    readonly ipv6Address: string;
  }

  /**
   * Describes whether monitoring is enabled.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetmonitoring.html
   */
  export interface SpotFleetMonitoringProperty {
    /**
     * Enables monitoring for the instance.
     *
     * Default: `false`
     *
     * @default - false
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetmonitoring.html#cfn-ec2-spotfleet-spotfleetmonitoring-enabled
     */
    readonly enabled?: boolean | cdk.IResolvable;
  }

  /**
   * Specifies the Classic Load Balancers and target groups to attach to a Spot Fleet request.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-loadbalancersconfig.html
   */
  export interface LoadBalancersConfigProperty {
    /**
     * The Classic Load Balancers.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-loadbalancersconfig.html#cfn-ec2-spotfleet-loadbalancersconfig-classicloadbalancersconfig
     */
    readonly classicLoadBalancersConfig?: CfnSpotFleet.ClassicLoadBalancersConfigProperty | cdk.IResolvable;

    /**
     * The target groups.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-loadbalancersconfig.html#cfn-ec2-spotfleet-loadbalancersconfig-targetgroupsconfig
     */
    readonly targetGroupsConfig?: cdk.IResolvable | CfnSpotFleet.TargetGroupsConfigProperty;
  }

  /**
   * Specifies the Classic Load Balancers to attach to a Spot Fleet.
   *
   * Spot Fleet registers the running Spot Instances with these Classic Load Balancers.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-classicloadbalancersconfig.html
   */
  export interface ClassicLoadBalancersConfigProperty {
    /**
     * One or more Classic Load Balancers.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-classicloadbalancersconfig.html#cfn-ec2-spotfleet-classicloadbalancersconfig-classicloadbalancers
     */
    readonly classicLoadBalancers: Array<CfnSpotFleet.ClassicLoadBalancerProperty | cdk.IResolvable> | cdk.IResolvable;
  }

  /**
   * Specifies a Classic Load Balancer.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-classicloadbalancer.html
   */
  export interface ClassicLoadBalancerProperty {
    /**
     * The name of the load balancer.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-classicloadbalancer.html#cfn-ec2-spotfleet-classicloadbalancer-name
     */
    readonly name: string;
  }

  /**
   * Describes the target groups to attach to a Spot Fleet.
   *
   * Spot Fleet registers the running Spot Instances with these target groups.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-targetgroupsconfig.html
   */
  export interface TargetGroupsConfigProperty {
    /**
     * One or more target groups.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-targetgroupsconfig.html#cfn-ec2-spotfleet-targetgroupsconfig-targetgroups
     */
    readonly targetGroups: Array<cdk.IResolvable | CfnSpotFleet.TargetGroupProperty> | cdk.IResolvable;
  }

  /**
   * Describes a load balancer target group.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-targetgroup.html
   */
  export interface TargetGroupProperty {
    /**
     * The Amazon Resource Name (ARN) of the target group.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-targetgroup.html#cfn-ec2-spotfleet-targetgroup-arn
     */
    readonly arn: string;
  }
}

/**
 * Properties for defining a `CfnSpotFleet`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-spotfleet.html
 */
export interface CfnSpotFleetProps {
  /**
   * Describes the configuration of a Spot Fleet request.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-spotfleet.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata
   */
  readonly spotFleetRequestConfigData: cdk.IResolvable | CfnSpotFleet.SpotFleetRequestConfigDataProperty;
}

/**
 * Determine whether the given properties match those of a `SpotFleetTagSpecificationProperty`
 *
 * @param properties - the TypeScript properties of a `SpotFleetTagSpecificationProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetSpotFleetTagSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("resourceType", cdk.validateString)(properties.resourceType));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \"SpotFleetTagSpecificationProperty\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetSpotFleetTagSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetSpotFleetTagSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "ResourceType": cdk.stringToCloudFormation(properties.resourceType),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetSpotFleetTagSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSpotFleet.SpotFleetTagSpecificationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleet.SpotFleetTagSpecificationProperty>();
  ret.addPropertyResult("resourceType", "ResourceType", (properties.ResourceType != null ? cfn_parse.FromCloudFormation.getString(properties.ResourceType) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `FleetLaunchTemplateSpecificationProperty`
 *
 * @param properties - the TypeScript properties of a `FleetLaunchTemplateSpecificationProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetFleetLaunchTemplateSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("launchTemplateId", cdk.validateString)(properties.launchTemplateId));
  errors.collect(cdk.propertyValidator("launchTemplateName", cdk.validateString)(properties.launchTemplateName));
  errors.collect(cdk.propertyValidator("version", cdk.requiredValidator)(properties.version));
  errors.collect(cdk.propertyValidator("version", cdk.validateString)(properties.version));
  return errors.wrap("supplied properties not correct for \"FleetLaunchTemplateSpecificationProperty\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetFleetLaunchTemplateSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetFleetLaunchTemplateSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "LaunchTemplateId": cdk.stringToCloudFormation(properties.launchTemplateId),
    "LaunchTemplateName": cdk.stringToCloudFormation(properties.launchTemplateName),
    "Version": cdk.stringToCloudFormation(properties.version)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetFleetLaunchTemplateSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSpotFleet.FleetLaunchTemplateSpecificationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleet.FleetLaunchTemplateSpecificationProperty>();
  ret.addPropertyResult("launchTemplateId", "LaunchTemplateId", (properties.LaunchTemplateId != null ? cfn_parse.FromCloudFormation.getString(properties.LaunchTemplateId) : undefined));
  ret.addPropertyResult("launchTemplateName", "LaunchTemplateName", (properties.LaunchTemplateName != null ? cfn_parse.FromCloudFormation.getString(properties.LaunchTemplateName) : undefined));
  ret.addPropertyResult("version", "Version", (properties.Version != null ? cfn_parse.FromCloudFormation.getString(properties.Version) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `NetworkInterfaceCountRequestProperty`
 *
 * @param properties - the TypeScript properties of a `NetworkInterfaceCountRequestProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetNetworkInterfaceCountRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("max", cdk.validateNumber)(properties.max));
  errors.collect(cdk.propertyValidator("min", cdk.validateNumber)(properties.min));
  return errors.wrap("supplied properties not correct for \"NetworkInterfaceCountRequestProperty\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetNetworkInterfaceCountRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetNetworkInterfaceCountRequestPropertyValidator(properties).assertSuccess();
  return {
    "Max": cdk.numberToCloudFormation(properties.max),
    "Min": cdk.numberToCloudFormation(properties.min)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetNetworkInterfaceCountRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSpotFleet.NetworkInterfaceCountRequestProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleet.NetworkInterfaceCountRequestProperty>();
  ret.addPropertyResult("max", "Max", (properties.Max != null ? cfn_parse.FromCloudFormation.getNumber(properties.Max) : undefined));
  ret.addPropertyResult("min", "Min", (properties.Min != null ? cfn_parse.FromCloudFormation.getNumber(properties.Min) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `MemoryGiBPerVCpuRequestProperty`
 *
 * @param properties - the TypeScript properties of a `MemoryGiBPerVCpuRequestProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetMemoryGiBPerVCpuRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("max", cdk.validateNumber)(properties.max));
  errors.collect(cdk.propertyValidator("min", cdk.validateNumber)(properties.min));
  return errors.wrap("supplied properties not correct for \"MemoryGiBPerVCpuRequestProperty\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetMemoryGiBPerVCpuRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetMemoryGiBPerVCpuRequestPropertyValidator(properties).assertSuccess();
  return {
    "Max": cdk.numberToCloudFormation(properties.max),
    "Min": cdk.numberToCloudFormation(properties.min)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetMemoryGiBPerVCpuRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSpotFleet.MemoryGiBPerVCpuRequestProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleet.MemoryGiBPerVCpuRequestProperty>();
  ret.addPropertyResult("max", "Max", (properties.Max != null ? cfn_parse.FromCloudFormation.getNumber(properties.Max) : undefined));
  ret.addPropertyResult("min", "Min", (properties.Min != null ? cfn_parse.FromCloudFormation.getNumber(properties.Min) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `VCpuCountRangeRequestProperty`
 *
 * @param properties - the TypeScript properties of a `VCpuCountRangeRequestProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetVCpuCountRangeRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("max", cdk.validateNumber)(properties.max));
  errors.collect(cdk.propertyValidator("min", cdk.validateNumber)(properties.min));
  return errors.wrap("supplied properties not correct for \"VCpuCountRangeRequestProperty\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetVCpuCountRangeRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetVCpuCountRangeRequestPropertyValidator(properties).assertSuccess();
  return {
    "Max": cdk.numberToCloudFormation(properties.max),
    "Min": cdk.numberToCloudFormation(properties.min)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetVCpuCountRangeRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSpotFleet.VCpuCountRangeRequestProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleet.VCpuCountRangeRequestProperty>();
  ret.addPropertyResult("max", "Max", (properties.Max != null ? cfn_parse.FromCloudFormation.getNumber(properties.Max) : undefined));
  ret.addPropertyResult("min", "Min", (properties.Min != null ? cfn_parse.FromCloudFormation.getNumber(properties.Min) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `NetworkBandwidthGbpsRequestProperty`
 *
 * @param properties - the TypeScript properties of a `NetworkBandwidthGbpsRequestProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetNetworkBandwidthGbpsRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("max", cdk.validateNumber)(properties.max));
  errors.collect(cdk.propertyValidator("min", cdk.validateNumber)(properties.min));
  return errors.wrap("supplied properties not correct for \"NetworkBandwidthGbpsRequestProperty\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetNetworkBandwidthGbpsRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetNetworkBandwidthGbpsRequestPropertyValidator(properties).assertSuccess();
  return {
    "Max": cdk.numberToCloudFormation(properties.max),
    "Min": cdk.numberToCloudFormation(properties.min)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetNetworkBandwidthGbpsRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSpotFleet.NetworkBandwidthGbpsRequestProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleet.NetworkBandwidthGbpsRequestProperty>();
  ret.addPropertyResult("max", "Max", (properties.Max != null ? cfn_parse.FromCloudFormation.getNumber(properties.Max) : undefined));
  ret.addPropertyResult("min", "Min", (properties.Min != null ? cfn_parse.FromCloudFormation.getNumber(properties.Min) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `AcceleratorCountRequestProperty`
 *
 * @param properties - the TypeScript properties of a `AcceleratorCountRequestProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetAcceleratorCountRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("max", cdk.validateNumber)(properties.max));
  errors.collect(cdk.propertyValidator("min", cdk.validateNumber)(properties.min));
  return errors.wrap("supplied properties not correct for \"AcceleratorCountRequestProperty\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetAcceleratorCountRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetAcceleratorCountRequestPropertyValidator(properties).assertSuccess();
  return {
    "Max": cdk.numberToCloudFormation(properties.max),
    "Min": cdk.numberToCloudFormation(properties.min)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetAcceleratorCountRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSpotFleet.AcceleratorCountRequestProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleet.AcceleratorCountRequestProperty>();
  ret.addPropertyResult("max", "Max", (properties.Max != null ? cfn_parse.FromCloudFormation.getNumber(properties.Max) : undefined));
  ret.addPropertyResult("min", "Min", (properties.Min != null ? cfn_parse.FromCloudFormation.getNumber(properties.Min) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `BaselineEbsBandwidthMbpsRequestProperty`
 *
 * @param properties - the TypeScript properties of a `BaselineEbsBandwidthMbpsRequestProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetBaselineEbsBandwidthMbpsRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("max", cdk.validateNumber)(properties.max));
  errors.collect(cdk.propertyValidator("min", cdk.validateNumber)(properties.min));
  return errors.wrap("supplied properties not correct for \"BaselineEbsBandwidthMbpsRequestProperty\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetBaselineEbsBandwidthMbpsRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetBaselineEbsBandwidthMbpsRequestPropertyValidator(properties).assertSuccess();
  return {
    "Max": cdk.numberToCloudFormation(properties.max),
    "Min": cdk.numberToCloudFormation(properties.min)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetBaselineEbsBandwidthMbpsRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSpotFleet.BaselineEbsBandwidthMbpsRequestProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleet.BaselineEbsBandwidthMbpsRequestProperty>();
  ret.addPropertyResult("max", "Max", (properties.Max != null ? cfn_parse.FromCloudFormation.getNumber(properties.Max) : undefined));
  ret.addPropertyResult("min", "Min", (properties.Min != null ? cfn_parse.FromCloudFormation.getNumber(properties.Min) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `AcceleratorTotalMemoryMiBRequestProperty`
 *
 * @param properties - the TypeScript properties of a `AcceleratorTotalMemoryMiBRequestProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetAcceleratorTotalMemoryMiBRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("max", cdk.validateNumber)(properties.max));
  errors.collect(cdk.propertyValidator("min", cdk.validateNumber)(properties.min));
  return errors.wrap("supplied properties not correct for \"AcceleratorTotalMemoryMiBRequestProperty\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetAcceleratorTotalMemoryMiBRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetAcceleratorTotalMemoryMiBRequestPropertyValidator(properties).assertSuccess();
  return {
    "Max": cdk.numberToCloudFormation(properties.max),
    "Min": cdk.numberToCloudFormation(properties.min)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetAcceleratorTotalMemoryMiBRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSpotFleet.AcceleratorTotalMemoryMiBRequestProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleet.AcceleratorTotalMemoryMiBRequestProperty>();
  ret.addPropertyResult("max", "Max", (properties.Max != null ? cfn_parse.FromCloudFormation.getNumber(properties.Max) : undefined));
  ret.addPropertyResult("min", "Min", (properties.Min != null ? cfn_parse.FromCloudFormation.getNumber(properties.Min) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `MemoryMiBRequestProperty`
 *
 * @param properties - the TypeScript properties of a `MemoryMiBRequestProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetMemoryMiBRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("max", cdk.validateNumber)(properties.max));
  errors.collect(cdk.propertyValidator("min", cdk.validateNumber)(properties.min));
  return errors.wrap("supplied properties not correct for \"MemoryMiBRequestProperty\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetMemoryMiBRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetMemoryMiBRequestPropertyValidator(properties).assertSuccess();
  return {
    "Max": cdk.numberToCloudFormation(properties.max),
    "Min": cdk.numberToCloudFormation(properties.min)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetMemoryMiBRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSpotFleet.MemoryMiBRequestProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleet.MemoryMiBRequestProperty>();
  ret.addPropertyResult("max", "Max", (properties.Max != null ? cfn_parse.FromCloudFormation.getNumber(properties.Max) : undefined));
  ret.addPropertyResult("min", "Min", (properties.Min != null ? cfn_parse.FromCloudFormation.getNumber(properties.Min) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `TotalLocalStorageGBRequestProperty`
 *
 * @param properties - the TypeScript properties of a `TotalLocalStorageGBRequestProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetTotalLocalStorageGBRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("max", cdk.validateNumber)(properties.max));
  errors.collect(cdk.propertyValidator("min", cdk.validateNumber)(properties.min));
  return errors.wrap("supplied properties not correct for \"TotalLocalStorageGBRequestProperty\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetTotalLocalStorageGBRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetTotalLocalStorageGBRequestPropertyValidator(properties).assertSuccess();
  return {
    "Max": cdk.numberToCloudFormation(properties.max),
    "Min": cdk.numberToCloudFormation(properties.min)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetTotalLocalStorageGBRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSpotFleet.TotalLocalStorageGBRequestProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleet.TotalLocalStorageGBRequestProperty>();
  ret.addPropertyResult("max", "Max", (properties.Max != null ? cfn_parse.FromCloudFormation.getNumber(properties.Max) : undefined));
  ret.addPropertyResult("min", "Min", (properties.Min != null ? cfn_parse.FromCloudFormation.getNumber(properties.Min) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `InstanceRequirementsRequestProperty`
 *
 * @param properties - the TypeScript properties of a `InstanceRequirementsRequestProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetInstanceRequirementsRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("acceleratorCount", CfnSpotFleetAcceleratorCountRequestPropertyValidator)(properties.acceleratorCount));
  errors.collect(cdk.propertyValidator("acceleratorManufacturers", cdk.listValidator(cdk.validateString))(properties.acceleratorManufacturers));
  errors.collect(cdk.propertyValidator("acceleratorNames", cdk.listValidator(cdk.validateString))(properties.acceleratorNames));
  errors.collect(cdk.propertyValidator("acceleratorTotalMemoryMiB", CfnSpotFleetAcceleratorTotalMemoryMiBRequestPropertyValidator)(properties.acceleratorTotalMemoryMiB));
  errors.collect(cdk.propertyValidator("acceleratorTypes", cdk.listValidator(cdk.validateString))(properties.acceleratorTypes));
  errors.collect(cdk.propertyValidator("allowedInstanceTypes", cdk.listValidator(cdk.validateString))(properties.allowedInstanceTypes));
  errors.collect(cdk.propertyValidator("bareMetal", cdk.validateString)(properties.bareMetal));
  errors.collect(cdk.propertyValidator("baselineEbsBandwidthMbps", CfnSpotFleetBaselineEbsBandwidthMbpsRequestPropertyValidator)(properties.baselineEbsBandwidthMbps));
  errors.collect(cdk.propertyValidator("burstablePerformance", cdk.validateString)(properties.burstablePerformance));
  errors.collect(cdk.propertyValidator("cpuManufacturers", cdk.listValidator(cdk.validateString))(properties.cpuManufacturers));
  errors.collect(cdk.propertyValidator("excludedInstanceTypes", cdk.listValidator(cdk.validateString))(properties.excludedInstanceTypes));
  errors.collect(cdk.propertyValidator("instanceGenerations", cdk.listValidator(cdk.validateString))(properties.instanceGenerations));
  errors.collect(cdk.propertyValidator("localStorage", cdk.validateString)(properties.localStorage));
  errors.collect(cdk.propertyValidator("localStorageTypes", cdk.listValidator(cdk.validateString))(properties.localStorageTypes));
  errors.collect(cdk.propertyValidator("memoryGiBPerVCpu", CfnSpotFleetMemoryGiBPerVCpuRequestPropertyValidator)(properties.memoryGiBPerVCpu));
  errors.collect(cdk.propertyValidator("memoryMiB", CfnSpotFleetMemoryMiBRequestPropertyValidator)(properties.memoryMiB));
  errors.collect(cdk.propertyValidator("networkBandwidthGbps", CfnSpotFleetNetworkBandwidthGbpsRequestPropertyValidator)(properties.networkBandwidthGbps));
  errors.collect(cdk.propertyValidator("networkInterfaceCount", CfnSpotFleetNetworkInterfaceCountRequestPropertyValidator)(properties.networkInterfaceCount));
  errors.collect(cdk.propertyValidator("onDemandMaxPricePercentageOverLowestPrice", cdk.validateNumber)(properties.onDemandMaxPricePercentageOverLowestPrice));
  errors.collect(cdk.propertyValidator("requireHibernateSupport", cdk.validateBoolean)(properties.requireHibernateSupport));
  errors.collect(cdk.propertyValidator("spotMaxPricePercentageOverLowestPrice", cdk.validateNumber)(properties.spotMaxPricePercentageOverLowestPrice));
  errors.collect(cdk.propertyValidator("totalLocalStorageGb", CfnSpotFleetTotalLocalStorageGBRequestPropertyValidator)(properties.totalLocalStorageGb));
  errors.collect(cdk.propertyValidator("vCpuCount", CfnSpotFleetVCpuCountRangeRequestPropertyValidator)(properties.vCpuCount));
  return errors.wrap("supplied properties not correct for \"InstanceRequirementsRequestProperty\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetInstanceRequirementsRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetInstanceRequirementsRequestPropertyValidator(properties).assertSuccess();
  return {
    "AcceleratorCount": convertCfnSpotFleetAcceleratorCountRequestPropertyToCloudFormation(properties.acceleratorCount),
    "AcceleratorManufacturers": cdk.listMapper(cdk.stringToCloudFormation)(properties.acceleratorManufacturers),
    "AcceleratorNames": cdk.listMapper(cdk.stringToCloudFormation)(properties.acceleratorNames),
    "AcceleratorTotalMemoryMiB": convertCfnSpotFleetAcceleratorTotalMemoryMiBRequestPropertyToCloudFormation(properties.acceleratorTotalMemoryMiB),
    "AcceleratorTypes": cdk.listMapper(cdk.stringToCloudFormation)(properties.acceleratorTypes),
    "AllowedInstanceTypes": cdk.listMapper(cdk.stringToCloudFormation)(properties.allowedInstanceTypes),
    "BareMetal": cdk.stringToCloudFormation(properties.bareMetal),
    "BaselineEbsBandwidthMbps": convertCfnSpotFleetBaselineEbsBandwidthMbpsRequestPropertyToCloudFormation(properties.baselineEbsBandwidthMbps),
    "BurstablePerformance": cdk.stringToCloudFormation(properties.burstablePerformance),
    "CpuManufacturers": cdk.listMapper(cdk.stringToCloudFormation)(properties.cpuManufacturers),
    "ExcludedInstanceTypes": cdk.listMapper(cdk.stringToCloudFormation)(properties.excludedInstanceTypes),
    "InstanceGenerations": cdk.listMapper(cdk.stringToCloudFormation)(properties.instanceGenerations),
    "LocalStorage": cdk.stringToCloudFormation(properties.localStorage),
    "LocalStorageTypes": cdk.listMapper(cdk.stringToCloudFormation)(properties.localStorageTypes),
    "MemoryGiBPerVCpu": convertCfnSpotFleetMemoryGiBPerVCpuRequestPropertyToCloudFormation(properties.memoryGiBPerVCpu),
    "MemoryMiB": convertCfnSpotFleetMemoryMiBRequestPropertyToCloudFormation(properties.memoryMiB),
    "NetworkBandwidthGbps": convertCfnSpotFleetNetworkBandwidthGbpsRequestPropertyToCloudFormation(properties.networkBandwidthGbps),
    "NetworkInterfaceCount": convertCfnSpotFleetNetworkInterfaceCountRequestPropertyToCloudFormation(properties.networkInterfaceCount),
    "OnDemandMaxPricePercentageOverLowestPrice": cdk.numberToCloudFormation(properties.onDemandMaxPricePercentageOverLowestPrice),
    "RequireHibernateSupport": cdk.booleanToCloudFormation(properties.requireHibernateSupport),
    "SpotMaxPricePercentageOverLowestPrice": cdk.numberToCloudFormation(properties.spotMaxPricePercentageOverLowestPrice),
    "TotalLocalStorageGB": convertCfnSpotFleetTotalLocalStorageGBRequestPropertyToCloudFormation(properties.totalLocalStorageGb),
    "VCpuCount": convertCfnSpotFleetVCpuCountRangeRequestPropertyToCloudFormation(properties.vCpuCount)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetInstanceRequirementsRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSpotFleet.InstanceRequirementsRequestProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleet.InstanceRequirementsRequestProperty>();
  ret.addPropertyResult("acceleratorCount", "AcceleratorCount", (properties.AcceleratorCount != null ? CfnSpotFleetAcceleratorCountRequestPropertyFromCloudFormation(properties.AcceleratorCount) : undefined));
  ret.addPropertyResult("acceleratorManufacturers", "AcceleratorManufacturers", (properties.AcceleratorManufacturers != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.AcceleratorManufacturers) : undefined));
  ret.addPropertyResult("acceleratorNames", "AcceleratorNames", (properties.AcceleratorNames != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.AcceleratorNames) : undefined));
  ret.addPropertyResult("acceleratorTotalMemoryMiB", "AcceleratorTotalMemoryMiB", (properties.AcceleratorTotalMemoryMiB != null ? CfnSpotFleetAcceleratorTotalMemoryMiBRequestPropertyFromCloudFormation(properties.AcceleratorTotalMemoryMiB) : undefined));
  ret.addPropertyResult("acceleratorTypes", "AcceleratorTypes", (properties.AcceleratorTypes != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.AcceleratorTypes) : undefined));
  ret.addPropertyResult("allowedInstanceTypes", "AllowedInstanceTypes", (properties.AllowedInstanceTypes != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.AllowedInstanceTypes) : undefined));
  ret.addPropertyResult("bareMetal", "BareMetal", (properties.BareMetal != null ? cfn_parse.FromCloudFormation.getString(properties.BareMetal) : undefined));
  ret.addPropertyResult("baselineEbsBandwidthMbps", "BaselineEbsBandwidthMbps", (properties.BaselineEbsBandwidthMbps != null ? CfnSpotFleetBaselineEbsBandwidthMbpsRequestPropertyFromCloudFormation(properties.BaselineEbsBandwidthMbps) : undefined));
  ret.addPropertyResult("burstablePerformance", "BurstablePerformance", (properties.BurstablePerformance != null ? cfn_parse.FromCloudFormation.getString(properties.BurstablePerformance) : undefined));
  ret.addPropertyResult("cpuManufacturers", "CpuManufacturers", (properties.CpuManufacturers != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.CpuManufacturers) : undefined));
  ret.addPropertyResult("excludedInstanceTypes", "ExcludedInstanceTypes", (properties.ExcludedInstanceTypes != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.ExcludedInstanceTypes) : undefined));
  ret.addPropertyResult("instanceGenerations", "InstanceGenerations", (properties.InstanceGenerations != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.InstanceGenerations) : undefined));
  ret.addPropertyResult("localStorage", "LocalStorage", (properties.LocalStorage != null ? cfn_parse.FromCloudFormation.getString(properties.LocalStorage) : undefined));
  ret.addPropertyResult("localStorageTypes", "LocalStorageTypes", (properties.LocalStorageTypes != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.LocalStorageTypes) : undefined));
  ret.addPropertyResult("memoryGiBPerVCpu", "MemoryGiBPerVCpu", (properties.MemoryGiBPerVCpu != null ? CfnSpotFleetMemoryGiBPerVCpuRequestPropertyFromCloudFormation(properties.MemoryGiBPerVCpu) : undefined));
  ret.addPropertyResult("memoryMiB", "MemoryMiB", (properties.MemoryMiB != null ? CfnSpotFleetMemoryMiBRequestPropertyFromCloudFormation(properties.MemoryMiB) : undefined));
  ret.addPropertyResult("networkBandwidthGbps", "NetworkBandwidthGbps", (properties.NetworkBandwidthGbps != null ? CfnSpotFleetNetworkBandwidthGbpsRequestPropertyFromCloudFormation(properties.NetworkBandwidthGbps) : undefined));
  ret.addPropertyResult("networkInterfaceCount", "NetworkInterfaceCount", (properties.NetworkInterfaceCount != null ? CfnSpotFleetNetworkInterfaceCountRequestPropertyFromCloudFormation(properties.NetworkInterfaceCount) : undefined));
  ret.addPropertyResult("onDemandMaxPricePercentageOverLowestPrice", "OnDemandMaxPricePercentageOverLowestPrice", (properties.OnDemandMaxPricePercentageOverLowestPrice != null ? cfn_parse.FromCloudFormation.getNumber(properties.OnDemandMaxPricePercentageOverLowestPrice) : undefined));
  ret.addPropertyResult("requireHibernateSupport", "RequireHibernateSupport", (properties.RequireHibernateSupport != null ? cfn_parse.FromCloudFormation.getBoolean(properties.RequireHibernateSupport) : undefined));
  ret.addPropertyResult("spotMaxPricePercentageOverLowestPrice", "SpotMaxPricePercentageOverLowestPrice", (properties.SpotMaxPricePercentageOverLowestPrice != null ? cfn_parse.FromCloudFormation.getNumber(properties.SpotMaxPricePercentageOverLowestPrice) : undefined));
  ret.addPropertyResult("totalLocalStorageGb", "TotalLocalStorageGB", (properties.TotalLocalStorageGB != null ? CfnSpotFleetTotalLocalStorageGBRequestPropertyFromCloudFormation(properties.TotalLocalStorageGB) : undefined));
  ret.addPropertyResult("vCpuCount", "VCpuCount", (properties.VCpuCount != null ? CfnSpotFleetVCpuCountRangeRequestPropertyFromCloudFormation(properties.VCpuCount) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `LaunchTemplateOverridesProperty`
 *
 * @param properties - the TypeScript properties of a `LaunchTemplateOverridesProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetLaunchTemplateOverridesPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("availabilityZone", cdk.validateString)(properties.availabilityZone));
  errors.collect(cdk.propertyValidator("instanceRequirements", CfnSpotFleetInstanceRequirementsRequestPropertyValidator)(properties.instanceRequirements));
  errors.collect(cdk.propertyValidator("instanceType", cdk.validateString)(properties.instanceType));
  errors.collect(cdk.propertyValidator("priority", cdk.validateNumber)(properties.priority));
  errors.collect(cdk.propertyValidator("spotPrice", cdk.validateString)(properties.spotPrice));
  errors.collect(cdk.propertyValidator("subnetId", cdk.validateString)(properties.subnetId));
  errors.collect(cdk.propertyValidator("weightedCapacity", cdk.validateNumber)(properties.weightedCapacity));
  return errors.wrap("supplied properties not correct for \"LaunchTemplateOverridesProperty\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetLaunchTemplateOverridesPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetLaunchTemplateOverridesPropertyValidator(properties).assertSuccess();
  return {
    "AvailabilityZone": cdk.stringToCloudFormation(properties.availabilityZone),
    "InstanceRequirements": convertCfnSpotFleetInstanceRequirementsRequestPropertyToCloudFormation(properties.instanceRequirements),
    "InstanceType": cdk.stringToCloudFormation(properties.instanceType),
    "Priority": cdk.numberToCloudFormation(properties.priority),
    "SpotPrice": cdk.stringToCloudFormation(properties.spotPrice),
    "SubnetId": cdk.stringToCloudFormation(properties.subnetId),
    "WeightedCapacity": cdk.numberToCloudFormation(properties.weightedCapacity)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetLaunchTemplateOverridesPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSpotFleet.LaunchTemplateOverridesProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleet.LaunchTemplateOverridesProperty>();
  ret.addPropertyResult("availabilityZone", "AvailabilityZone", (properties.AvailabilityZone != null ? cfn_parse.FromCloudFormation.getString(properties.AvailabilityZone) : undefined));
  ret.addPropertyResult("instanceRequirements", "InstanceRequirements", (properties.InstanceRequirements != null ? CfnSpotFleetInstanceRequirementsRequestPropertyFromCloudFormation(properties.InstanceRequirements) : undefined));
  ret.addPropertyResult("instanceType", "InstanceType", (properties.InstanceType != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceType) : undefined));
  ret.addPropertyResult("priority", "Priority", (properties.Priority != null ? cfn_parse.FromCloudFormation.getNumber(properties.Priority) : undefined));
  ret.addPropertyResult("spotPrice", "SpotPrice", (properties.SpotPrice != null ? cfn_parse.FromCloudFormation.getString(properties.SpotPrice) : undefined));
  ret.addPropertyResult("subnetId", "SubnetId", (properties.SubnetId != null ? cfn_parse.FromCloudFormation.getString(properties.SubnetId) : undefined));
  ret.addPropertyResult("weightedCapacity", "WeightedCapacity", (properties.WeightedCapacity != null ? cfn_parse.FromCloudFormation.getNumber(properties.WeightedCapacity) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `LaunchTemplateConfigProperty`
 *
 * @param properties - the TypeScript properties of a `LaunchTemplateConfigProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetLaunchTemplateConfigPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("launchTemplateSpecification", CfnSpotFleetFleetLaunchTemplateSpecificationPropertyValidator)(properties.launchTemplateSpecification));
  errors.collect(cdk.propertyValidator("overrides", cdk.listValidator(CfnSpotFleetLaunchTemplateOverridesPropertyValidator))(properties.overrides));
  return errors.wrap("supplied properties not correct for \"LaunchTemplateConfigProperty\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetLaunchTemplateConfigPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetLaunchTemplateConfigPropertyValidator(properties).assertSuccess();
  return {
    "LaunchTemplateSpecification": convertCfnSpotFleetFleetLaunchTemplateSpecificationPropertyToCloudFormation(properties.launchTemplateSpecification),
    "Overrides": cdk.listMapper(convertCfnSpotFleetLaunchTemplateOverridesPropertyToCloudFormation)(properties.overrides)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetLaunchTemplateConfigPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSpotFleet.LaunchTemplateConfigProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleet.LaunchTemplateConfigProperty>();
  ret.addPropertyResult("launchTemplateSpecification", "LaunchTemplateSpecification", (properties.LaunchTemplateSpecification != null ? CfnSpotFleetFleetLaunchTemplateSpecificationPropertyFromCloudFormation(properties.LaunchTemplateSpecification) : undefined));
  ret.addPropertyResult("overrides", "Overrides", (properties.Overrides != null ? cfn_parse.FromCloudFormation.getArray(CfnSpotFleetLaunchTemplateOverridesPropertyFromCloudFormation)(properties.Overrides) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `SpotCapacityRebalanceProperty`
 *
 * @param properties - the TypeScript properties of a `SpotCapacityRebalanceProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetSpotCapacityRebalancePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("replacementStrategy", cdk.validateString)(properties.replacementStrategy));
  errors.collect(cdk.propertyValidator("terminationDelay", cdk.validateNumber)(properties.terminationDelay));
  return errors.wrap("supplied properties not correct for \"SpotCapacityRebalanceProperty\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetSpotCapacityRebalancePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetSpotCapacityRebalancePropertyValidator(properties).assertSuccess();
  return {
    "ReplacementStrategy": cdk.stringToCloudFormation(properties.replacementStrategy),
    "TerminationDelay": cdk.numberToCloudFormation(properties.terminationDelay)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetSpotCapacityRebalancePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSpotFleet.SpotCapacityRebalanceProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleet.SpotCapacityRebalanceProperty>();
  ret.addPropertyResult("replacementStrategy", "ReplacementStrategy", (properties.ReplacementStrategy != null ? cfn_parse.FromCloudFormation.getString(properties.ReplacementStrategy) : undefined));
  ret.addPropertyResult("terminationDelay", "TerminationDelay", (properties.TerminationDelay != null ? cfn_parse.FromCloudFormation.getNumber(properties.TerminationDelay) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `SpotMaintenanceStrategiesProperty`
 *
 * @param properties - the TypeScript properties of a `SpotMaintenanceStrategiesProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetSpotMaintenanceStrategiesPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("capacityRebalance", CfnSpotFleetSpotCapacityRebalancePropertyValidator)(properties.capacityRebalance));
  return errors.wrap("supplied properties not correct for \"SpotMaintenanceStrategiesProperty\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetSpotMaintenanceStrategiesPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetSpotMaintenanceStrategiesPropertyValidator(properties).assertSuccess();
  return {
    "CapacityRebalance": convertCfnSpotFleetSpotCapacityRebalancePropertyToCloudFormation(properties.capacityRebalance)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetSpotMaintenanceStrategiesPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSpotFleet.SpotMaintenanceStrategiesProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleet.SpotMaintenanceStrategiesProperty>();
  ret.addPropertyResult("capacityRebalance", "CapacityRebalance", (properties.CapacityRebalance != null ? CfnSpotFleetSpotCapacityRebalancePropertyFromCloudFormation(properties.CapacityRebalance) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `GroupIdentifierProperty`
 *
 * @param properties - the TypeScript properties of a `GroupIdentifierProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetGroupIdentifierPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("groupId", cdk.requiredValidator)(properties.groupId));
  errors.collect(cdk.propertyValidator("groupId", cdk.validateString)(properties.groupId));
  return errors.wrap("supplied properties not correct for \"GroupIdentifierProperty\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetGroupIdentifierPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetGroupIdentifierPropertyValidator(properties).assertSuccess();
  return {
    "GroupId": cdk.stringToCloudFormation(properties.groupId)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetGroupIdentifierPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSpotFleet.GroupIdentifierProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleet.GroupIdentifierProperty>();
  ret.addPropertyResult("groupId", "GroupId", (properties.GroupId != null ? cfn_parse.FromCloudFormation.getString(properties.GroupId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `EbsBlockDeviceProperty`
 *
 * @param properties - the TypeScript properties of a `EbsBlockDeviceProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetEbsBlockDevicePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("deleteOnTermination", cdk.validateBoolean)(properties.deleteOnTermination));
  errors.collect(cdk.propertyValidator("encrypted", cdk.validateBoolean)(properties.encrypted));
  errors.collect(cdk.propertyValidator("iops", cdk.validateNumber)(properties.iops));
  errors.collect(cdk.propertyValidator("snapshotId", cdk.validateString)(properties.snapshotId));
  errors.collect(cdk.propertyValidator("volumeSize", cdk.validateNumber)(properties.volumeSize));
  errors.collect(cdk.propertyValidator("volumeType", cdk.validateString)(properties.volumeType));
  return errors.wrap("supplied properties not correct for \"EbsBlockDeviceProperty\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetEbsBlockDevicePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetEbsBlockDevicePropertyValidator(properties).assertSuccess();
  return {
    "DeleteOnTermination": cdk.booleanToCloudFormation(properties.deleteOnTermination),
    "Encrypted": cdk.booleanToCloudFormation(properties.encrypted),
    "Iops": cdk.numberToCloudFormation(properties.iops),
    "SnapshotId": cdk.stringToCloudFormation(properties.snapshotId),
    "VolumeSize": cdk.numberToCloudFormation(properties.volumeSize),
    "VolumeType": cdk.stringToCloudFormation(properties.volumeType)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetEbsBlockDevicePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSpotFleet.EbsBlockDeviceProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleet.EbsBlockDeviceProperty>();
  ret.addPropertyResult("deleteOnTermination", "DeleteOnTermination", (properties.DeleteOnTermination != null ? cfn_parse.FromCloudFormation.getBoolean(properties.DeleteOnTermination) : undefined));
  ret.addPropertyResult("encrypted", "Encrypted", (properties.Encrypted != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Encrypted) : undefined));
  ret.addPropertyResult("iops", "Iops", (properties.Iops != null ? cfn_parse.FromCloudFormation.getNumber(properties.Iops) : undefined));
  ret.addPropertyResult("snapshotId", "SnapshotId", (properties.SnapshotId != null ? cfn_parse.FromCloudFormation.getString(properties.SnapshotId) : undefined));
  ret.addPropertyResult("volumeSize", "VolumeSize", (properties.VolumeSize != null ? cfn_parse.FromCloudFormation.getNumber(properties.VolumeSize) : undefined));
  ret.addPropertyResult("volumeType", "VolumeType", (properties.VolumeType != null ? cfn_parse.FromCloudFormation.getString(properties.VolumeType) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `BlockDeviceMappingProperty`
 *
 * @param properties - the TypeScript properties of a `BlockDeviceMappingProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetBlockDeviceMappingPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("deviceName", cdk.requiredValidator)(properties.deviceName));
  errors.collect(cdk.propertyValidator("deviceName", cdk.validateString)(properties.deviceName));
  errors.collect(cdk.propertyValidator("ebs", CfnSpotFleetEbsBlockDevicePropertyValidator)(properties.ebs));
  errors.collect(cdk.propertyValidator("noDevice", cdk.validateString)(properties.noDevice));
  errors.collect(cdk.propertyValidator("virtualName", cdk.validateString)(properties.virtualName));
  return errors.wrap("supplied properties not correct for \"BlockDeviceMappingProperty\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetBlockDeviceMappingPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetBlockDeviceMappingPropertyValidator(properties).assertSuccess();
  return {
    "DeviceName": cdk.stringToCloudFormation(properties.deviceName),
    "Ebs": convertCfnSpotFleetEbsBlockDevicePropertyToCloudFormation(properties.ebs),
    "NoDevice": cdk.stringToCloudFormation(properties.noDevice),
    "VirtualName": cdk.stringToCloudFormation(properties.virtualName)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetBlockDeviceMappingPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSpotFleet.BlockDeviceMappingProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleet.BlockDeviceMappingProperty>();
  ret.addPropertyResult("deviceName", "DeviceName", (properties.DeviceName != null ? cfn_parse.FromCloudFormation.getString(properties.DeviceName) : undefined));
  ret.addPropertyResult("ebs", "Ebs", (properties.Ebs != null ? CfnSpotFleetEbsBlockDevicePropertyFromCloudFormation(properties.Ebs) : undefined));
  ret.addPropertyResult("noDevice", "NoDevice", (properties.NoDevice != null ? cfn_parse.FromCloudFormation.getString(properties.NoDevice) : undefined));
  ret.addPropertyResult("virtualName", "VirtualName", (properties.VirtualName != null ? cfn_parse.FromCloudFormation.getString(properties.VirtualName) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `IamInstanceProfileSpecificationProperty`
 *
 * @param properties - the TypeScript properties of a `IamInstanceProfileSpecificationProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetIamInstanceProfileSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("arn", cdk.validateString)(properties.arn));
  return errors.wrap("supplied properties not correct for \"IamInstanceProfileSpecificationProperty\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetIamInstanceProfileSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetIamInstanceProfileSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "Arn": cdk.stringToCloudFormation(properties.arn)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetIamInstanceProfileSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSpotFleet.IamInstanceProfileSpecificationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleet.IamInstanceProfileSpecificationProperty>();
  ret.addPropertyResult("arn", "Arn", (properties.Arn != null ? cfn_parse.FromCloudFormation.getString(properties.Arn) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `SpotPlacementProperty`
 *
 * @param properties - the TypeScript properties of a `SpotPlacementProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetSpotPlacementPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("availabilityZone", cdk.validateString)(properties.availabilityZone));
  errors.collect(cdk.propertyValidator("groupName", cdk.validateString)(properties.groupName));
  errors.collect(cdk.propertyValidator("tenancy", cdk.validateString)(properties.tenancy));
  return errors.wrap("supplied properties not correct for \"SpotPlacementProperty\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetSpotPlacementPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetSpotPlacementPropertyValidator(properties).assertSuccess();
  return {
    "AvailabilityZone": cdk.stringToCloudFormation(properties.availabilityZone),
    "GroupName": cdk.stringToCloudFormation(properties.groupName),
    "Tenancy": cdk.stringToCloudFormation(properties.tenancy)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetSpotPlacementPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSpotFleet.SpotPlacementProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleet.SpotPlacementProperty>();
  ret.addPropertyResult("availabilityZone", "AvailabilityZone", (properties.AvailabilityZone != null ? cfn_parse.FromCloudFormation.getString(properties.AvailabilityZone) : undefined));
  ret.addPropertyResult("groupName", "GroupName", (properties.GroupName != null ? cfn_parse.FromCloudFormation.getString(properties.GroupName) : undefined));
  ret.addPropertyResult("tenancy", "Tenancy", (properties.Tenancy != null ? cfn_parse.FromCloudFormation.getString(properties.Tenancy) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `PrivateIpAddressSpecificationProperty`
 *
 * @param properties - the TypeScript properties of a `PrivateIpAddressSpecificationProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetPrivateIpAddressSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("primary", cdk.validateBoolean)(properties.primary));
  errors.collect(cdk.propertyValidator("privateIpAddress", cdk.requiredValidator)(properties.privateIpAddress));
  errors.collect(cdk.propertyValidator("privateIpAddress", cdk.validateString)(properties.privateIpAddress));
  return errors.wrap("supplied properties not correct for \"PrivateIpAddressSpecificationProperty\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetPrivateIpAddressSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetPrivateIpAddressSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "Primary": cdk.booleanToCloudFormation(properties.primary),
    "PrivateIpAddress": cdk.stringToCloudFormation(properties.privateIpAddress)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetPrivateIpAddressSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSpotFleet.PrivateIpAddressSpecificationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleet.PrivateIpAddressSpecificationProperty>();
  ret.addPropertyResult("primary", "Primary", (properties.Primary != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Primary) : undefined));
  ret.addPropertyResult("privateIpAddress", "PrivateIpAddress", (properties.PrivateIpAddress != null ? cfn_parse.FromCloudFormation.getString(properties.PrivateIpAddress) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `InstanceIpv6AddressProperty`
 *
 * @param properties - the TypeScript properties of a `InstanceIpv6AddressProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetInstanceIpv6AddressPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("ipv6Address", cdk.requiredValidator)(properties.ipv6Address));
  errors.collect(cdk.propertyValidator("ipv6Address", cdk.validateString)(properties.ipv6Address));
  return errors.wrap("supplied properties not correct for \"InstanceIpv6AddressProperty\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetInstanceIpv6AddressPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetInstanceIpv6AddressPropertyValidator(properties).assertSuccess();
  return {
    "Ipv6Address": cdk.stringToCloudFormation(properties.ipv6Address)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetInstanceIpv6AddressPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSpotFleet.InstanceIpv6AddressProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleet.InstanceIpv6AddressProperty>();
  ret.addPropertyResult("ipv6Address", "Ipv6Address", (properties.Ipv6Address != null ? cfn_parse.FromCloudFormation.getString(properties.Ipv6Address) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `InstanceNetworkInterfaceSpecificationProperty`
 *
 * @param properties - the TypeScript properties of a `InstanceNetworkInterfaceSpecificationProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetInstanceNetworkInterfaceSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("associatePublicIpAddress", cdk.validateBoolean)(properties.associatePublicIpAddress));
  errors.collect(cdk.propertyValidator("deleteOnTermination", cdk.validateBoolean)(properties.deleteOnTermination));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("deviceIndex", cdk.validateNumber)(properties.deviceIndex));
  errors.collect(cdk.propertyValidator("groups", cdk.listValidator(cdk.validateString))(properties.groups));
  errors.collect(cdk.propertyValidator("ipv6AddressCount", cdk.validateNumber)(properties.ipv6AddressCount));
  errors.collect(cdk.propertyValidator("ipv6Addresses", cdk.listValidator(CfnSpotFleetInstanceIpv6AddressPropertyValidator))(properties.ipv6Addresses));
  errors.collect(cdk.propertyValidator("networkInterfaceId", cdk.validateString)(properties.networkInterfaceId));
  errors.collect(cdk.propertyValidator("privateIpAddresses", cdk.listValidator(CfnSpotFleetPrivateIpAddressSpecificationPropertyValidator))(properties.privateIpAddresses));
  errors.collect(cdk.propertyValidator("secondaryPrivateIpAddressCount", cdk.validateNumber)(properties.secondaryPrivateIpAddressCount));
  errors.collect(cdk.propertyValidator("subnetId", cdk.validateString)(properties.subnetId));
  return errors.wrap("supplied properties not correct for \"InstanceNetworkInterfaceSpecificationProperty\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetInstanceNetworkInterfaceSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetInstanceNetworkInterfaceSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "AssociatePublicIpAddress": cdk.booleanToCloudFormation(properties.associatePublicIpAddress),
    "DeleteOnTermination": cdk.booleanToCloudFormation(properties.deleteOnTermination),
    "Description": cdk.stringToCloudFormation(properties.description),
    "DeviceIndex": cdk.numberToCloudFormation(properties.deviceIndex),
    "Groups": cdk.listMapper(cdk.stringToCloudFormation)(properties.groups),
    "Ipv6AddressCount": cdk.numberToCloudFormation(properties.ipv6AddressCount),
    "Ipv6Addresses": cdk.listMapper(convertCfnSpotFleetInstanceIpv6AddressPropertyToCloudFormation)(properties.ipv6Addresses),
    "NetworkInterfaceId": cdk.stringToCloudFormation(properties.networkInterfaceId),
    "PrivateIpAddresses": cdk.listMapper(convertCfnSpotFleetPrivateIpAddressSpecificationPropertyToCloudFormation)(properties.privateIpAddresses),
    "SecondaryPrivateIpAddressCount": cdk.numberToCloudFormation(properties.secondaryPrivateIpAddressCount),
    "SubnetId": cdk.stringToCloudFormation(properties.subnetId)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetInstanceNetworkInterfaceSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSpotFleet.InstanceNetworkInterfaceSpecificationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleet.InstanceNetworkInterfaceSpecificationProperty>();
  ret.addPropertyResult("associatePublicIpAddress", "AssociatePublicIpAddress", (properties.AssociatePublicIpAddress != null ? cfn_parse.FromCloudFormation.getBoolean(properties.AssociatePublicIpAddress) : undefined));
  ret.addPropertyResult("deleteOnTermination", "DeleteOnTermination", (properties.DeleteOnTermination != null ? cfn_parse.FromCloudFormation.getBoolean(properties.DeleteOnTermination) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("deviceIndex", "DeviceIndex", (properties.DeviceIndex != null ? cfn_parse.FromCloudFormation.getNumber(properties.DeviceIndex) : undefined));
  ret.addPropertyResult("groups", "Groups", (properties.Groups != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.Groups) : undefined));
  ret.addPropertyResult("ipv6AddressCount", "Ipv6AddressCount", (properties.Ipv6AddressCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.Ipv6AddressCount) : undefined));
  ret.addPropertyResult("ipv6Addresses", "Ipv6Addresses", (properties.Ipv6Addresses != null ? cfn_parse.FromCloudFormation.getArray(CfnSpotFleetInstanceIpv6AddressPropertyFromCloudFormation)(properties.Ipv6Addresses) : undefined));
  ret.addPropertyResult("networkInterfaceId", "NetworkInterfaceId", (properties.NetworkInterfaceId != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkInterfaceId) : undefined));
  ret.addPropertyResult("privateIpAddresses", "PrivateIpAddresses", (properties.PrivateIpAddresses != null ? cfn_parse.FromCloudFormation.getArray(CfnSpotFleetPrivateIpAddressSpecificationPropertyFromCloudFormation)(properties.PrivateIpAddresses) : undefined));
  ret.addPropertyResult("secondaryPrivateIpAddressCount", "SecondaryPrivateIpAddressCount", (properties.SecondaryPrivateIpAddressCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.SecondaryPrivateIpAddressCount) : undefined));
  ret.addPropertyResult("subnetId", "SubnetId", (properties.SubnetId != null ? cfn_parse.FromCloudFormation.getString(properties.SubnetId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `SpotFleetMonitoringProperty`
 *
 * @param properties - the TypeScript properties of a `SpotFleetMonitoringProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetSpotFleetMonitoringPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("enabled", cdk.validateBoolean)(properties.enabled));
  return errors.wrap("supplied properties not correct for \"SpotFleetMonitoringProperty\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetSpotFleetMonitoringPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetSpotFleetMonitoringPropertyValidator(properties).assertSuccess();
  return {
    "Enabled": cdk.booleanToCloudFormation(properties.enabled)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetSpotFleetMonitoringPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSpotFleet.SpotFleetMonitoringProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleet.SpotFleetMonitoringProperty>();
  ret.addPropertyResult("enabled", "Enabled", (properties.Enabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Enabled) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `SpotFleetLaunchSpecificationProperty`
 *
 * @param properties - the TypeScript properties of a `SpotFleetLaunchSpecificationProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetSpotFleetLaunchSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("blockDeviceMappings", cdk.listValidator(CfnSpotFleetBlockDeviceMappingPropertyValidator))(properties.blockDeviceMappings));
  errors.collect(cdk.propertyValidator("ebsOptimized", cdk.validateBoolean)(properties.ebsOptimized));
  errors.collect(cdk.propertyValidator("iamInstanceProfile", CfnSpotFleetIamInstanceProfileSpecificationPropertyValidator)(properties.iamInstanceProfile));
  errors.collect(cdk.propertyValidator("imageId", cdk.requiredValidator)(properties.imageId));
  errors.collect(cdk.propertyValidator("imageId", cdk.validateString)(properties.imageId));
  errors.collect(cdk.propertyValidator("instanceRequirements", CfnSpotFleetInstanceRequirementsRequestPropertyValidator)(properties.instanceRequirements));
  errors.collect(cdk.propertyValidator("instanceType", cdk.validateString)(properties.instanceType));
  errors.collect(cdk.propertyValidator("kernelId", cdk.validateString)(properties.kernelId));
  errors.collect(cdk.propertyValidator("keyName", cdk.validateString)(properties.keyName));
  errors.collect(cdk.propertyValidator("monitoring", CfnSpotFleetSpotFleetMonitoringPropertyValidator)(properties.monitoring));
  errors.collect(cdk.propertyValidator("networkInterfaces", cdk.listValidator(CfnSpotFleetInstanceNetworkInterfaceSpecificationPropertyValidator))(properties.networkInterfaces));
  errors.collect(cdk.propertyValidator("placement", CfnSpotFleetSpotPlacementPropertyValidator)(properties.placement));
  errors.collect(cdk.propertyValidator("ramdiskId", cdk.validateString)(properties.ramdiskId));
  errors.collect(cdk.propertyValidator("securityGroups", cdk.listValidator(CfnSpotFleetGroupIdentifierPropertyValidator))(properties.securityGroups));
  errors.collect(cdk.propertyValidator("spotPrice", cdk.validateString)(properties.spotPrice));
  errors.collect(cdk.propertyValidator("subnetId", cdk.validateString)(properties.subnetId));
  errors.collect(cdk.propertyValidator("tagSpecifications", cdk.listValidator(CfnSpotFleetSpotFleetTagSpecificationPropertyValidator))(properties.tagSpecifications));
  errors.collect(cdk.propertyValidator("userData", cdk.validateString)(properties.userData));
  errors.collect(cdk.propertyValidator("weightedCapacity", cdk.validateNumber)(properties.weightedCapacity));
  return errors.wrap("supplied properties not correct for \"SpotFleetLaunchSpecificationProperty\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetSpotFleetLaunchSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetSpotFleetLaunchSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "BlockDeviceMappings": cdk.listMapper(convertCfnSpotFleetBlockDeviceMappingPropertyToCloudFormation)(properties.blockDeviceMappings),
    "EbsOptimized": cdk.booleanToCloudFormation(properties.ebsOptimized),
    "IamInstanceProfile": convertCfnSpotFleetIamInstanceProfileSpecificationPropertyToCloudFormation(properties.iamInstanceProfile),
    "ImageId": cdk.stringToCloudFormation(properties.imageId),
    "InstanceRequirements": convertCfnSpotFleetInstanceRequirementsRequestPropertyToCloudFormation(properties.instanceRequirements),
    "InstanceType": cdk.stringToCloudFormation(properties.instanceType),
    "KernelId": cdk.stringToCloudFormation(properties.kernelId),
    "KeyName": cdk.stringToCloudFormation(properties.keyName),
    "Monitoring": convertCfnSpotFleetSpotFleetMonitoringPropertyToCloudFormation(properties.monitoring),
    "NetworkInterfaces": cdk.listMapper(convertCfnSpotFleetInstanceNetworkInterfaceSpecificationPropertyToCloudFormation)(properties.networkInterfaces),
    "Placement": convertCfnSpotFleetSpotPlacementPropertyToCloudFormation(properties.placement),
    "RamdiskId": cdk.stringToCloudFormation(properties.ramdiskId),
    "SecurityGroups": cdk.listMapper(convertCfnSpotFleetGroupIdentifierPropertyToCloudFormation)(properties.securityGroups),
    "SpotPrice": cdk.stringToCloudFormation(properties.spotPrice),
    "SubnetId": cdk.stringToCloudFormation(properties.subnetId),
    "TagSpecifications": cdk.listMapper(convertCfnSpotFleetSpotFleetTagSpecificationPropertyToCloudFormation)(properties.tagSpecifications),
    "UserData": cdk.stringToCloudFormation(properties.userData),
    "WeightedCapacity": cdk.numberToCloudFormation(properties.weightedCapacity)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetSpotFleetLaunchSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSpotFleet.SpotFleetLaunchSpecificationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleet.SpotFleetLaunchSpecificationProperty>();
  ret.addPropertyResult("blockDeviceMappings", "BlockDeviceMappings", (properties.BlockDeviceMappings != null ? cfn_parse.FromCloudFormation.getArray(CfnSpotFleetBlockDeviceMappingPropertyFromCloudFormation)(properties.BlockDeviceMappings) : undefined));
  ret.addPropertyResult("ebsOptimized", "EbsOptimized", (properties.EbsOptimized != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EbsOptimized) : undefined));
  ret.addPropertyResult("iamInstanceProfile", "IamInstanceProfile", (properties.IamInstanceProfile != null ? CfnSpotFleetIamInstanceProfileSpecificationPropertyFromCloudFormation(properties.IamInstanceProfile) : undefined));
  ret.addPropertyResult("imageId", "ImageId", (properties.ImageId != null ? cfn_parse.FromCloudFormation.getString(properties.ImageId) : undefined));
  ret.addPropertyResult("instanceRequirements", "InstanceRequirements", (properties.InstanceRequirements != null ? CfnSpotFleetInstanceRequirementsRequestPropertyFromCloudFormation(properties.InstanceRequirements) : undefined));
  ret.addPropertyResult("instanceType", "InstanceType", (properties.InstanceType != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceType) : undefined));
  ret.addPropertyResult("kernelId", "KernelId", (properties.KernelId != null ? cfn_parse.FromCloudFormation.getString(properties.KernelId) : undefined));
  ret.addPropertyResult("keyName", "KeyName", (properties.KeyName != null ? cfn_parse.FromCloudFormation.getString(properties.KeyName) : undefined));
  ret.addPropertyResult("monitoring", "Monitoring", (properties.Monitoring != null ? CfnSpotFleetSpotFleetMonitoringPropertyFromCloudFormation(properties.Monitoring) : undefined));
  ret.addPropertyResult("networkInterfaces", "NetworkInterfaces", (properties.NetworkInterfaces != null ? cfn_parse.FromCloudFormation.getArray(CfnSpotFleetInstanceNetworkInterfaceSpecificationPropertyFromCloudFormation)(properties.NetworkInterfaces) : undefined));
  ret.addPropertyResult("placement", "Placement", (properties.Placement != null ? CfnSpotFleetSpotPlacementPropertyFromCloudFormation(properties.Placement) : undefined));
  ret.addPropertyResult("ramdiskId", "RamdiskId", (properties.RamdiskId != null ? cfn_parse.FromCloudFormation.getString(properties.RamdiskId) : undefined));
  ret.addPropertyResult("securityGroups", "SecurityGroups", (properties.SecurityGroups != null ? cfn_parse.FromCloudFormation.getArray(CfnSpotFleetGroupIdentifierPropertyFromCloudFormation)(properties.SecurityGroups) : undefined));
  ret.addPropertyResult("spotPrice", "SpotPrice", (properties.SpotPrice != null ? cfn_parse.FromCloudFormation.getString(properties.SpotPrice) : undefined));
  ret.addPropertyResult("subnetId", "SubnetId", (properties.SubnetId != null ? cfn_parse.FromCloudFormation.getString(properties.SubnetId) : undefined));
  ret.addPropertyResult("tagSpecifications", "TagSpecifications", (properties.TagSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnSpotFleetSpotFleetTagSpecificationPropertyFromCloudFormation)(properties.TagSpecifications) : undefined));
  ret.addPropertyResult("userData", "UserData", (properties.UserData != null ? cfn_parse.FromCloudFormation.getString(properties.UserData) : undefined));
  ret.addPropertyResult("weightedCapacity", "WeightedCapacity", (properties.WeightedCapacity != null ? cfn_parse.FromCloudFormation.getNumber(properties.WeightedCapacity) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `ClassicLoadBalancerProperty`
 *
 * @param properties - the TypeScript properties of a `ClassicLoadBalancerProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetClassicLoadBalancerPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("name", cdk.requiredValidator)(properties.name));
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  return errors.wrap("supplied properties not correct for \"ClassicLoadBalancerProperty\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetClassicLoadBalancerPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetClassicLoadBalancerPropertyValidator(properties).assertSuccess();
  return {
    "Name": cdk.stringToCloudFormation(properties.name)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetClassicLoadBalancerPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSpotFleet.ClassicLoadBalancerProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleet.ClassicLoadBalancerProperty>();
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `ClassicLoadBalancersConfigProperty`
 *
 * @param properties - the TypeScript properties of a `ClassicLoadBalancersConfigProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetClassicLoadBalancersConfigPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("classicLoadBalancers", cdk.requiredValidator)(properties.classicLoadBalancers));
  errors.collect(cdk.propertyValidator("classicLoadBalancers", cdk.listValidator(CfnSpotFleetClassicLoadBalancerPropertyValidator))(properties.classicLoadBalancers));
  return errors.wrap("supplied properties not correct for \"ClassicLoadBalancersConfigProperty\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetClassicLoadBalancersConfigPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetClassicLoadBalancersConfigPropertyValidator(properties).assertSuccess();
  return {
    "ClassicLoadBalancers": cdk.listMapper(convertCfnSpotFleetClassicLoadBalancerPropertyToCloudFormation)(properties.classicLoadBalancers)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetClassicLoadBalancersConfigPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSpotFleet.ClassicLoadBalancersConfigProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleet.ClassicLoadBalancersConfigProperty>();
  ret.addPropertyResult("classicLoadBalancers", "ClassicLoadBalancers", (properties.ClassicLoadBalancers != null ? cfn_parse.FromCloudFormation.getArray(CfnSpotFleetClassicLoadBalancerPropertyFromCloudFormation)(properties.ClassicLoadBalancers) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `TargetGroupProperty`
 *
 * @param properties - the TypeScript properties of a `TargetGroupProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetTargetGroupPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("arn", cdk.requiredValidator)(properties.arn));
  errors.collect(cdk.propertyValidator("arn", cdk.validateString)(properties.arn));
  return errors.wrap("supplied properties not correct for \"TargetGroupProperty\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetTargetGroupPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetTargetGroupPropertyValidator(properties).assertSuccess();
  return {
    "Arn": cdk.stringToCloudFormation(properties.arn)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetTargetGroupPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSpotFleet.TargetGroupProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleet.TargetGroupProperty>();
  ret.addPropertyResult("arn", "Arn", (properties.Arn != null ? cfn_parse.FromCloudFormation.getString(properties.Arn) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `TargetGroupsConfigProperty`
 *
 * @param properties - the TypeScript properties of a `TargetGroupsConfigProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetTargetGroupsConfigPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("targetGroups", cdk.requiredValidator)(properties.targetGroups));
  errors.collect(cdk.propertyValidator("targetGroups", cdk.listValidator(CfnSpotFleetTargetGroupPropertyValidator))(properties.targetGroups));
  return errors.wrap("supplied properties not correct for \"TargetGroupsConfigProperty\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetTargetGroupsConfigPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetTargetGroupsConfigPropertyValidator(properties).assertSuccess();
  return {
    "TargetGroups": cdk.listMapper(convertCfnSpotFleetTargetGroupPropertyToCloudFormation)(properties.targetGroups)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetTargetGroupsConfigPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSpotFleet.TargetGroupsConfigProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleet.TargetGroupsConfigProperty>();
  ret.addPropertyResult("targetGroups", "TargetGroups", (properties.TargetGroups != null ? cfn_parse.FromCloudFormation.getArray(CfnSpotFleetTargetGroupPropertyFromCloudFormation)(properties.TargetGroups) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `LoadBalancersConfigProperty`
 *
 * @param properties - the TypeScript properties of a `LoadBalancersConfigProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetLoadBalancersConfigPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("classicLoadBalancersConfig", CfnSpotFleetClassicLoadBalancersConfigPropertyValidator)(properties.classicLoadBalancersConfig));
  errors.collect(cdk.propertyValidator("targetGroupsConfig", CfnSpotFleetTargetGroupsConfigPropertyValidator)(properties.targetGroupsConfig));
  return errors.wrap("supplied properties not correct for \"LoadBalancersConfigProperty\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetLoadBalancersConfigPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetLoadBalancersConfigPropertyValidator(properties).assertSuccess();
  return {
    "ClassicLoadBalancersConfig": convertCfnSpotFleetClassicLoadBalancersConfigPropertyToCloudFormation(properties.classicLoadBalancersConfig),
    "TargetGroupsConfig": convertCfnSpotFleetTargetGroupsConfigPropertyToCloudFormation(properties.targetGroupsConfig)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetLoadBalancersConfigPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSpotFleet.LoadBalancersConfigProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleet.LoadBalancersConfigProperty>();
  ret.addPropertyResult("classicLoadBalancersConfig", "ClassicLoadBalancersConfig", (properties.ClassicLoadBalancersConfig != null ? CfnSpotFleetClassicLoadBalancersConfigPropertyFromCloudFormation(properties.ClassicLoadBalancersConfig) : undefined));
  ret.addPropertyResult("targetGroupsConfig", "TargetGroupsConfig", (properties.TargetGroupsConfig != null ? CfnSpotFleetTargetGroupsConfigPropertyFromCloudFormation(properties.TargetGroupsConfig) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `SpotFleetRequestConfigDataProperty`
 *
 * @param properties - the TypeScript properties of a `SpotFleetRequestConfigDataProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetSpotFleetRequestConfigDataPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("allocationStrategy", cdk.validateString)(properties.allocationStrategy));
  errors.collect(cdk.propertyValidator("context", cdk.validateString)(properties.context));
  errors.collect(cdk.propertyValidator("excessCapacityTerminationPolicy", cdk.validateString)(properties.excessCapacityTerminationPolicy));
  errors.collect(cdk.propertyValidator("iamFleetRole", cdk.requiredValidator)(properties.iamFleetRole));
  errors.collect(cdk.propertyValidator("iamFleetRole", cdk.validateString)(properties.iamFleetRole));
  errors.collect(cdk.propertyValidator("instanceInterruptionBehavior", cdk.validateString)(properties.instanceInterruptionBehavior));
  errors.collect(cdk.propertyValidator("instancePoolsToUseCount", cdk.validateNumber)(properties.instancePoolsToUseCount));
  errors.collect(cdk.propertyValidator("launchSpecifications", cdk.listValidator(CfnSpotFleetSpotFleetLaunchSpecificationPropertyValidator))(properties.launchSpecifications));
  errors.collect(cdk.propertyValidator("launchTemplateConfigs", cdk.listValidator(CfnSpotFleetLaunchTemplateConfigPropertyValidator))(properties.launchTemplateConfigs));
  errors.collect(cdk.propertyValidator("loadBalancersConfig", CfnSpotFleetLoadBalancersConfigPropertyValidator)(properties.loadBalancersConfig));
  errors.collect(cdk.propertyValidator("onDemandAllocationStrategy", cdk.validateString)(properties.onDemandAllocationStrategy));
  errors.collect(cdk.propertyValidator("onDemandMaxTotalPrice", cdk.validateString)(properties.onDemandMaxTotalPrice));
  errors.collect(cdk.propertyValidator("onDemandTargetCapacity", cdk.validateNumber)(properties.onDemandTargetCapacity));
  errors.collect(cdk.propertyValidator("replaceUnhealthyInstances", cdk.validateBoolean)(properties.replaceUnhealthyInstances));
  errors.collect(cdk.propertyValidator("spotMaintenanceStrategies", CfnSpotFleetSpotMaintenanceStrategiesPropertyValidator)(properties.spotMaintenanceStrategies));
  errors.collect(cdk.propertyValidator("spotMaxTotalPrice", cdk.validateString)(properties.spotMaxTotalPrice));
  errors.collect(cdk.propertyValidator("spotPrice", cdk.validateString)(properties.spotPrice));
  errors.collect(cdk.propertyValidator("tagSpecifications", cdk.listValidator(CfnSpotFleetSpotFleetTagSpecificationPropertyValidator))(properties.tagSpecifications));
  errors.collect(cdk.propertyValidator("targetCapacity", cdk.requiredValidator)(properties.targetCapacity));
  errors.collect(cdk.propertyValidator("targetCapacity", cdk.validateNumber)(properties.targetCapacity));
  errors.collect(cdk.propertyValidator("targetCapacityUnitType", cdk.validateString)(properties.targetCapacityUnitType));
  errors.collect(cdk.propertyValidator("terminateInstancesWithExpiration", cdk.validateBoolean)(properties.terminateInstancesWithExpiration));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  errors.collect(cdk.propertyValidator("validFrom", cdk.validateString)(properties.validFrom));
  errors.collect(cdk.propertyValidator("validUntil", cdk.validateString)(properties.validUntil));
  return errors.wrap("supplied properties not correct for \"SpotFleetRequestConfigDataProperty\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetSpotFleetRequestConfigDataPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetSpotFleetRequestConfigDataPropertyValidator(properties).assertSuccess();
  return {
    "AllocationStrategy": cdk.stringToCloudFormation(properties.allocationStrategy),
    "Context": cdk.stringToCloudFormation(properties.context),
    "ExcessCapacityTerminationPolicy": cdk.stringToCloudFormation(properties.excessCapacityTerminationPolicy),
    "IamFleetRole": cdk.stringToCloudFormation(properties.iamFleetRole),
    "InstanceInterruptionBehavior": cdk.stringToCloudFormation(properties.instanceInterruptionBehavior),
    "InstancePoolsToUseCount": cdk.numberToCloudFormation(properties.instancePoolsToUseCount),
    "LaunchSpecifications": cdk.listMapper(convertCfnSpotFleetSpotFleetLaunchSpecificationPropertyToCloudFormation)(properties.launchSpecifications),
    "LaunchTemplateConfigs": cdk.listMapper(convertCfnSpotFleetLaunchTemplateConfigPropertyToCloudFormation)(properties.launchTemplateConfigs),
    "LoadBalancersConfig": convertCfnSpotFleetLoadBalancersConfigPropertyToCloudFormation(properties.loadBalancersConfig),
    "OnDemandAllocationStrategy": cdk.stringToCloudFormation(properties.onDemandAllocationStrategy),
    "OnDemandMaxTotalPrice": cdk.stringToCloudFormation(properties.onDemandMaxTotalPrice),
    "OnDemandTargetCapacity": cdk.numberToCloudFormation(properties.onDemandTargetCapacity),
    "ReplaceUnhealthyInstances": cdk.booleanToCloudFormation(properties.replaceUnhealthyInstances),
    "SpotMaintenanceStrategies": convertCfnSpotFleetSpotMaintenanceStrategiesPropertyToCloudFormation(properties.spotMaintenanceStrategies),
    "SpotMaxTotalPrice": cdk.stringToCloudFormation(properties.spotMaxTotalPrice),
    "SpotPrice": cdk.stringToCloudFormation(properties.spotPrice),
    "TagSpecifications": cdk.listMapper(convertCfnSpotFleetSpotFleetTagSpecificationPropertyToCloudFormation)(properties.tagSpecifications),
    "TargetCapacity": cdk.numberToCloudFormation(properties.targetCapacity),
    "TargetCapacityUnitType": cdk.stringToCloudFormation(properties.targetCapacityUnitType),
    "TerminateInstancesWithExpiration": cdk.booleanToCloudFormation(properties.terminateInstancesWithExpiration),
    "Type": cdk.stringToCloudFormation(properties.type),
    "ValidFrom": cdk.stringToCloudFormation(properties.validFrom),
    "ValidUntil": cdk.stringToCloudFormation(properties.validUntil)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetSpotFleetRequestConfigDataPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSpotFleet.SpotFleetRequestConfigDataProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleet.SpotFleetRequestConfigDataProperty>();
  ret.addPropertyResult("allocationStrategy", "AllocationStrategy", (properties.AllocationStrategy != null ? cfn_parse.FromCloudFormation.getString(properties.AllocationStrategy) : undefined));
  ret.addPropertyResult("context", "Context", (properties.Context != null ? cfn_parse.FromCloudFormation.getString(properties.Context) : undefined));
  ret.addPropertyResult("excessCapacityTerminationPolicy", "ExcessCapacityTerminationPolicy", (properties.ExcessCapacityTerminationPolicy != null ? cfn_parse.FromCloudFormation.getString(properties.ExcessCapacityTerminationPolicy) : undefined));
  ret.addPropertyResult("iamFleetRole", "IamFleetRole", (properties.IamFleetRole != null ? cfn_parse.FromCloudFormation.getString(properties.IamFleetRole) : undefined));
  ret.addPropertyResult("instanceInterruptionBehavior", "InstanceInterruptionBehavior", (properties.InstanceInterruptionBehavior != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceInterruptionBehavior) : undefined));
  ret.addPropertyResult("instancePoolsToUseCount", "InstancePoolsToUseCount", (properties.InstancePoolsToUseCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.InstancePoolsToUseCount) : undefined));
  ret.addPropertyResult("launchSpecifications", "LaunchSpecifications", (properties.LaunchSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnSpotFleetSpotFleetLaunchSpecificationPropertyFromCloudFormation)(properties.LaunchSpecifications) : undefined));
  ret.addPropertyResult("launchTemplateConfigs", "LaunchTemplateConfigs", (properties.LaunchTemplateConfigs != null ? cfn_parse.FromCloudFormation.getArray(CfnSpotFleetLaunchTemplateConfigPropertyFromCloudFormation)(properties.LaunchTemplateConfigs) : undefined));
  ret.addPropertyResult("loadBalancersConfig", "LoadBalancersConfig", (properties.LoadBalancersConfig != null ? CfnSpotFleetLoadBalancersConfigPropertyFromCloudFormation(properties.LoadBalancersConfig) : undefined));
  ret.addPropertyResult("onDemandAllocationStrategy", "OnDemandAllocationStrategy", (properties.OnDemandAllocationStrategy != null ? cfn_parse.FromCloudFormation.getString(properties.OnDemandAllocationStrategy) : undefined));
  ret.addPropertyResult("onDemandMaxTotalPrice", "OnDemandMaxTotalPrice", (properties.OnDemandMaxTotalPrice != null ? cfn_parse.FromCloudFormation.getString(properties.OnDemandMaxTotalPrice) : undefined));
  ret.addPropertyResult("onDemandTargetCapacity", "OnDemandTargetCapacity", (properties.OnDemandTargetCapacity != null ? cfn_parse.FromCloudFormation.getNumber(properties.OnDemandTargetCapacity) : undefined));
  ret.addPropertyResult("replaceUnhealthyInstances", "ReplaceUnhealthyInstances", (properties.ReplaceUnhealthyInstances != null ? cfn_parse.FromCloudFormation.getBoolean(properties.ReplaceUnhealthyInstances) : undefined));
  ret.addPropertyResult("spotMaintenanceStrategies", "SpotMaintenanceStrategies", (properties.SpotMaintenanceStrategies != null ? CfnSpotFleetSpotMaintenanceStrategiesPropertyFromCloudFormation(properties.SpotMaintenanceStrategies) : undefined));
  ret.addPropertyResult("spotMaxTotalPrice", "SpotMaxTotalPrice", (properties.SpotMaxTotalPrice != null ? cfn_parse.FromCloudFormation.getString(properties.SpotMaxTotalPrice) : undefined));
  ret.addPropertyResult("spotPrice", "SpotPrice", (properties.SpotPrice != null ? cfn_parse.FromCloudFormation.getString(properties.SpotPrice) : undefined));
  ret.addPropertyResult("tagSpecifications", "TagSpecifications", (properties.TagSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnSpotFleetSpotFleetTagSpecificationPropertyFromCloudFormation)(properties.TagSpecifications) : undefined));
  ret.addPropertyResult("targetCapacity", "TargetCapacity", (properties.TargetCapacity != null ? cfn_parse.FromCloudFormation.getNumber(properties.TargetCapacity) : undefined));
  ret.addPropertyResult("targetCapacityUnitType", "TargetCapacityUnitType", (properties.TargetCapacityUnitType != null ? cfn_parse.FromCloudFormation.getString(properties.TargetCapacityUnitType) : undefined));
  ret.addPropertyResult("terminateInstancesWithExpiration", "TerminateInstancesWithExpiration", (properties.TerminateInstancesWithExpiration != null ? cfn_parse.FromCloudFormation.getBoolean(properties.TerminateInstancesWithExpiration) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addPropertyResult("validFrom", "ValidFrom", (properties.ValidFrom != null ? cfn_parse.FromCloudFormation.getString(properties.ValidFrom) : undefined));
  ret.addPropertyResult("validUntil", "ValidUntil", (properties.ValidUntil != null ? cfn_parse.FromCloudFormation.getString(properties.ValidUntil) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `CfnSpotFleetProps`
 *
 * @param properties - the TypeScript properties of a `CfnSpotFleetProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("spotFleetRequestConfigData", cdk.requiredValidator)(properties.spotFleetRequestConfigData));
  errors.collect(cdk.propertyValidator("spotFleetRequestConfigData", CfnSpotFleetSpotFleetRequestConfigDataPropertyValidator)(properties.spotFleetRequestConfigData));
  return errors.wrap("supplied properties not correct for \"CfnSpotFleetProps\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetPropsValidator(properties).assertSuccess();
  return {
    "SpotFleetRequestConfigData": convertCfnSpotFleetSpotFleetRequestConfigDataPropertyToCloudFormation(properties.spotFleetRequestConfigData)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSpotFleetProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleetProps>();
  ret.addPropertyResult("spotFleetRequestConfigData", "SpotFleetRequestConfigData", (properties.SpotFleetRequestConfigData != null ? CfnSpotFleetSpotFleetRequestConfigDataPropertyFromCloudFormation(properties.SpotFleetRequestConfigData) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a subnet for the specified VPC.
 *
 * For an IPv4 only subnet, specify an IPv4 CIDR block. If the VPC has an IPv6 CIDR block, you can create an IPv6 only subnet or a dual stack subnet instead. For an IPv6 only subnet, specify an IPv6 CIDR block. For a dual stack subnet, specify both an IPv4 CIDR block and an IPv6 CIDR block.
 *
 * For more information, see [Subnets for your VPC](https://docs.aws.amazon.com/vpc/latest/userguide/configure-subnets.html) in the *Amazon VPC User Guide* .
 *
 * @cloudformationResource AWS::EC2::Subnet
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html
 */
export class CfnSubnet extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::Subnet";

  /**
   * Build a CfnSubnet from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnSubnet {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnSubnetPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnSubnet(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The Availability Zone of this subnet. For example, `us-east-1a` .
   *
   * @cloudformationAttribute AvailabilityZone
   */
  public readonly attrAvailabilityZone: string;

  /**
   * The Availability Zone ID of this subnet. For example, `use1-az1` .
   *
   * @cloudformationAttribute AvailabilityZoneId
   */
  public readonly attrAvailabilityZoneId: string;

  /**
   * The IPv4 CIDR blocks that are associated with the subnet.
   *
   * @cloudformationAttribute CidrBlock
   */
  public readonly attrCidrBlock: string;

  /**
   * @cloudformationAttribute Ipv6CidrBlocks
   */
  public readonly attrIpv6CidrBlocks: Array<string>;

  /**
   * The ID of the network ACL that is associated with the subnet's VPC, such as `acl-5fb85d36` .
   *
   * @cloudformationAttribute NetworkAclAssociationId
   */
  public readonly attrNetworkAclAssociationId: string;

  /**
   * The Amazon Resource Name (ARN) of the Outpost.
   *
   * @cloudformationAttribute OutpostArn
   */
  public readonly attrOutpostArn: string;

  /**
   * The ID of the subnet.
   *
   * @cloudformationAttribute SubnetId
   */
  public readonly attrSubnetId: string;

  /**
   * The ID of the subnet's VPC, such as `vpc-11ad4878` .
   *
   * @cloudformationAttribute VpcId
   */
  public readonly attrVpcId: string;

  /**
   * Indicates whether a network interface created in this subnet receives an IPv6 address. The default value is `false` .
   */
  public assignIpv6AddressOnCreation?: boolean | cdk.IResolvable;

  /**
   * The Availability Zone of the subnet.
   */
  public availabilityZone?: string;

  /**
   * The AZ ID of the subnet.
   */
  public availabilityZoneId?: string;

  /**
   * The IPv4 CIDR block assigned to the subnet.
   */
  public cidrBlock?: string;

  /**
   * Indicates whether DNS queries made to the Amazon-provided DNS Resolver in this subnet should return synthetic IPv6 addresses for IPv4-only destinations.
   */
  public enableDns64?: boolean | cdk.IResolvable;

  /**
   * An IPv4 IPAM pool ID for the subnet.
   */
  public ipv4IpamPoolId?: string;

  /**
   * An IPv4 netmask length for the subnet.
   */
  public ipv4NetmaskLength?: number;

  /**
   * The IPv6 CIDR block.
   */
  public ipv6CidrBlock?: string;

  public ipv6CidrBlocks?: Array<string>;

  /**
   * An IPv6 IPAM pool ID for the subnet.
   */
  public ipv6IpamPoolId?: string;

  /**
   * Indicates whether this is an IPv6 only subnet.
   */
  public ipv6Native?: boolean | cdk.IResolvable;

  /**
   * An IPv6 netmask length for the subnet.
   */
  public ipv6NetmaskLength?: number;

  /**
   * Indicates whether instances launched in this subnet receive a public IPv4 address. The default value is `false` .
   */
  public mapPublicIpOnLaunch?: boolean | cdk.IResolvable;

  /**
   * The Amazon Resource Name (ARN) of the Outpost.
   */
  public outpostArn?: string;

  /**
   * The hostname type for EC2 instances launched into this subnet and how DNS A and AAAA record queries to the instances should be handled.
   */
  public privateDnsNameOptionsOnLaunch?: any | cdk.IResolvable;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * Any tags assigned to the subnet.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The ID of the VPC the subnet is in.
   */
  public vpcId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnSubnetProps) {
    super(scope, id, {
      "type": CfnSubnet.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "vpcId", this);

    this.attrAvailabilityZone = cdk.Token.asString(this.getAtt("AvailabilityZone", cdk.ResolutionTypeHint.STRING));
    this.attrAvailabilityZoneId = cdk.Token.asString(this.getAtt("AvailabilityZoneId", cdk.ResolutionTypeHint.STRING));
    this.attrCidrBlock = cdk.Token.asString(this.getAtt("CidrBlock", cdk.ResolutionTypeHint.STRING));
    this.attrIpv6CidrBlocks = cdk.Token.asList(this.getAtt("Ipv6CidrBlocks", cdk.ResolutionTypeHint.STRING_LIST));
    this.attrNetworkAclAssociationId = cdk.Token.asString(this.getAtt("NetworkAclAssociationId", cdk.ResolutionTypeHint.STRING));
    this.attrOutpostArn = cdk.Token.asString(this.getAtt("OutpostArn", cdk.ResolutionTypeHint.STRING));
    this.attrSubnetId = cdk.Token.asString(this.getAtt("SubnetId", cdk.ResolutionTypeHint.STRING));
    this.attrVpcId = cdk.Token.asString(this.getAtt("VpcId", cdk.ResolutionTypeHint.STRING));
    this.assignIpv6AddressOnCreation = props.assignIpv6AddressOnCreation;
    this.availabilityZone = props.availabilityZone;
    this.availabilityZoneId = props.availabilityZoneId;
    this.cidrBlock = props.cidrBlock;
    this.enableDns64 = props.enableDns64;
    this.ipv4IpamPoolId = props.ipv4IpamPoolId;
    this.ipv4NetmaskLength = props.ipv4NetmaskLength;
    this.ipv6CidrBlock = props.ipv6CidrBlock;
    this.ipv6CidrBlocks = props.ipv6CidrBlocks;
    this.ipv6IpamPoolId = props.ipv6IpamPoolId;
    this.ipv6Native = props.ipv6Native;
    this.ipv6NetmaskLength = props.ipv6NetmaskLength;
    this.mapPublicIpOnLaunch = props.mapPublicIpOnLaunch;
    this.outpostArn = props.outpostArn;
    this.privateDnsNameOptionsOnLaunch = props.privateDnsNameOptionsOnLaunch;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::Subnet", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.vpcId = props.vpcId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "assignIpv6AddressOnCreation": this.assignIpv6AddressOnCreation,
      "availabilityZone": this.availabilityZone,
      "availabilityZoneId": this.availabilityZoneId,
      "cidrBlock": this.cidrBlock,
      "enableDns64": this.enableDns64,
      "ipv4IpamPoolId": this.ipv4IpamPoolId,
      "ipv4NetmaskLength": this.ipv4NetmaskLength,
      "ipv6CidrBlock": this.ipv6CidrBlock,
      "ipv6CidrBlocks": this.ipv6CidrBlocks,
      "ipv6IpamPoolId": this.ipv6IpamPoolId,
      "ipv6Native": this.ipv6Native,
      "ipv6NetmaskLength": this.ipv6NetmaskLength,
      "mapPublicIpOnLaunch": this.mapPublicIpOnLaunch,
      "outpostArn": this.outpostArn,
      "privateDnsNameOptionsOnLaunch": this.privateDnsNameOptionsOnLaunch,
      "tags": this.tags.renderTags(),
      "vpcId": this.vpcId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnSubnet.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnSubnetPropsToCloudFormation(props);
  }
}

export namespace CfnSubnet {
  /**
   * Describes the options for instance hostnames.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-subnet-privatednsnameoptionsonlaunch.html
   */
  export interface PrivateDnsNameOptionsOnLaunchProperty {
    /**
     * Indicates whether to respond to DNS queries for instance hostname with DNS AAAA records.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-subnet-privatednsnameoptionsonlaunch.html#cfn-ec2-subnet-privatednsnameoptionsonlaunch-enableresourcenamednsaaaarecord
     */
    readonly enableResourceNameDnsAaaaRecord?: boolean | cdk.IResolvable;

    /**
     * Indicates whether to respond to DNS queries for instance hostnames with DNS A records.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-subnet-privatednsnameoptionsonlaunch.html#cfn-ec2-subnet-privatednsnameoptionsonlaunch-enableresourcenamednsarecord
     */
    readonly enableResourceNameDnsARecord?: boolean | cdk.IResolvable;

    /**
     * The type of hostname for EC2 instances.
     *
     * For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 only subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-subnet-privatednsnameoptionsonlaunch.html#cfn-ec2-subnet-privatednsnameoptionsonlaunch-hostnametype
     */
    readonly hostnameType?: string;
  }
}

/**
 * Properties for defining a `CfnSubnet`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html
 */
export interface CfnSubnetProps {
  /**
   * Indicates whether a network interface created in this subnet receives an IPv6 address. The default value is `false` .
   *
   * If you specify `AssignIpv6AddressOnCreation` , you must also specify `Ipv6CidrBlock` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-assignipv6addressoncreation
   */
  readonly assignIpv6AddressOnCreation?: boolean | cdk.IResolvable;

  /**
   * The Availability Zone of the subnet.
   *
   * If you update this property, you must also update the `CidrBlock` property.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-availabilityzone
   */
  readonly availabilityZone?: string;

  /**
   * The AZ ID of the subnet.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-availabilityzoneid
   */
  readonly availabilityZoneId?: string;

  /**
   * The IPv4 CIDR block assigned to the subnet.
   *
   * If you update this property, we create a new subnet, and then delete the existing one.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-cidrblock
   */
  readonly cidrBlock?: string;

  /**
   * Indicates whether DNS queries made to the Amazon-provided DNS Resolver in this subnet should return synthetic IPv6 addresses for IPv4-only destinations.
   *
   * For more information, see [DNS64 and NAT64](https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html#nat-gateway-nat64-dns64) in the *Amazon Virtual Private Cloud User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-enabledns64
   */
  readonly enableDns64?: boolean | cdk.IResolvable;

  /**
   * An IPv4 IPAM pool ID for the subnet.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-ipv4ipampoolid
   */
  readonly ipv4IpamPoolId?: string;

  /**
   * An IPv4 netmask length for the subnet.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-ipv4netmasklength
   */
  readonly ipv4NetmaskLength?: number;

  /**
   * The IPv6 CIDR block.
   *
   * If you specify `AssignIpv6AddressOnCreation` , you must also specify `Ipv6CidrBlock` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-ipv6cidrblock
   */
  readonly ipv6CidrBlock?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-ipv6cidrblocks
   */
  readonly ipv6CidrBlocks?: Array<string>;

  /**
   * An IPv6 IPAM pool ID for the subnet.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-ipv6ipampoolid
   */
  readonly ipv6IpamPoolId?: string;

  /**
   * Indicates whether this is an IPv6 only subnet.
   *
   * For more information, see [Subnet basics](https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Subnets.html#subnet-basics) in the *Amazon Virtual Private Cloud User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-ipv6native
   */
  readonly ipv6Native?: boolean | cdk.IResolvable;

  /**
   * An IPv6 netmask length for the subnet.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-ipv6netmasklength
   */
  readonly ipv6NetmaskLength?: number;

  /**
   * Indicates whether instances launched in this subnet receive a public IPv4 address. The default value is `false` .
   *
   * Starting on February 1, 2024, AWS will charge for all public IPv4 addresses, including public IPv4 addresses associated with running instances and Elastic IP addresses. For more information, see the *Public IPv4 Address* tab on the [VPC pricing page](https://docs.aws.amazon.com/vpc/pricing/) .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-mappubliciponlaunch
   */
  readonly mapPublicIpOnLaunch?: boolean | cdk.IResolvable;

  /**
   * The Amazon Resource Name (ARN) of the Outpost.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-outpostarn
   */
  readonly outpostArn?: string;

  /**
   * The hostname type for EC2 instances launched into this subnet and how DNS A and AAAA record queries to the instances should be handled.
   *
   * For more information, see [Amazon EC2 instance hostname types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html) in the *Amazon Elastic Compute Cloud User Guide* .
   *
   * Available options:
   *
   * - EnableResourceNameDnsAAAARecord (true | false)
   * - EnableResourceNameDnsARecord (true | false)
   * - HostnameType (ip-name | resource-name)
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-privatednsnameoptionsonlaunch
   */
  readonly privateDnsNameOptionsOnLaunch?: any | cdk.IResolvable;

  /**
   * Any tags assigned to the subnet.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The ID of the VPC the subnet is in.
   *
   * If you update this property, you must also update the `CidrBlock` property.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-vpcid
   */
  readonly vpcId: string;
}

/**
 * Determine whether the given properties match those of a `PrivateDnsNameOptionsOnLaunchProperty`
 *
 * @param properties - the TypeScript properties of a `PrivateDnsNameOptionsOnLaunchProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSubnetPrivateDnsNameOptionsOnLaunchPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("enableResourceNameDnsAaaaRecord", cdk.validateBoolean)(properties.enableResourceNameDnsAaaaRecord));
  errors.collect(cdk.propertyValidator("enableResourceNameDnsARecord", cdk.validateBoolean)(properties.enableResourceNameDnsARecord));
  errors.collect(cdk.propertyValidator("hostnameType", cdk.validateString)(properties.hostnameType));
  return errors.wrap("supplied properties not correct for \"PrivateDnsNameOptionsOnLaunchProperty\"");
}

// @ts-ignore TS6133
function convertCfnSubnetPrivateDnsNameOptionsOnLaunchPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSubnetPrivateDnsNameOptionsOnLaunchPropertyValidator(properties).assertSuccess();
  return {
    "EnableResourceNameDnsAAAARecord": cdk.booleanToCloudFormation(properties.enableResourceNameDnsAaaaRecord),
    "EnableResourceNameDnsARecord": cdk.booleanToCloudFormation(properties.enableResourceNameDnsARecord),
    "HostnameType": cdk.stringToCloudFormation(properties.hostnameType)
  };
}

// @ts-ignore TS6133
function CfnSubnetPrivateDnsNameOptionsOnLaunchPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSubnet.PrivateDnsNameOptionsOnLaunchProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSubnet.PrivateDnsNameOptionsOnLaunchProperty>();
  ret.addPropertyResult("enableResourceNameDnsAaaaRecord", "EnableResourceNameDnsAAAARecord", (properties.EnableResourceNameDnsAAAARecord != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EnableResourceNameDnsAAAARecord) : undefined));
  ret.addPropertyResult("enableResourceNameDnsARecord", "EnableResourceNameDnsARecord", (properties.EnableResourceNameDnsARecord != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EnableResourceNameDnsARecord) : undefined));
  ret.addPropertyResult("hostnameType", "HostnameType", (properties.HostnameType != null ? cfn_parse.FromCloudFormation.getString(properties.HostnameType) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `CfnSubnetProps`
 *
 * @param properties - the TypeScript properties of a `CfnSubnetProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSubnetPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("assignIpv6AddressOnCreation", cdk.validateBoolean)(properties.assignIpv6AddressOnCreation));
  errors.collect(cdk.propertyValidator("availabilityZone", cdk.validateString)(properties.availabilityZone));
  errors.collect(cdk.propertyValidator("availabilityZoneId", cdk.validateString)(properties.availabilityZoneId));
  errors.collect(cdk.propertyValidator("cidrBlock", cdk.validateString)(properties.cidrBlock));
  errors.collect(cdk.propertyValidator("enableDns64", cdk.validateBoolean)(properties.enableDns64));
  errors.collect(cdk.propertyValidator("ipv4IpamPoolId", cdk.validateString)(properties.ipv4IpamPoolId));
  errors.collect(cdk.propertyValidator("ipv4NetmaskLength", cdk.validateNumber)(properties.ipv4NetmaskLength));
  errors.collect(cdk.propertyValidator("ipv6CidrBlock", cdk.validateString)(properties.ipv6CidrBlock));
  errors.collect(cdk.propertyValidator("ipv6CidrBlocks", cdk.listValidator(cdk.validateString))(properties.ipv6CidrBlocks));
  errors.collect(cdk.propertyValidator("ipv6IpamPoolId", cdk.validateString)(properties.ipv6IpamPoolId));
  errors.collect(cdk.propertyValidator("ipv6Native", cdk.validateBoolean)(properties.ipv6Native));
  errors.collect(cdk.propertyValidator("ipv6NetmaskLength", cdk.validateNumber)(properties.ipv6NetmaskLength));
  errors.collect(cdk.propertyValidator("mapPublicIpOnLaunch", cdk.validateBoolean)(properties.mapPublicIpOnLaunch));
  errors.collect(cdk.propertyValidator("outpostArn", cdk.validateString)(properties.outpostArn));
  errors.collect(cdk.propertyValidator("privateDnsNameOptionsOnLaunch", cdk.validateObject)(properties.privateDnsNameOptionsOnLaunch));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("vpcId", cdk.requiredValidator)(properties.vpcId));
  errors.collect(cdk.propertyValidator("vpcId", cdk.validateString)(properties.vpcId));
  return errors.wrap("supplied properties not correct for \"CfnSubnetProps\"");
}

// @ts-ignore TS6133
function convertCfnSubnetPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSubnetPropsValidator(properties).assertSuccess();
  return {
    "AssignIpv6AddressOnCreation": cdk.booleanToCloudFormation(properties.assignIpv6AddressOnCreation),
    "AvailabilityZone": cdk.stringToCloudFormation(properties.availabilityZone),
    "AvailabilityZoneId": cdk.stringToCloudFormation(properties.availabilityZoneId),
    "CidrBlock": cdk.stringToCloudFormation(properties.cidrBlock),
    "EnableDns64": cdk.booleanToCloudFormation(properties.enableDns64),
    "Ipv4IpamPoolId": cdk.stringToCloudFormation(properties.ipv4IpamPoolId),
    "Ipv4NetmaskLength": cdk.numberToCloudFormation(properties.ipv4NetmaskLength),
    "Ipv6CidrBlock": cdk.stringToCloudFormation(properties.ipv6CidrBlock),
    "Ipv6CidrBlocks": cdk.listMapper(cdk.stringToCloudFormation)(properties.ipv6CidrBlocks),
    "Ipv6IpamPoolId": cdk.stringToCloudFormation(properties.ipv6IpamPoolId),
    "Ipv6Native": cdk.booleanToCloudFormation(properties.ipv6Native),
    "Ipv6NetmaskLength": cdk.numberToCloudFormation(properties.ipv6NetmaskLength),
    "MapPublicIpOnLaunch": cdk.booleanToCloudFormation(properties.mapPublicIpOnLaunch),
    "OutpostArn": cdk.stringToCloudFormation(properties.outpostArn),
    "PrivateDnsNameOptionsOnLaunch": cdk.objectToCloudFormation(properties.privateDnsNameOptionsOnLaunch),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "VpcId": cdk.stringToCloudFormation(properties.vpcId)
  };
}

// @ts-ignore TS6133
function CfnSubnetPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSubnetProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSubnetProps>();
  ret.addPropertyResult("assignIpv6AddressOnCreation", "AssignIpv6AddressOnCreation", (properties.AssignIpv6AddressOnCreation != null ? cfn_parse.FromCloudFormation.getBoolean(properties.AssignIpv6AddressOnCreation) : undefined));
  ret.addPropertyResult("availabilityZone", "AvailabilityZone", (properties.AvailabilityZone != null ? cfn_parse.FromCloudFormation.getString(properties.AvailabilityZone) : undefined));
  ret.addPropertyResult("availabilityZoneId", "AvailabilityZoneId", (properties.AvailabilityZoneId != null ? cfn_parse.FromCloudFormation.getString(properties.AvailabilityZoneId) : undefined));
  ret.addPropertyResult("cidrBlock", "CidrBlock", (properties.CidrBlock != null ? cfn_parse.FromCloudFormation.getString(properties.CidrBlock) : undefined));
  ret.addPropertyResult("enableDns64", "EnableDns64", (properties.EnableDns64 != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EnableDns64) : undefined));
  ret.addPropertyResult("ipv4IpamPoolId", "Ipv4IpamPoolId", (properties.Ipv4IpamPoolId != null ? cfn_parse.FromCloudFormation.getString(properties.Ipv4IpamPoolId) : undefined));
  ret.addPropertyResult("ipv4NetmaskLength", "Ipv4NetmaskLength", (properties.Ipv4NetmaskLength != null ? cfn_parse.FromCloudFormation.getNumber(properties.Ipv4NetmaskLength) : undefined));
  ret.addPropertyResult("ipv6CidrBlock", "Ipv6CidrBlock", (properties.Ipv6CidrBlock != null ? cfn_parse.FromCloudFormation.getString(properties.Ipv6CidrBlock) : undefined));
  ret.addPropertyResult("ipv6CidrBlocks", "Ipv6CidrBlocks", (properties.Ipv6CidrBlocks != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.Ipv6CidrBlocks) : undefined));
  ret.addPropertyResult("ipv6IpamPoolId", "Ipv6IpamPoolId", (properties.Ipv6IpamPoolId != null ? cfn_parse.FromCloudFormation.getString(properties.Ipv6IpamPoolId) : undefined));
  ret.addPropertyResult("ipv6Native", "Ipv6Native", (properties.Ipv6Native != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Ipv6Native) : undefined));
  ret.addPropertyResult("ipv6NetmaskLength", "Ipv6NetmaskLength", (properties.Ipv6NetmaskLength != null ? cfn_parse.FromCloudFormation.getNumber(properties.Ipv6NetmaskLength) : undefined));
  ret.addPropertyResult("mapPublicIpOnLaunch", "MapPublicIpOnLaunch", (properties.MapPublicIpOnLaunch != null ? cfn_parse.FromCloudFormation.getBoolean(properties.MapPublicIpOnLaunch) : undefined));
  ret.addPropertyResult("outpostArn", "OutpostArn", (properties.OutpostArn != null ? cfn_parse.FromCloudFormation.getString(properties.OutpostArn) : undefined));
  ret.addPropertyResult("privateDnsNameOptionsOnLaunch", "PrivateDnsNameOptionsOnLaunch", (properties.PrivateDnsNameOptionsOnLaunch != null ? cfn_parse.FromCloudFormation.getAny(properties.PrivateDnsNameOptionsOnLaunch) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("vpcId", "VpcId", (properties.VpcId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Associates a CIDR block with your subnet.
 *
 * You can associate a single IPv6 CIDR block with your subnet.
 *
 * @cloudformationResource AWS::EC2::SubnetCidrBlock
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetcidrblock.html
 */
export class CfnSubnetCidrBlock extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::SubnetCidrBlock";

  /**
   * Build a CfnSubnetCidrBlock from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnSubnetCidrBlock {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnSubnetCidrBlockPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnSubnetCidrBlock(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the association.
   *
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The IPv6 network range for the subnet, in CIDR notation.
   */
  public ipv6CidrBlock?: string;

  /**
   * An IPv6 IPAM pool ID for the subnet.
   */
  public ipv6IpamPoolId?: string;

  /**
   * An IPv6 netmask length for the subnet.
   */
  public ipv6NetmaskLength?: number;

  /**
   * The ID of the subnet.
   */
  public subnetId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnSubnetCidrBlockProps) {
    super(scope, id, {
      "type": CfnSubnetCidrBlock.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "subnetId", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.ipv6CidrBlock = props.ipv6CidrBlock;
    this.ipv6IpamPoolId = props.ipv6IpamPoolId;
    this.ipv6NetmaskLength = props.ipv6NetmaskLength;
    this.subnetId = props.subnetId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "ipv6CidrBlock": this.ipv6CidrBlock,
      "ipv6IpamPoolId": this.ipv6IpamPoolId,
      "ipv6NetmaskLength": this.ipv6NetmaskLength,
      "subnetId": this.subnetId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnSubnetCidrBlock.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnSubnetCidrBlockPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a `CfnSubnetCidrBlock`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetcidrblock.html
 */
export interface CfnSubnetCidrBlockProps {
  /**
   * The IPv6 network range for the subnet, in CIDR notation.
   *
   * This parameter is required for an IPv6 only subnet.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetcidrblock.html#cfn-ec2-subnetcidrblock-ipv6cidrblock
   */
  readonly ipv6CidrBlock?: string;

  /**
   * An IPv6 IPAM pool ID for the subnet.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetcidrblock.html#cfn-ec2-subnetcidrblock-ipv6ipampoolid
   */
  readonly ipv6IpamPoolId?: string;

  /**
   * An IPv6 netmask length for the subnet.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetcidrblock.html#cfn-ec2-subnetcidrblock-ipv6netmasklength
   */
  readonly ipv6NetmaskLength?: number;

  /**
   * The ID of the subnet.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetcidrblock.html#cfn-ec2-subnetcidrblock-subnetid
   */
  readonly subnetId: string;
}

/**
 * Determine whether the given properties match those of a `CfnSubnetCidrBlockProps`
 *
 * @param properties - the TypeScript properties of a `CfnSubnetCidrBlockProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSubnetCidrBlockPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("ipv6CidrBlock", cdk.validateString)(properties.ipv6CidrBlock));
  errors.collect(cdk.propertyValidator("ipv6IpamPoolId", cdk.validateString)(properties.ipv6IpamPoolId));
  errors.collect(cdk.propertyValidator("ipv6NetmaskLength", cdk.validateNumber)(properties.ipv6NetmaskLength));
  errors.collect(cdk.propertyValidator("subnetId", cdk.requiredValidator)(properties.subnetId));
  errors.collect(cdk.propertyValidator("subnetId", cdk.validateString)(properties.subnetId));
  return errors.wrap("supplied properties not correct for \"CfnSubnetCidrBlockProps\"");
}

// @ts-ignore TS6133
function convertCfnSubnetCidrBlockPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSubnetCidrBlockPropsValidator(properties).assertSuccess();
  return {
    "Ipv6CidrBlock": cdk.stringToCloudFormation(properties.ipv6CidrBlock),
    "Ipv6IpamPoolId": cdk.stringToCloudFormation(properties.ipv6IpamPoolId),
    "Ipv6NetmaskLength": cdk.numberToCloudFormation(properties.ipv6NetmaskLength),
    "SubnetId": cdk.stringToCloudFormation(properties.subnetId)
  };
}

// @ts-ignore TS6133
function CfnSubnetCidrBlockPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSubnetCidrBlockProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSubnetCidrBlockProps>();
  ret.addPropertyResult("ipv6CidrBlock", "Ipv6CidrBlock", (properties.Ipv6CidrBlock != null ? cfn_parse.FromCloudFormation.getString(properties.Ipv6CidrBlock) : undefined));
  ret.addPropertyResult("ipv6IpamPoolId", "Ipv6IpamPoolId", (properties.Ipv6IpamPoolId != null ? cfn_parse.FromCloudFormation.getString(properties.Ipv6IpamPoolId) : undefined));
  ret.addPropertyResult("ipv6NetmaskLength", "Ipv6NetmaskLength", (properties.Ipv6NetmaskLength != null ? cfn_parse.FromCloudFormation.getNumber(properties.Ipv6NetmaskLength) : undefined));
  ret.addPropertyResult("subnetId", "SubnetId", (properties.SubnetId != null ? cfn_parse.FromCloudFormation.getString(properties.SubnetId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Associates a subnet with a network ACL. For more information, see [ReplaceNetworkAclAssociation](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/ApiReference-query-ReplaceNetworkAclAssociation.html) in the *Amazon EC2 API Reference* .
 *
 * When `AWS::EC2::SubnetNetworkAclAssociation` resources are created during create or update operations, AWS CloudFormation adopts existing resources that share the same key properties (the properties that contribute to uniquely identify the resource). However, if the operation fails and rolls back, AWS CloudFormation deletes the previously out-of-band resources. You can protect against this behavior by using `Retain` deletion policies. For more information, see [DeletionPolicy Attribute](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html) .
 *
 * @cloudformationResource AWS::EC2::SubnetNetworkAclAssociation
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetnetworkaclassociation.html
 */
export class CfnSubnetNetworkAclAssociation extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::SubnetNetworkAclAssociation";

  /**
   * Build a CfnSubnetNetworkAclAssociation from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnSubnetNetworkAclAssociation {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnSubnetNetworkAclAssociationPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnSubnetNetworkAclAssociation(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * Returns the value of this object's AssociationId property.
   *
   * @cloudformationAttribute AssociationId
   */
  public readonly attrAssociationId: string;

  /**
   * The ID of the network ACL.
   */
  public networkAclId: string;

  /**
   * The ID of the subnet.
   */
  public subnetId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnSubnetNetworkAclAssociationProps) {
    super(scope, id, {
      "type": CfnSubnetNetworkAclAssociation.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "networkAclId", this);
    cdk.requireProperty(props, "subnetId", this);

    this.attrAssociationId = cdk.Token.asString(this.getAtt("AssociationId", cdk.ResolutionTypeHint.STRING));
    this.networkAclId = props.networkAclId;
    this.subnetId = props.subnetId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "networkAclId": this.networkAclId,
      "subnetId": this.subnetId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnSubnetNetworkAclAssociation.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnSubnetNetworkAclAssociationPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a `CfnSubnetNetworkAclAssociation`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetnetworkaclassociation.html
 */
export interface CfnSubnetNetworkAclAssociationProps {
  /**
   * The ID of the network ACL.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetnetworkaclassociation.html#cfn-ec2-subnetnetworkaclassociation-networkaclid
   */
  readonly networkAclId: string;

  /**
   * The ID of the subnet.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetnetworkaclassociation.html#cfn-ec2-subnetnetworkaclassociation-subnetid
   */
  readonly subnetId: string;
}

/**
 * Determine whether the given properties match those of a `CfnSubnetNetworkAclAssociationProps`
 *
 * @param properties - the TypeScript properties of a `CfnSubnetNetworkAclAssociationProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSubnetNetworkAclAssociationPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("networkAclId", cdk.requiredValidator)(properties.networkAclId));
  errors.collect(cdk.propertyValidator("networkAclId", cdk.validateString)(properties.networkAclId));
  errors.collect(cdk.propertyValidator("subnetId", cdk.requiredValidator)(properties.subnetId));
  errors.collect(cdk.propertyValidator("subnetId", cdk.validateString)(properties.subnetId));
  return errors.wrap("supplied properties not correct for \"CfnSubnetNetworkAclAssociationProps\"");
}

// @ts-ignore TS6133
function convertCfnSubnetNetworkAclAssociationPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSubnetNetworkAclAssociationPropsValidator(properties).assertSuccess();
  return {
    "NetworkAclId": cdk.stringToCloudFormation(properties.networkAclId),
    "SubnetId": cdk.stringToCloudFormation(properties.subnetId)
  };
}

// @ts-ignore TS6133
function CfnSubnetNetworkAclAssociationPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSubnetNetworkAclAssociationProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSubnetNetworkAclAssociationProps>();
  ret.addPropertyResult("networkAclId", "NetworkAclId", (properties.NetworkAclId != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkAclId) : undefined));
  ret.addPropertyResult("subnetId", "SubnetId", (properties.SubnetId != null ? cfn_parse.FromCloudFormation.getString(properties.SubnetId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Associates a subnet with a route table.
 *
 * The subnet and route table must be in the same VPC. This association causes traffic originating from the subnet to be routed according to the routes in the route table. A route table can be associated with multiple subnets. To create a route table, see [AWS::EC2::RouteTable](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-routetable.html) .
 *
 * @cloudformationResource AWS::EC2::SubnetRouteTableAssociation
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetroutetableassociation.html
 */
export class CfnSubnetRouteTableAssociation extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::SubnetRouteTableAssociation";

  /**
   * Build a CfnSubnetRouteTableAssociation from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnSubnetRouteTableAssociation {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnSubnetRouteTableAssociationPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnSubnetRouteTableAssociation(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the subnet route table association.
   *
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The ID of the route table.
   */
  public routeTableId: string;

  /**
   * The ID of the subnet.
   */
  public subnetId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnSubnetRouteTableAssociationProps) {
    super(scope, id, {
      "type": CfnSubnetRouteTableAssociation.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "routeTableId", this);
    cdk.requireProperty(props, "subnetId", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.routeTableId = props.routeTableId;
    this.subnetId = props.subnetId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "routeTableId": this.routeTableId,
      "subnetId": this.subnetId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnSubnetRouteTableAssociation.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnSubnetRouteTableAssociationPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a `CfnSubnetRouteTableAssociation`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetroutetableassociation.html
 */
export interface CfnSubnetRouteTableAssociationProps {
  /**
   * The ID of the route table.
   *
   * The physical ID changes when the route table ID is changed.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetroutetableassociation.html#cfn-ec2-subnetroutetableassociation-routetableid
   */
  readonly routeTableId: string;

  /**
   * The ID of the subnet.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetroutetableassociation.html#cfn-ec2-subnetroutetableassociation-subnetid
   */
  readonly subnetId: string;
}

/**
 * Determine whether the given properties match those of a `CfnSubnetRouteTableAssociationProps`
 *
 * @param properties - the TypeScript properties of a `CfnSubnetRouteTableAssociationProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSubnetRouteTableAssociationPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("routeTableId", cdk.requiredValidator)(properties.routeTableId));
  errors.collect(cdk.propertyValidator("routeTableId", cdk.validateString)(properties.routeTableId));
  errors.collect(cdk.propertyValidator("subnetId", cdk.requiredValidator)(properties.subnetId));
  errors.collect(cdk.propertyValidator("subnetId", cdk.validateString)(properties.subnetId));
  return errors.wrap("supplied properties not correct for \"CfnSubnetRouteTableAssociationProps\"");
}

// @ts-ignore TS6133
function convertCfnSubnetRouteTableAssociationPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSubnetRouteTableAssociationPropsValidator(properties).assertSuccess();
  return {
    "RouteTableId": cdk.stringToCloudFormation(properties.routeTableId),
    "SubnetId": cdk.stringToCloudFormation(properties.subnetId)
  };
}

// @ts-ignore TS6133
function CfnSubnetRouteTableAssociationPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSubnetRouteTableAssociationProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSubnetRouteTableAssociationProps>();
  ret.addPropertyResult("routeTableId", "RouteTableId", (properties.RouteTableId != null ? cfn_parse.FromCloudFormation.getString(properties.RouteTableId) : undefined));
  ret.addPropertyResult("subnetId", "SubnetId", (properties.SubnetId != null ? cfn_parse.FromCloudFormation.getString(properties.SubnetId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a Traffic Mirror filter.
 *
 * A Traffic Mirror filter is a set of rules that defines the traffic to mirror.
 *
 * By default, no traffic is mirrored. To mirror traffic, use [AWS::EC2::TrafficMirrorFilterRule](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html) to add Traffic Mirror rules to the filter. The rules you add define what traffic gets mirrored.
 *
 * @cloudformationResource AWS::EC2::TrafficMirrorFilter
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilter.html
 */
export class CfnTrafficMirrorFilter extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::TrafficMirrorFilter";

  /**
   * Build a CfnTrafficMirrorFilter from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnTrafficMirrorFilter {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnTrafficMirrorFilterPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnTrafficMirrorFilter(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The description of the Traffic Mirror filter.
   */
  public description?: string;

  /**
   * The network service traffic that is associated with the Traffic Mirror filter.
   */
  public networkServices?: Array<string>;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags to assign to a Traffic Mirror filter.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnTrafficMirrorFilterProps = {}) {
    super(scope, id, {
      "type": CfnTrafficMirrorFilter.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.description = props.description;
    this.networkServices = props.networkServices;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::TrafficMirrorFilter", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "description": this.description,
      "networkServices": this.networkServices,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnTrafficMirrorFilter.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnTrafficMirrorFilterPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a `CfnTrafficMirrorFilter`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilter.html
 */
export interface CfnTrafficMirrorFilterProps {
  /**
   * The description of the Traffic Mirror filter.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilter.html#cfn-ec2-trafficmirrorfilter-description
   */
  readonly description?: string;

  /**
   * The network service traffic that is associated with the Traffic Mirror filter.
   *
   * Valid values are `amazon-dns` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilter.html#cfn-ec2-trafficmirrorfilter-networkservices
   */
  readonly networkServices?: Array<string>;

  /**
   * The tags to assign to a Traffic Mirror filter.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilter.html#cfn-ec2-trafficmirrorfilter-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a `CfnTrafficMirrorFilterProps`
 *
 * @param properties - the TypeScript properties of a `CfnTrafficMirrorFilterProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTrafficMirrorFilterPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("networkServices", cdk.listValidator(cdk.validateString))(properties.networkServices));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \"CfnTrafficMirrorFilterProps\"");
}

// @ts-ignore TS6133
function convertCfnTrafficMirrorFilterPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTrafficMirrorFilterPropsValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "NetworkServices": cdk.listMapper(cdk.stringToCloudFormation)(properties.networkServices),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnTrafficMirrorFilterPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnTrafficMirrorFilterProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTrafficMirrorFilterProps>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("networkServices", "NetworkServices", (properties.NetworkServices != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.NetworkServices) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Creates a Traffic Mirror filter rule.
 *
 * A Traffic Mirror rule defines the Traffic Mirror source traffic to mirror.
 *
 * You need the Traffic Mirror filter ID when you create the rule.
 *
 * @cloudformationResource AWS::EC2::TrafficMirrorFilterRule
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html
 */
export class CfnTrafficMirrorFilterRule extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::TrafficMirrorFilterRule";

  /**
   * Build a CfnTrafficMirrorFilterRule from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnTrafficMirrorFilterRule {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnTrafficMirrorFilterRulePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnTrafficMirrorFilterRule(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The description of the Traffic Mirror rule.
   */
  public description?: string;

  /**
   * The destination CIDR block to assign to the Traffic Mirror rule.
   */
  public destinationCidrBlock: string;

  /**
   * The destination port range.
   */
  public destinationPortRange?: cdk.IResolvable | CfnTrafficMirrorFilterRule.TrafficMirrorPortRangeProperty;

  /**
   * The protocol, for example UDP, to assign to the Traffic Mirror rule.
   */
  public protocol?: number;

  /**
   * The action to take on the filtered traffic.
   */
  public ruleAction: string;

  /**
   * The number of the Traffic Mirror rule.
   */
  public ruleNumber: number;

  /**
   * The source CIDR block to assign to the Traffic Mirror rule.
   */
  public sourceCidrBlock: string;

  /**
   * The source port range.
   */
  public sourcePortRange?: cdk.IResolvable | CfnTrafficMirrorFilterRule.TrafficMirrorPortRangeProperty;

  /**
   * The type of traffic.
   */
  public trafficDirection: string;

  /**
   * The ID of the filter that this rule is associated with.
   */
  public trafficMirrorFilterId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnTrafficMirrorFilterRuleProps) {
    super(scope, id, {
      "type": CfnTrafficMirrorFilterRule.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "destinationCidrBlock", this);
    cdk.requireProperty(props, "ruleAction", this);
    cdk.requireProperty(props, "ruleNumber", this);
    cdk.requireProperty(props, "sourceCidrBlock", this);
    cdk.requireProperty(props, "trafficDirection", this);
    cdk.requireProperty(props, "trafficMirrorFilterId", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.description = props.description;
    this.destinationCidrBlock = props.destinationCidrBlock;
    this.destinationPortRange = props.destinationPortRange;
    this.protocol = props.protocol;
    this.ruleAction = props.ruleAction;
    this.ruleNumber = props.ruleNumber;
    this.sourceCidrBlock = props.sourceCidrBlock;
    this.sourcePortRange = props.sourcePortRange;
    this.trafficDirection = props.trafficDirection;
    this.trafficMirrorFilterId = props.trafficMirrorFilterId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "description": this.description,
      "destinationCidrBlock": this.destinationCidrBlock,
      "destinationPortRange": this.destinationPortRange,
      "protocol": this.protocol,
      "ruleAction": this.ruleAction,
      "ruleNumber": this.ruleNumber,
      "sourceCidrBlock": this.sourceCidrBlock,
      "sourcePortRange": this.sourcePortRange,
      "trafficDirection": this.trafficDirection,
      "trafficMirrorFilterId": this.trafficMirrorFilterId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnTrafficMirrorFilterRule.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnTrafficMirrorFilterRulePropsToCloudFormation(props);
  }
}

export namespace CfnTrafficMirrorFilterRule {
  /**
   * Describes the Traffic Mirror port range.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-trafficmirrorfilterrule-trafficmirrorportrange.html
   */
  export interface TrafficMirrorPortRangeProperty {
    /**
     * The start of the Traffic Mirror port range.
     *
     * This applies to the TCP and UDP protocols.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-trafficmirrorfilterrule-trafficmirrorportrange.html#cfn-ec2-trafficmirrorfilterrule-trafficmirrorportrange-fromport
     */
    readonly fromPort: number;

    /**
     * The end of the Traffic Mirror port range.
     *
     * This applies to the TCP and UDP protocols.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-trafficmirrorfilterrule-trafficmirrorportrange.html#cfn-ec2-trafficmirrorfilterrule-trafficmirrorportrange-toport
     */
    readonly toPort: number;
  }
}

/**
 * Properties for defining a `CfnTrafficMirrorFilterRule`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html
 */
export interface CfnTrafficMirrorFilterRuleProps {
  /**
   * The description of the Traffic Mirror rule.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-description
   */
  readonly description?: string;

  /**
   * The destination CIDR block to assign to the Traffic Mirror rule.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-destinationcidrblock
   */
  readonly destinationCidrBlock: string;

  /**
   * The destination port range.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-destinationportrange
   */
  readonly destinationPortRange?: cdk.IResolvable | CfnTrafficMirrorFilterRule.TrafficMirrorPortRangeProperty;

  /**
   * The protocol, for example UDP, to assign to the Traffic Mirror rule.
   *
   * For information about the protocol value, see [Protocol Numbers](https://docs.aws.amazon.com/https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml) on the Internet Assigned Numbers Authority (IANA) website.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-protocol
   */
  readonly protocol?: number;

  /**
   * The action to take on the filtered traffic.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-ruleaction
   */
  readonly ruleAction: string;

  /**
   * The number of the Traffic Mirror rule.
   *
   * This number must be unique for each Traffic Mirror rule in a given direction. The rules are processed in ascending order by rule number.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-rulenumber
   */
  readonly ruleNumber: number;

  /**
   * The source CIDR block to assign to the Traffic Mirror rule.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-sourcecidrblock
   */
  readonly sourceCidrBlock: string;

  /**
   * The source port range.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-sourceportrange
   */
  readonly sourcePortRange?: cdk.IResolvable | CfnTrafficMirrorFilterRule.TrafficMirrorPortRangeProperty;

  /**
   * The type of traffic.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-trafficdirection
   */
  readonly trafficDirection: string;

  /**
   * The ID of the filter that this rule is associated with.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-trafficmirrorfilterid
   */
  readonly trafficMirrorFilterId: string;
}

/**
 * Determine whether the given properties match those of a `TrafficMirrorPortRangeProperty`
 *
 * @param properties - the TypeScript properties of a `TrafficMirrorPortRangeProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTrafficMirrorFilterRuleTrafficMirrorPortRangePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("fromPort", cdk.requiredValidator)(properties.fromPort));
  errors.collect(cdk.propertyValidator("fromPort", cdk.validateNumber)(properties.fromPort));
  errors.collect(cdk.propertyValidator("toPort", cdk.requiredValidator)(properties.toPort));
  errors.collect(cdk.propertyValidator("toPort", cdk.validateNumber)(properties.toPort));
  return errors.wrap("supplied properties not correct for \"TrafficMirrorPortRangeProperty\"");
}

// @ts-ignore TS6133
function convertCfnTrafficMirrorFilterRuleTrafficMirrorPortRangePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTrafficMirrorFilterRuleTrafficMirrorPortRangePropertyValidator(properties).assertSuccess();
  return {
    "FromPort": cdk.numberToCloudFormation(properties.fromPort),
    "ToPort": cdk.numberToCloudFormation(properties.toPort)
  };
}

// @ts-ignore TS6133
function CfnTrafficMirrorFilterRuleTrafficMirrorPortRangePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnTrafficMirrorFilterRule.TrafficMirrorPortRangeProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTrafficMirrorFilterRule.TrafficMirrorPortRangeProperty>();
  ret.addPropertyResult("fromPort", "FromPort", (properties.FromPort != null ? cfn_parse.FromCloudFormation.getNumber(properties.FromPort) : undefined));
  ret.addPropertyResult("toPort", "ToPort", (properties.ToPort != null ? cfn_parse.FromCloudFormation.getNumber(properties.ToPort) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `CfnTrafficMirrorFilterRuleProps`
 *
 * @param properties - the TypeScript properties of a `CfnTrafficMirrorFilterRuleProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTrafficMirrorFilterRulePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("destinationCidrBlock", cdk.requiredValidator)(properties.destinationCidrBlock));
  errors.collect(cdk.propertyValidator("destinationCidrBlock", cdk.validateString)(properties.destinationCidrBlock));
  errors.collect(cdk.propertyValidator("destinationPortRange", CfnTrafficMirrorFilterRuleTrafficMirrorPortRangePropertyValidator)(properties.destinationPortRange));
  errors.collect(cdk.propertyValidator("protocol", cdk.validateNumber)(properties.protocol));
  errors.collect(cdk.propertyValidator("ruleAction", cdk.requiredValidator)(properties.ruleAction));
  errors.collect(cdk.propertyValidator("ruleAction", cdk.validateString)(properties.ruleAction));
  errors.collect(cdk.propertyValidator("ruleNumber", cdk.requiredValidator)(properties.ruleNumber));
  errors.collect(cdk.propertyValidator("ruleNumber", cdk.validateNumber)(properties.ruleNumber));
  errors.collect(cdk.propertyValidator("sourceCidrBlock", cdk.requiredValidator)(properties.sourceCidrBlock));
  errors.collect(cdk.propertyValidator("sourceCidrBlock", cdk.validateString)(properties.sourceCidrBlock));
  errors.collect(cdk.propertyValidator("sourcePortRange", CfnTrafficMirrorFilterRuleTrafficMirrorPortRangePropertyValidator)(properties.sourcePortRange));
  errors.collect(cdk.propertyValidator("trafficDirection", cdk.requiredValidator)(properties.trafficDirection));
  errors.collect(cdk.propertyValidator("trafficDirection", cdk.validateString)(properties.trafficDirection));
  errors.collect(cdk.propertyValidator("trafficMirrorFilterId", cdk.requiredValidator)(properties.trafficMirrorFilterId));
  errors.collect(cdk.propertyValidator("trafficMirrorFilterId", cdk.validateString)(properties.trafficMirrorFilterId));
  return errors.wrap("supplied properties not correct for \"CfnTrafficMirrorFilterRuleProps\"");
}

// @ts-ignore TS6133
function convertCfnTrafficMirrorFilterRulePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTrafficMirrorFilterRulePropsValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "DestinationCidrBlock": cdk.stringToCloudFormation(properties.destinationCidrBlock),
    "DestinationPortRange": convertCfnTrafficMirrorFilterRuleTrafficMirrorPortRangePropertyToCloudFormation(properties.destinationPortRange),
    "Protocol": cdk.numberToCloudFormation(properties.protocol),
    "RuleAction": cdk.stringToCloudFormation(properties.ruleAction),
    "RuleNumber": cdk.numberToCloudFormation(properties.ruleNumber),
    "SourceCidrBlock": cdk.stringToCloudFormation(properties.sourceCidrBlock),
    "SourcePortRange": convertCfnTrafficMirrorFilterRuleTrafficMirrorPortRangePropertyToCloudFormation(properties.sourcePortRange),
    "TrafficDirection": cdk.stringToCloudFormation(properties.trafficDirection),
    "TrafficMirrorFilterId": cdk.stringToCloudFormation(properties.trafficMirrorFilterId)
  };
}

// @ts-ignore TS6133
function CfnTrafficMirrorFilterRulePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnTrafficMirrorFilterRuleProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTrafficMirrorFilterRuleProps>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("destinationCidrBlock", "DestinationCidrBlock", (properties.DestinationCidrBlock != null ? cfn_parse.FromCloudFormation.getString(properties.DestinationCidrBlock) : undefined));
  ret.addPropertyResult("destinationPortRange", "DestinationPortRange", (properties.DestinationPortRange != null ? CfnTrafficMirrorFilterRuleTrafficMirrorPortRangePropertyFromCloudFormation(properties.DestinationPortRange) : undefined));
  ret.addPropertyResult("protocol", "Protocol", (properties.Protocol != null ? cfn_parse.FromCloudFormation.getNumber(properties.Protocol) : undefined));
  ret.addPropertyResult("ruleAction", "RuleAction", (properties.RuleAction != null ? cfn_parse.FromCloudFormation.getString(properties.RuleAction) : undefined));
  ret.addPropertyResult("ruleNumber", "RuleNumber", (properties.RuleNumber != null ? cfn_parse.FromCloudFormation.getNumber(properties.RuleNumber) : undefined));
  ret.addPropertyResult("sourceCidrBlock", "SourceCidrBlock", (properties.SourceCidrBlock != null ? cfn_parse.FromCloudFormation.getString(properties.SourceCidrBlock) : undefined));
  ret.addPropertyResult("sourcePortRange", "SourcePortRange", (properties.SourcePortRange != null ? CfnTrafficMirrorFilterRuleTrafficMirrorPortRangePropertyFromCloudFormation(properties.SourcePortRange) : undefined));
  ret.addPropertyResult("trafficDirection", "TrafficDirection", (properties.TrafficDirection != null ? cfn_parse.FromCloudFormation.getString(properties.TrafficDirection) : undefined));
  ret.addPropertyResult("trafficMirrorFilterId", "TrafficMirrorFilterId", (properties.TrafficMirrorFilterId != null ? cfn_parse.FromCloudFormation.getString(properties.TrafficMirrorFilterId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Creates a Traffic Mirror session.
 *
 * A Traffic Mirror session actively copies packets from a Traffic Mirror source to a Traffic Mirror target. Create a filter, and then assign it to the session to define a subset of the traffic to mirror, for example all TCP traffic.
 *
 * The Traffic Mirror source and the Traffic Mirror target (monitoring appliances) can be in the same VPC, or in a different VPC connected via VPC peering or a transit gateway.
 *
 * By default, no traffic is mirrored. Use [AWS::EC2::TrafficMirrorFilterRule](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html) to specify filter rules that specify the traffic to mirror.
 *
 * @cloudformationResource AWS::EC2::TrafficMirrorSession
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html
 */
export class CfnTrafficMirrorSession extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::TrafficMirrorSession";

  /**
   * Build a CfnTrafficMirrorSession from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnTrafficMirrorSession {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnTrafficMirrorSessionPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnTrafficMirrorSession(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The description of the Traffic Mirror session.
   */
  public description?: string;

  /**
   * The ID of the source network interface.
   */
  public networkInterfaceId: string;

  /**
   * The number of bytes in each packet to mirror.
   */
  public packetLength?: number;

  /**
   * The session number determines the order in which sessions are evaluated when an interface is used by multiple sessions.
   */
  public sessionNumber: number;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags to assign to a Traffic Mirror session.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The ID of the Traffic Mirror filter.
   */
  public trafficMirrorFilterId: string;

  /**
   * The ID of the Traffic Mirror target.
   */
  public trafficMirrorTargetId: string;

  /**
   * The VXLAN ID for the Traffic Mirror session.
   */
  public virtualNetworkId?: number;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnTrafficMirrorSessionProps) {
    super(scope, id, {
      "type": CfnTrafficMirrorSession.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "networkInterfaceId", this);
    cdk.requireProperty(props, "sessionNumber", this);
    cdk.requireProperty(props, "trafficMirrorFilterId", this);
    cdk.requireProperty(props, "trafficMirrorTargetId", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.description = props.description;
    this.networkInterfaceId = props.networkInterfaceId;
    this.packetLength = props.packetLength;
    this.sessionNumber = props.sessionNumber;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::TrafficMirrorSession", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.trafficMirrorFilterId = props.trafficMirrorFilterId;
    this.trafficMirrorTargetId = props.trafficMirrorTargetId;
    this.virtualNetworkId = props.virtualNetworkId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "description": this.description,
      "networkInterfaceId": this.networkInterfaceId,
      "packetLength": this.packetLength,
      "sessionNumber": this.sessionNumber,
      "tags": this.tags.renderTags(),
      "trafficMirrorFilterId": this.trafficMirrorFilterId,
      "trafficMirrorTargetId": this.trafficMirrorTargetId,
      "virtualNetworkId": this.virtualNetworkId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnTrafficMirrorSession.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnTrafficMirrorSessionPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a `CfnTrafficMirrorSession`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html
 */
export interface CfnTrafficMirrorSessionProps {
  /**
   * The description of the Traffic Mirror session.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html#cfn-ec2-trafficmirrorsession-description
   */
  readonly description?: string;

  /**
   * The ID of the source network interface.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html#cfn-ec2-trafficmirrorsession-networkinterfaceid
   */
  readonly networkInterfaceId: string;

  /**
   * The number of bytes in each packet to mirror.
   *
   * These are bytes after the VXLAN header. Do not specify this parameter when you want to mirror the entire packet. To mirror a subset of the packet, set this to the length (in bytes) that you want to mirror. For example, if you set this value to 100, then the first 100 bytes that meet the filter criteria are copied to the target.
   *
   * If you do not want to mirror the entire packet, use the `PacketLength` parameter to specify the number of bytes in each packet to mirror.
   *
   * For sessions with Network Load Balancer (NLB) Traffic Mirror targets the default `PacketLength` will be set to 8500. Valid values are 1-8500. Setting a `PacketLength` greater than 8500 will result in an error response.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html#cfn-ec2-trafficmirrorsession-packetlength
   */
  readonly packetLength?: number;

  /**
   * The session number determines the order in which sessions are evaluated when an interface is used by multiple sessions.
   *
   * The first session with a matching filter is the one that mirrors the packets.
   *
   * Valid values are 1-32766.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html#cfn-ec2-trafficmirrorsession-sessionnumber
   */
  readonly sessionNumber: number;

  /**
   * The tags to assign to a Traffic Mirror session.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html#cfn-ec2-trafficmirrorsession-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The ID of the Traffic Mirror filter.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html#cfn-ec2-trafficmirrorsession-trafficmirrorfilterid
   */
  readonly trafficMirrorFilterId: string;

  /**
   * The ID of the Traffic Mirror target.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html#cfn-ec2-trafficmirrorsession-trafficmirrortargetid
   */
  readonly trafficMirrorTargetId: string;

  /**
   * The VXLAN ID for the Traffic Mirror session.
   *
   * For more information about the VXLAN protocol, see [RFC 7348](https://docs.aws.amazon.com/https://tools.ietf.org/html/rfc7348) . If you do not specify a `VirtualNetworkId` , an account-wide unique id is chosen at random.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html#cfn-ec2-trafficmirrorsession-virtualnetworkid
   */
  readonly virtualNetworkId?: number;
}

/**
 * Determine whether the given properties match those of a `CfnTrafficMirrorSessionProps`
 *
 * @param properties - the TypeScript properties of a `CfnTrafficMirrorSessionProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTrafficMirrorSessionPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("networkInterfaceId", cdk.requiredValidator)(properties.networkInterfaceId));
  errors.collect(cdk.propertyValidator("networkInterfaceId", cdk.validateString)(properties.networkInterfaceId));
  errors.collect(cdk.propertyValidator("packetLength", cdk.validateNumber)(properties.packetLength));
  errors.collect(cdk.propertyValidator("sessionNumber", cdk.requiredValidator)(properties.sessionNumber));
  errors.collect(cdk.propertyValidator("sessionNumber", cdk.validateNumber)(properties.sessionNumber));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("trafficMirrorFilterId", cdk.requiredValidator)(properties.trafficMirrorFilterId));
  errors.collect(cdk.propertyValidator("trafficMirrorFilterId", cdk.validateString)(properties.trafficMirrorFilterId));
  errors.collect(cdk.propertyValidator("trafficMirrorTargetId", cdk.requiredValidator)(properties.trafficMirrorTargetId));
  errors.collect(cdk.propertyValidator("trafficMirrorTargetId", cdk.validateString)(properties.trafficMirrorTargetId));
  errors.collect(cdk.propertyValidator("virtualNetworkId", cdk.validateNumber)(properties.virtualNetworkId));
  return errors.wrap("supplied properties not correct for \"CfnTrafficMirrorSessionProps\"");
}

// @ts-ignore TS6133
function convertCfnTrafficMirrorSessionPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTrafficMirrorSessionPropsValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "NetworkInterfaceId": cdk.stringToCloudFormation(properties.networkInterfaceId),
    "PacketLength": cdk.numberToCloudFormation(properties.packetLength),
    "SessionNumber": cdk.numberToCloudFormation(properties.sessionNumber),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "TrafficMirrorFilterId": cdk.stringToCloudFormation(properties.trafficMirrorFilterId),
    "TrafficMirrorTargetId": cdk.stringToCloudFormation(properties.trafficMirrorTargetId),
    "VirtualNetworkId": cdk.numberToCloudFormation(properties.virtualNetworkId)
  };
}

// @ts-ignore TS6133
function CfnTrafficMirrorSessionPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnTrafficMirrorSessionProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTrafficMirrorSessionProps>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("networkInterfaceId", "NetworkInterfaceId", (properties.NetworkInterfaceId != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkInterfaceId) : undefined));
  ret.addPropertyResult("packetLength", "PacketLength", (properties.PacketLength != null ? cfn_parse.FromCloudFormation.getNumber(properties.PacketLength) : undefined));
  ret.addPropertyResult("sessionNumber", "SessionNumber", (properties.SessionNumber != null ? cfn_parse.FromCloudFormation.getNumber(properties.SessionNumber) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("trafficMirrorFilterId", "TrafficMirrorFilterId", (properties.TrafficMirrorFilterId != null ? cfn_parse.FromCloudFormation.getString(properties.TrafficMirrorFilterId) : undefined));
  ret.addPropertyResult("trafficMirrorTargetId", "TrafficMirrorTargetId", (properties.TrafficMirrorTargetId != null ? cfn_parse.FromCloudFormation.getString(properties.TrafficMirrorTargetId) : undefined));
  ret.addPropertyResult("virtualNetworkId", "VirtualNetworkId", (properties.VirtualNetworkId != null ? cfn_parse.FromCloudFormation.getNumber(properties.VirtualNetworkId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a target for your Traffic Mirror session.
 *
 * A Traffic Mirror target is the destination for mirrored traffic. The Traffic Mirror source and the Traffic Mirror target (monitoring appliances) can be in the same VPC, or in different VPCs connected via VPC peering or a transit gateway.
 *
 * A Traffic Mirror target can be a network interface, a Network Load Balancer, or a Gateway Load Balancer endpoint.
 *
 * To use the target in a Traffic Mirror session, use [AWS::EC2::TrafficMirrorSession](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html) .
 *
 * @cloudformationResource AWS::EC2::TrafficMirrorTarget
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrortarget.html
 */
export class CfnTrafficMirrorTarget extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::TrafficMirrorTarget";

  /**
   * Build a CfnTrafficMirrorTarget from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnTrafficMirrorTarget {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnTrafficMirrorTargetPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnTrafficMirrorTarget(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The description of the Traffic Mirror target.
   */
  public description?: string;

  /**
   * The ID of the Gateway Load Balancer endpoint.
   */
  public gatewayLoadBalancerEndpointId?: string;

  /**
   * The network interface ID that is associated with the target.
   */
  public networkInterfaceId?: string;

  /**
   * The Amazon Resource Name (ARN) of the Network Load Balancer that is associated with the target.
   */
  public networkLoadBalancerArn?: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags to assign to the Traffic Mirror target.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnTrafficMirrorTargetProps = {}) {
    super(scope, id, {
      "type": CfnTrafficMirrorTarget.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.description = props.description;
    this.gatewayLoadBalancerEndpointId = props.gatewayLoadBalancerEndpointId;
    this.networkInterfaceId = props.networkInterfaceId;
    this.networkLoadBalancerArn = props.networkLoadBalancerArn;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::TrafficMirrorTarget", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "description": this.description,
      "gatewayLoadBalancerEndpointId": this.gatewayLoadBalancerEndpointId,
      "networkInterfaceId": this.networkInterfaceId,
      "networkLoadBalancerArn": this.networkLoadBalancerArn,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnTrafficMirrorTarget.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnTrafficMirrorTargetPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a `CfnTrafficMirrorTarget`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrortarget.html
 */
export interface CfnTrafficMirrorTargetProps {
  /**
   * The description of the Traffic Mirror target.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrortarget.html#cfn-ec2-trafficmirrortarget-description
   */
  readonly description?: string;

  /**
   * The ID of the Gateway Load Balancer endpoint.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrortarget.html#cfn-ec2-trafficmirrortarget-gatewayloadbalancerendpointid
   */
  readonly gatewayLoadBalancerEndpointId?: string;

  /**
   * The network interface ID that is associated with the target.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrortarget.html#cfn-ec2-trafficmirrortarget-networkinterfaceid
   */
  readonly networkInterfaceId?: string;

  /**
   * The Amazon Resource Name (ARN) of the Network Load Balancer that is associated with the target.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrortarget.html#cfn-ec2-trafficmirrortarget-networkloadbalancerarn
   */
  readonly networkLoadBalancerArn?: string;

  /**
   * The tags to assign to the Traffic Mirror target.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrortarget.html#cfn-ec2-trafficmirrortarget-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a `CfnTrafficMirrorTargetProps`
 *
 * @param properties - the TypeScript properties of a `CfnTrafficMirrorTargetProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTrafficMirrorTargetPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("gatewayLoadBalancerEndpointId", cdk.validateString)(properties.gatewayLoadBalancerEndpointId));
  errors.collect(cdk.propertyValidator("networkInterfaceId", cdk.validateString)(properties.networkInterfaceId));
  errors.collect(cdk.propertyValidator("networkLoadBalancerArn", cdk.validateString)(properties.networkLoadBalancerArn));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \"CfnTrafficMirrorTargetProps\"");
}

// @ts-ignore TS6133
function convertCfnTrafficMirrorTargetPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTrafficMirrorTargetPropsValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "GatewayLoadBalancerEndpointId": cdk.stringToCloudFormation(properties.gatewayLoadBalancerEndpointId),
    "NetworkInterfaceId": cdk.stringToCloudFormation(properties.networkInterfaceId),
    "NetworkLoadBalancerArn": cdk.stringToCloudFormation(properties.networkLoadBalancerArn),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnTrafficMirrorTargetPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnTrafficMirrorTargetProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTrafficMirrorTargetProps>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("gatewayLoadBalancerEndpointId", "GatewayLoadBalancerEndpointId", (properties.GatewayLoadBalancerEndpointId != null ? cfn_parse.FromCloudFormation.getString(properties.GatewayLoadBalancerEndpointId) : undefined));
  ret.addPropertyResult("networkInterfaceId", "NetworkInterfaceId", (properties.NetworkInterfaceId != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkInterfaceId) : undefined));
  ret.addPropertyResult("networkLoadBalancerArn", "NetworkLoadBalancerArn", (properties.NetworkLoadBalancerArn != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkLoadBalancerArn) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a transit gateway.
 *
 * You can use a transit gateway to interconnect your virtual private clouds (VPC) and on-premises networks. After the transit gateway enters the `available` state, you can attach your VPCs and VPN connections to the transit gateway.
 *
 * To attach your VPCs, use [AWS::EC2::TransitGatewayAttachment](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayattachment.html) .
 *
 * To attach a VPN connection, use [AWS::EC2::CustomerGateway](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customer-gateway.html) to create a customer gateway and specify the ID of the customer gateway and the ID of the transit gateway in a call to [AWS::EC2::VPNConnection](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpn-connection.html) .
 *
 * When you create a transit gateway, we create a default transit gateway route table and use it as the default association route table and the default propagation route table. You can use [AWS::EC2::TransitGatewayRouteTable](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetable.html) to create additional transit gateway route tables. If you disable automatic route propagation, we do not create a default transit gateway route table. You can use [AWS::EC2::TransitGatewayRouteTablePropagation](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetablepropagation.html) to propagate routes from a resource attachment to a transit gateway route table. If you disable automatic associations, you can use [AWS::EC2::TransitGatewayRouteTableAssociation](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetableassociation.html) to associate a resource attachment with a transit gateway route table.
 *
 * @cloudformationResource AWS::EC2::TransitGateway
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html
 */
export class CfnTransitGateway extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::TransitGateway";

  /**
   * Build a CfnTransitGateway from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnTransitGateway {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnTransitGatewayPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnTransitGateway(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the transit gateway.
   *
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * @cloudformationAttribute TransitGatewayArn
   */
  public readonly attrTransitGatewayArn: string;

  /**
   * A private Autonomous System Number (ASN) for the Amazon side of a BGP session.
   */
  public amazonSideAsn?: number;

  /**
   * The ID of the default association route table.
   */
  public associationDefaultRouteTableId?: string;

  /**
   * Enable or disable automatic acceptance of attachment requests.
   */
  public autoAcceptSharedAttachments?: string;

  /**
   * Enable or disable automatic association with the default association route table.
   */
  public defaultRouteTableAssociation?: string;

  /**
   * Enable or disable automatic propagation of routes to the default propagation route table.
   */
  public defaultRouteTablePropagation?: string;

  /**
   * The description of the transit gateway.
   */
  public description?: string;

  /**
   * Enable or disable DNS support.
   */
  public dnsSupport?: string;

  /**
   * Indicates whether multicast is enabled on the transit gateway.
   */
  public multicastSupport?: string;

  /**
   * The ID of the default propagation route table.
   */
  public propagationDefaultRouteTableId?: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags for the transit gateway.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The transit gateway CIDR blocks.
   */
  public transitGatewayCidrBlocks?: Array<string>;

  /**
   * Enable or disable Equal Cost Multipath Protocol support.
   */
  public vpnEcmpSupport?: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnTransitGatewayProps = {}) {
    super(scope, id, {
      "type": CfnTransitGateway.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.attrTransitGatewayArn = cdk.Token.asString(this.getAtt("TransitGatewayArn", cdk.ResolutionTypeHint.STRING));
    this.amazonSideAsn = props.amazonSideAsn;
    this.associationDefaultRouteTableId = props.associationDefaultRouteTableId;
    this.autoAcceptSharedAttachments = props.autoAcceptSharedAttachments;
    this.defaultRouteTableAssociation = props.defaultRouteTableAssociation;
    this.defaultRouteTablePropagation = props.defaultRouteTablePropagation;
    this.description = props.description;
    this.dnsSupport = props.dnsSupport;
    this.multicastSupport = props.multicastSupport;
    this.propagationDefaultRouteTableId = props.propagationDefaultRouteTableId;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::TransitGateway", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.transitGatewayCidrBlocks = props.transitGatewayCidrBlocks;
    this.vpnEcmpSupport = props.vpnEcmpSupport;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "amazonSideAsn": this.amazonSideAsn,
      "associationDefaultRouteTableId": this.associationDefaultRouteTableId,
      "autoAcceptSharedAttachments": this.autoAcceptSharedAttachments,
      "defaultRouteTableAssociation": this.defaultRouteTableAssociation,
      "defaultRouteTablePropagation": this.defaultRouteTablePropagation,
      "description": this.description,
      "dnsSupport": this.dnsSupport,
      "multicastSupport": this.multicastSupport,
      "propagationDefaultRouteTableId": this.propagationDefaultRouteTableId,
      "tags": this.tags.renderTags(),
      "transitGatewayCidrBlocks": this.transitGatewayCidrBlocks,
      "vpnEcmpSupport": this.vpnEcmpSupport
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnTransitGateway.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnTransitGatewayPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a `CfnTransitGateway`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html
 */
export interface CfnTransitGatewayProps {
  /**
   * A private Autonomous System Number (ASN) for the Amazon side of a BGP session.
   *
   * The range is 64512 to 65534 for 16-bit ASNs. The default is 64512.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-amazonsideasn
   */
  readonly amazonSideAsn?: number;

  /**
   * The ID of the default association route table.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-associationdefaultroutetableid
   */
  readonly associationDefaultRouteTableId?: string;

  /**
   * Enable or disable automatic acceptance of attachment requests.
   *
   * Disabled by default.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-autoacceptsharedattachments
   */
  readonly autoAcceptSharedAttachments?: string;

  /**
   * Enable or disable automatic association with the default association route table.
   *
   * Enabled by default.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-defaultroutetableassociation
   */
  readonly defaultRouteTableAssociation?: string;

  /**
   * Enable or disable automatic propagation of routes to the default propagation route table.
   *
   * Enabled by default.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-defaultroutetablepropagation
   */
  readonly defaultRouteTablePropagation?: string;

  /**
   * The description of the transit gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-description
   */
  readonly description?: string;

  /**
   * Enable or disable DNS support.
   *
   * Enabled by default.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-dnssupport
   */
  readonly dnsSupport?: string;

  /**
   * Indicates whether multicast is enabled on the transit gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-multicastsupport
   */
  readonly multicastSupport?: string;

  /**
   * The ID of the default propagation route table.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-propagationdefaultroutetableid
   */
  readonly propagationDefaultRouteTableId?: string;

  /**
   * The tags for the transit gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The transit gateway CIDR blocks.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-transitgatewaycidrblocks
   */
  readonly transitGatewayCidrBlocks?: Array<string>;

  /**
   * Enable or disable Equal Cost Multipath Protocol support.
   *
   * Enabled by default.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-vpnecmpsupport
   */
  readonly vpnEcmpSupport?: string;
}

/**
 * Determine whether the given properties match those of a `CfnTransitGatewayProps`
 *
 * @param properties - the TypeScript properties of a `CfnTransitGatewayProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTransitGatewayPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("amazonSideAsn", cdk.validateNumber)(properties.amazonSideAsn));
  errors.collect(cdk.propertyValidator("associationDefaultRouteTableId", cdk.validateString)(properties.associationDefaultRouteTableId));
  errors.collect(cdk.propertyValidator("autoAcceptSharedAttachments", cdk.validateString)(properties.autoAcceptSharedAttachments));
  errors.collect(cdk.propertyValidator("defaultRouteTableAssociation", cdk.validateString)(properties.defaultRouteTableAssociation));
  errors.collect(cdk.propertyValidator("defaultRouteTablePropagation", cdk.validateString)(properties.defaultRouteTablePropagation));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("dnsSupport", cdk.validateString)(properties.dnsSupport));
  errors.collect(cdk.propertyValidator("multicastSupport", cdk.validateString)(properties.multicastSupport));
  errors.collect(cdk.propertyValidator("propagationDefaultRouteTableId", cdk.validateString)(properties.propagationDefaultRouteTableId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("transitGatewayCidrBlocks", cdk.listValidator(cdk.validateString))(properties.transitGatewayCidrBlocks));
  errors.collect(cdk.propertyValidator("vpnEcmpSupport", cdk.validateString)(properties.vpnEcmpSupport));
  return errors.wrap("supplied properties not correct for \"CfnTransitGatewayProps\"");
}

// @ts-ignore TS6133
function convertCfnTransitGatewayPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTransitGatewayPropsValidator(properties).assertSuccess();
  return {
    "AmazonSideAsn": cdk.numberToCloudFormation(properties.amazonSideAsn),
    "AssociationDefaultRouteTableId": cdk.stringToCloudFormation(properties.associationDefaultRouteTableId),
    "AutoAcceptSharedAttachments": cdk.stringToCloudFormation(properties.autoAcceptSharedAttachments),
    "DefaultRouteTableAssociation": cdk.stringToCloudFormation(properties.defaultRouteTableAssociation),
    "DefaultRouteTablePropagation": cdk.stringToCloudFormation(properties.defaultRouteTablePropagation),
    "Description": cdk.stringToCloudFormation(properties.description),
    "DnsSupport": cdk.stringToCloudFormation(properties.dnsSupport),
    "MulticastSupport": cdk.stringToCloudFormation(properties.multicastSupport),
    "PropagationDefaultRouteTableId": cdk.stringToCloudFormation(properties.propagationDefaultRouteTableId),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "TransitGatewayCidrBlocks": cdk.listMapper(cdk.stringToCloudFormation)(properties.transitGatewayCidrBlocks),
    "VpnEcmpSupport": cdk.stringToCloudFormation(properties.vpnEcmpSupport)
  };
}

// @ts-ignore TS6133
function CfnTransitGatewayPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnTransitGatewayProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTransitGatewayProps>();
  ret.addPropertyResult("amazonSideAsn", "AmazonSideAsn", (properties.AmazonSideAsn != null ? cfn_parse.FromCloudFormation.getNumber(properties.AmazonSideAsn) : undefined));
  ret.addPropertyResult("associationDefaultRouteTableId", "AssociationDefaultRouteTableId", (properties.AssociationDefaultRouteTableId != null ? cfn_parse.FromCloudFormation.getString(properties.AssociationDefaultRouteTableId) : undefined));
  ret.addPropertyResult("autoAcceptSharedAttachments", "AutoAcceptSharedAttachments", (properties.AutoAcceptSharedAttachments != null ? cfn_parse.FromCloudFormation.getString(properties.AutoAcceptSharedAttachments) : undefined));
  ret.addPropertyResult("defaultRouteTableAssociation", "DefaultRouteTableAssociation", (properties.DefaultRouteTableAssociation != null ? cfn_parse.FromCloudFormation.getString(properties.DefaultRouteTableAssociation) : undefined));
  ret.addPropertyResult("defaultRouteTablePropagation", "DefaultRouteTablePropagation", (properties.DefaultRouteTablePropagation != null ? cfn_parse.FromCloudFormation.getString(properties.DefaultRouteTablePropagation) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("dnsSupport", "DnsSupport", (properties.DnsSupport != null ? cfn_parse.FromCloudFormation.getString(properties.DnsSupport) : undefined));
  ret.addPropertyResult("multicastSupport", "MulticastSupport", (properties.MulticastSupport != null ? cfn_parse.FromCloudFormation.getString(properties.MulticastSupport) : undefined));
  ret.addPropertyResult("propagationDefaultRouteTableId", "PropagationDefaultRouteTableId", (properties.PropagationDefaultRouteTableId != null ? cfn_parse.FromCloudFormation.getString(properties.PropagationDefaultRouteTableId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("transitGatewayCidrBlocks", "TransitGatewayCidrBlocks", (properties.TransitGatewayCidrBlocks != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.TransitGatewayCidrBlocks) : undefined));
  ret.addPropertyResult("vpnEcmpSupport", "VpnEcmpSupport", (properties.VpnEcmpSupport != null ? cfn_parse.FromCloudFormation.getString(properties.VpnEcmpSupport) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Attaches a VPC to a transit gateway.
 *
 * If you attach a VPC with a CIDR range that overlaps the CIDR range of a VPC that is already attached, the new VPC CIDR range is not propagated to the default propagation route table.
 *
 * To send VPC traffic to an attached transit gateway, add a route to the VPC route table using [AWS::EC2::Route](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html) .
 *
 * To update tags for a VPC attachment after creation without replacing the attachment, use [AWS::EC2::TransitGatewayVpcAttachment](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html) instead.
 *
 * @cloudformationResource AWS::EC2::TransitGatewayAttachment
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayattachment.html
 */
export class CfnTransitGatewayAttachment extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::TransitGatewayAttachment";

  /**
   * Build a CfnTransitGatewayAttachment from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnTransitGatewayAttachment {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnTransitGatewayAttachmentPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnTransitGatewayAttachment(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the attachment.
   *
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The VPC attachment options.
   */
  public options?: any | cdk.IResolvable;

  /**
   * The IDs of one or more subnets.
   */
  public subnetIds: Array<string>;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags for the attachment.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The ID of the transit gateway.
   */
  public transitGatewayId: string;

  /**
   * The ID of the VPC.
   */
  public vpcId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnTransitGatewayAttachmentProps) {
    super(scope, id, {
      "type": CfnTransitGatewayAttachment.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "subnetIds", this);
    cdk.requireProperty(props, "transitGatewayId", this);
    cdk.requireProperty(props, "vpcId", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.options = props.options;
    this.subnetIds = props.subnetIds;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::TransitGatewayAttachment", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.transitGatewayId = props.transitGatewayId;
    this.vpcId = props.vpcId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "options": this.options,
      "subnetIds": this.subnetIds,
      "tags": this.tags.renderTags(),
      "transitGatewayId": this.transitGatewayId,
      "vpcId": this.vpcId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnTransitGatewayAttachment.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnTransitGatewayAttachmentPropsToCloudFormation(props);
  }
}

export namespace CfnTransitGatewayAttachment {
  /**
   * Describes the VPC attachment options.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayattachment-options.html
   */
  export interface OptionsProperty {
    /**
     * Enable or disable appliance mode support.
     *
     * The default is `disable` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayattachment-options.html#cfn-ec2-transitgatewayattachment-options-appliancemodesupport
     */
    readonly applianceModeSupport?: string;

    /**
     * Enable or disable DNS support.
     *
     * The default is `disable` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayattachment-options.html#cfn-ec2-transitgatewayattachment-options-dnssupport
     */
    readonly dnsSupport?: string;

    /**
     * Enable or disable IPv6 support.
     *
     * The default is `disable` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayattachment-options.html#cfn-ec2-transitgatewayattachment-options-ipv6support
     */
    readonly ipv6Support?: string;

    /**
     * Enables you to reference a security group across VPCs attached to a transit gateway (TGW).
     *
     * Use this option to simplify security group management and control of instance-to-instance traffic across VPCs that are connected by transit gateway. You can also use this option to migrate from VPC peering (which was the only option that supported security group referencing) to transit gateways (which now also support security group referencing). This option is disabled by default and there are no additional costs to use this feature.
     *
     * For important information about this feature, see [Create a transit gateway](https://docs.aws.amazon.com/vpc/latest/tgw/tgw-transit-gateways.html#create-tgw) in the *AWS Transit Gateway Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayattachment-options.html#cfn-ec2-transitgatewayattachment-options-securitygroupreferencingsupport
     */
    readonly securityGroupReferencingSupport?: string;
  }
}

/**
 * Properties for defining a `CfnTransitGatewayAttachment`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayattachment.html
 */
export interface CfnTransitGatewayAttachmentProps {
  /**
   * The VPC attachment options.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayattachment.html#cfn-ec2-transitgatewayattachment-options
   */
  readonly options?: any | cdk.IResolvable;

  /**
   * The IDs of one or more subnets.
   *
   * You can specify only one subnet per Availability Zone. You must specify at least one subnet, but we recommend that you specify two subnets for better availability. The transit gateway uses one IP address from each specified subnet.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayattachment.html#cfn-ec2-transitgatewayattachment-subnetids
   */
  readonly subnetIds: Array<string>;

  /**
   * The tags for the attachment.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayattachment.html#cfn-ec2-transitgatewayattachment-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The ID of the transit gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayattachment.html#cfn-ec2-transitgatewayattachment-transitgatewayid
   */
  readonly transitGatewayId: string;

  /**
   * The ID of the VPC.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayattachment.html#cfn-ec2-transitgatewayattachment-vpcid
   */
  readonly vpcId: string;
}

/**
 * Determine whether the given properties match those of a `OptionsProperty`
 *
 * @param properties - the TypeScript properties of a `OptionsProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTransitGatewayAttachmentOptionsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("applianceModeSupport", cdk.validateString)(properties.applianceModeSupport));
  errors.collect(cdk.propertyValidator("dnsSupport", cdk.validateString)(properties.dnsSupport));
  errors.collect(cdk.propertyValidator("ipv6Support", cdk.validateString)(properties.ipv6Support));
  errors.collect(cdk.propertyValidator("securityGroupReferencingSupport", cdk.validateString)(properties.securityGroupReferencingSupport));
  return errors.wrap("supplied properties not correct for \"OptionsProperty\"");
}

// @ts-ignore TS6133
function convertCfnTransitGatewayAttachmentOptionsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTransitGatewayAttachmentOptionsPropertyValidator(properties).assertSuccess();
  return {
    "ApplianceModeSupport": cdk.stringToCloudFormation(properties.applianceModeSupport),
    "DnsSupport": cdk.stringToCloudFormation(properties.dnsSupport),
    "Ipv6Support": cdk.stringToCloudFormation(properties.ipv6Support),
    "SecurityGroupReferencingSupport": cdk.stringToCloudFormation(properties.securityGroupReferencingSupport)
  };
}

// @ts-ignore TS6133
function CfnTransitGatewayAttachmentOptionsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnTransitGatewayAttachment.OptionsProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTransitGatewayAttachment.OptionsProperty>();
  ret.addPropertyResult("applianceModeSupport", "ApplianceModeSupport", (properties.ApplianceModeSupport != null ? cfn_parse.FromCloudFormation.getString(properties.ApplianceModeSupport) : undefined));
  ret.addPropertyResult("dnsSupport", "DnsSupport", (properties.DnsSupport != null ? cfn_parse.FromCloudFormation.getString(properties.DnsSupport) : undefined));
  ret.addPropertyResult("ipv6Support", "Ipv6Support", (properties.Ipv6Support != null ? cfn_parse.FromCloudFormation.getString(properties.Ipv6Support) : undefined));
  ret.addPropertyResult("securityGroupReferencingSupport", "SecurityGroupReferencingSupport", (properties.SecurityGroupReferencingSupport != null ? cfn_parse.FromCloudFormation.getString(properties.SecurityGroupReferencingSupport) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `CfnTransitGatewayAttachmentProps`
 *
 * @param properties - the TypeScript properties of a `CfnTransitGatewayAttachmentProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTransitGatewayAttachmentPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("options", cdk.validateObject)(properties.options));
  errors.collect(cdk.propertyValidator("subnetIds", cdk.requiredValidator)(properties.subnetIds));
  errors.collect(cdk.propertyValidator("subnetIds", cdk.listValidator(cdk.validateString))(properties.subnetIds));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("transitGatewayId", cdk.requiredValidator)(properties.transitGatewayId));
  errors.collect(cdk.propertyValidator("transitGatewayId", cdk.validateString)(properties.transitGatewayId));
  errors.collect(cdk.propertyValidator("vpcId", cdk.requiredValidator)(properties.vpcId));
  errors.collect(cdk.propertyValidator("vpcId", cdk.validateString)(properties.vpcId));
  return errors.wrap("supplied properties not correct for \"CfnTransitGatewayAttachmentProps\"");
}

// @ts-ignore TS6133
function convertCfnTransitGatewayAttachmentPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTransitGatewayAttachmentPropsValidator(properties).assertSuccess();
  return {
    "Options": cdk.objectToCloudFormation(properties.options),
    "SubnetIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.subnetIds),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "TransitGatewayId": cdk.stringToCloudFormation(properties.transitGatewayId),
    "VpcId": cdk.stringToCloudFormation(properties.vpcId)
  };
}

// @ts-ignore TS6133
function CfnTransitGatewayAttachmentPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnTransitGatewayAttachmentProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTransitGatewayAttachmentProps>();
  ret.addPropertyResult("options", "Options", (properties.Options != null ? cfn_parse.FromCloudFormation.getAny(properties.Options) : undefined));
  ret.addPropertyResult("subnetIds", "SubnetIds", (properties.SubnetIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SubnetIds) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("transitGatewayId", "TransitGatewayId", (properties.TransitGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.TransitGatewayId) : undefined));
  ret.addPropertyResult("vpcId", "VpcId", (properties.VpcId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Creates a Connect attachment from a specified transit gateway attachment.
 *
 * A Connect attachment is a GRE-based tunnel attachment that you can use to establish a connection between a transit gateway and an appliance.
 *
 * A Connect attachment uses an existing VPC or AWS Direct Connect attachment as the underlying transport mechanism.
 *
 * @cloudformationResource AWS::EC2::TransitGatewayConnect
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayconnect.html
 */
export class CfnTransitGatewayConnect extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::TransitGatewayConnect";

  /**
   * Build a CfnTransitGatewayConnect from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnTransitGatewayConnect {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnTransitGatewayConnectPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnTransitGatewayConnect(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The creation time.
   *
   * @cloudformationAttribute CreationTime
   */
  public readonly attrCreationTime: string;

  /**
   * The state of the attachment.
   *
   * @cloudformationAttribute State
   */
  public readonly attrState: string;

  /**
   * The ID of the transit gateway attachment.
   *
   * @cloudformationAttribute TransitGatewayAttachmentId
   */
  public readonly attrTransitGatewayAttachmentId: string;

  /**
   * The ID of the transit gateway.
   *
   * @cloudformationAttribute TransitGatewayId
   */
  public readonly attrTransitGatewayId: string;

  /**
   * The Connect attachment options.
   */
  public options: cdk.IResolvable | CfnTransitGatewayConnect.TransitGatewayConnectOptionsProperty;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags for the attachment.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The ID of the attachment from which the Connect attachment was created.
   */
  public transportTransitGatewayAttachmentId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnTransitGatewayConnectProps) {
    super(scope, id, {
      "type": CfnTransitGatewayConnect.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "options", this);
    cdk.requireProperty(props, "transportTransitGatewayAttachmentId", this);

    this.attrCreationTime = cdk.Token.asString(this.getAtt("CreationTime", cdk.ResolutionTypeHint.STRING));
    this.attrState = cdk.Token.asString(this.getAtt("State", cdk.ResolutionTypeHint.STRING));
    this.attrTransitGatewayAttachmentId = cdk.Token.asString(this.getAtt("TransitGatewayAttachmentId", cdk.ResolutionTypeHint.STRING));
    this.attrTransitGatewayId = cdk.Token.asString(this.getAtt("TransitGatewayId", cdk.ResolutionTypeHint.STRING));
    this.options = props.options;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::TransitGatewayConnect", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.transportTransitGatewayAttachmentId = props.transportTransitGatewayAttachmentId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "options": this.options,
      "tags": this.tags.renderTags(),
      "transportTransitGatewayAttachmentId": this.transportTransitGatewayAttachmentId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnTransitGatewayConnect.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnTransitGatewayConnectPropsToCloudFormation(props);
  }
}

export namespace CfnTransitGatewayConnect {
  /**
   * Describes the Connect attachment options.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayconnect-transitgatewayconnectoptions.html
   */
  export interface TransitGatewayConnectOptionsProperty {
    /**
     * The tunnel protocol.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayconnect-transitgatewayconnectoptions.html#cfn-ec2-transitgatewayconnect-transitgatewayconnectoptions-protocol
     */
    readonly protocol?: string;
  }
}

/**
 * Properties for defining a `CfnTransitGatewayConnect`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayconnect.html
 */
export interface CfnTransitGatewayConnectProps {
  /**
   * The Connect attachment options.
   *
   * - protocol (gre)
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayconnect.html#cfn-ec2-transitgatewayconnect-options
   */
  readonly options: cdk.IResolvable | CfnTransitGatewayConnect.TransitGatewayConnectOptionsProperty;

  /**
   * The tags for the attachment.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayconnect.html#cfn-ec2-transitgatewayconnect-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The ID of the attachment from which the Connect attachment was created.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayconnect.html#cfn-ec2-transitgatewayconnect-transporttransitgatewayattachmentid
   */
  readonly transportTransitGatewayAttachmentId: string;
}

/**
 * Determine whether the given properties match those of a `TransitGatewayConnectOptionsProperty`
 *
 * @param properties - the TypeScript properties of a `TransitGatewayConnectOptionsProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTransitGatewayConnectTransitGatewayConnectOptionsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("protocol", cdk.validateString)(properties.protocol));
  return errors.wrap("supplied properties not correct for \"TransitGatewayConnectOptionsProperty\"");
}

// @ts-ignore TS6133
function convertCfnTransitGatewayConnectTransitGatewayConnectOptionsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTransitGatewayConnectTransitGatewayConnectOptionsPropertyValidator(properties).assertSuccess();
  return {
    "Protocol": cdk.stringToCloudFormation(properties.protocol)
  };
}

// @ts-ignore TS6133
function CfnTransitGatewayConnectTransitGatewayConnectOptionsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnTransitGatewayConnect.TransitGatewayConnectOptionsProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTransitGatewayConnect.TransitGatewayConnectOptionsProperty>();
  ret.addPropertyResult("protocol", "Protocol", (properties.Protocol != null ? cfn_parse.FromCloudFormation.getString(properties.Protocol) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `CfnTransitGatewayConnectProps`
 *
 * @param properties - the TypeScript properties of a `CfnTransitGatewayConnectProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTransitGatewayConnectPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("options", cdk.requiredValidator)(properties.options));
  errors.collect(cdk.propertyValidator("options", CfnTransitGatewayConnectTransitGatewayConnectOptionsPropertyValidator)(properties.options));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("transportTransitGatewayAttachmentId", cdk.requiredValidator)(properties.transportTransitGatewayAttachmentId));
  errors.collect(cdk.propertyValidator("transportTransitGatewayAttachmentId", cdk.validateString)(properties.transportTransitGatewayAttachmentId));
  return errors.wrap("supplied properties not correct for \"CfnTransitGatewayConnectProps\"");
}

// @ts-ignore TS6133
function convertCfnTransitGatewayConnectPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTransitGatewayConnectPropsValidator(properties).assertSuccess();
  return {
    "Options": convertCfnTransitGatewayConnectTransitGatewayConnectOptionsPropertyToCloudFormation(properties.options),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "TransportTransitGatewayAttachmentId": cdk.stringToCloudFormation(properties.transportTransitGatewayAttachmentId)
  };
}

// @ts-ignore TS6133
function CfnTransitGatewayConnectPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnTransitGatewayConnectProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTransitGatewayConnectProps>();
  ret.addPropertyResult("options", "Options", (properties.Options != null ? CfnTransitGatewayConnectTransitGatewayConnectOptionsPropertyFromCloudFormation(properties.Options) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("transportTransitGatewayAttachmentId", "TransportTransitGatewayAttachmentId", (properties.TransportTransitGatewayAttachmentId != null ? cfn_parse.FromCloudFormation.getString(properties.TransportTransitGatewayAttachmentId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Creates a multicast domain using the specified transit gateway.
 *
 * The transit gateway must be in the available state before you create a domain.
 *
 * @cloudformationResource AWS::EC2::TransitGatewayMulticastDomain
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomain.html
 */
export class CfnTransitGatewayMulticastDomain extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::TransitGatewayMulticastDomain";

  /**
   * Build a CfnTransitGatewayMulticastDomain from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnTransitGatewayMulticastDomain {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnTransitGatewayMulticastDomainPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnTransitGatewayMulticastDomain(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The time the multicast domain was created.
   *
   * @cloudformationAttribute CreationTime
   */
  public readonly attrCreationTime: string;

  /**
   * The state of the multicast domain.
   *
   * @cloudformationAttribute State
   */
  public readonly attrState: string;

  /**
   * The Amazon Resource Name (ARN) of the multicast domain.
   *
   * @cloudformationAttribute TransitGatewayMulticastDomainArn
   */
  public readonly attrTransitGatewayMulticastDomainArn: string;

  /**
   * The ID of the multicast domain.
   *
   * @cloudformationAttribute TransitGatewayMulticastDomainId
   */
  public readonly attrTransitGatewayMulticastDomainId: string;

  /**
   * The options for the transit gateway multicast domain.
   */
  public options?: any | cdk.IResolvable;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags for the transit gateway multicast domain.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The ID of the transit gateway.
   */
  public transitGatewayId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnTransitGatewayMulticastDomainProps) {
    super(scope, id, {
      "type": CfnTransitGatewayMulticastDomain.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "transitGatewayId", this);

    this.attrCreationTime = cdk.Token.asString(this.getAtt("CreationTime", cdk.ResolutionTypeHint.STRING));
    this.attrState = cdk.Token.asString(this.getAtt("State", cdk.ResolutionTypeHint.STRING));
    this.attrTransitGatewayMulticastDomainArn = cdk.Token.asString(this.getAtt("TransitGatewayMulticastDomainArn", cdk.ResolutionTypeHint.STRING));
    this.attrTransitGatewayMulticastDomainId = cdk.Token.asString(this.getAtt("TransitGatewayMulticastDomainId", cdk.ResolutionTypeHint.STRING));
    this.options = props.options;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::TransitGatewayMulticastDomain", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.transitGatewayId = props.transitGatewayId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "options": this.options,
      "tags": this.tags.renderTags(),
      "transitGatewayId": this.transitGatewayId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnTransitGatewayMulticastDomain.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnTransitGatewayMulticastDomainPropsToCloudFormation(props);
  }
}

export namespace CfnTransitGatewayMulticastDomain {
  /**
   * The options for the transit gateway multicast domain.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewaymulticastdomain-options.html
   */
  export interface OptionsProperty {
    /**
     * Indicates whether to automatically accept cross-account subnet associations that are associated with the transit gateway multicast domain.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewaymulticastdomain-options.html#cfn-ec2-transitgatewaymulticastdomain-options-autoacceptsharedassociations
     */
    readonly autoAcceptSharedAssociations?: string;

    /**
     * Specify whether to enable Internet Group Management Protocol (IGMP) version 2 for the transit gateway multicast domain.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewaymulticastdomain-options.html#cfn-ec2-transitgatewaymulticastdomain-options-igmpv2support
     */
    readonly igmpv2Support?: string;

    /**
     * Specify whether to enable support for statically configuring multicast group sources for a domain.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewaymulticastdomain-options.html#cfn-ec2-transitgatewaymulticastdomain-options-staticsourcessupport
     */
    readonly staticSourcesSupport?: string;
  }
}

/**
 * Properties for defining a `CfnTransitGatewayMulticastDomain`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomain.html
 */
export interface CfnTransitGatewayMulticastDomainProps {
  /**
   * The options for the transit gateway multicast domain.
   *
   * - AutoAcceptSharedAssociations (enable | disable)
   * - Igmpv2Support (enable | disable)
   * - StaticSourcesSupport (enable | disable)
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomain.html#cfn-ec2-transitgatewaymulticastdomain-options
   */
  readonly options?: any | cdk.IResolvable;

  /**
   * The tags for the transit gateway multicast domain.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomain.html#cfn-ec2-transitgatewaymulticastdomain-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The ID of the transit gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomain.html#cfn-ec2-transitgatewaymulticastdomain-transitgatewayid
   */
  readonly transitGatewayId: string;
}

/**
 * Determine whether the given properties match those of a `OptionsProperty`
 *
 * @param properties - the TypeScript properties of a `OptionsProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTransitGatewayMulticastDomainOptionsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("autoAcceptSharedAssociations", cdk.validateString)(properties.autoAcceptSharedAssociations));
  errors.collect(cdk.propertyValidator("igmpv2Support", cdk.validateString)(properties.igmpv2Support));
  errors.collect(cdk.propertyValidator("staticSourcesSupport", cdk.validateString)(properties.staticSourcesSupport));
  return errors.wrap("supplied properties not correct for \"OptionsProperty\"");
}

// @ts-ignore TS6133
function convertCfnTransitGatewayMulticastDomainOptionsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTransitGatewayMulticastDomainOptionsPropertyValidator(properties).assertSuccess();
  return {
    "AutoAcceptSharedAssociations": cdk.stringToCloudFormation(properties.autoAcceptSharedAssociations),
    "Igmpv2Support": cdk.stringToCloudFormation(properties.igmpv2Support),
    "StaticSourcesSupport": cdk.stringToCloudFormation(properties.staticSourcesSupport)
  };
}

// @ts-ignore TS6133
function CfnTransitGatewayMulticastDomainOptionsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnTransitGatewayMulticastDomain.OptionsProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTransitGatewayMulticastDomain.OptionsProperty>();
  ret.addPropertyResult("autoAcceptSharedAssociations", "AutoAcceptSharedAssociations", (properties.AutoAcceptSharedAssociations != null ? cfn_parse.FromCloudFormation.getString(properties.AutoAcceptSharedAssociations) : undefined));
  ret.addPropertyResult("igmpv2Support", "Igmpv2Support", (properties.Igmpv2Support != null ? cfn_parse.FromCloudFormation.getString(properties.Igmpv2Support) : undefined));
  ret.addPropertyResult("staticSourcesSupport", "StaticSourcesSupport", (properties.StaticSourcesSupport != null ? cfn_parse.FromCloudFormation.getString(properties.StaticSourcesSupport) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `CfnTransitGatewayMulticastDomainProps`
 *
 * @param properties - the TypeScript properties of a `CfnTransitGatewayMulticastDomainProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTransitGatewayMulticastDomainPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("options", cdk.validateObject)(properties.options));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("transitGatewayId", cdk.requiredValidator)(properties.transitGatewayId));
  errors.collect(cdk.propertyValidator("transitGatewayId", cdk.validateString)(properties.transitGatewayId));
  return errors.wrap("supplied properties not correct for \"CfnTransitGatewayMulticastDomainProps\"");
}

// @ts-ignore TS6133
function convertCfnTransitGatewayMulticastDomainPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTransitGatewayMulticastDomainPropsValidator(properties).assertSuccess();
  return {
    "Options": cdk.objectToCloudFormation(properties.options),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "TransitGatewayId": cdk.stringToCloudFormation(properties.transitGatewayId)
  };
}

// @ts-ignore TS6133
function CfnTransitGatewayMulticastDomainPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnTransitGatewayMulticastDomainProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTransitGatewayMulticastDomainProps>();
  ret.addPropertyResult("options", "Options", (properties.Options != null ? cfn_parse.FromCloudFormation.getAny(properties.Options) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("transitGatewayId", "TransitGatewayId", (properties.TransitGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.TransitGatewayId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Associates the specified subnets and transit gateway attachments with the specified transit gateway multicast domain.
 *
 * The transit gateway attachment must be in the available state before you can add a resource.
 *
 * @cloudformationResource AWS::EC2::TransitGatewayMulticastDomainAssociation
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomainassociation.html
 */
export class CfnTransitGatewayMulticastDomainAssociation extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::TransitGatewayMulticastDomainAssociation";

  /**
   * Build a CfnTransitGatewayMulticastDomainAssociation from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnTransitGatewayMulticastDomainAssociation {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnTransitGatewayMulticastDomainAssociationPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnTransitGatewayMulticastDomainAssociation(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the resource.
   *
   * @cloudformationAttribute ResourceId
   */
  public readonly attrResourceId: string;

  /**
   * The type of resource, for example a VPC attachment.
   *
   * @cloudformationAttribute ResourceType
   */
  public readonly attrResourceType: string;

  /**
   * The state of the resource.
   *
   * @cloudformationAttribute State
   */
  public readonly attrState: string;

  /**
   * The IDs of the subnets to associate with the transit gateway multicast domain.
   */
  public subnetId: string;

  /**
   * The ID of the transit gateway attachment.
   */
  public transitGatewayAttachmentId: string;

  /**
   * The ID of the transit gateway multicast domain.
   */
  public transitGatewayMulticastDomainId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnTransitGatewayMulticastDomainAssociationProps) {
    super(scope, id, {
      "type": CfnTransitGatewayMulticastDomainAssociation.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "subnetId", this);
    cdk.requireProperty(props, "transitGatewayAttachmentId", this);
    cdk.requireProperty(props, "transitGatewayMulticastDomainId", this);

    this.attrResourceId = cdk.Token.asString(this.getAtt("ResourceId", cdk.ResolutionTypeHint.STRING));
    this.attrResourceType = cdk.Token.asString(this.getAtt("ResourceType", cdk.ResolutionTypeHint.STRING));
    this.attrState = cdk.Token.asString(this.getAtt("State", cdk.ResolutionTypeHint.STRING));
    this.subnetId = props.subnetId;
    this.transitGatewayAttachmentId = props.transitGatewayAttachmentId;
    this.transitGatewayMulticastDomainId = props.transitGatewayMulticastDomainId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "subnetId": this.subnetId,
      "transitGatewayAttachmentId": this.transitGatewayAttachmentId,
      "transitGatewayMulticastDomainId": this.transitGatewayMulticastDomainId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnTransitGatewayMulticastDomainAssociation.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnTransitGatewayMulticastDomainAssociationPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a `CfnTransitGatewayMulticastDomainAssociation`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomainassociation.html
 */
export interface CfnTransitGatewayMulticastDomainAssociationProps {
  /**
   * The IDs of the subnets to associate with the transit gateway multicast domain.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomainassociation.html#cfn-ec2-transitgatewaymulticastdomainassociation-subnetid
   */
  readonly subnetId: string;

  /**
   * The ID of the transit gateway attachment.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomainassociation.html#cfn-ec2-transitgatewaymulticastdomainassociation-transitgatewayattachmentid
   */
  readonly transitGatewayAttachmentId: string;

  /**
   * The ID of the transit gateway multicast domain.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomainassociation.html#cfn-ec2-transitgatewaymulticastdomainassociation-transitgatewaymulticastdomainid
   */
  readonly transitGatewayMulticastDomainId: string;
}

/**
 * Determine whether the given properties match those of a `CfnTransitGatewayMulticastDomainAssociationProps`
 *
 * @param properties - the TypeScript properties of a `CfnTransitGatewayMulticastDomainAssociationProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTransitGatewayMulticastDomainAssociationPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("subnetId", cdk.requiredValidator)(properties.subnetId));
  errors.collect(cdk.propertyValidator("subnetId", cdk.validateString)(properties.subnetId));
  errors.collect(cdk.propertyValidator("transitGatewayAttachmentId", cdk.requiredValidator)(properties.transitGatewayAttachmentId));
  errors.collect(cdk.propertyValidator("transitGatewayAttachmentId", cdk.validateString)(properties.transitGatewayAttachmentId));
  errors.collect(cdk.propertyValidator("transitGatewayMulticastDomainId", cdk.requiredValidator)(properties.transitGatewayMulticastDomainId));
  errors.collect(cdk.propertyValidator("transitGatewayMulticastDomainId", cdk.validateString)(properties.transitGatewayMulticastDomainId));
  return errors.wrap("supplied properties not correct for \"CfnTransitGatewayMulticastDomainAssociationProps\"");
}

// @ts-ignore TS6133
function convertCfnTransitGatewayMulticastDomainAssociationPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTransitGatewayMulticastDomainAssociationPropsValidator(properties).assertSuccess();
  return {
    "SubnetId": cdk.stringToCloudFormation(properties.subnetId),
    "TransitGatewayAttachmentId": cdk.stringToCloudFormation(properties.transitGatewayAttachmentId),
    "TransitGatewayMulticastDomainId": cdk.stringToCloudFormation(properties.transitGatewayMulticastDomainId)
  };
}

// @ts-ignore TS6133
function CfnTransitGatewayMulticastDomainAssociationPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnTransitGatewayMulticastDomainAssociationProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTransitGatewayMulticastDomainAssociationProps>();
  ret.addPropertyResult("subnetId", "SubnetId", (properties.SubnetId != null ? cfn_parse.FromCloudFormation.getString(properties.SubnetId) : undefined));
  ret.addPropertyResult("transitGatewayAttachmentId", "TransitGatewayAttachmentId", (properties.TransitGatewayAttachmentId != null ? cfn_parse.FromCloudFormation.getString(properties.TransitGatewayAttachmentId) : undefined));
  ret.addPropertyResult("transitGatewayMulticastDomainId", "TransitGatewayMulticastDomainId", (properties.TransitGatewayMulticastDomainId != null ? cfn_parse.FromCloudFormation.getString(properties.TransitGatewayMulticastDomainId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Registers members (network interfaces) with the transit gateway multicast group.
 *
 * A member is a network interface associated with a supported EC2 instance that receives multicast traffic. For information about supported instances, see [Multicast Consideration](https://docs.aws.amazon.com/vpc/latest/tgw/transit-gateway-limits.html#multicast-limits) in *Amazon VPC Transit Gateways* .
 *
 * @cloudformationResource AWS::EC2::TransitGatewayMulticastGroupMember
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupmember.html
 */
export class CfnTransitGatewayMulticastGroupMember extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::TransitGatewayMulticastGroupMember";

  /**
   * Build a CfnTransitGatewayMulticastGroupMember from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnTransitGatewayMulticastGroupMember {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnTransitGatewayMulticastGroupMemberPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnTransitGatewayMulticastGroupMember(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * Information about the registered transit gateway multicast domain group members.
   *
   * @cloudformationAttribute GroupMember
   */
  public readonly attrGroupMember: cdk.IResolvable;

  /**
   * Indicates that the resource is a transit gateway multicast domain group member.
   *
   * @cloudformationAttribute GroupSource
   */
  public readonly attrGroupSource: cdk.IResolvable;

  /**
   * The type of group member, for example static.
   *
   * @cloudformationAttribute MemberType
   */
  public readonly attrMemberType: string;

  /**
   * The ID of the resource.
   *
   * @cloudformationAttribute ResourceId
   */
  public readonly attrResourceId: string;

  /**
   * The type of resource, for example a VPC attachment.
   *
   * @cloudformationAttribute ResourceType
   */
  public readonly attrResourceType: string;

  /**
   * The type of source.
   *
   * @cloudformationAttribute SourceType
   */
  public readonly attrSourceType: string;

  /**
   * The ID of the subnet.
   *
   * @cloudformationAttribute SubnetId
   */
  public readonly attrSubnetId: string;

  /**
   * The ID of the transit gateway attachment.
   *
   * @cloudformationAttribute TransitGatewayAttachmentId
   */
  public readonly attrTransitGatewayAttachmentId: string;

  /**
   * The IP address assigned to the transit gateway multicast group.
   */
  public groupIpAddress: string;

  /**
   * The group members' network interface IDs to register with the transit gateway multicast group.
   */
  public networkInterfaceId: string;

  /**
   * The ID of the transit gateway multicast domain.
   */
  public transitGatewayMulticastDomainId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnTransitGatewayMulticastGroupMemberProps) {
    super(scope, id, {
      "type": CfnTransitGatewayMulticastGroupMember.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "groupIpAddress", this);
    cdk.requireProperty(props, "networkInterfaceId", this);
    cdk.requireProperty(props, "transitGatewayMulticastDomainId", this);

    this.attrGroupMember = this.getAtt("GroupMember");
    this.attrGroupSource = this.getAtt("GroupSource");
    this.attrMemberType = cdk.Token.asString(this.getAtt("MemberType", cdk.ResolutionTypeHint.STRING));
    this.attrResourceId = cdk.Token.asString(this.getAtt("ResourceId", cdk.ResolutionTypeHint.STRING));
    this.attrResourceType = cdk.Token.asString(this.getAtt("ResourceType", cdk.ResolutionTypeHint.STRING));
    this.attrSourceType = cdk.Token.asString(this.getAtt("SourceType", cdk.ResolutionTypeHint.STRING));
    this.attrSubnetId = cdk.Token.asString(this.getAtt("SubnetId", cdk.ResolutionTypeHint.STRING));
    this.attrTransitGatewayAttachmentId = cdk.Token.asString(this.getAtt("TransitGatewayAttachmentId", cdk.ResolutionTypeHint.STRING));
    this.groupIpAddress = props.groupIpAddress;
    this.networkInterfaceId = props.networkInterfaceId;
    this.transitGatewayMulticastDomainId = props.transitGatewayMulticastDomainId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "groupIpAddress": this.groupIpAddress,
      "networkInterfaceId": this.networkInterfaceId,
      "transitGatewayMulticastDomainId": this.transitGatewayMulticastDomainId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnTransitGatewayMulticastGroupMember.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnTransitGatewayMulticastGroupMemberPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a `CfnTransitGatewayMulticastGroupMember`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupmember.html
 */
export interface CfnTransitGatewayMulticastGroupMemberProps {
  /**
   * The IP address assigned to the transit gateway multicast group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupmember.html#cfn-ec2-transitgatewaymulticastgroupmember-groupipaddress
   */
  readonly groupIpAddress: string;

  /**
   * The group members' network interface IDs to register with the transit gateway multicast group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupmember.html#cfn-ec2-transitgatewaymulticastgroupmember-networkinterfaceid
   */
  readonly networkInterfaceId: string;

  /**
   * The ID of the transit gateway multicast domain.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupmember.html#cfn-ec2-transitgatewaymulticastgroupmember-transitgatewaymulticastdomainid
   */
  readonly transitGatewayMulticastDomainId: string;
}

/**
 * Determine whether the given properties match those of a `CfnTransitGatewayMulticastGroupMemberProps`
 *
 * @param properties - the TypeScript properties of a `CfnTransitGatewayMulticastGroupMemberProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTransitGatewayMulticastGroupMemberPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("groupIpAddress", cdk.requiredValidator)(properties.groupIpAddress));
  errors.collect(cdk.propertyValidator("groupIpAddress", cdk.validateString)(properties.groupIpAddress));
  errors.collect(cdk.propertyValidator("networkInterfaceId", cdk.requiredValidator)(properties.networkInterfaceId));
  errors.collect(cdk.propertyValidator("networkInterfaceId", cdk.validateString)(properties.networkInterfaceId));
  errors.collect(cdk.propertyValidator("transitGatewayMulticastDomainId", cdk.requiredValidator)(properties.transitGatewayMulticastDomainId));
  errors.collect(cdk.propertyValidator("transitGatewayMulticastDomainId", cdk.validateString)(properties.transitGatewayMulticastDomainId));
  return errors.wrap("supplied properties not correct for \"CfnTransitGatewayMulticastGroupMemberProps\"");
}

// @ts-ignore TS6133
function convertCfnTransitGatewayMulticastGroupMemberPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTransitGatewayMulticastGroupMemberPropsValidator(properties).assertSuccess();
  return {
    "GroupIpAddress": cdk.stringToCloudFormation(properties.groupIpAddress),
    "NetworkInterfaceId": cdk.stringToCloudFormation(properties.networkInterfaceId),
    "TransitGatewayMulticastDomainId": cdk.stringToCloudFormation(properties.transitGatewayMulticastDomainId)
  };
}

// @ts-ignore TS6133
function CfnTransitGatewayMulticastGroupMemberPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnTransitGatewayMulticastGroupMemberProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTransitGatewayMulticastGroupMemberProps>();
  ret.addPropertyResult("groupIpAddress", "GroupIpAddress", (properties.GroupIpAddress != null ? cfn_parse.FromCloudFormation.getString(properties.GroupIpAddress) : undefined));
  ret.addPropertyResult("networkInterfaceId", "NetworkInterfaceId", (properties.NetworkInterfaceId != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkInterfaceId) : undefined));
  ret.addPropertyResult("transitGatewayMulticastDomainId", "TransitGatewayMulticastDomainId", (properties.TransitGatewayMulticastDomainId != null ? cfn_parse.FromCloudFormation.getString(properties.TransitGatewayMulticastDomainId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Registers sources (network interfaces) with the specified transit gateway multicast domain.
 *
 * A multicast source is a network interface attached to a supported instance that sends multicast traffic. For information about supported instances, see [Multicast Considerations](https://docs.aws.amazon.com/vpc/latest/tgw/transit-gateway-limits.html#multicast-limits) in *Amazon VPC Transit Gateways* .
 *
 * @cloudformationResource AWS::EC2::TransitGatewayMulticastGroupSource
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupsource.html
 */
export class CfnTransitGatewayMulticastGroupSource extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::TransitGatewayMulticastGroupSource";

  /**
   * Build a CfnTransitGatewayMulticastGroupSource from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnTransitGatewayMulticastGroupSource {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnTransitGatewayMulticastGroupSourcePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnTransitGatewayMulticastGroupSource(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * Information about the registered transit gateway multicast domain group members.
   *
   * @cloudformationAttribute GroupMember
   */
  public readonly attrGroupMember: cdk.IResolvable;

  /**
   * Indicates that the resource is a transit gateway group member.
   *
   * @cloudformationAttribute GroupSource
   */
  public readonly attrGroupSource: cdk.IResolvable;

  /**
   * The type of group member, for example static.
   *
   * @cloudformationAttribute MemberType
   */
  public readonly attrMemberType: string;

  /**
   * The ID of the resource.
   *
   * @cloudformationAttribute ResourceId
   */
  public readonly attrResourceId: string;

  /**
   * The type of resource, for example a VPC attachment.
   *
   * @cloudformationAttribute ResourceType
   */
  public readonly attrResourceType: string;

  /**
   * The type of source.
   *
   * @cloudformationAttribute SourceType
   */
  public readonly attrSourceType: string;

  /**
   * The ID of the subnet.
   *
   * @cloudformationAttribute SubnetId
   */
  public readonly attrSubnetId: string;

  /**
   * The ID of the transit gateway attachment.
   *
   * @cloudformationAttribute TransitGatewayAttachmentId
   */
  public readonly attrTransitGatewayAttachmentId: string;

  /**
   * The IP address assigned to the transit gateway multicast group.
   */
  public groupIpAddress: string;

  /**
   * The group sources' network interface IDs to register with the transit gateway multicast group.
   */
  public networkInterfaceId: string;

  /**
   * The ID of the transit gateway multicast domain.
   */
  public transitGatewayMulticastDomainId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnTransitGatewayMulticastGroupSourceProps) {
    super(scope, id, {
      "type": CfnTransitGatewayMulticastGroupSource.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "groupIpAddress", this);
    cdk.requireProperty(props, "networkInterfaceId", this);
    cdk.requireProperty(props, "transitGatewayMulticastDomainId", this);

    this.attrGroupMember = this.getAtt("GroupMember");
    this.attrGroupSource = this.getAtt("GroupSource");
    this.attrMemberType = cdk.Token.asString(this.getAtt("MemberType", cdk.ResolutionTypeHint.STRING));
    this.attrResourceId = cdk.Token.asString(this.getAtt("ResourceId", cdk.ResolutionTypeHint.STRING));
    this.attrResourceType = cdk.Token.asString(this.getAtt("ResourceType", cdk.ResolutionTypeHint.STRING));
    this.attrSourceType = cdk.Token.asString(this.getAtt("SourceType", cdk.ResolutionTypeHint.STRING));
    this.attrSubnetId = cdk.Token.asString(this.getAtt("SubnetId", cdk.ResolutionTypeHint.STRING));
    this.attrTransitGatewayAttachmentId = cdk.Token.asString(this.getAtt("TransitGatewayAttachmentId", cdk.ResolutionTypeHint.STRING));
    this.groupIpAddress = props.groupIpAddress;
    this.networkInterfaceId = props.networkInterfaceId;
    this.transitGatewayMulticastDomainId = props.transitGatewayMulticastDomainId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "groupIpAddress": this.groupIpAddress,
      "networkInterfaceId": this.networkInterfaceId,
      "transitGatewayMulticastDomainId": this.transitGatewayMulticastDomainId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnTransitGatewayMulticastGroupSource.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnTransitGatewayMulticastGroupSourcePropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a `CfnTransitGatewayMulticastGroupSource`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupsource.html
 */
export interface CfnTransitGatewayMulticastGroupSourceProps {
  /**
   * The IP address assigned to the transit gateway multicast group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupsource.html#cfn-ec2-transitgatewaymulticastgroupsource-groupipaddress
   */
  readonly groupIpAddress: string;

  /**
   * The group sources' network interface IDs to register with the transit gateway multicast group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupsource.html#cfn-ec2-transitgatewaymulticastgroupsource-networkinterfaceid
   */
  readonly networkInterfaceId: string;

  /**
   * The ID of the transit gateway multicast domain.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupsource.html#cfn-ec2-transitgatewaymulticastgroupsource-transitgatewaymulticastdomainid
   */
  readonly transitGatewayMulticastDomainId: string;
}

/**
 * Determine whether the given properties match those of a `CfnTransitGatewayMulticastGroupSourceProps`
 *
 * @param properties - the TypeScript properties of a `CfnTransitGatewayMulticastGroupSourceProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTransitGatewayMulticastGroupSourcePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("groupIpAddress", cdk.requiredValidator)(properties.groupIpAddress));
  errors.collect(cdk.propertyValidator("groupIpAddress", cdk.validateString)(properties.groupIpAddress));
  errors.collect(cdk.propertyValidator("networkInterfaceId", cdk.requiredValidator)(properties.networkInterfaceId));
  errors.collect(cdk.propertyValidator("networkInterfaceId", cdk.validateString)(properties.networkInterfaceId));
  errors.collect(cdk.propertyValidator("transitGatewayMulticastDomainId", cdk.requiredValidator)(properties.transitGatewayMulticastDomainId));
  errors.collect(cdk.propertyValidator("transitGatewayMulticastDomainId", cdk.validateString)(properties.transitGatewayMulticastDomainId));
  return errors.wrap("supplied properties not correct for \"CfnTransitGatewayMulticastGroupSourceProps\"");
}

// @ts-ignore TS6133
function convertCfnTransitGatewayMulticastGroupSourcePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTransitGatewayMulticastGroupSourcePropsValidator(properties).assertSuccess();
  return {
    "GroupIpAddress": cdk.stringToCloudFormation(properties.groupIpAddress),
    "NetworkInterfaceId": cdk.stringToCloudFormation(properties.networkInterfaceId),
    "TransitGatewayMulticastDomainId": cdk.stringToCloudFormation(properties.transitGatewayMulticastDomainId)
  };
}

// @ts-ignore TS6133
function CfnTransitGatewayMulticastGroupSourcePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnTransitGatewayMulticastGroupSourceProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTransitGatewayMulticastGroupSourceProps>();
  ret.addPropertyResult("groupIpAddress", "GroupIpAddress", (properties.GroupIpAddress != null ? cfn_parse.FromCloudFormation.getString(properties.GroupIpAddress) : undefined));
  ret.addPropertyResult("networkInterfaceId", "NetworkInterfaceId", (properties.NetworkInterfaceId != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkInterfaceId) : undefined));
  ret.addPropertyResult("transitGatewayMulticastDomainId", "TransitGatewayMulticastDomainId", (properties.TransitGatewayMulticastDomainId != null ? cfn_parse.FromCloudFormation.getString(properties.TransitGatewayMulticastDomainId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Requests a transit gateway peering attachment between the specified transit gateway (requester) and a peer transit gateway (accepter).
 *
 * The peer transit gateway can be in your account or a different AWS account .
 *
 * After you create the peering attachment, the owner of the accepter transit gateway must accept the attachment request.
 *
 * @cloudformationResource AWS::EC2::TransitGatewayPeeringAttachment
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html
 */
export class CfnTransitGatewayPeeringAttachment extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::TransitGatewayPeeringAttachment";

  /**
   * Build a CfnTransitGatewayPeeringAttachment from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnTransitGatewayPeeringAttachment {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnTransitGatewayPeeringAttachmentPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnTransitGatewayPeeringAttachment(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The time the transit gateway peering attachment was created.
   *
   * @cloudformationAttribute CreationTime
   */
  public readonly attrCreationTime: string;

  /**
   * The state of the transit gateway peering attachment. Note that the `initiating` state has been deprecated.
   *
   * @cloudformationAttribute State
   */
  public readonly attrState: string;

  /**
   * The status of the transit gateway peering attachment.
   *
   * @cloudformationAttribute Status
   */
  public readonly attrStatus: cdk.IResolvable;

  /**
   * @cloudformationAttribute Status.Code
   */
  public readonly attrStatusCode: string;

  /**
   * @cloudformationAttribute Status.Message
   */
  public readonly attrStatusMessage: string;

  /**
   * The ID of the transit gateway peering attachment.
   *
   * @cloudformationAttribute TransitGatewayAttachmentId
   */
  public readonly attrTransitGatewayAttachmentId: string;

  /**
   * The ID of the AWS account that owns the transit gateway.
   */
  public peerAccountId: string;

  /**
   * The Region of the transit gateway.
   */
  public peerRegion: string;

  /**
   * The ID of the transit gateway.
   */
  public peerTransitGatewayId: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags for the transit gateway peering attachment.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The ID of the transit gateway peering attachment.
   */
  public transitGatewayId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnTransitGatewayPeeringAttachmentProps) {
    super(scope, id, {
      "type": CfnTransitGatewayPeeringAttachment.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "peerAccountId", this);
    cdk.requireProperty(props, "peerRegion", this);
    cdk.requireProperty(props, "peerTransitGatewayId", this);
    cdk.requireProperty(props, "transitGatewayId", this);

    this.attrCreationTime = cdk.Token.asString(this.getAtt("CreationTime", cdk.ResolutionTypeHint.STRING));
    this.attrState = cdk.Token.asString(this.getAtt("State", cdk.ResolutionTypeHint.STRING));
    this.attrStatus = this.getAtt("Status");
    this.attrStatusCode = cdk.Token.asString(this.getAtt("Status.Code", cdk.ResolutionTypeHint.STRING));
    this.attrStatusMessage = cdk.Token.asString(this.getAtt("Status.Message", cdk.ResolutionTypeHint.STRING));
    this.attrTransitGatewayAttachmentId = cdk.Token.asString(this.getAtt("TransitGatewayAttachmentId", cdk.ResolutionTypeHint.STRING));
    this.peerAccountId = props.peerAccountId;
    this.peerRegion = props.peerRegion;
    this.peerTransitGatewayId = props.peerTransitGatewayId;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::TransitGatewayPeeringAttachment", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.transitGatewayId = props.transitGatewayId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "peerAccountId": this.peerAccountId,
      "peerRegion": this.peerRegion,
      "peerTransitGatewayId": this.peerTransitGatewayId,
      "tags": this.tags.renderTags(),
      "transitGatewayId": this.transitGatewayId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnTransitGatewayPeeringAttachment.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnTransitGatewayPeeringAttachmentPropsToCloudFormation(props);
  }
}

export namespace CfnTransitGatewayPeeringAttachment {
  /**
   * The status of the transit gateway peering attachment.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewaypeeringattachment-peeringattachmentstatus.html
   */
  export interface PeeringAttachmentStatusProperty {
    /**
     * The status code.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewaypeeringattachment-peeringattachmentstatus.html#cfn-ec2-transitgatewaypeeringattachment-peeringattachmentstatus-code
     */
    readonly code?: string;

    /**
     * The status message, if applicable.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewaypeeringattachment-peeringattachmentstatus.html#cfn-ec2-transitgatewaypeeringattachment-peeringattachmentstatus-message
     */
    readonly message?: string;
  }
}

/**
 * Properties for defining a `CfnTransitGatewayPeeringAttachment`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html
 */
export interface CfnTransitGatewayPeeringAttachmentProps {
  /**
   * The ID of the AWS account that owns the transit gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-peeraccountid
   */
  readonly peerAccountId: string;

  /**
   * The Region of the transit gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-peerregion
   */
  readonly peerRegion: string;

  /**
   * The ID of the transit gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-peertransitgatewayid
   */
  readonly peerTransitGatewayId: string;

  /**
   * The tags for the transit gateway peering attachment.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The ID of the transit gateway peering attachment.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-transitgatewayid
   */
  readonly transitGatewayId: string;
}

/**
 * Determine whether the given properties match those of a `PeeringAttachmentStatusProperty`
 *
 * @param properties - the TypeScript properties of a `PeeringAttachmentStatusProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTransitGatewayPeeringAttachmentPeeringAttachmentStatusPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("code", cdk.validateString)(properties.code));
  errors.collect(cdk.propertyValidator("message", cdk.validateString)(properties.message));
  return errors.wrap("supplied properties not correct for \"PeeringAttachmentStatusProperty\"");
}

// @ts-ignore TS6133
function convertCfnTransitGatewayPeeringAttachmentPeeringAttachmentStatusPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTransitGatewayPeeringAttachmentPeeringAttachmentStatusPropertyValidator(properties).assertSuccess();
  return {
    "Code": cdk.stringToCloudFormation(properties.code),
    "Message": cdk.stringToCloudFormation(properties.message)
  };
}

// @ts-ignore TS6133
function CfnTransitGatewayPeeringAttachmentPeeringAttachmentStatusPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnTransitGatewayPeeringAttachment.PeeringAttachmentStatusProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTransitGatewayPeeringAttachment.PeeringAttachmentStatusProperty>();
  ret.addPropertyResult("code", "Code", (properties.Code != null ? cfn_parse.FromCloudFormation.getString(properties.Code) : undefined));
  ret.addPropertyResult("message", "Message", (properties.Message != null ? cfn_parse.FromCloudFormation.getString(properties.Message) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `CfnTransitGatewayPeeringAttachmentProps`
 *
 * @param properties - the TypeScript properties of a `CfnTransitGatewayPeeringAttachmentProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTransitGatewayPeeringAttachmentPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("peerAccountId", cdk.requiredValidator)(properties.peerAccountId));
  errors.collect(cdk.propertyValidator("peerAccountId", cdk.validateString)(properties.peerAccountId));
  errors.collect(cdk.propertyValidator("peerRegion", cdk.requiredValidator)(properties.peerRegion));
  errors.collect(cdk.propertyValidator("peerRegion", cdk.validateString)(properties.peerRegion));
  errors.collect(cdk.propertyValidator("peerTransitGatewayId", cdk.requiredValidator)(properties.peerTransitGatewayId));
  errors.collect(cdk.propertyValidator("peerTransitGatewayId", cdk.validateString)(properties.peerTransitGatewayId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("transitGatewayId", cdk.requiredValidator)(properties.transitGatewayId));
  errors.collect(cdk.propertyValidator("transitGatewayId", cdk.validateString)(properties.transitGatewayId));
  return errors.wrap("supplied properties not correct for \"CfnTransitGatewayPeeringAttachmentProps\"");
}

// @ts-ignore TS6133
function convertCfnTransitGatewayPeeringAttachmentPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTransitGatewayPeeringAttachmentPropsValidator(properties).assertSuccess();
  return {
    "PeerAccountId": cdk.stringToCloudFormation(properties.peerAccountId),
    "PeerRegion": cdk.stringToCloudFormation(properties.peerRegion),
    "PeerTransitGatewayId": cdk.stringToCloudFormation(properties.peerTransitGatewayId),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "TransitGatewayId": cdk.stringToCloudFormation(properties.transitGatewayId)
  };
}

// @ts-ignore TS6133
function CfnTransitGatewayPeeringAttachmentPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnTransitGatewayPeeringAttachmentProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTransitGatewayPeeringAttachmentProps>();
  ret.addPropertyResult("peerAccountId", "PeerAccountId", (properties.PeerAccountId != null ? cfn_parse.FromCloudFormation.getString(properties.PeerAccountId) : undefined));
  ret.addPropertyResult("peerRegion", "PeerRegion", (properties.PeerRegion != null ? cfn_parse.FromCloudFormation.getString(properties.PeerRegion) : undefined));
  ret.addPropertyResult("peerTransitGatewayId", "PeerTransitGatewayId", (properties.PeerTransitGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.PeerTransitGatewayId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("transitGatewayId", "TransitGatewayId", (properties.TransitGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.TransitGatewayId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a static route for a transit gateway route table.
 *
 * @cloudformationResource AWS::EC2::TransitGatewayRoute
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroute.html
 */
export class CfnTransitGatewayRoute extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::TransitGatewayRoute";

  /**
   * Build a CfnTransitGatewayRoute from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnTransitGatewayRoute {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnTransitGatewayRoutePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnTransitGatewayRoute(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * Indicates whether to drop traffic that matches this route.
   */
  public blackhole?: boolean | cdk.IResolvable;

  /**
   * The CIDR block used for destination matches.
   */
  public destinationCidrBlock?: string;

  /**
   * The ID of the attachment.
   */
  public transitGatewayAttachmentId?: string;

  /**
   * The ID of the transit gateway route table.
   */
  public transitGatewayRouteTableId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnTransitGatewayRouteProps) {
    super(scope, id, {
      "type": CfnTransitGatewayRoute.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "transitGatewayRouteTableId", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.blackhole = props.blackhole;
    this.destinationCidrBlock = props.destinationCidrBlock;
    this.transitGatewayAttachmentId = props.transitGatewayAttachmentId;
    this.transitGatewayRouteTableId = props.transitGatewayRouteTableId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "blackhole": this.blackhole,
      "destinationCidrBlock": this.destinationCidrBlock,
      "transitGatewayAttachmentId": this.transitGatewayAttachmentId,
      "transitGatewayRouteTableId": this.transitGatewayRouteTableId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnTransitGatewayRoute.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnTransitGatewayRoutePropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a `CfnTransitGatewayRoute`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroute.html
 */
export interface CfnTransitGatewayRouteProps {
  /**
   * Indicates whether to drop traffic that matches this route.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroute.html#cfn-ec2-transitgatewayroute-blackhole
   */
  readonly blackhole?: boolean | cdk.IResolvable;

  /**
   * The CIDR block used for destination matches.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroute.html#cfn-ec2-transitgatewayroute-destinationcidrblock
   */
  readonly destinationCidrBlock?: string;

  /**
   * The ID of the attachment.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroute.html#cfn-ec2-transitgatewayroute-transitgatewayattachmentid
   */
  readonly transitGatewayAttachmentId?: string;

  /**
   * The ID of the transit gateway route table.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroute.html#cfn-ec2-transitgatewayroute-transitgatewayroutetableid
   */
  readonly transitGatewayRouteTableId: string;
}

/**
 * Determine whether the given properties match those of a `CfnTransitGatewayRouteProps`
 *
 * @param properties - the TypeScript properties of a `CfnTransitGatewayRouteProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTransitGatewayRoutePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("blackhole", cdk.validateBoolean)(properties.blackhole));
  errors.collect(cdk.propertyValidator("destinationCidrBlock", cdk.validateString)(properties.destinationCidrBlock));
  errors.collect(cdk.propertyValidator("transitGatewayAttachmentId", cdk.validateString)(properties.transitGatewayAttachmentId));
  errors.collect(cdk.propertyValidator("transitGatewayRouteTableId", cdk.requiredValidator)(properties.transitGatewayRouteTableId));
  errors.collect(cdk.propertyValidator("transitGatewayRouteTableId", cdk.validateString)(properties.transitGatewayRouteTableId));
  return errors.wrap("supplied properties not correct for \"CfnTransitGatewayRouteProps\"");
}

// @ts-ignore TS6133
function convertCfnTransitGatewayRoutePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTransitGatewayRoutePropsValidator(properties).assertSuccess();
  return {
    "Blackhole": cdk.booleanToCloudFormation(properties.blackhole),
    "DestinationCidrBlock": cdk.stringToCloudFormation(properties.destinationCidrBlock),
    "TransitGatewayAttachmentId": cdk.stringToCloudFormation(properties.transitGatewayAttachmentId),
    "TransitGatewayRouteTableId": cdk.stringToCloudFormation(properties.transitGatewayRouteTableId)
  };
}

// @ts-ignore TS6133
function CfnTransitGatewayRoutePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnTransitGatewayRouteProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTransitGatewayRouteProps>();
  ret.addPropertyResult("blackhole", "Blackhole", (properties.Blackhole != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Blackhole) : undefined));
  ret.addPropertyResult("destinationCidrBlock", "DestinationCidrBlock", (properties.DestinationCidrBlock != null ? cfn_parse.FromCloudFormation.getString(properties.DestinationCidrBlock) : undefined));
  ret.addPropertyResult("transitGatewayAttachmentId", "TransitGatewayAttachmentId", (properties.TransitGatewayAttachmentId != null ? cfn_parse.FromCloudFormation.getString(properties.TransitGatewayAttachmentId) : undefined));
  ret.addPropertyResult("transitGatewayRouteTableId", "TransitGatewayRouteTableId", (properties.TransitGatewayRouteTableId != null ? cfn_parse.FromCloudFormation.getString(properties.TransitGatewayRouteTableId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a route table for a transit gateway.
 *
 * @cloudformationResource AWS::EC2::TransitGatewayRouteTable
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetable.html
 */
export class CfnTransitGatewayRouteTable extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::TransitGatewayRouteTable";

  /**
   * Build a CfnTransitGatewayRouteTable from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnTransitGatewayRouteTable {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnTransitGatewayRouteTablePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnTransitGatewayRouteTable(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the transit gateway route table.
   *
   * @cloudformationAttribute TransitGatewayRouteTableId
   */
  public readonly attrTransitGatewayRouteTableId: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * Any tags assigned to the route table.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The ID of the transit gateway.
   */
  public transitGatewayId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnTransitGatewayRouteTableProps) {
    super(scope, id, {
      "type": CfnTransitGatewayRouteTable.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "transitGatewayId", this);

    this.attrTransitGatewayRouteTableId = cdk.Token.asString(this.getAtt("TransitGatewayRouteTableId", cdk.ResolutionTypeHint.STRING));
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::TransitGatewayRouteTable", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.transitGatewayId = props.transitGatewayId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "tags": this.tags.renderTags(),
      "transitGatewayId": this.transitGatewayId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnTransitGatewayRouteTable.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnTransitGatewayRouteTablePropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a `CfnTransitGatewayRouteTable`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetable.html
 */
export interface CfnTransitGatewayRouteTableProps {
  /**
   * Any tags assigned to the route table.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetable.html#cfn-ec2-transitgatewayroutetable-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The ID of the transit gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetable.html#cfn-ec2-transitgatewayroutetable-transitgatewayid
   */
  readonly transitGatewayId: string;
}

/**
 * Determine whether the given properties match those of a `CfnTransitGatewayRouteTableProps`
 *
 * @param properties - the TypeScript properties of a `CfnTransitGatewayRouteTableProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTransitGatewayRouteTablePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("transitGatewayId", cdk.requiredValidator)(properties.transitGatewayId));
  errors.collect(cdk.propertyValidator("transitGatewayId", cdk.validateString)(properties.transitGatewayId));
  return errors.wrap("supplied properties not correct for \"CfnTransitGatewayRouteTableProps\"");
}

// @ts-ignore TS6133
function convertCfnTransitGatewayRouteTablePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTransitGatewayRouteTablePropsValidator(properties).assertSuccess();
  return {
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "TransitGatewayId": cdk.stringToCloudFormation(properties.transitGatewayId)
  };
}

// @ts-ignore TS6133
function CfnTransitGatewayRouteTablePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnTransitGatewayRouteTableProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTransitGatewayRouteTableProps>();
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("transitGatewayId", "TransitGatewayId", (properties.TransitGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.TransitGatewayId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Associates the specified attachment with the specified transit gateway route table.
 *
 * You can associate one route table with an attachment.
 *
 * Before you can update the route table associated with an attachment, you must disassociate the transit gateway route table that is currently associated with the attachment. First update the stack to remove the associated transit gateway route table, and then update the stack with the ID of the new transit gateway route table to associate.
 *
 * @cloudformationResource AWS::EC2::TransitGatewayRouteTableAssociation
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetableassociation.html
 */
export class CfnTransitGatewayRouteTableAssociation extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::TransitGatewayRouteTableAssociation";

  /**
   * Build a CfnTransitGatewayRouteTableAssociation from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnTransitGatewayRouteTableAssociation {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnTransitGatewayRouteTableAssociationPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnTransitGatewayRouteTableAssociation(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The ID of the attachment.
   */
  public transitGatewayAttachmentId: string;

  /**
   * The ID of the route table for the transit gateway.
   */
  public transitGatewayRouteTableId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnTransitGatewayRouteTableAssociationProps) {
    super(scope, id, {
      "type": CfnTransitGatewayRouteTableAssociation.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "transitGatewayAttachmentId", this);
    cdk.requireProperty(props, "transitGatewayRouteTableId", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.transitGatewayAttachmentId = props.transitGatewayAttachmentId;
    this.transitGatewayRouteTableId = props.transitGatewayRouteTableId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "transitGatewayAttachmentId": this.transitGatewayAttachmentId,
      "transitGatewayRouteTableId": this.transitGatewayRouteTableId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnTransitGatewayRouteTableAssociation.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnTransitGatewayRouteTableAssociationPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a `CfnTransitGatewayRouteTableAssociation`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetableassociation.html
 */
export interface CfnTransitGatewayRouteTableAssociationProps {
  /**
   * The ID of the attachment.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetableassociation.html#cfn-ec2-transitgatewayroutetableassociation-transitgatewayattachmentid
   */
  readonly transitGatewayAttachmentId: string;

  /**
   * The ID of the route table for the transit gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetableassociation.html#cfn-ec2-transitgatewayroutetableassociation-transitgatewayroutetableid
   */
  readonly transitGatewayRouteTableId: string;
}

/**
 * Determine whether the given properties match those of a `CfnTransitGatewayRouteTableAssociationProps`
 *
 * @param properties - the TypeScript properties of a `CfnTransitGatewayRouteTableAssociationProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTransitGatewayRouteTableAssociationPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("transitGatewayAttachmentId", cdk.requiredValidator)(properties.transitGatewayAttachmentId));
  errors.collect(cdk.propertyValidator("transitGatewayAttachmentId", cdk.validateString)(properties.transitGatewayAttachmentId));
  errors.collect(cdk.propertyValidator("transitGatewayRouteTableId", cdk.requiredValidator)(properties.transitGatewayRouteTableId));
  errors.collect(cdk.propertyValidator("transitGatewayRouteTableId", cdk.validateString)(properties.transitGatewayRouteTableId));
  return errors.wrap("supplied properties not correct for \"CfnTransitGatewayRouteTableAssociationProps\"");
}

// @ts-ignore TS6133
function convertCfnTransitGatewayRouteTableAssociationPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTransitGatewayRouteTableAssociationPropsValidator(properties).assertSuccess();
  return {
    "TransitGatewayAttachmentId": cdk.stringToCloudFormation(properties.transitGatewayAttachmentId),
    "TransitGatewayRouteTableId": cdk.stringToCloudFormation(properties.transitGatewayRouteTableId)
  };
}

// @ts-ignore TS6133
function CfnTransitGatewayRouteTableAssociationPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnTransitGatewayRouteTableAssociationProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTransitGatewayRouteTableAssociationProps>();
  ret.addPropertyResult("transitGatewayAttachmentId", "TransitGatewayAttachmentId", (properties.TransitGatewayAttachmentId != null ? cfn_parse.FromCloudFormation.getString(properties.TransitGatewayAttachmentId) : undefined));
  ret.addPropertyResult("transitGatewayRouteTableId", "TransitGatewayRouteTableId", (properties.TransitGatewayRouteTableId != null ? cfn_parse.FromCloudFormation.getString(properties.TransitGatewayRouteTableId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Enables the specified attachment to propagate routes to the specified propagation route table.
 *
 * For more information about enabling transit gateway route propagation, see [EnableTransitGatewayRouteTablePropagation](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_EnableTransitGatewayRouteTablePropagation.html) in the *Amazon EC2 API Reference* .
 *
 * @cloudformationResource AWS::EC2::TransitGatewayRouteTablePropagation
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetablepropagation.html
 */
export class CfnTransitGatewayRouteTablePropagation extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::TransitGatewayRouteTablePropagation";

  /**
   * Build a CfnTransitGatewayRouteTablePropagation from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnTransitGatewayRouteTablePropagation {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnTransitGatewayRouteTablePropagationPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnTransitGatewayRouteTablePropagation(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The ID of the attachment.
   */
  public transitGatewayAttachmentId: string;

  /**
   * The ID of the propagation route table.
   */
  public transitGatewayRouteTableId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnTransitGatewayRouteTablePropagationProps) {
    super(scope, id, {
      "type": CfnTransitGatewayRouteTablePropagation.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "transitGatewayAttachmentId", this);
    cdk.requireProperty(props, "transitGatewayRouteTableId", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.transitGatewayAttachmentId = props.transitGatewayAttachmentId;
    this.transitGatewayRouteTableId = props.transitGatewayRouteTableId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "transitGatewayAttachmentId": this.transitGatewayAttachmentId,
      "transitGatewayRouteTableId": this.transitGatewayRouteTableId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnTransitGatewayRouteTablePropagation.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnTransitGatewayRouteTablePropagationPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a `CfnTransitGatewayRouteTablePropagation`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetablepropagation.html
 */
export interface CfnTransitGatewayRouteTablePropagationProps {
  /**
   * The ID of the attachment.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetablepropagation.html#cfn-ec2-transitgatewayroutetablepropagation-transitgatewayattachmentid
   */
  readonly transitGatewayAttachmentId: string;

  /**
   * The ID of the propagation route table.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetablepropagation.html#cfn-ec2-transitgatewayroutetablepropagation-transitgatewayroutetableid
   */
  readonly transitGatewayRouteTableId: string;
}

/**
 * Determine whether the given properties match those of a `CfnTransitGatewayRouteTablePropagationProps`
 *
 * @param properties - the TypeScript properties of a `CfnTransitGatewayRouteTablePropagationProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTransitGatewayRouteTablePropagationPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("transitGatewayAttachmentId", cdk.requiredValidator)(properties.transitGatewayAttachmentId));
  errors.collect(cdk.propertyValidator("transitGatewayAttachmentId", cdk.validateString)(properties.transitGatewayAttachmentId));
  errors.collect(cdk.propertyValidator("transitGatewayRouteTableId", cdk.requiredValidator)(properties.transitGatewayRouteTableId));
  errors.collect(cdk.propertyValidator("transitGatewayRouteTableId", cdk.validateString)(properties.transitGatewayRouteTableId));
  return errors.wrap("supplied properties not correct for \"CfnTransitGatewayRouteTablePropagationProps\"");
}

// @ts-ignore TS6133
function convertCfnTransitGatewayRouteTablePropagationPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTransitGatewayRouteTablePropagationPropsValidator(properties).assertSuccess();
  return {
    "TransitGatewayAttachmentId": cdk.stringToCloudFormation(properties.transitGatewayAttachmentId),
    "TransitGatewayRouteTableId": cdk.stringToCloudFormation(properties.transitGatewayRouteTableId)
  };
}

// @ts-ignore TS6133
function CfnTransitGatewayRouteTablePropagationPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnTransitGatewayRouteTablePropagationProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTransitGatewayRouteTablePropagationProps>();
  ret.addPropertyResult("transitGatewayAttachmentId", "TransitGatewayAttachmentId", (properties.TransitGatewayAttachmentId != null ? cfn_parse.FromCloudFormation.getString(properties.TransitGatewayAttachmentId) : undefined));
  ret.addPropertyResult("transitGatewayRouteTableId", "TransitGatewayRouteTableId", (properties.TransitGatewayRouteTableId != null ? cfn_parse.FromCloudFormation.getString(properties.TransitGatewayRouteTableId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a VPC attachment.
 *
 * @cloudformationResource AWS::EC2::TransitGatewayVpcAttachment
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html
 */
export class CfnTransitGatewayVpcAttachment extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::TransitGatewayVpcAttachment";

  /**
   * Build a CfnTransitGatewayVpcAttachment from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnTransitGatewayVpcAttachment {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnTransitGatewayVpcAttachmentPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnTransitGatewayVpcAttachment(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the attachment.
   *
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The IDs of one or more subnets to add.
   */
  public addSubnetIds?: Array<string>;

  /**
   * The VPC attachment options.
   */
  public options?: any | cdk.IResolvable;

  /**
   * The IDs of one or more subnets to remove.
   */
  public removeSubnetIds?: Array<string>;

  /**
   * The IDs of the subnets.
   */
  public subnetIds: Array<string>;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags for the VPC attachment.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The ID of the transit gateway.
   */
  public transitGatewayId: string;

  /**
   * The ID of the VPC.
   */
  public vpcId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnTransitGatewayVpcAttachmentProps) {
    super(scope, id, {
      "type": CfnTransitGatewayVpcAttachment.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "subnetIds", this);
    cdk.requireProperty(props, "transitGatewayId", this);
    cdk.requireProperty(props, "vpcId", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.addSubnetIds = props.addSubnetIds;
    this.options = props.options;
    this.removeSubnetIds = props.removeSubnetIds;
    this.subnetIds = props.subnetIds;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::TransitGatewayVpcAttachment", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.transitGatewayId = props.transitGatewayId;
    this.vpcId = props.vpcId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "addSubnetIds": this.addSubnetIds,
      "options": this.options,
      "removeSubnetIds": this.removeSubnetIds,
      "subnetIds": this.subnetIds,
      "tags": this.tags.renderTags(),
      "transitGatewayId": this.transitGatewayId,
      "vpcId": this.vpcId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnTransitGatewayVpcAttachment.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnTransitGatewayVpcAttachmentPropsToCloudFormation(props);
  }
}

export namespace CfnTransitGatewayVpcAttachment {
  /**
   * Describes the VPC attachment options.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayvpcattachment-options.html
   */
  export interface OptionsProperty {
    /**
     * Enable or disable appliance mode support.
     *
     * The default is `disable` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayvpcattachment-options.html#cfn-ec2-transitgatewayvpcattachment-options-appliancemodesupport
     */
    readonly applianceModeSupport?: string;

    /**
     * Enable or disable DNS support.
     *
     * The default is `disable` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayvpcattachment-options.html#cfn-ec2-transitgatewayvpcattachment-options-dnssupport
     */
    readonly dnsSupport?: string;

    /**
     * Enable or disable IPv6 support.
     *
     * The default is `disable` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayvpcattachment-options.html#cfn-ec2-transitgatewayvpcattachment-options-ipv6support
     */
    readonly ipv6Support?: string;
  }
}

/**
 * Properties for defining a `CfnTransitGatewayVpcAttachment`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html
 */
export interface CfnTransitGatewayVpcAttachmentProps {
  /**
   * The IDs of one or more subnets to add.
   *
   * You can specify at most one subnet per Availability Zone.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-addsubnetids
   */
  readonly addSubnetIds?: Array<string>;

  /**
   * The VPC attachment options.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-options
   */
  readonly options?: any | cdk.IResolvable;

  /**
   * The IDs of one or more subnets to remove.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-removesubnetids
   */
  readonly removeSubnetIds?: Array<string>;

  /**
   * The IDs of the subnets.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-subnetids
   */
  readonly subnetIds: Array<string>;

  /**
   * The tags for the VPC attachment.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The ID of the transit gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-transitgatewayid
   */
  readonly transitGatewayId: string;

  /**
   * The ID of the VPC.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-vpcid
   */
  readonly vpcId: string;
}

/**
 * Determine whether the given properties match those of a `OptionsProperty`
 *
 * @param properties - the TypeScript properties of a `OptionsProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTransitGatewayVpcAttachmentOptionsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("applianceModeSupport", cdk.validateString)(properties.applianceModeSupport));
  errors.collect(cdk.propertyValidator("dnsSupport", cdk.validateString)(properties.dnsSupport));
  errors.collect(cdk.propertyValidator("ipv6Support", cdk.validateString)(properties.ipv6Support));
  return errors.wrap("supplied properties not correct for \"OptionsProperty\"");
}

// @ts-ignore TS6133
function convertCfnTransitGatewayVpcAttachmentOptionsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTransitGatewayVpcAttachmentOptionsPropertyValidator(properties).assertSuccess();
  return {
    "ApplianceModeSupport": cdk.stringToCloudFormation(properties.applianceModeSupport),
    "DnsSupport": cdk.stringToCloudFormation(properties.dnsSupport),
    "Ipv6Support": cdk.stringToCloudFormation(properties.ipv6Support)
  };
}

// @ts-ignore TS6133
function CfnTransitGatewayVpcAttachmentOptionsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnTransitGatewayVpcAttachment.OptionsProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTransitGatewayVpcAttachment.OptionsProperty>();
  ret.addPropertyResult("applianceModeSupport", "ApplianceModeSupport", (properties.ApplianceModeSupport != null ? cfn_parse.FromCloudFormation.getString(properties.ApplianceModeSupport) : undefined));
  ret.addPropertyResult("dnsSupport", "DnsSupport", (properties.DnsSupport != null ? cfn_parse.FromCloudFormation.getString(properties.DnsSupport) : undefined));
  ret.addPropertyResult("ipv6Support", "Ipv6Support", (properties.Ipv6Support != null ? cfn_parse.FromCloudFormation.getString(properties.Ipv6Support) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `CfnTransitGatewayVpcAttachmentProps`
 *
 * @param properties - the TypeScript properties of a `CfnTransitGatewayVpcAttachmentProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTransitGatewayVpcAttachmentPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("addSubnetIds", cdk.listValidator(cdk.validateString))(properties.addSubnetIds));
  errors.collect(cdk.propertyValidator("options", cdk.validateObject)(properties.options));
  errors.collect(cdk.propertyValidator("removeSubnetIds", cdk.listValidator(cdk.validateString))(properties.removeSubnetIds));
  errors.collect(cdk.propertyValidator("subnetIds", cdk.requiredValidator)(properties.subnetIds));
  errors.collect(cdk.propertyValidator("subnetIds", cdk.listValidator(cdk.validateString))(properties.subnetIds));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("transitGatewayId", cdk.requiredValidator)(properties.transitGatewayId));
  errors.collect(cdk.propertyValidator("transitGatewayId", cdk.validateString)(properties.transitGatewayId));
  errors.collect(cdk.propertyValidator("vpcId", cdk.requiredValidator)(properties.vpcId));
  errors.collect(cdk.propertyValidator("vpcId", cdk.validateString)(properties.vpcId));
  return errors.wrap("supplied properties not correct for \"CfnTransitGatewayVpcAttachmentProps\"");
}

// @ts-ignore TS6133
function convertCfnTransitGatewayVpcAttachmentPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTransitGatewayVpcAttachmentPropsValidator(properties).assertSuccess();
  return {
    "AddSubnetIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.addSubnetIds),
    "Options": cdk.objectToCloudFormation(properties.options),
    "RemoveSubnetIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.removeSubnetIds),
    "SubnetIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.subnetIds),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "TransitGatewayId": cdk.stringToCloudFormation(properties.transitGatewayId),
    "VpcId": cdk.stringToCloudFormation(properties.vpcId)
  };
}

// @ts-ignore TS6133
function CfnTransitGatewayVpcAttachmentPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnTransitGatewayVpcAttachmentProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTransitGatewayVpcAttachmentProps>();
  ret.addPropertyResult("addSubnetIds", "AddSubnetIds", (properties.AddSubnetIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.AddSubnetIds) : undefined));
  ret.addPropertyResult("options", "Options", (properties.Options != null ? cfn_parse.FromCloudFormation.getAny(properties.Options) : undefined));
  ret.addPropertyResult("removeSubnetIds", "RemoveSubnetIds", (properties.RemoveSubnetIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.RemoveSubnetIds) : undefined));
  ret.addPropertyResult("subnetIds", "SubnetIds", (properties.SubnetIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SubnetIds) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("transitGatewayId", "TransitGatewayId", (properties.TransitGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.TransitGatewayId) : undefined));
  ret.addPropertyResult("vpcId", "VpcId", (properties.VpcId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a virtual private cloud (VPC).
 *
 * You can optionally request an IPv6 CIDR block for the VPC. You can request an Amazon-provided IPv6 CIDR block from Amazon's pool of IPv6 addresses, or an IPv6 CIDR block from an IPv6 address pool that you provisioned through bring your own IP addresses (BYOIP).
 *
 * For more information, see [Virtual private clouds (VPC)](https://docs.aws.amazon.com/vpc/latest/userguide/configure-your-vpc.html) in the *Amazon VPC User Guide* .
 *
 * @cloudformationResource AWS::EC2::VPC
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html
 */
export class CfnVPC extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::VPC";

  /**
   * Build a CfnVPC from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnVPC {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnVPCPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnVPC(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The primary IPv4 CIDR block for the VPC. For example, 10.0.0.0/16.
   *
   * @cloudformationAttribute CidrBlock
   */
  public readonly attrCidrBlock: string;

  /**
   * The association IDs of the IPv4 CIDR blocks for the VPC. For example, [ vpc-cidr-assoc-0280ab6b ].
   *
   * @cloudformationAttribute CidrBlockAssociations
   */
  public readonly attrCidrBlockAssociations: Array<string>;

  /**
   * The ID of the default network ACL for the VPC. For example, acl-814dafe3.
   *
   * @cloudformationAttribute DefaultNetworkAcl
   */
  public readonly attrDefaultNetworkAcl: string;

  /**
   * The ID of the default security group for the VPC. For example, sg-b178e0d3.
   *
   * @cloudformationAttribute DefaultSecurityGroup
   */
  public readonly attrDefaultSecurityGroup: string;

  /**
   * The IPv6 CIDR blocks for the VPC. For example, [ 2001:db8:1234:1a00::/56 ].
   *
   * @cloudformationAttribute Ipv6CidrBlocks
   */
  public readonly attrIpv6CidrBlocks: Array<string>;

  /**
   * The ID of the VPC.
   *
   * @cloudformationAttribute VpcId
   */
  public readonly attrVpcId: string;

  /**
   * The IPv4 network range for the VPC, in CIDR notation.
   */
  public cidrBlock?: string;

  /**
   * Indicates whether the instances launched in the VPC get DNS hostnames.
   */
  public enableDnsHostnames?: boolean | cdk.IResolvable;

  /**
   * Indicates whether the DNS resolution is supported for the VPC.
   */
  public enableDnsSupport?: boolean | cdk.IResolvable;

  /**
   * The allowed tenancy of instances launched into the VPC.
   */
  public instanceTenancy?: string;

  /**
   * The ID of an IPv4 IPAM pool you want to use for allocating this VPC's CIDR.
   */
  public ipv4IpamPoolId?: string;

  /**
   * The netmask length of the IPv4 CIDR you want to allocate to this VPC from an Amazon VPC IP Address Manager (IPAM) pool.
   */
  public ipv4NetmaskLength?: number;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags for the VPC.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnVPCProps = {}) {
    super(scope, id, {
      "type": CfnVPC.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.attrCidrBlock = cdk.Token.asString(this.getAtt("CidrBlock", cdk.ResolutionTypeHint.STRING));
    this.attrCidrBlockAssociations = cdk.Token.asList(this.getAtt("CidrBlockAssociations", cdk.ResolutionTypeHint.STRING_LIST));
    this.attrDefaultNetworkAcl = cdk.Token.asString(this.getAtt("DefaultNetworkAcl", cdk.ResolutionTypeHint.STRING));
    this.attrDefaultSecurityGroup = cdk.Token.asString(this.getAtt("DefaultSecurityGroup", cdk.ResolutionTypeHint.STRING));
    this.attrIpv6CidrBlocks = cdk.Token.asList(this.getAtt("Ipv6CidrBlocks", cdk.ResolutionTypeHint.STRING_LIST));
    this.attrVpcId = cdk.Token.asString(this.getAtt("VpcId", cdk.ResolutionTypeHint.STRING));
    this.cidrBlock = props.cidrBlock;
    this.enableDnsHostnames = props.enableDnsHostnames;
    this.enableDnsSupport = props.enableDnsSupport;
    this.instanceTenancy = props.instanceTenancy;
    this.ipv4IpamPoolId = props.ipv4IpamPoolId;
    this.ipv4NetmaskLength = props.ipv4NetmaskLength;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::VPC", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "cidrBlock": this.cidrBlock,
      "enableDnsHostnames": this.enableDnsHostnames,
      "enableDnsSupport": this.enableDnsSupport,
      "instanceTenancy": this.instanceTenancy,
      "ipv4IpamPoolId": this.ipv4IpamPoolId,
      "ipv4NetmaskLength": this.ipv4NetmaskLength,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnVPC.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnVPCPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a `CfnVPC`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html
 */
export interface CfnVPCProps {
  /**
   * The IPv4 network range for the VPC, in CIDR notation.
   *
   * For example, `10.0.0.0/16` . We modify the specified CIDR block to its canonical form; for example, if you specify `100.68.0.18/18` , we modify it to `100.68.0.0/18` .
   *
   * You must specify either `CidrBlock` or `Ipv4IpamPoolId` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html#cfn-ec2-vpc-cidrblock
   */
  readonly cidrBlock?: string;

  /**
   * Indicates whether the instances launched in the VPC get DNS hostnames.
   *
   * If enabled, instances in the VPC get DNS hostnames; otherwise, they do not. Disabled by default for nondefault VPCs. For more information, see [DNS attributes in your VPC](https://docs.aws.amazon.com/vpc/latest/userguide/vpc-dns.html#vpc-dns-support) .
   *
   * You can only enable DNS hostnames if you've enabled DNS support.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html#cfn-ec2-vpc-enablednshostnames
   */
  readonly enableDnsHostnames?: boolean | cdk.IResolvable;

  /**
   * Indicates whether the DNS resolution is supported for the VPC.
   *
   * If enabled, queries to the Amazon provided DNS server at the 169.254.169.253 IP address, or the reserved IP address at the base of the VPC network range "plus two" succeed. If disabled, the Amazon provided DNS service in the VPC that resolves public DNS hostnames to IP addresses is not enabled. Enabled by default. For more information, see [DNS attributes in your VPC](https://docs.aws.amazon.com/vpc/latest/userguide/vpc-dns.html#vpc-dns-support) .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html#cfn-ec2-vpc-enablednssupport
   */
  readonly enableDnsSupport?: boolean | cdk.IResolvable;

  /**
   * The allowed tenancy of instances launched into the VPC.
   *
   * - `default` : An instance launched into the VPC runs on shared hardware by default, unless you explicitly specify a different tenancy during instance launch.
   * - `dedicated` : An instance launched into the VPC runs on dedicated hardware by default, unless you explicitly specify a tenancy of `host` during instance launch. You cannot specify a tenancy of `default` during instance launch.
   *
   * Updating `InstanceTenancy` requires no replacement only if you are updating its value from `dedicated` to `default` . Updating `InstanceTenancy` from `default` to `dedicated` requires replacement.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html#cfn-ec2-vpc-instancetenancy
   */
  readonly instanceTenancy?: string;

  /**
   * The ID of an IPv4 IPAM pool you want to use for allocating this VPC's CIDR.
   *
   * For more information, see [What is IPAM?](https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html) in the *Amazon VPC IPAM User Guide* .
   *
   * You must specify either `CidrBlock` or `Ipv4IpamPoolId` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html#cfn-ec2-vpc-ipv4ipampoolid
   */
  readonly ipv4IpamPoolId?: string;

  /**
   * The netmask length of the IPv4 CIDR you want to allocate to this VPC from an Amazon VPC IP Address Manager (IPAM) pool.
   *
   * For more information about IPAM, see [What is IPAM?](https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html) in the *Amazon VPC IPAM User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html#cfn-ec2-vpc-ipv4netmasklength
   */
  readonly ipv4NetmaskLength?: number;

  /**
   * The tags for the VPC.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html#cfn-ec2-vpc-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a `CfnVPCProps`
 *
 * @param properties - the TypeScript properties of a `CfnVPCProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVPCPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("cidrBlock", cdk.validateString)(properties.cidrBlock));
  errors.collect(cdk.propertyValidator("enableDnsHostnames", cdk.validateBoolean)(properties.enableDnsHostnames));
  errors.collect(cdk.propertyValidator("enableDnsSupport", cdk.validateBoolean)(properties.enableDnsSupport));
  errors.collect(cdk.propertyValidator("instanceTenancy", cdk.validateString)(properties.instanceTenancy));
  errors.collect(cdk.propertyValidator("ipv4IpamPoolId", cdk.validateString)(properties.ipv4IpamPoolId));
  errors.collect(cdk.propertyValidator("ipv4NetmaskLength", cdk.validateNumber)(properties.ipv4NetmaskLength));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \"CfnVPCProps\"");
}

// @ts-ignore TS6133
function convertCfnVPCPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVPCPropsValidator(properties).assertSuccess();
  return {
    "CidrBlock": cdk.stringToCloudFormation(properties.cidrBlock),
    "EnableDnsHostnames": cdk.booleanToCloudFormation(properties.enableDnsHostnames),
    "EnableDnsSupport": cdk.booleanToCloudFormation(properties.enableDnsSupport),
    "InstanceTenancy": cdk.stringToCloudFormation(properties.instanceTenancy),
    "Ipv4IpamPoolId": cdk.stringToCloudFormation(properties.ipv4IpamPoolId),
    "Ipv4NetmaskLength": cdk.numberToCloudFormation(properties.ipv4NetmaskLength),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnVPCPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnVPCProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVPCProps>();
  ret.addPropertyResult("cidrBlock", "CidrBlock", (properties.CidrBlock != null ? cfn_parse.FromCloudFormation.getString(properties.CidrBlock) : undefined));
  ret.addPropertyResult("enableDnsHostnames", "EnableDnsHostnames", (properties.EnableDnsHostnames != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EnableDnsHostnames) : undefined));
  ret.addPropertyResult("enableDnsSupport", "EnableDnsSupport", (properties.EnableDnsSupport != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EnableDnsSupport) : undefined));
  ret.addPropertyResult("instanceTenancy", "InstanceTenancy", (properties.InstanceTenancy != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceTenancy) : undefined));
  ret.addPropertyResult("ipv4IpamPoolId", "Ipv4IpamPoolId", (properties.Ipv4IpamPoolId != null ? cfn_parse.FromCloudFormation.getString(properties.Ipv4IpamPoolId) : undefined));
  ret.addPropertyResult("ipv4NetmaskLength", "Ipv4NetmaskLength", (properties.Ipv4NetmaskLength != null ? cfn_parse.FromCloudFormation.getNumber(properties.Ipv4NetmaskLength) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Associates a CIDR block with your VPC. You can only associate a single IPv6 CIDR block with your VPC.
 *
 * For more information about associating CIDR blocks with your VPC and applicable restrictions, see [VPC and Subnet Sizing](https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Subnets.html#VPC_Sizing) in the *Amazon VPC User Guide* .
 *
 * @cloudformationResource AWS::EC2::VPCCidrBlock
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html
 */
export class CfnVPCCidrBlock extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::VPCCidrBlock";

  /**
   * Build a CfnVPCCidrBlock from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnVPCCidrBlock {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnVPCCidrBlockPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnVPCCidrBlock(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * Requests an Amazon-provided IPv6 CIDR block with a /56 prefix length for the VPC.
   */
  public amazonProvidedIpv6CidrBlock?: boolean | cdk.IResolvable;

  /**
   * An IPv4 CIDR block to associate with the VPC.
   */
  public cidrBlock?: string;

  /**
   * Associate a CIDR allocated from an IPv4 IPAM pool to a VPC.
   */
  public ipv4IpamPoolId?: string;

  /**
   * The netmask length of the IPv4 CIDR you would like to associate from an Amazon VPC IP Address Manager (IPAM) pool.
   */
  public ipv4NetmaskLength?: number;

  /**
   * An IPv6 CIDR block from the IPv6 address pool. You must also specify `Ipv6Pool` in the request.
   */
  public ipv6CidrBlock?: string;

  /**
   * Associates a CIDR allocated from an IPv6 IPAM pool to a VPC.
   */
  public ipv6IpamPoolId?: string;

  /**
   * The netmask length of the IPv6 CIDR you would like to associate from an Amazon VPC IP Address Manager (IPAM) pool.
   */
  public ipv6NetmaskLength?: number;

  /**
   * The ID of an IPv6 address pool from which to allocate the IPv6 CIDR block.
   */
  public ipv6Pool?: string;

  /**
   * The ID of the VPC.
   */
  public vpcId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnVPCCidrBlockProps) {
    super(scope, id, {
      "type": CfnVPCCidrBlock.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "vpcId", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.amazonProvidedIpv6CidrBlock = props.amazonProvidedIpv6CidrBlock;
    this.cidrBlock = props.cidrBlock;
    this.ipv4IpamPoolId = props.ipv4IpamPoolId;
    this.ipv4NetmaskLength = props.ipv4NetmaskLength;
    this.ipv6CidrBlock = props.ipv6CidrBlock;
    this.ipv6IpamPoolId = props.ipv6IpamPoolId;
    this.ipv6NetmaskLength = props.ipv6NetmaskLength;
    this.ipv6Pool = props.ipv6Pool;
    this.vpcId = props.vpcId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "amazonProvidedIpv6CidrBlock": this.amazonProvidedIpv6CidrBlock,
      "cidrBlock": this.cidrBlock,
      "ipv4IpamPoolId": this.ipv4IpamPoolId,
      "ipv4NetmaskLength": this.ipv4NetmaskLength,
      "ipv6CidrBlock": this.ipv6CidrBlock,
      "ipv6IpamPoolId": this.ipv6IpamPoolId,
      "ipv6NetmaskLength": this.ipv6NetmaskLength,
      "ipv6Pool": this.ipv6Pool,
      "vpcId": this.vpcId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnVPCCidrBlock.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnVPCCidrBlockPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a `CfnVPCCidrBlock`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html
 */
export interface CfnVPCCidrBlockProps {
  /**
   * Requests an Amazon-provided IPv6 CIDR block with a /56 prefix length for the VPC.
   *
   * You cannot specify the range of IPv6 addresses or the size of the CIDR block.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-amazonprovidedipv6cidrblock
   */
  readonly amazonProvidedIpv6CidrBlock?: boolean | cdk.IResolvable;

  /**
   * An IPv4 CIDR block to associate with the VPC.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-cidrblock
   */
  readonly cidrBlock?: string;

  /**
   * Associate a CIDR allocated from an IPv4 IPAM pool to a VPC.
   *
   * For more information about Amazon VPC IP Address Manager (IPAM), see [What is IPAM?](https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html) in the *Amazon VPC IPAM User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-ipv4ipampoolid
   */
  readonly ipv4IpamPoolId?: string;

  /**
   * The netmask length of the IPv4 CIDR you would like to associate from an Amazon VPC IP Address Manager (IPAM) pool.
   *
   * For more information about IPAM, see [What is IPAM?](https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html) in the *Amazon VPC IPAM User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-ipv4netmasklength
   */
  readonly ipv4NetmaskLength?: number;

  /**
   * An IPv6 CIDR block from the IPv6 address pool. You must also specify `Ipv6Pool` in the request.
   *
   * To let Amazon choose the IPv6 CIDR block for you, omit this parameter.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-ipv6cidrblock
   */
  readonly ipv6CidrBlock?: string;

  /**
   * Associates a CIDR allocated from an IPv6 IPAM pool to a VPC.
   *
   * For more information about Amazon VPC IP Address Manager (IPAM), see [What is IPAM?](https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html) in the *Amazon VPC IPAM User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-ipv6ipampoolid
   */
  readonly ipv6IpamPoolId?: string;

  /**
   * The netmask length of the IPv6 CIDR you would like to associate from an Amazon VPC IP Address Manager (IPAM) pool.
   *
   * For more information about IPAM, see [What is IPAM?](https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html) in the *Amazon VPC IPAM User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-ipv6netmasklength
   */
  readonly ipv6NetmaskLength?: number;

  /**
   * The ID of an IPv6 address pool from which to allocate the IPv6 CIDR block.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-ipv6pool
   */
  readonly ipv6Pool?: string;

  /**
   * The ID of the VPC.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-vpcid
   */
  readonly vpcId: string;
}

/**
 * Determine whether the given properties match those of a `CfnVPCCidrBlockProps`
 *
 * @param properties - the TypeScript properties of a `CfnVPCCidrBlockProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVPCCidrBlockPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("amazonProvidedIpv6CidrBlock", cdk.validateBoolean)(properties.amazonProvidedIpv6CidrBlock));
  errors.collect(cdk.propertyValidator("cidrBlock", cdk.validateString)(properties.cidrBlock));
  errors.collect(cdk.propertyValidator("ipv4IpamPoolId", cdk.validateString)(properties.ipv4IpamPoolId));
  errors.collect(cdk.propertyValidator("ipv4NetmaskLength", cdk.validateNumber)(properties.ipv4NetmaskLength));
  errors.collect(cdk.propertyValidator("ipv6CidrBlock", cdk.validateString)(properties.ipv6CidrBlock));
  errors.collect(cdk.propertyValidator("ipv6IpamPoolId", cdk.validateString)(properties.ipv6IpamPoolId));
  errors.collect(cdk.propertyValidator("ipv6NetmaskLength", cdk.validateNumber)(properties.ipv6NetmaskLength));
  errors.collect(cdk.propertyValidator("ipv6Pool", cdk.validateString)(properties.ipv6Pool));
  errors.collect(cdk.propertyValidator("vpcId", cdk.requiredValidator)(properties.vpcId));
  errors.collect(cdk.propertyValidator("vpcId", cdk.validateString)(properties.vpcId));
  return errors.wrap("supplied properties not correct for \"CfnVPCCidrBlockProps\"");
}

// @ts-ignore TS6133
function convertCfnVPCCidrBlockPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVPCCidrBlockPropsValidator(properties).assertSuccess();
  return {
    "AmazonProvidedIpv6CidrBlock": cdk.booleanToCloudFormation(properties.amazonProvidedIpv6CidrBlock),
    "CidrBlock": cdk.stringToCloudFormation(properties.cidrBlock),
    "Ipv4IpamPoolId": cdk.stringToCloudFormation(properties.ipv4IpamPoolId),
    "Ipv4NetmaskLength": cdk.numberToCloudFormation(properties.ipv4NetmaskLength),
    "Ipv6CidrBlock": cdk.stringToCloudFormation(properties.ipv6CidrBlock),
    "Ipv6IpamPoolId": cdk.stringToCloudFormation(properties.ipv6IpamPoolId),
    "Ipv6NetmaskLength": cdk.numberToCloudFormation(properties.ipv6NetmaskLength),
    "Ipv6Pool": cdk.stringToCloudFormation(properties.ipv6Pool),
    "VpcId": cdk.stringToCloudFormation(properties.vpcId)
  };
}

// @ts-ignore TS6133
function CfnVPCCidrBlockPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnVPCCidrBlockProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVPCCidrBlockProps>();
  ret.addPropertyResult("amazonProvidedIpv6CidrBlock", "AmazonProvidedIpv6CidrBlock", (properties.AmazonProvidedIpv6CidrBlock != null ? cfn_parse.FromCloudFormation.getBoolean(properties.AmazonProvidedIpv6CidrBlock) : undefined));
  ret.addPropertyResult("cidrBlock", "CidrBlock", (properties.CidrBlock != null ? cfn_parse.FromCloudFormation.getString(properties.CidrBlock) : undefined));
  ret.addPropertyResult("ipv4IpamPoolId", "Ipv4IpamPoolId", (properties.Ipv4IpamPoolId != null ? cfn_parse.FromCloudFormation.getString(properties.Ipv4IpamPoolId) : undefined));
  ret.addPropertyResult("ipv4NetmaskLength", "Ipv4NetmaskLength", (properties.Ipv4NetmaskLength != null ? cfn_parse.FromCloudFormation.getNumber(properties.Ipv4NetmaskLength) : undefined));
  ret.addPropertyResult("ipv6CidrBlock", "Ipv6CidrBlock", (properties.Ipv6CidrBlock != null ? cfn_parse.FromCloudFormation.getString(properties.Ipv6CidrBlock) : undefined));
  ret.addPropertyResult("ipv6IpamPoolId", "Ipv6IpamPoolId", (properties.Ipv6IpamPoolId != null ? cfn_parse.FromCloudFormation.getString(properties.Ipv6IpamPoolId) : undefined));
  ret.addPropertyResult("ipv6NetmaskLength", "Ipv6NetmaskLength", (properties.Ipv6NetmaskLength != null ? cfn_parse.FromCloudFormation.getNumber(properties.Ipv6NetmaskLength) : undefined));
  ret.addPropertyResult("ipv6Pool", "Ipv6Pool", (properties.Ipv6Pool != null ? cfn_parse.FromCloudFormation.getString(properties.Ipv6Pool) : undefined));
  ret.addPropertyResult("vpcId", "VpcId", (properties.VpcId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Associates a set of DHCP options with a VPC, or associates no DHCP options with the VPC.
 *
 * After you associate the options with the VPC, any existing instances and all new instances that you launch in that VPC use the options. You don't need to restart or relaunch the instances. They automatically pick up the changes within a few hours, depending on how frequently the instance renews its DHCP lease. You can explicitly renew the lease using the operating system on the instance.
 *
 * @cloudformationResource AWS::EC2::VPCDHCPOptionsAssociation
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcdhcpoptionsassociation.html
 */
export class CfnVPCDHCPOptionsAssociation extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::VPCDHCPOptionsAssociation";

  /**
   * Build a CfnVPCDHCPOptionsAssociation from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnVPCDHCPOptionsAssociation {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnVPCDHCPOptionsAssociationPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnVPCDHCPOptionsAssociation(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the DHCP options set, or `default` to associate no DHCP options with the VPC.
   */
  public dhcpOptionsId: string;

  /**
   * The ID of the VPC.
   */
  public vpcId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnVPCDHCPOptionsAssociationProps) {
    super(scope, id, {
      "type": CfnVPCDHCPOptionsAssociation.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "dhcpOptionsId", this);
    cdk.requireProperty(props, "vpcId", this);

    this.dhcpOptionsId = props.dhcpOptionsId;
    this.vpcId = props.vpcId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "dhcpOptionsId": this.dhcpOptionsId,
      "vpcId": this.vpcId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnVPCDHCPOptionsAssociation.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnVPCDHCPOptionsAssociationPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a `CfnVPCDHCPOptionsAssociation`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcdhcpoptionsassociation.html
 */
export interface CfnVPCDHCPOptionsAssociationProps {
  /**
   * The ID of the DHCP options set, or `default` to associate no DHCP options with the VPC.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcdhcpoptionsassociation.html#cfn-ec2-vpcdhcpoptionsassociation-dhcpoptionsid
   */
  readonly dhcpOptionsId: string;

  /**
   * The ID of the VPC.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcdhcpoptionsassociation.html#cfn-ec2-vpcdhcpoptionsassociation-vpcid
   */
  readonly vpcId: string;
}

/**
 * Determine whether the given properties match those of a `CfnVPCDHCPOptionsAssociationProps`
 *
 * @param properties - the TypeScript properties of a `CfnVPCDHCPOptionsAssociationProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVPCDHCPOptionsAssociationPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("dhcpOptionsId", cdk.requiredValidator)(properties.dhcpOptionsId));
  errors.collect(cdk.propertyValidator("dhcpOptionsId", cdk.validateString)(properties.dhcpOptionsId));
  errors.collect(cdk.propertyValidator("vpcId", cdk.requiredValidator)(properties.vpcId));
  errors.collect(cdk.propertyValidator("vpcId", cdk.validateString)(properties.vpcId));
  return errors.wrap("supplied properties not correct for \"CfnVPCDHCPOptionsAssociationProps\"");
}

// @ts-ignore TS6133
function convertCfnVPCDHCPOptionsAssociationPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVPCDHCPOptionsAssociationPropsValidator(properties).assertSuccess();
  return {
    "DhcpOptionsId": cdk.stringToCloudFormation(properties.dhcpOptionsId),
    "VpcId": cdk.stringToCloudFormation(properties.vpcId)
  };
}

// @ts-ignore TS6133
function CfnVPCDHCPOptionsAssociationPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnVPCDHCPOptionsAssociationProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVPCDHCPOptionsAssociationProps>();
  ret.addPropertyResult("dhcpOptionsId", "DhcpOptionsId", (properties.DhcpOptionsId != null ? cfn_parse.FromCloudFormation.getString(properties.DhcpOptionsId) : undefined));
  ret.addPropertyResult("vpcId", "VpcId", (properties.VpcId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a VPC endpoint.
 *
 * A VPC endpoint provides a private connection between your VPC and an endpoint service. You can use an endpoint service provided by AWS , an AWS Marketplace Partner, or another AWS accounts in your organization. For more information, see the [AWS PrivateLink User Guide](https://docs.aws.amazon.com/vpc/latest/privatelink/) .
 *
 * An endpoint of type `Interface` establishes connections between the subnets in your VPC and an AWS service , your own service, or a service hosted by another AWS account . With an interface VPC endpoint, you specify the subnets in which to create the endpoint and the security groups to associate with the endpoint network interfaces.
 *
 * An endpoint of type `gateway` serves as a target for a route in your route table for traffic destined for Amazon S3 or DynamoDB . You can specify an endpoint policy for the endpoint, which controls access to the service from your VPC. You can also specify the VPC route tables that use the endpoint. For more information about connectivity to Amazon S3 , see [Why can't I connect to an S3 bucket using a gateway VPC endpoint?](https://docs.aws.amazon.com/premiumsupport/knowledge-center/connect-s3-vpc-endpoint)
 *
 * An endpoint of type `GatewayLoadBalancer` provides private connectivity between your VPC and virtual appliances from a service provider.
 *
 * @cloudformationResource AWS::EC2::VPCEndpoint
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html
 */
export class CfnVPCEndpoint extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::VPCEndpoint";

  /**
   * Build a CfnVPCEndpoint from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnVPCEndpoint {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnVPCEndpointPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnVPCEndpoint(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The date and time the VPC endpoint was created. For example: `Fri Sep 28 23:34:36 UTC 2018.`
   *
   * @cloudformationAttribute CreationTimestamp
   */
  public readonly attrCreationTimestamp: string;

  /**
   * (Interface endpoints) The DNS entries for the endpoint. Each entry is a combination of the hosted zone ID and the DNS name. The entries are ordered as follows: regional public DNS, zonal public DNS, private DNS, and wildcard DNS. This order is not enforced for AWS Marketplace services.
   *
   * The following is an example. In the first entry, the hosted zone ID is Z1HUB23UULQXV and the DNS name is vpce-01abc23456de78f9g-12abccd3.ec2.us-east-1.vpce.amazonaws.com.
   *
   * ["Z1HUB23UULQXV:vpce-01abc23456de78f9g-12abccd3.ec2.us-east-1.vpce.amazonaws.com", "Z1HUB23UULQXV:vpce-01abc23456de78f9g-12abccd3-us-east-1a.ec2.us-east-1.vpce.amazonaws.com", "Z1C12344VYDITB0:ec2.us-east-1.amazonaws.com"]
   *
   * If you update the `PrivateDnsEnabled` or `SubnetIds` properties, the DNS entries in the list will change.
   *
   * @cloudformationAttribute DnsEntries
   */
  public readonly attrDnsEntries: Array<string>;

  /**
   * The ID of the VPC endpoint.
   *
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * (Interface endpoints) The network interface IDs. If you update the `PrivateDnsEnabled` or `SubnetIds` properties, the items in this list might change.
   *
   * @cloudformationAttribute NetworkInterfaceIds
   */
  public readonly attrNetworkInterfaceIds: Array<string>;

  /**
   * An endpoint policy, which controls access to the service from the VPC.
   */
  public policyDocument?: any | cdk.IResolvable;

  /**
   * Indicate whether to associate a private hosted zone with the specified VPC.
   */
  public privateDnsEnabled?: boolean | cdk.IResolvable;

  /**
   * The IDs of the route tables.
   */
  public routeTableIds?: Array<string>;

  /**
   * The IDs of the security groups to associate with the endpoint network interfaces.
   */
  public securityGroupIds?: Array<string>;

  /**
   * The name of the endpoint service.
   */
  public serviceName: string;

  /**
   * The IDs of the subnets in which to create endpoint network interfaces.
   */
  public subnetIds?: Array<string>;

  /**
   * The type of endpoint.
   */
  public vpcEndpointType?: string;

  /**
   * The ID of the VPC.
   */
  public vpcId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnVPCEndpointProps) {
    super(scope, id, {
      "type": CfnVPCEndpoint.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "serviceName", this);
    cdk.requireProperty(props, "vpcId", this);

    this.attrCreationTimestamp = cdk.Token.asString(this.getAtt("CreationTimestamp", cdk.ResolutionTypeHint.STRING));
    this.attrDnsEntries = cdk.Token.asList(this.getAtt("DnsEntries", cdk.ResolutionTypeHint.STRING_LIST));
    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.attrNetworkInterfaceIds = cdk.Token.asList(this.getAtt("NetworkInterfaceIds", cdk.ResolutionTypeHint.STRING_LIST));
    this.policyDocument = props.policyDocument;
    this.privateDnsEnabled = props.privateDnsEnabled;
    this.routeTableIds = props.routeTableIds;
    this.securityGroupIds = props.securityGroupIds;
    this.serviceName = props.serviceName;
    this.subnetIds = props.subnetIds;
    this.vpcEndpointType = props.vpcEndpointType;
    this.vpcId = props.vpcId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "policyDocument": this.policyDocument,
      "privateDnsEnabled": this.privateDnsEnabled,
      "routeTableIds": this.routeTableIds,
      "securityGroupIds": this.securityGroupIds,
      "serviceName": this.serviceName,
      "subnetIds": this.subnetIds,
      "vpcEndpointType": this.vpcEndpointType,
      "vpcId": this.vpcId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnVPCEndpoint.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnVPCEndpointPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a `CfnVPCEndpoint`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html
 */
export interface CfnVPCEndpointProps {
  /**
   * An endpoint policy, which controls access to the service from the VPC.
   *
   * The default endpoint policy allows full access to the service. Endpoint policies are supported only for gateway and interface endpoints.
   *
   * For CloudFormation templates in YAML, you can provide the policy in JSON or YAML format. AWS CloudFormation converts YAML policies to JSON format before calling the API to create or modify the VPC endpoint.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-policydocument
   */
  readonly policyDocument?: any | cdk.IResolvable;

  /**
   * Indicate whether to associate a private hosted zone with the specified VPC.
   *
   * The private hosted zone contains a record set for the default public DNS name for the service for the Region (for example, `kinesis.us-east-1.amazonaws.com` ), which resolves to the private IP addresses of the endpoint network interfaces in the VPC. This enables you to make requests to the default public DNS name for the service instead of the public DNS names that are automatically generated by the VPC endpoint service.
   *
   * To use a private hosted zone, you must set the following VPC attributes to `true` : `enableDnsHostnames` and `enableDnsSupport` .
   *
   * This property is supported only for interface endpoints.
   *
   * Default: `false`
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-privatednsenabled
   */
  readonly privateDnsEnabled?: boolean | cdk.IResolvable;

  /**
   * The IDs of the route tables.
   *
   * Routing is supported only for gateway endpoints.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-routetableids
   */
  readonly routeTableIds?: Array<string>;

  /**
   * The IDs of the security groups to associate with the endpoint network interfaces.
   *
   * If this parameter is not specified, we use the default security group for the VPC. Security groups are supported only for interface endpoints.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-securitygroupids
   */
  readonly securityGroupIds?: Array<string>;

  /**
   * The name of the endpoint service.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-servicename
   */
  readonly serviceName: string;

  /**
   * The IDs of the subnets in which to create endpoint network interfaces.
   *
   * You must specify this property for an interface endpoint or a Gateway Load Balancer endpoint. You can't specify this property for a gateway endpoint. For a Gateway Load Balancer endpoint, you can specify only one subnet.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-subnetids
   */
  readonly subnetIds?: Array<string>;

  /**
   * The type of endpoint.
   *
   * Default: Gateway
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-vpcendpointtype
   */
  readonly vpcEndpointType?: string;

  /**
   * The ID of the VPC.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-vpcid
   */
  readonly vpcId: string;
}

/**
 * Determine whether the given properties match those of a `CfnVPCEndpointProps`
 *
 * @param properties - the TypeScript properties of a `CfnVPCEndpointProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVPCEndpointPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("policyDocument", cdk.validateObject)(properties.policyDocument));
  errors.collect(cdk.propertyValidator("privateDnsEnabled", cdk.validateBoolean)(properties.privateDnsEnabled));
  errors.collect(cdk.propertyValidator("routeTableIds", cdk.listValidator(cdk.validateString))(properties.routeTableIds));
  errors.collect(cdk.propertyValidator("securityGroupIds", cdk.listValidator(cdk.validateString))(properties.securityGroupIds));
  errors.collect(cdk.propertyValidator("serviceName", cdk.requiredValidator)(properties.serviceName));
  errors.collect(cdk.propertyValidator("serviceName", cdk.validateString)(properties.serviceName));
  errors.collect(cdk.propertyValidator("subnetIds", cdk.listValidator(cdk.validateString))(properties.subnetIds));
  errors.collect(cdk.propertyValidator("vpcEndpointType", cdk.validateString)(properties.vpcEndpointType));
  errors.collect(cdk.propertyValidator("vpcId", cdk.requiredValidator)(properties.vpcId));
  errors.collect(cdk.propertyValidator("vpcId", cdk.validateString)(properties.vpcId));
  return errors.wrap("supplied properties not correct for \"CfnVPCEndpointProps\"");
}

// @ts-ignore TS6133
function convertCfnVPCEndpointPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVPCEndpointPropsValidator(properties).assertSuccess();
  return {
    "PolicyDocument": cdk.objectToCloudFormation(properties.policyDocument),
    "PrivateDnsEnabled": cdk.booleanToCloudFormation(properties.privateDnsEnabled),
    "RouteTableIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.routeTableIds),
    "SecurityGroupIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.securityGroupIds),
    "ServiceName": cdk.stringToCloudFormation(properties.serviceName),
    "SubnetIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.subnetIds),
    "VpcEndpointType": cdk.stringToCloudFormation(properties.vpcEndpointType),
    "VpcId": cdk.stringToCloudFormation(properties.vpcId)
  };
}

// @ts-ignore TS6133
function CfnVPCEndpointPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnVPCEndpointProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVPCEndpointProps>();
  ret.addPropertyResult("policyDocument", "PolicyDocument", (properties.PolicyDocument != null ? cfn_parse.FromCloudFormation.getAny(properties.PolicyDocument) : undefined));
  ret.addPropertyResult("privateDnsEnabled", "PrivateDnsEnabled", (properties.PrivateDnsEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.PrivateDnsEnabled) : undefined));
  ret.addPropertyResult("routeTableIds", "RouteTableIds", (properties.RouteTableIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.RouteTableIds) : undefined));
  ret.addPropertyResult("securityGroupIds", "SecurityGroupIds", (properties.SecurityGroupIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecurityGroupIds) : undefined));
  ret.addPropertyResult("serviceName", "ServiceName", (properties.ServiceName != null ? cfn_parse.FromCloudFormation.getString(properties.ServiceName) : undefined));
  ret.addPropertyResult("subnetIds", "SubnetIds", (properties.SubnetIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SubnetIds) : undefined));
  ret.addPropertyResult("vpcEndpointType", "VpcEndpointType", (properties.VpcEndpointType != null ? cfn_parse.FromCloudFormation.getString(properties.VpcEndpointType) : undefined));
  ret.addPropertyResult("vpcId", "VpcId", (properties.VpcId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a connection notification for a VPC endpoint or VPC endpoint service.
 *
 * A connection notification notifies you of specific endpoint events. You must create an SNS topic to receive notifications. For more information, see [Create a Topic](https://docs.aws.amazon.com/sns/latest/dg/CreateTopic.html) in the *Amazon Simple Notification Service Developer Guide* .
 *
 * You can create a connection notification for interface endpoints only.
 *
 * @cloudformationResource AWS::EC2::VPCEndpointConnectionNotification
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointconnectionnotification.html
 */
export class CfnVPCEndpointConnectionNotification extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::VPCEndpointConnectionNotification";

  /**
   * Build a CfnVPCEndpointConnectionNotification from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnVPCEndpointConnectionNotification {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnVPCEndpointConnectionNotificationPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnVPCEndpointConnectionNotification(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the notification.
   *
   * @cloudformationAttribute VPCEndpointConnectionNotificationId
   */
  public readonly attrVpcEndpointConnectionNotificationId: string;

  /**
   * The endpoint events for which to receive notifications.
   */
  public connectionEvents: Array<string>;

  /**
   * The ARN of the SNS topic for the notifications.
   */
  public connectionNotificationArn: string;

  /**
   * The ID of the endpoint service.
   */
  public serviceId?: string;

  /**
   * The ID of the endpoint.
   */
  public vpcEndpointId?: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnVPCEndpointConnectionNotificationProps) {
    super(scope, id, {
      "type": CfnVPCEndpointConnectionNotification.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "connectionEvents", this);
    cdk.requireProperty(props, "connectionNotificationArn", this);

    this.attrVpcEndpointConnectionNotificationId = cdk.Token.asString(this.getAtt("VPCEndpointConnectionNotificationId", cdk.ResolutionTypeHint.STRING));
    this.connectionEvents = props.connectionEvents;
    this.connectionNotificationArn = props.connectionNotificationArn;
    this.serviceId = props.serviceId;
    this.vpcEndpointId = props.vpcEndpointId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "connectionEvents": this.connectionEvents,
      "connectionNotificationArn": this.connectionNotificationArn,
      "serviceId": this.serviceId,
      "vpcEndpointId": this.vpcEndpointId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnVPCEndpointConnectionNotification.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnVPCEndpointConnectionNotificationPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a `CfnVPCEndpointConnectionNotification`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointconnectionnotification.html
 */
export interface CfnVPCEndpointConnectionNotificationProps {
  /**
   * The endpoint events for which to receive notifications.
   *
   * Valid values are `Accept` , `Connect` , `Delete` , and `Reject` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointconnectionnotification.html#cfn-ec2-vpcendpointconnectionnotification-connectionevents
   */
  readonly connectionEvents: Array<string>;

  /**
   * The ARN of the SNS topic for the notifications.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointconnectionnotification.html#cfn-ec2-vpcendpointconnectionnotification-connectionnotificationarn
   */
  readonly connectionNotificationArn: string;

  /**
   * The ID of the endpoint service.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointconnectionnotification.html#cfn-ec2-vpcendpointconnectionnotification-serviceid
   */
  readonly serviceId?: string;

  /**
   * The ID of the endpoint.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointconnectionnotification.html#cfn-ec2-vpcendpointconnectionnotification-vpcendpointid
   */
  readonly vpcEndpointId?: string;
}

/**
 * Determine whether the given properties match those of a `CfnVPCEndpointConnectionNotificationProps`
 *
 * @param properties - the TypeScript properties of a `CfnVPCEndpointConnectionNotificationProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVPCEndpointConnectionNotificationPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("connectionEvents", cdk.requiredValidator)(properties.connectionEvents));
  errors.collect(cdk.propertyValidator("connectionEvents", cdk.listValidator(cdk.validateString))(properties.connectionEvents));
  errors.collect(cdk.propertyValidator("connectionNotificationArn", cdk.requiredValidator)(properties.connectionNotificationArn));
  errors.collect(cdk.propertyValidator("connectionNotificationArn", cdk.validateString)(properties.connectionNotificationArn));
  errors.collect(cdk.propertyValidator("serviceId", cdk.validateString)(properties.serviceId));
  errors.collect(cdk.propertyValidator("vpcEndpointId", cdk.validateString)(properties.vpcEndpointId));
  return errors.wrap("supplied properties not correct for \"CfnVPCEndpointConnectionNotificationProps\"");
}

// @ts-ignore TS6133
function convertCfnVPCEndpointConnectionNotificationPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVPCEndpointConnectionNotificationPropsValidator(properties).assertSuccess();
  return {
    "ConnectionEvents": cdk.listMapper(cdk.stringToCloudFormation)(properties.connectionEvents),
    "ConnectionNotificationArn": cdk.stringToCloudFormation(properties.connectionNotificationArn),
    "ServiceId": cdk.stringToCloudFormation(properties.serviceId),
    "VPCEndpointId": cdk.stringToCloudFormation(properties.vpcEndpointId)
  };
}

// @ts-ignore TS6133
function CfnVPCEndpointConnectionNotificationPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnVPCEndpointConnectionNotificationProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVPCEndpointConnectionNotificationProps>();
  ret.addPropertyResult("connectionEvents", "ConnectionEvents", (properties.ConnectionEvents != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.ConnectionEvents) : undefined));
  ret.addPropertyResult("connectionNotificationArn", "ConnectionNotificationArn", (properties.ConnectionNotificationArn != null ? cfn_parse.FromCloudFormation.getString(properties.ConnectionNotificationArn) : undefined));
  ret.addPropertyResult("serviceId", "ServiceId", (properties.ServiceId != null ? cfn_parse.FromCloudFormation.getString(properties.ServiceId) : undefined));
  ret.addPropertyResult("vpcEndpointId", "VPCEndpointId", (properties.VPCEndpointId != null ? cfn_parse.FromCloudFormation.getString(properties.VPCEndpointId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Creates a VPC endpoint service configuration to which service consumers ( AWS accounts, users, and IAM roles) can connect.
 *
 * To create an endpoint service configuration, you must first create one of the following for your service:
 *
 * - A [Network Load Balancer](https://docs.aws.amazon.com/elasticloadbalancing/latest/network/introduction.html) . Service consumers connect to your service using an interface endpoint.
 * - A [Gateway Load Balancer](https://docs.aws.amazon.com/elasticloadbalancing/latest/gateway/introduction.html) . Service consumers connect to your service using a Gateway Load Balancer endpoint.
 *
 * For more information, see the [AWS PrivateLink User Guide](https://docs.aws.amazon.com/vpc/latest/privatelink/) .
 *
 * @cloudformationResource AWS::EC2::VPCEndpointService
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservice.html
 */
export class CfnVPCEndpointService extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::VPCEndpointService";

  /**
   * Build a CfnVPCEndpointService from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnVPCEndpointService {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnVPCEndpointServicePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnVPCEndpointService(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the endpoint service.
   *
   * @cloudformationAttribute ServiceId
   */
  public readonly attrServiceId: string;

  /**
   * Indicates whether requests from service consumers to create an endpoint to your service must be accepted.
   */
  public acceptanceRequired?: boolean | cdk.IResolvable;

  /**
   * Indicates whether to enable the built-in Contributor Insights rules provided by AWS PrivateLink .
   */
  public contributorInsightsEnabled?: boolean | cdk.IResolvable;

  /**
   * The Amazon Resource Names (ARNs) of the Gateway Load Balancers.
   */
  public gatewayLoadBalancerArns?: Array<string>;

  /**
   * The Amazon Resource Names (ARNs) of the Network Load Balancers.
   */
  public networkLoadBalancerArns?: Array<string>;

  /**
   * The entity that is responsible for the endpoint costs.
   */
  public payerResponsibility?: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnVPCEndpointServiceProps = {}) {
    super(scope, id, {
      "type": CfnVPCEndpointService.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.attrServiceId = cdk.Token.asString(this.getAtt("ServiceId", cdk.ResolutionTypeHint.STRING));
    this.acceptanceRequired = props.acceptanceRequired;
    this.contributorInsightsEnabled = props.contributorInsightsEnabled;
    this.gatewayLoadBalancerArns = props.gatewayLoadBalancerArns;
    this.networkLoadBalancerArns = props.networkLoadBalancerArns;
    this.payerResponsibility = props.payerResponsibility;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "acceptanceRequired": this.acceptanceRequired,
      "contributorInsightsEnabled": this.contributorInsightsEnabled,
      "gatewayLoadBalancerArns": this.gatewayLoadBalancerArns,
      "networkLoadBalancerArns": this.networkLoadBalancerArns,
      "payerResponsibility": this.payerResponsibility
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnVPCEndpointService.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnVPCEndpointServicePropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a `CfnVPCEndpointService`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservice.html
 */
export interface CfnVPCEndpointServiceProps {
  /**
   * Indicates whether requests from service consumers to create an endpoint to your service must be accepted.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservice.html#cfn-ec2-vpcendpointservice-acceptancerequired
   */
  readonly acceptanceRequired?: boolean | cdk.IResolvable;

  /**
   * Indicates whether to enable the built-in Contributor Insights rules provided by AWS PrivateLink .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservice.html#cfn-ec2-vpcendpointservice-contributorinsightsenabled
   */
  readonly contributorInsightsEnabled?: boolean | cdk.IResolvable;

  /**
   * The Amazon Resource Names (ARNs) of the Gateway Load Balancers.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservice.html#cfn-ec2-vpcendpointservice-gatewayloadbalancerarns
   */
  readonly gatewayLoadBalancerArns?: Array<string>;

  /**
   * The Amazon Resource Names (ARNs) of the Network Load Balancers.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservice.html#cfn-ec2-vpcendpointservice-networkloadbalancerarns
   */
  readonly networkLoadBalancerArns?: Array<string>;

  /**
   * The entity that is responsible for the endpoint costs.
   *
   * The default is the endpoint owner. If you set the payer responsibility to the service owner, you cannot set it back to the endpoint owner.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservice.html#cfn-ec2-vpcendpointservice-payerresponsibility
   */
  readonly payerResponsibility?: string;
}

/**
 * Determine whether the given properties match those of a `CfnVPCEndpointServiceProps`
 *
 * @param properties - the TypeScript properties of a `CfnVPCEndpointServiceProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVPCEndpointServicePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("acceptanceRequired", cdk.validateBoolean)(properties.acceptanceRequired));
  errors.collect(cdk.propertyValidator("contributorInsightsEnabled", cdk.validateBoolean)(properties.contributorInsightsEnabled));
  errors.collect(cdk.propertyValidator("gatewayLoadBalancerArns", cdk.listValidator(cdk.validateString))(properties.gatewayLoadBalancerArns));
  errors.collect(cdk.propertyValidator("networkLoadBalancerArns", cdk.listValidator(cdk.validateString))(properties.networkLoadBalancerArns));
  errors.collect(cdk.propertyValidator("payerResponsibility", cdk.validateString)(properties.payerResponsibility));
  return errors.wrap("supplied properties not correct for \"CfnVPCEndpointServiceProps\"");
}

// @ts-ignore TS6133
function convertCfnVPCEndpointServicePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVPCEndpointServicePropsValidator(properties).assertSuccess();
  return {
    "AcceptanceRequired": cdk.booleanToCloudFormation(properties.acceptanceRequired),
    "ContributorInsightsEnabled": cdk.booleanToCloudFormation(properties.contributorInsightsEnabled),
    "GatewayLoadBalancerArns": cdk.listMapper(cdk.stringToCloudFormation)(properties.gatewayLoadBalancerArns),
    "NetworkLoadBalancerArns": cdk.listMapper(cdk.stringToCloudFormation)(properties.networkLoadBalancerArns),
    "PayerResponsibility": cdk.stringToCloudFormation(properties.payerResponsibility)
  };
}

// @ts-ignore TS6133
function CfnVPCEndpointServicePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnVPCEndpointServiceProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVPCEndpointServiceProps>();
  ret.addPropertyResult("acceptanceRequired", "AcceptanceRequired", (properties.AcceptanceRequired != null ? cfn_parse.FromCloudFormation.getBoolean(properties.AcceptanceRequired) : undefined));
  ret.addPropertyResult("contributorInsightsEnabled", "ContributorInsightsEnabled", (properties.ContributorInsightsEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.ContributorInsightsEnabled) : undefined));
  ret.addPropertyResult("gatewayLoadBalancerArns", "GatewayLoadBalancerArns", (properties.GatewayLoadBalancerArns != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.GatewayLoadBalancerArns) : undefined));
  ret.addPropertyResult("networkLoadBalancerArns", "NetworkLoadBalancerArns", (properties.NetworkLoadBalancerArns != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.NetworkLoadBalancerArns) : undefined));
  ret.addPropertyResult("payerResponsibility", "PayerResponsibility", (properties.PayerResponsibility != null ? cfn_parse.FromCloudFormation.getString(properties.PayerResponsibility) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Grant or revoke permissions for service consumers (users, IAM roles, and AWS accounts) to connect to a VPC endpoint service.
 *
 * If you grant permissions to all principals, the service is public. Any users who know the name of a public service can send a request to attach an endpoint. If the service does not require manual approval, attachments are automatically approved.
 *
 * @cloudformationResource AWS::EC2::VPCEndpointServicePermissions
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservicepermissions.html
 */
export class CfnVPCEndpointServicePermissions extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::VPCEndpointServicePermissions";

  /**
   * Build a CfnVPCEndpointServicePermissions from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnVPCEndpointServicePermissions {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnVPCEndpointServicePermissionsPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnVPCEndpointServicePermissions(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The Amazon Resource Names (ARN) of one or more principals (for example, users, IAM roles, and AWS accounts ).
   */
  public allowedPrincipals?: Array<string>;

  /**
   * The ID of the service.
   */
  public serviceId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnVPCEndpointServicePermissionsProps) {
    super(scope, id, {
      "type": CfnVPCEndpointServicePermissions.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "serviceId", this);

    this.allowedPrincipals = props.allowedPrincipals;
    this.serviceId = props.serviceId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "allowedPrincipals": this.allowedPrincipals,
      "serviceId": this.serviceId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnVPCEndpointServicePermissions.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnVPCEndpointServicePermissionsPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a `CfnVPCEndpointServicePermissions`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservicepermissions.html
 */
export interface CfnVPCEndpointServicePermissionsProps {
  /**
   * The Amazon Resource Names (ARN) of one or more principals (for example, users, IAM roles, and AWS accounts ).
   *
   * Permissions are granted to the principals in this list. To grant permissions to all principals, specify an asterisk (*). Permissions are revoked for principals not in this list. If the list is empty, then all permissions are revoked.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservicepermissions.html#cfn-ec2-vpcendpointservicepermissions-allowedprincipals
   */
  readonly allowedPrincipals?: Array<string>;

  /**
   * The ID of the service.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservicepermissions.html#cfn-ec2-vpcendpointservicepermissions-serviceid
   */
  readonly serviceId: string;
}

/**
 * Determine whether the given properties match those of a `CfnVPCEndpointServicePermissionsProps`
 *
 * @param properties - the TypeScript properties of a `CfnVPCEndpointServicePermissionsProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVPCEndpointServicePermissionsPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("allowedPrincipals", cdk.listValidator(cdk.validateString))(properties.allowedPrincipals));
  errors.collect(cdk.propertyValidator("serviceId", cdk.requiredValidator)(properties.serviceId));
  errors.collect(cdk.propertyValidator("serviceId", cdk.validateString)(properties.serviceId));
  return errors.wrap("supplied properties not correct for \"CfnVPCEndpointServicePermissionsProps\"");
}

// @ts-ignore TS6133
function convertCfnVPCEndpointServicePermissionsPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVPCEndpointServicePermissionsPropsValidator(properties).assertSuccess();
  return {
    "AllowedPrincipals": cdk.listMapper(cdk.stringToCloudFormation)(properties.allowedPrincipals),
    "ServiceId": cdk.stringToCloudFormation(properties.serviceId)
  };
}

// @ts-ignore TS6133
function CfnVPCEndpointServicePermissionsPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnVPCEndpointServicePermissionsProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVPCEndpointServicePermissionsProps>();
  ret.addPropertyResult("allowedPrincipals", "AllowedPrincipals", (properties.AllowedPrincipals != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.AllowedPrincipals) : undefined));
  ret.addPropertyResult("serviceId", "ServiceId", (properties.ServiceId != null ? cfn_parse.FromCloudFormation.getString(properties.ServiceId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Attaches an internet gateway, or a virtual private gateway to a VPC, enabling connectivity between the internet and the VPC.
 *
 * @cloudformationResource AWS::EC2::VPCGatewayAttachment
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcgatewayattachment.html
 */
export class CfnVPCGatewayAttachment extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::VPCGatewayAttachment";

  /**
   * Build a CfnVPCGatewayAttachment from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnVPCGatewayAttachment {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnVPCGatewayAttachmentPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnVPCGatewayAttachment(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * Used to identify if this resource is an Internet Gateway or Vpn Gateway Attachment
   *
   * @cloudformationAttribute AttachmentType
   */
  public readonly attrAttachmentType: string;

  /**
   * The ID of the internet gateway.
   */
  public internetGatewayId?: string;

  /**
   * The ID of the VPC.
   */
  public vpcId: string;

  /**
   * The ID of the virtual private gateway.
   */
  public vpnGatewayId?: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnVPCGatewayAttachmentProps) {
    super(scope, id, {
      "type": CfnVPCGatewayAttachment.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "vpcId", this);

    this.attrAttachmentType = cdk.Token.asString(this.getAtt("AttachmentType", cdk.ResolutionTypeHint.STRING));
    this.internetGatewayId = props.internetGatewayId;
    this.vpcId = props.vpcId;
    this.vpnGatewayId = props.vpnGatewayId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "internetGatewayId": this.internetGatewayId,
      "vpcId": this.vpcId,
      "vpnGatewayId": this.vpnGatewayId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnVPCGatewayAttachment.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnVPCGatewayAttachmentPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a `CfnVPCGatewayAttachment`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcgatewayattachment.html
 */
export interface CfnVPCGatewayAttachmentProps {
  /**
   * The ID of the internet gateway.
   *
   * You must specify either `InternetGatewayId` or `VpnGatewayId` , but not both.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcgatewayattachment.html#cfn-ec2-vpcgatewayattachment-internetgatewayid
   */
  readonly internetGatewayId?: string;

  /**
   * The ID of the VPC.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcgatewayattachment.html#cfn-ec2-vpcgatewayattachment-vpcid
   */
  readonly vpcId: string;

  /**
   * The ID of the virtual private gateway.
   *
   * You must specify either `InternetGatewayId` or `VpnGatewayId` , but not both.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcgatewayattachment.html#cfn-ec2-vpcgatewayattachment-vpngatewayid
   */
  readonly vpnGatewayId?: string;
}

/**
 * Determine whether the given properties match those of a `CfnVPCGatewayAttachmentProps`
 *
 * @param properties - the TypeScript properties of a `CfnVPCGatewayAttachmentProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVPCGatewayAttachmentPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("internetGatewayId", cdk.validateString)(properties.internetGatewayId));
  errors.collect(cdk.propertyValidator("vpcId", cdk.requiredValidator)(properties.vpcId));
  errors.collect(cdk.propertyValidator("vpcId", cdk.validateString)(properties.vpcId));
  errors.collect(cdk.propertyValidator("vpnGatewayId", cdk.validateString)(properties.vpnGatewayId));
  return errors.wrap("supplied properties not correct for \"CfnVPCGatewayAttachmentProps\"");
}

// @ts-ignore TS6133
function convertCfnVPCGatewayAttachmentPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVPCGatewayAttachmentPropsValidator(properties).assertSuccess();
  return {
    "InternetGatewayId": cdk.stringToCloudFormation(properties.internetGatewayId),
    "VpcId": cdk.stringToCloudFormation(properties.vpcId),
    "VpnGatewayId": cdk.stringToCloudFormation(properties.vpnGatewayId)
  };
}

// @ts-ignore TS6133
function CfnVPCGatewayAttachmentPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnVPCGatewayAttachmentProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVPCGatewayAttachmentProps>();
  ret.addPropertyResult("internetGatewayId", "InternetGatewayId", (properties.InternetGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.InternetGatewayId) : undefined));
  ret.addPropertyResult("vpcId", "VpcId", (properties.VpcId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcId) : undefined));
  ret.addPropertyResult("vpnGatewayId", "VpnGatewayId", (properties.VpnGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.VpnGatewayId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Requests a VPC peering connection between two VPCs: a requester VPC that you own and an accepter VPC with which to create the connection.
 *
 * The accepter VPC can belong to a different AWS account and can be in a different Region than the requester VPC.
 *
 * The requester VPC and accepter VPC cannot have overlapping CIDR blocks. If you create a VPC peering connection request between VPCs with overlapping CIDR blocks, the VPC peering connection has a status of `failed` .
 *
 * If the VPCs belong to different accounts, the acceptor account must have a role that allows the requester account to accept the VPC peering connection. For more information, see [Walkthough: Peer with a VPC in another AWS account](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/peer-with-vpc-in-another-account.html) .
 *
 * If the requester and acceptor VPCs are in the same account, the peering request is accepted without a peering role.
 *
 * @cloudformationResource AWS::EC2::VPCPeeringConnection
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcpeeringconnection.html
 */
export class CfnVPCPeeringConnection extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::VPCPeeringConnection";

  /**
   * Build a CfnVPCPeeringConnection from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnVPCPeeringConnection {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnVPCPeeringConnectionPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnVPCPeeringConnection(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the peering connection.
   *
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The AWS account ID of the owner of the accepter VPC.
   */
  public peerOwnerId?: string;

  /**
   * The Region code for the accepter VPC, if the accepter VPC is located in a Region other than the Region in which you make the request.
   */
  public peerRegion?: string;

  /**
   * The Amazon Resource Name (ARN) of the VPC peer role for the peering connection in another AWS account.
   */
  public peerRoleArn?: string;

  /**
   * The ID of the VPC with which you are creating the VPC peering connection.
   */
  public peerVpcId: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * Any tags assigned to the resource.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The ID of the VPC.
   */
  public vpcId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnVPCPeeringConnectionProps) {
    super(scope, id, {
      "type": CfnVPCPeeringConnection.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "peerVpcId", this);
    cdk.requireProperty(props, "vpcId", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.peerOwnerId = props.peerOwnerId;
    this.peerRegion = props.peerRegion;
    this.peerRoleArn = props.peerRoleArn;
    this.peerVpcId = props.peerVpcId;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::VPCPeeringConnection", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.vpcId = props.vpcId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "peerOwnerId": this.peerOwnerId,
      "peerRegion": this.peerRegion,
      "peerRoleArn": this.peerRoleArn,
      "peerVpcId": this.peerVpcId,
      "tags": this.tags.renderTags(),
      "vpcId": this.vpcId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnVPCPeeringConnection.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnVPCPeeringConnectionPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a `CfnVPCPeeringConnection`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcpeeringconnection.html
 */
export interface CfnVPCPeeringConnectionProps {
  /**
   * The AWS account ID of the owner of the accepter VPC.
   *
   * Default: Your AWS account ID
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcpeeringconnection.html#cfn-ec2-vpcpeeringconnection-peerownerid
   */
  readonly peerOwnerId?: string;

  /**
   * The Region code for the accepter VPC, if the accepter VPC is located in a Region other than the Region in which you make the request.
   *
   * Default: The Region in which you make the request.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcpeeringconnection.html#cfn-ec2-vpcpeeringconnection-peerregion
   */
  readonly peerRegion?: string;

  /**
   * The Amazon Resource Name (ARN) of the VPC peer role for the peering connection in another AWS account.
   *
   * This is required when you are peering a VPC in a different AWS account.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcpeeringconnection.html#cfn-ec2-vpcpeeringconnection-peerrolearn
   */
  readonly peerRoleArn?: string;

  /**
   * The ID of the VPC with which you are creating the VPC peering connection.
   *
   * You must specify this parameter in the request.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcpeeringconnection.html#cfn-ec2-vpcpeeringconnection-peervpcid
   */
  readonly peerVpcId: string;

  /**
   * Any tags assigned to the resource.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcpeeringconnection.html#cfn-ec2-vpcpeeringconnection-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The ID of the VPC.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcpeeringconnection.html#cfn-ec2-vpcpeeringconnection-vpcid
   */
  readonly vpcId: string;
}

/**
 * Determine whether the given properties match those of a `CfnVPCPeeringConnectionProps`
 *
 * @param properties - the TypeScript properties of a `CfnVPCPeeringConnectionProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVPCPeeringConnectionPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("peerOwnerId", cdk.validateString)(properties.peerOwnerId));
  errors.collect(cdk.propertyValidator("peerRegion", cdk.validateString)(properties.peerRegion));
  errors.collect(cdk.propertyValidator("peerRoleArn", cdk.validateString)(properties.peerRoleArn));
  errors.collect(cdk.propertyValidator("peerVpcId", cdk.requiredValidator)(properties.peerVpcId));
  errors.collect(cdk.propertyValidator("peerVpcId", cdk.validateString)(properties.peerVpcId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("vpcId", cdk.requiredValidator)(properties.vpcId));
  errors.collect(cdk.propertyValidator("vpcId", cdk.validateString)(properties.vpcId));
  return errors.wrap("supplied properties not correct for \"CfnVPCPeeringConnectionProps\"");
}

// @ts-ignore TS6133
function convertCfnVPCPeeringConnectionPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVPCPeeringConnectionPropsValidator(properties).assertSuccess();
  return {
    "PeerOwnerId": cdk.stringToCloudFormation(properties.peerOwnerId),
    "PeerRegion": cdk.stringToCloudFormation(properties.peerRegion),
    "PeerRoleArn": cdk.stringToCloudFormation(properties.peerRoleArn),
    "PeerVpcId": cdk.stringToCloudFormation(properties.peerVpcId),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "VpcId": cdk.stringToCloudFormation(properties.vpcId)
  };
}

// @ts-ignore TS6133
function CfnVPCPeeringConnectionPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnVPCPeeringConnectionProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVPCPeeringConnectionProps>();
  ret.addPropertyResult("peerOwnerId", "PeerOwnerId", (properties.PeerOwnerId != null ? cfn_parse.FromCloudFormation.getString(properties.PeerOwnerId) : undefined));
  ret.addPropertyResult("peerRegion", "PeerRegion", (properties.PeerRegion != null ? cfn_parse.FromCloudFormation.getString(properties.PeerRegion) : undefined));
  ret.addPropertyResult("peerRoleArn", "PeerRoleArn", (properties.PeerRoleArn != null ? cfn_parse.FromCloudFormation.getString(properties.PeerRoleArn) : undefined));
  ret.addPropertyResult("peerVpcId", "PeerVpcId", (properties.PeerVpcId != null ? cfn_parse.FromCloudFormation.getString(properties.PeerVpcId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("vpcId", "VpcId", (properties.VpcId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a VPN connection between a virtual private gateway and a VPN customer gateway or a transit gateway and a VPN customer gateway.
 *
 * To specify a VPN connection between a transit gateway and customer gateway, use the `TransitGatewayId` and `CustomerGatewayId` properties.
 *
 * To specify a VPN connection between a virtual private gateway and customer gateway, use the `VpnGatewayId` and `CustomerGatewayId` properties.
 *
 * For more information, see [AWS Site-to-Site VPN](https://docs.aws.amazon.com/vpn/latest/s2svpn/VPC_VPN.html) in the *AWS Site-to-Site VPN User Guide* .
 *
 * @cloudformationResource AWS::EC2::VPNConnection
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnection.html
 */
export class CfnVPNConnection extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::VPNConnection";

  /**
   * Build a CfnVPNConnection from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnVPNConnection {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnVPNConnectionPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnVPNConnection(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the VPN connection.
   *
   * @cloudformationAttribute VpnConnectionId
   */
  public readonly attrVpnConnectionId: string;

  /**
   * The ID of the customer gateway at your end of the VPN connection.
   */
  public customerGatewayId: string;

  /**
   * Indicates whether the VPN connection uses static routes only.
   */
  public staticRoutesOnly?: boolean | cdk.IResolvable;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * Any tags assigned to the VPN connection.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The ID of the transit gateway associated with the VPN connection.
   */
  public transitGatewayId?: string;

  /**
   * The type of VPN connection.
   */
  public type: string;

  /**
   * The ID of the virtual private gateway at the AWS side of the VPN connection.
   */
  public vpnGatewayId?: string;

  /**
   * The tunnel options for the VPN connection.
   */
  public vpnTunnelOptionsSpecifications?: Array<cdk.IResolvable | CfnVPNConnection.VpnTunnelOptionsSpecificationProperty> | cdk.IResolvable;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnVPNConnectionProps) {
    super(scope, id, {
      "type": CfnVPNConnection.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "customerGatewayId", this);
    cdk.requireProperty(props, "type", this);

    this.attrVpnConnectionId = cdk.Token.asString(this.getAtt("VpnConnectionId", cdk.ResolutionTypeHint.STRING));
    this.customerGatewayId = props.customerGatewayId;
    this.staticRoutesOnly = props.staticRoutesOnly;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::VPNConnection", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.transitGatewayId = props.transitGatewayId;
    this.type = props.type;
    this.vpnGatewayId = props.vpnGatewayId;
    this.vpnTunnelOptionsSpecifications = props.vpnTunnelOptionsSpecifications;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "customerGatewayId": this.customerGatewayId,
      "staticRoutesOnly": this.staticRoutesOnly,
      "tags": this.tags.renderTags(),
      "transitGatewayId": this.transitGatewayId,
      "type": this.type,
      "vpnGatewayId": this.vpnGatewayId,
      "vpnTunnelOptionsSpecifications": this.vpnTunnelOptionsSpecifications
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnVPNConnection.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnVPNConnectionPropsToCloudFormation(props);
  }
}

export namespace CfnVPNConnection {
  /**
   * The tunnel options for a single VPN tunnel.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-vpntunneloptionsspecification.html
   */
  export interface VpnTunnelOptionsSpecificationProperty {
    /**
     * The pre-shared key (PSK) to establish initial authentication between the virtual private gateway and customer gateway.
     *
     * Constraints: Allowed characters are alphanumeric characters, periods (.), and underscores (_). Must be between 8 and 64 characters in length and cannot start with zero (0).
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-vpntunneloptionsspecification.html#cfn-ec2-vpnconnection-vpntunneloptionsspecification-presharedkey
     */
    readonly preSharedKey?: string;

    /**
     * The range of inside IP addresses for the tunnel.
     *
     * Any specified CIDR blocks must be unique across all VPN connections that use the same virtual private gateway.
     *
     * Constraints: A size /30 CIDR block from the `169.254.0.0/16` range. The following CIDR blocks are reserved and cannot be used:
     *
     * - `169.254.0.0/30`
     * - `169.254.1.0/30`
     * - `169.254.2.0/30`
     * - `169.254.3.0/30`
     * - `169.254.4.0/30`
     * - `169.254.5.0/30`
     * - `169.254.169.252/30`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-vpntunneloptionsspecification.html#cfn-ec2-vpnconnection-vpntunneloptionsspecification-tunnelinsidecidr
     */
    readonly tunnelInsideCidr?: string;
  }
}

/**
 * Properties for defining a `CfnVPNConnection`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnection.html
 */
export interface CfnVPNConnectionProps {
  /**
   * The ID of the customer gateway at your end of the VPN connection.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnection.html#cfn-ec2-vpnconnection-customergatewayid
   */
  readonly customerGatewayId: string;

  /**
   * Indicates whether the VPN connection uses static routes only.
   *
   * Static routes must be used for devices that don't support BGP.
   *
   * If you are creating a VPN connection for a device that does not support Border Gateway Protocol (BGP), you must specify `true` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnection.html#cfn-ec2-vpnconnection-staticroutesonly
   */
  readonly staticRoutesOnly?: boolean | cdk.IResolvable;

  /**
   * Any tags assigned to the VPN connection.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnection.html#cfn-ec2-vpnconnection-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The ID of the transit gateway associated with the VPN connection.
   *
   * You must specify either `TransitGatewayId` or `VpnGatewayId` , but not both.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnection.html#cfn-ec2-vpnconnection-transitgatewayid
   */
  readonly transitGatewayId?: string;

  /**
   * The type of VPN connection.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnection.html#cfn-ec2-vpnconnection-type
   */
  readonly type: string;

  /**
   * The ID of the virtual private gateway at the AWS side of the VPN connection.
   *
   * You must specify either `TransitGatewayId` or `VpnGatewayId` , but not both.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnection.html#cfn-ec2-vpnconnection-vpngatewayid
   */
  readonly vpnGatewayId?: string;

  /**
   * The tunnel options for the VPN connection.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnection.html#cfn-ec2-vpnconnection-vpntunneloptionsspecifications
   */
  readonly vpnTunnelOptionsSpecifications?: Array<cdk.IResolvable | CfnVPNConnection.VpnTunnelOptionsSpecificationProperty> | cdk.IResolvable;
}

/**
 * Determine whether the given properties match those of a `VpnTunnelOptionsSpecificationProperty`
 *
 * @param properties - the TypeScript properties of a `VpnTunnelOptionsSpecificationProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVPNConnectionVpnTunnelOptionsSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("preSharedKey", cdk.validateString)(properties.preSharedKey));
  errors.collect(cdk.propertyValidator("tunnelInsideCidr", cdk.validateString)(properties.tunnelInsideCidr));
  return errors.wrap("supplied properties not correct for \"VpnTunnelOptionsSpecificationProperty\"");
}

// @ts-ignore TS6133
function convertCfnVPNConnectionVpnTunnelOptionsSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVPNConnectionVpnTunnelOptionsSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "PreSharedKey": cdk.stringToCloudFormation(properties.preSharedKey),
    "TunnelInsideCidr": cdk.stringToCloudFormation(properties.tunnelInsideCidr)
  };
}

// @ts-ignore TS6133
function CfnVPNConnectionVpnTunnelOptionsSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnVPNConnection.VpnTunnelOptionsSpecificationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVPNConnection.VpnTunnelOptionsSpecificationProperty>();
  ret.addPropertyResult("preSharedKey", "PreSharedKey", (properties.PreSharedKey != null ? cfn_parse.FromCloudFormation.getString(properties.PreSharedKey) : undefined));
  ret.addPropertyResult("tunnelInsideCidr", "TunnelInsideCidr", (properties.TunnelInsideCidr != null ? cfn_parse.FromCloudFormation.getString(properties.TunnelInsideCidr) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `CfnVPNConnectionProps`
 *
 * @param properties - the TypeScript properties of a `CfnVPNConnectionProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVPNConnectionPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("customerGatewayId", cdk.requiredValidator)(properties.customerGatewayId));
  errors.collect(cdk.propertyValidator("customerGatewayId", cdk.validateString)(properties.customerGatewayId));
  errors.collect(cdk.propertyValidator("staticRoutesOnly", cdk.validateBoolean)(properties.staticRoutesOnly));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("transitGatewayId", cdk.validateString)(properties.transitGatewayId));
  errors.collect(cdk.propertyValidator("type", cdk.requiredValidator)(properties.type));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  errors.collect(cdk.propertyValidator("vpnGatewayId", cdk.validateString)(properties.vpnGatewayId));
  errors.collect(cdk.propertyValidator("vpnTunnelOptionsSpecifications", cdk.listValidator(CfnVPNConnectionVpnTunnelOptionsSpecificationPropertyValidator))(properties.vpnTunnelOptionsSpecifications));
  return errors.wrap("supplied properties not correct for \"CfnVPNConnectionProps\"");
}

// @ts-ignore TS6133
function convertCfnVPNConnectionPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVPNConnectionPropsValidator(properties).assertSuccess();
  return {
    "CustomerGatewayId": cdk.stringToCloudFormation(properties.customerGatewayId),
    "StaticRoutesOnly": cdk.booleanToCloudFormation(properties.staticRoutesOnly),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "TransitGatewayId": cdk.stringToCloudFormation(properties.transitGatewayId),
    "Type": cdk.stringToCloudFormation(properties.type),
    "VpnGatewayId": cdk.stringToCloudFormation(properties.vpnGatewayId),
    "VpnTunnelOptionsSpecifications": cdk.listMapper(convertCfnVPNConnectionVpnTunnelOptionsSpecificationPropertyToCloudFormation)(properties.vpnTunnelOptionsSpecifications)
  };
}

// @ts-ignore TS6133
function CfnVPNConnectionPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnVPNConnectionProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVPNConnectionProps>();
  ret.addPropertyResult("customerGatewayId", "CustomerGatewayId", (properties.CustomerGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.CustomerGatewayId) : undefined));
  ret.addPropertyResult("staticRoutesOnly", "StaticRoutesOnly", (properties.StaticRoutesOnly != null ? cfn_parse.FromCloudFormation.getBoolean(properties.StaticRoutesOnly) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("transitGatewayId", "TransitGatewayId", (properties.TransitGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.TransitGatewayId) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addPropertyResult("vpnGatewayId", "VpnGatewayId", (properties.VpnGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.VpnGatewayId) : undefined));
  ret.addPropertyResult("vpnTunnelOptionsSpecifications", "VpnTunnelOptionsSpecifications", (properties.VpnTunnelOptionsSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnVPNConnectionVpnTunnelOptionsSpecificationPropertyFromCloudFormation)(properties.VpnTunnelOptionsSpecifications) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a static route for a VPN connection between an existing virtual private gateway and a VPN customer gateway.
 *
 * The static route allows traffic to be routed from the virtual private gateway to the VPN customer gateway.
 *
 * For more information, see [AWS Site-to-Site VPN](https://docs.aws.amazon.com/vpn/latest/s2svpn/VPC_VPN.html) in the *AWS Site-to-Site VPN User Guide* .
 *
 * @cloudformationResource AWS::EC2::VPNConnectionRoute
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnectionroute.html
 */
export class CfnVPNConnectionRoute extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::VPNConnectionRoute";

  /**
   * Build a CfnVPNConnectionRoute from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnVPNConnectionRoute {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnVPNConnectionRoutePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnVPNConnectionRoute(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The CIDR block associated with the local subnet of the customer network.
   */
  public destinationCidrBlock: string;

  /**
   * The ID of the VPN connection.
   */
  public vpnConnectionId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnVPNConnectionRouteProps) {
    super(scope, id, {
      "type": CfnVPNConnectionRoute.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "destinationCidrBlock", this);
    cdk.requireProperty(props, "vpnConnectionId", this);

    this.destinationCidrBlock = props.destinationCidrBlock;
    this.vpnConnectionId = props.vpnConnectionId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "destinationCidrBlock": this.destinationCidrBlock,
      "vpnConnectionId": this.vpnConnectionId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnVPNConnectionRoute.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnVPNConnectionRoutePropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a `CfnVPNConnectionRoute`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnectionroute.html
 */
export interface CfnVPNConnectionRouteProps {
  /**
   * The CIDR block associated with the local subnet of the customer network.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnectionroute.html#cfn-ec2-vpnconnectionroute-destinationcidrblock
   */
  readonly destinationCidrBlock: string;

  /**
   * The ID of the VPN connection.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnectionroute.html#cfn-ec2-vpnconnectionroute-vpnconnectionid
   */
  readonly vpnConnectionId: string;
}

/**
 * Determine whether the given properties match those of a `CfnVPNConnectionRouteProps`
 *
 * @param properties - the TypeScript properties of a `CfnVPNConnectionRouteProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVPNConnectionRoutePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("destinationCidrBlock", cdk.requiredValidator)(properties.destinationCidrBlock));
  errors.collect(cdk.propertyValidator("destinationCidrBlock", cdk.validateString)(properties.destinationCidrBlock));
  errors.collect(cdk.propertyValidator("vpnConnectionId", cdk.requiredValidator)(properties.vpnConnectionId));
  errors.collect(cdk.propertyValidator("vpnConnectionId", cdk.validateString)(properties.vpnConnectionId));
  return errors.wrap("supplied properties not correct for \"CfnVPNConnectionRouteProps\"");
}

// @ts-ignore TS6133
function convertCfnVPNConnectionRoutePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVPNConnectionRoutePropsValidator(properties).assertSuccess();
  return {
    "DestinationCidrBlock": cdk.stringToCloudFormation(properties.destinationCidrBlock),
    "VpnConnectionId": cdk.stringToCloudFormation(properties.vpnConnectionId)
  };
}

// @ts-ignore TS6133
function CfnVPNConnectionRoutePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnVPNConnectionRouteProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVPNConnectionRouteProps>();
  ret.addPropertyResult("destinationCidrBlock", "DestinationCidrBlock", (properties.DestinationCidrBlock != null ? cfn_parse.FromCloudFormation.getString(properties.DestinationCidrBlock) : undefined));
  ret.addPropertyResult("vpnConnectionId", "VpnConnectionId", (properties.VpnConnectionId != null ? cfn_parse.FromCloudFormation.getString(properties.VpnConnectionId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a virtual private gateway.
 *
 * A virtual private gateway is the endpoint on the VPC side of your VPN connection. You can create a virtual private gateway before creating the VPC itself.
 *
 * For more information, see [AWS Site-to-Site VPN](https://docs.aws.amazon.com/vpn/latest/s2svpn/VPC_VPN.html) in the *AWS Site-to-Site VPN User Guide* .
 *
 * @cloudformationResource AWS::EC2::VPNGateway
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpngateway.html
 */
export class CfnVPNGateway extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::VPNGateway";

  /**
   * Build a CfnVPNGateway from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnVPNGateway {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnVPNGatewayPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnVPNGateway(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the VPN gateway.
   *
   * @cloudformationAttribute VPNGatewayId
   */
  public readonly attrVpnGatewayId: string;

  /**
   * The private Autonomous System Number (ASN) for the Amazon side of a BGP session.
   */
  public amazonSideAsn?: number;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * Any tags assigned to the virtual private gateway.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The type of VPN connection the virtual private gateway supports.
   */
  public type: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnVPNGatewayProps) {
    super(scope, id, {
      "type": CfnVPNGateway.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "type", this);

    this.attrVpnGatewayId = cdk.Token.asString(this.getAtt("VPNGatewayId", cdk.ResolutionTypeHint.STRING));
    this.amazonSideAsn = props.amazonSideAsn;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::VPNGateway", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.type = props.type;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "amazonSideAsn": this.amazonSideAsn,
      "tags": this.tags.renderTags(),
      "type": this.type
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnVPNGateway.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnVPNGatewayPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a `CfnVPNGateway`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpngateway.html
 */
export interface CfnVPNGatewayProps {
  /**
   * The private Autonomous System Number (ASN) for the Amazon side of a BGP session.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpngateway.html#cfn-ec2-vpngateway-amazonsideasn
   */
  readonly amazonSideAsn?: number;

  /**
   * Any tags assigned to the virtual private gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpngateway.html#cfn-ec2-vpngateway-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The type of VPN connection the virtual private gateway supports.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpngateway.html#cfn-ec2-vpngateway-type
   */
  readonly type: string;
}

/**
 * Determine whether the given properties match those of a `CfnVPNGatewayProps`
 *
 * @param properties - the TypeScript properties of a `CfnVPNGatewayProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVPNGatewayPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("amazonSideAsn", cdk.validateNumber)(properties.amazonSideAsn));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("type", cdk.requiredValidator)(properties.type));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  return errors.wrap("supplied properties not correct for \"CfnVPNGatewayProps\"");
}

// @ts-ignore TS6133
function convertCfnVPNGatewayPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVPNGatewayPropsValidator(properties).assertSuccess();
  return {
    "AmazonSideAsn": cdk.numberToCloudFormation(properties.amazonSideAsn),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "Type": cdk.stringToCloudFormation(properties.type)
  };
}

// @ts-ignore TS6133
function CfnVPNGatewayPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnVPNGatewayProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVPNGatewayProps>();
  ret.addPropertyResult("amazonSideAsn", "AmazonSideAsn", (properties.AmazonSideAsn != null ? cfn_parse.FromCloudFormation.getNumber(properties.AmazonSideAsn) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Enables a virtual private gateway (VGW) to propagate routes to the specified route table of a VPC.
 *
 * If you reference a VPN gateway that is in the same template as your VPN gateway route propagation, you must explicitly declare a dependency on the VPN gateway attachment. The `AWS::EC2::VPNGatewayRoutePropagation` resource cannot use the VPN gateway until it has successfully attached to the VPC. Add a [DependsOn Attribute](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-dependson.html) in the `AWS::EC2::VPNGatewayRoutePropagation` resource to explicitly declare a dependency on the VPN gateway attachment.
 *
 * @cloudformationResource AWS::EC2::VPNGatewayRoutePropagation
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpngatewayroutepropagation.html
 */
export class CfnVPNGatewayRoutePropagation extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::VPNGatewayRoutePropagation";

  /**
   * Build a CfnVPNGatewayRoutePropagation from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnVPNGatewayRoutePropagation {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnVPNGatewayRoutePropagationPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnVPNGatewayRoutePropagation(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the VPN gateway.
   *
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The ID of the route table.
   */
  public routeTableIds: Array<string>;

  /**
   * The ID of the virtual private gateway that is attached to a VPC.
   */
  public vpnGatewayId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnVPNGatewayRoutePropagationProps) {
    super(scope, id, {
      "type": CfnVPNGatewayRoutePropagation.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "routeTableIds", this);
    cdk.requireProperty(props, "vpnGatewayId", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.routeTableIds = props.routeTableIds;
    this.vpnGatewayId = props.vpnGatewayId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "routeTableIds": this.routeTableIds,
      "vpnGatewayId": this.vpnGatewayId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnVPNGatewayRoutePropagation.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnVPNGatewayRoutePropagationPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a `CfnVPNGatewayRoutePropagation`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpngatewayroutepropagation.html
 */
export interface CfnVPNGatewayRoutePropagationProps {
  /**
   * The ID of the route table.
   *
   * The routing table must be associated with the same VPC that the virtual private gateway is attached to.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpngatewayroutepropagation.html#cfn-ec2-vpngatewayroutepropagation-routetableids
   */
  readonly routeTableIds: Array<string>;

  /**
   * The ID of the virtual private gateway that is attached to a VPC.
   *
   * The virtual private gateway must be attached to the same VPC that the routing tables are associated with.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpngatewayroutepropagation.html#cfn-ec2-vpngatewayroutepropagation-vpngatewayid
   */
  readonly vpnGatewayId: string;
}

/**
 * Determine whether the given properties match those of a `CfnVPNGatewayRoutePropagationProps`
 *
 * @param properties - the TypeScript properties of a `CfnVPNGatewayRoutePropagationProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVPNGatewayRoutePropagationPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("routeTableIds", cdk.requiredValidator)(properties.routeTableIds));
  errors.collect(cdk.propertyValidator("routeTableIds", cdk.listValidator(cdk.validateString))(properties.routeTableIds));
  errors.collect(cdk.propertyValidator("vpnGatewayId", cdk.requiredValidator)(properties.vpnGatewayId));
  errors.collect(cdk.propertyValidator("vpnGatewayId", cdk.validateString)(properties.vpnGatewayId));
  return errors.wrap("supplied properties not correct for \"CfnVPNGatewayRoutePropagationProps\"");
}

// @ts-ignore TS6133
function convertCfnVPNGatewayRoutePropagationPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVPNGatewayRoutePropagationPropsValidator(properties).assertSuccess();
  return {
    "RouteTableIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.routeTableIds),
    "VpnGatewayId": cdk.stringToCloudFormation(properties.vpnGatewayId)
  };
}

// @ts-ignore TS6133
function CfnVPNGatewayRoutePropagationPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnVPNGatewayRoutePropagationProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVPNGatewayRoutePropagationProps>();
  ret.addPropertyResult("routeTableIds", "RouteTableIds", (properties.RouteTableIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.RouteTableIds) : undefined));
  ret.addPropertyResult("vpnGatewayId", "VpnGatewayId", (properties.VpnGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.VpnGatewayId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * An AWS Verified Access endpoint specifies the application that AWS Verified Access provides access to.
 *
 * It must be attached to an AWS Verified Access group. An AWS Verified Access endpoint must also have an attached access policy before you attached it to a group.
 *
 * @cloudformationResource AWS::EC2::VerifiedAccessEndpoint
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html
 */
export class CfnVerifiedAccessEndpoint extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::VerifiedAccessEndpoint";

  /**
   * Build a CfnVerifiedAccessEndpoint from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnVerifiedAccessEndpoint {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnVerifiedAccessEndpointPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnVerifiedAccessEndpoint(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The creation time.
   *
   * @cloudformationAttribute CreationTime
   */
  public readonly attrCreationTime: string;

  /**
   * Use this to construct the redirect URI to add to your OIDC provider's allow list.
   *
   * @cloudformationAttribute DeviceValidationDomain
   */
  public readonly attrDeviceValidationDomain: string;

  /**
   * The DNS name generated for the endpoint.
   *
   * @cloudformationAttribute EndpointDomain
   */
  public readonly attrEndpointDomain: string;

  /**
   * The last updated time.
   *
   * @cloudformationAttribute LastUpdatedTime
   */
  public readonly attrLastUpdatedTime: string;

  /**
   * The endpoint status.
   *
   * @cloudformationAttribute Status
   */
  public readonly attrStatus: string;

  /**
   * The ID of the Verified Access endpoint.
   *
   * @cloudformationAttribute VerifiedAccessEndpointId
   */
  public readonly attrVerifiedAccessEndpointId: string;

  /**
   * The instance identifier.
   *
   * @cloudformationAttribute VerifiedAccessInstanceId
   */
  public readonly attrVerifiedAccessInstanceId: string;

  /**
   * The DNS name for users to reach your application.
   */
  public applicationDomain: string;

  /**
   * The type of attachment used to provide connectivity between the AWS Verified Access endpoint and the application.
   */
  public attachmentType: string;

  /**
   * A description for the AWS Verified Access endpoint.
   */
  public description?: string;

  /**
   * The ARN of a public TLS/SSL certificate imported into or created with ACM.
   */
  public domainCertificateArn: string;

  /**
   * A custom identifier that is prepended to the DNS name that is generated for the endpoint.
   */
  public endpointDomainPrefix: string;

  /**
   * The type of AWS Verified Access endpoint.
   */
  public endpointType: string;

  /**
   * The load balancer details if creating the AWS Verified Access endpoint as `load-balancer` type.
   */
  public loadBalancerOptions?: cdk.IResolvable | CfnVerifiedAccessEndpoint.LoadBalancerOptionsProperty;

  /**
   * The options for network-interface type endpoint.
   */
  public networkInterfaceOptions?: cdk.IResolvable | CfnVerifiedAccessEndpoint.NetworkInterfaceOptionsProperty;

  /**
   * The Verified Access policy document.
   */
  public policyDocument?: string;

  /**
   * The status of the Verified Access policy.
   */
  public policyEnabled?: boolean | cdk.IResolvable;

  /**
   * The IDs of the security groups for the endpoint.
   */
  public securityGroupIds?: Array<string>;

  /**
   * The options for additional server side encryption.
   */
  public sseSpecification?: cdk.IResolvable | CfnVerifiedAccessEndpoint.SseSpecificationProperty;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The ID of the AWS Verified Access group.
   */
  public verifiedAccessGroupId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnVerifiedAccessEndpointProps) {
    super(scope, id, {
      "type": CfnVerifiedAccessEndpoint.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "applicationDomain", this);
    cdk.requireProperty(props, "attachmentType", this);
    cdk.requireProperty(props, "domainCertificateArn", this);
    cdk.requireProperty(props, "endpointDomainPrefix", this);
    cdk.requireProperty(props, "endpointType", this);
    cdk.requireProperty(props, "verifiedAccessGroupId", this);

    this.attrCreationTime = cdk.Token.asString(this.getAtt("CreationTime", cdk.ResolutionTypeHint.STRING));
    this.attrDeviceValidationDomain = cdk.Token.asString(this.getAtt("DeviceValidationDomain", cdk.ResolutionTypeHint.STRING));
    this.attrEndpointDomain = cdk.Token.asString(this.getAtt("EndpointDomain", cdk.ResolutionTypeHint.STRING));
    this.attrLastUpdatedTime = cdk.Token.asString(this.getAtt("LastUpdatedTime", cdk.ResolutionTypeHint.STRING));
    this.attrStatus = cdk.Token.asString(this.getAtt("Status", cdk.ResolutionTypeHint.STRING));
    this.attrVerifiedAccessEndpointId = cdk.Token.asString(this.getAtt("VerifiedAccessEndpointId", cdk.ResolutionTypeHint.STRING));
    this.attrVerifiedAccessInstanceId = cdk.Token.asString(this.getAtt("VerifiedAccessInstanceId", cdk.ResolutionTypeHint.STRING));
    this.applicationDomain = props.applicationDomain;
    this.attachmentType = props.attachmentType;
    this.description = props.description;
    this.domainCertificateArn = props.domainCertificateArn;
    this.endpointDomainPrefix = props.endpointDomainPrefix;
    this.endpointType = props.endpointType;
    this.loadBalancerOptions = props.loadBalancerOptions;
    this.networkInterfaceOptions = props.networkInterfaceOptions;
    this.policyDocument = props.policyDocument;
    this.policyEnabled = props.policyEnabled;
    this.securityGroupIds = props.securityGroupIds;
    this.sseSpecification = props.sseSpecification;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::VerifiedAccessEndpoint", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.verifiedAccessGroupId = props.verifiedAccessGroupId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "applicationDomain": this.applicationDomain,
      "attachmentType": this.attachmentType,
      "description": this.description,
      "domainCertificateArn": this.domainCertificateArn,
      "endpointDomainPrefix": this.endpointDomainPrefix,
      "endpointType": this.endpointType,
      "loadBalancerOptions": this.loadBalancerOptions,
      "networkInterfaceOptions": this.networkInterfaceOptions,
      "policyDocument": this.policyDocument,
      "policyEnabled": this.policyEnabled,
      "securityGroupIds": this.securityGroupIds,
      "sseSpecification": this.sseSpecification,
      "tags": this.tags.renderTags(),
      "verifiedAccessGroupId": this.verifiedAccessGroupId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnVerifiedAccessEndpoint.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnVerifiedAccessEndpointPropsToCloudFormation(props);
  }
}

export namespace CfnVerifiedAccessEndpoint {
  /**
   * Describes the load balancer options when creating an AWS Verified Access endpoint using the `load-balancer` type.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-loadbalanceroptions.html
   */
  export interface LoadBalancerOptionsProperty {
    /**
     * The ARN of the load balancer.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-loadbalanceroptions.html#cfn-ec2-verifiedaccessendpoint-loadbalanceroptions-loadbalancerarn
     */
    readonly loadBalancerArn?: string;

    /**
     * The IP port number.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-loadbalanceroptions.html#cfn-ec2-verifiedaccessendpoint-loadbalanceroptions-port
     */
    readonly port?: number;

    /**
     * The IP protocol.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-loadbalanceroptions.html#cfn-ec2-verifiedaccessendpoint-loadbalanceroptions-protocol
     */
    readonly protocol?: string;

    /**
     * The IDs of the subnets.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-loadbalanceroptions.html#cfn-ec2-verifiedaccessendpoint-loadbalanceroptions-subnetids
     */
    readonly subnetIds?: Array<string>;
  }

  /**
   * Describes the network interface options when creating an AWS Verified Access endpoint using the `network-interface` type.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-networkinterfaceoptions.html
   */
  export interface NetworkInterfaceOptionsProperty {
    /**
     * The ID of the network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-networkinterfaceoptions.html#cfn-ec2-verifiedaccessendpoint-networkinterfaceoptions-networkinterfaceid
     */
    readonly networkInterfaceId?: string;

    /**
     * The IP port number.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-networkinterfaceoptions.html#cfn-ec2-verifiedaccessendpoint-networkinterfaceoptions-port
     */
    readonly port?: number;

    /**
     * The IP protocol.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-networkinterfaceoptions.html#cfn-ec2-verifiedaccessendpoint-networkinterfaceoptions-protocol
     */
    readonly protocol?: string;
  }

  /**
   * AWS Verified Access provides server side encryption by default to data at rest using AWS -owned KMS keys.
   *
   * You also have the option of using customer managed KMS keys, which can be specified using the options below.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-ssespecification.html
   */
  export interface SseSpecificationProperty {
    /**
     * Enable or disable the use of customer managed KMS keys for server side encryption.
     *
     * Valid values: `True` | `False`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-ssespecification.html#cfn-ec2-verifiedaccessendpoint-ssespecification-customermanagedkeyenabled
     */
    readonly customerManagedKeyEnabled?: boolean | cdk.IResolvable;

    /**
     * The ARN of the KMS key.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-ssespecification.html#cfn-ec2-verifiedaccessendpoint-ssespecification-kmskeyarn
     */
    readonly kmsKeyArn?: string;
  }
}

/**
 * Properties for defining a `CfnVerifiedAccessEndpoint`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html
 */
export interface CfnVerifiedAccessEndpointProps {
  /**
   * The DNS name for users to reach your application.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-applicationdomain
   */
  readonly applicationDomain: string;

  /**
   * The type of attachment used to provide connectivity between the AWS Verified Access endpoint and the application.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-attachmenttype
   */
  readonly attachmentType: string;

  /**
   * A description for the AWS Verified Access endpoint.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-description
   */
  readonly description?: string;

  /**
   * The ARN of a public TLS/SSL certificate imported into or created with ACM.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-domaincertificatearn
   */
  readonly domainCertificateArn: string;

  /**
   * A custom identifier that is prepended to the DNS name that is generated for the endpoint.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-endpointdomainprefix
   */
  readonly endpointDomainPrefix: string;

  /**
   * The type of AWS Verified Access endpoint.
   *
   * Incoming application requests will be sent to an IP address, load balancer or a network interface depending on the endpoint type specified.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-endpointtype
   */
  readonly endpointType: string;

  /**
   * The load balancer details if creating the AWS Verified Access endpoint as `load-balancer` type.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-loadbalanceroptions
   */
  readonly loadBalancerOptions?: cdk.IResolvable | CfnVerifiedAccessEndpoint.LoadBalancerOptionsProperty;

  /**
   * The options for network-interface type endpoint.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-networkinterfaceoptions
   */
  readonly networkInterfaceOptions?: cdk.IResolvable | CfnVerifiedAccessEndpoint.NetworkInterfaceOptionsProperty;

  /**
   * The Verified Access policy document.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-policydocument
   */
  readonly policyDocument?: string;

  /**
   * The status of the Verified Access policy.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-policyenabled
   */
  readonly policyEnabled?: boolean | cdk.IResolvable;

  /**
   * The IDs of the security groups for the endpoint.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-securitygroupids
   */
  readonly securityGroupIds?: Array<string>;

  /**
   * The options for additional server side encryption.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-ssespecification
   */
  readonly sseSpecification?: cdk.IResolvable | CfnVerifiedAccessEndpoint.SseSpecificationProperty;

  /**
   * The tags.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The ID of the AWS Verified Access group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-verifiedaccessgroupid
   */
  readonly verifiedAccessGroupId: string;
}

/**
 * Determine whether the given properties match those of a `LoadBalancerOptionsProperty`
 *
 * @param properties - the TypeScript properties of a `LoadBalancerOptionsProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVerifiedAccessEndpointLoadBalancerOptionsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("loadBalancerArn", cdk.validateString)(properties.loadBalancerArn));
  errors.collect(cdk.propertyValidator("port", cdk.validateNumber)(properties.port));
  errors.collect(cdk.propertyValidator("protocol", cdk.validateString)(properties.protocol));
  errors.collect(cdk.propertyValidator("subnetIds", cdk.listValidator(cdk.validateString))(properties.subnetIds));
  return errors.wrap("supplied properties not correct for \"LoadBalancerOptionsProperty\"");
}

// @ts-ignore TS6133
function convertCfnVerifiedAccessEndpointLoadBalancerOptionsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVerifiedAccessEndpointLoadBalancerOptionsPropertyValidator(properties).assertSuccess();
  return {
    "LoadBalancerArn": cdk.stringToCloudFormation(properties.loadBalancerArn),
    "Port": cdk.numberToCloudFormation(properties.port),
    "Protocol": cdk.stringToCloudFormation(properties.protocol),
    "SubnetIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.subnetIds)
  };
}

// @ts-ignore TS6133
function CfnVerifiedAccessEndpointLoadBalancerOptionsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnVerifiedAccessEndpoint.LoadBalancerOptionsProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVerifiedAccessEndpoint.LoadBalancerOptionsProperty>();
  ret.addPropertyResult("loadBalancerArn", "LoadBalancerArn", (properties.LoadBalancerArn != null ? cfn_parse.FromCloudFormation.getString(properties.LoadBalancerArn) : undefined));
  ret.addPropertyResult("port", "Port", (properties.Port != null ? cfn_parse.FromCloudFormation.getNumber(properties.Port) : undefined));
  ret.addPropertyResult("protocol", "Protocol", (properties.Protocol != null ? cfn_parse.FromCloudFormation.getString(properties.Protocol) : undefined));
  ret.addPropertyResult("subnetIds", "SubnetIds", (properties.SubnetIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SubnetIds) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `NetworkInterfaceOptionsProperty`
 *
 * @param properties - the TypeScript properties of a `NetworkInterfaceOptionsProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVerifiedAccessEndpointNetworkInterfaceOptionsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("networkInterfaceId", cdk.validateString)(properties.networkInterfaceId));
  errors.collect(cdk.propertyValidator("port", cdk.validateNumber)(properties.port));
  errors.collect(cdk.propertyValidator("protocol", cdk.validateString)(properties.protocol));
  return errors.wrap("supplied properties not correct for \"NetworkInterfaceOptionsProperty\"");
}

// @ts-ignore TS6133
function convertCfnVerifiedAccessEndpointNetworkInterfaceOptionsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVerifiedAccessEndpointNetworkInterfaceOptionsPropertyValidator(properties).assertSuccess();
  return {
    "NetworkInterfaceId": cdk.stringToCloudFormation(properties.networkInterfaceId),
    "Port": cdk.numberToCloudFormation(properties.port),
    "Protocol": cdk.stringToCloudFormation(properties.protocol)
  };
}

// @ts-ignore TS6133
function CfnVerifiedAccessEndpointNetworkInterfaceOptionsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnVerifiedAccessEndpoint.NetworkInterfaceOptionsProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVerifiedAccessEndpoint.NetworkInterfaceOptionsProperty>();
  ret.addPropertyResult("networkInterfaceId", "NetworkInterfaceId", (properties.NetworkInterfaceId != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkInterfaceId) : undefined));
  ret.addPropertyResult("port", "Port", (properties.Port != null ? cfn_parse.FromCloudFormation.getNumber(properties.Port) : undefined));
  ret.addPropertyResult("protocol", "Protocol", (properties.Protocol != null ? cfn_parse.FromCloudFormation.getString(properties.Protocol) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `SseSpecificationProperty`
 *
 * @param properties - the TypeScript properties of a `SseSpecificationProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVerifiedAccessEndpointSseSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("customerManagedKeyEnabled", cdk.validateBoolean)(properties.customerManagedKeyEnabled));
  errors.collect(cdk.propertyValidator("kmsKeyArn", cdk.validateString)(properties.kmsKeyArn));
  return errors.wrap("supplied properties not correct for \"SseSpecificationProperty\"");
}

// @ts-ignore TS6133
function convertCfnVerifiedAccessEndpointSseSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVerifiedAccessEndpointSseSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "CustomerManagedKeyEnabled": cdk.booleanToCloudFormation(properties.customerManagedKeyEnabled),
    "KmsKeyArn": cdk.stringToCloudFormation(properties.kmsKeyArn)
  };
}

// @ts-ignore TS6133
function CfnVerifiedAccessEndpointSseSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnVerifiedAccessEndpoint.SseSpecificationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVerifiedAccessEndpoint.SseSpecificationProperty>();
  ret.addPropertyResult("customerManagedKeyEnabled", "CustomerManagedKeyEnabled", (properties.CustomerManagedKeyEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.CustomerManagedKeyEnabled) : undefined));
  ret.addPropertyResult("kmsKeyArn", "KmsKeyArn", (properties.KmsKeyArn != null ? cfn_parse.FromCloudFormation.getString(properties.KmsKeyArn) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `CfnVerifiedAccessEndpointProps`
 *
 * @param properties - the TypeScript properties of a `CfnVerifiedAccessEndpointProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVerifiedAccessEndpointPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("applicationDomain", cdk.requiredValidator)(properties.applicationDomain));
  errors.collect(cdk.propertyValidator("applicationDomain", cdk.validateString)(properties.applicationDomain));
  errors.collect(cdk.propertyValidator("attachmentType", cdk.requiredValidator)(properties.attachmentType));
  errors.collect(cdk.propertyValidator("attachmentType", cdk.validateString)(properties.attachmentType));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("domainCertificateArn", cdk.requiredValidator)(properties.domainCertificateArn));
  errors.collect(cdk.propertyValidator("domainCertificateArn", cdk.validateString)(properties.domainCertificateArn));
  errors.collect(cdk.propertyValidator("endpointDomainPrefix", cdk.requiredValidator)(properties.endpointDomainPrefix));
  errors.collect(cdk.propertyValidator("endpointDomainPrefix", cdk.validateString)(properties.endpointDomainPrefix));
  errors.collect(cdk.propertyValidator("endpointType", cdk.requiredValidator)(properties.endpointType));
  errors.collect(cdk.propertyValidator("endpointType", cdk.validateString)(properties.endpointType));
  errors.collect(cdk.propertyValidator("loadBalancerOptions", CfnVerifiedAccessEndpointLoadBalancerOptionsPropertyValidator)(properties.loadBalancerOptions));
  errors.collect(cdk.propertyValidator("networkInterfaceOptions", CfnVerifiedAccessEndpointNetworkInterfaceOptionsPropertyValidator)(properties.networkInterfaceOptions));
  errors.collect(cdk.propertyValidator("policyDocument", cdk.validateString)(properties.policyDocument));
  errors.collect(cdk.propertyValidator("policyEnabled", cdk.validateBoolean)(properties.policyEnabled));
  errors.collect(cdk.propertyValidator("securityGroupIds", cdk.listValidator(cdk.validateString))(properties.securityGroupIds));
  errors.collect(cdk.propertyValidator("sseSpecification", CfnVerifiedAccessEndpointSseSpecificationPropertyValidator)(properties.sseSpecification));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("verifiedAccessGroupId", cdk.requiredValidator)(properties.verifiedAccessGroupId));
  errors.collect(cdk.propertyValidator("verifiedAccessGroupId", cdk.validateString)(properties.verifiedAccessGroupId));
  return errors.wrap("supplied properties not correct for \"CfnVerifiedAccessEndpointProps\"");
}

// @ts-ignore TS6133
function convertCfnVerifiedAccessEndpointPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVerifiedAccessEndpointPropsValidator(properties).assertSuccess();
  return {
    "ApplicationDomain": cdk.stringToCloudFormation(properties.applicationDomain),
    "AttachmentType": cdk.stringToCloudFormation(properties.attachmentType),
    "Description": cdk.stringToCloudFormation(properties.description),
    "DomainCertificateArn": cdk.stringToCloudFormation(properties.domainCertificateArn),
    "EndpointDomainPrefix": cdk.stringToCloudFormation(properties.endpointDomainPrefix),
    "EndpointType": cdk.stringToCloudFormation(properties.endpointType),
    "LoadBalancerOptions": convertCfnVerifiedAccessEndpointLoadBalancerOptionsPropertyToCloudFormation(properties.loadBalancerOptions),
    "NetworkInterfaceOptions": convertCfnVerifiedAccessEndpointNetworkInterfaceOptionsPropertyToCloudFormation(properties.networkInterfaceOptions),
    "PolicyDocument": cdk.stringToCloudFormation(properties.policyDocument),
    "PolicyEnabled": cdk.booleanToCloudFormation(properties.policyEnabled),
    "SecurityGroupIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.securityGroupIds),
    "SseSpecification": convertCfnVerifiedAccessEndpointSseSpecificationPropertyToCloudFormation(properties.sseSpecification),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "VerifiedAccessGroupId": cdk.stringToCloudFormation(properties.verifiedAccessGroupId)
  };
}

// @ts-ignore TS6133
function CfnVerifiedAccessEndpointPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnVerifiedAccessEndpointProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVerifiedAccessEndpointProps>();
  ret.addPropertyResult("applicationDomain", "ApplicationDomain", (properties.ApplicationDomain != null ? cfn_parse.FromCloudFormation.getString(properties.ApplicationDomain) : undefined));
  ret.addPropertyResult("attachmentType", "AttachmentType", (properties.AttachmentType != null ? cfn_parse.FromCloudFormation.getString(properties.AttachmentType) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("domainCertificateArn", "DomainCertificateArn", (properties.DomainCertificateArn != null ? cfn_parse.FromCloudFormation.getString(properties.DomainCertificateArn) : undefined));
  ret.addPropertyResult("endpointDomainPrefix", "EndpointDomainPrefix", (properties.EndpointDomainPrefix != null ? cfn_parse.FromCloudFormation.getString(properties.EndpointDomainPrefix) : undefined));
  ret.addPropertyResult("endpointType", "EndpointType", (properties.EndpointType != null ? cfn_parse.FromCloudFormation.getString(properties.EndpointType) : undefined));
  ret.addPropertyResult("loadBalancerOptions", "LoadBalancerOptions", (properties.LoadBalancerOptions != null ? CfnVerifiedAccessEndpointLoadBalancerOptionsPropertyFromCloudFormation(properties.LoadBalancerOptions) : undefined));
  ret.addPropertyResult("networkInterfaceOptions", "NetworkInterfaceOptions", (properties.NetworkInterfaceOptions != null ? CfnVerifiedAccessEndpointNetworkInterfaceOptionsPropertyFromCloudFormation(properties.NetworkInterfaceOptions) : undefined));
  ret.addPropertyResult("policyDocument", "PolicyDocument", (properties.PolicyDocument != null ? cfn_parse.FromCloudFormation.getString(properties.PolicyDocument) : undefined));
  ret.addPropertyResult("policyEnabled", "PolicyEnabled", (properties.PolicyEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.PolicyEnabled) : undefined));
  ret.addPropertyResult("securityGroupIds", "SecurityGroupIds", (properties.SecurityGroupIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecurityGroupIds) : undefined));
  ret.addPropertyResult("sseSpecification", "SseSpecification", (properties.SseSpecification != null ? CfnVerifiedAccessEndpointSseSpecificationPropertyFromCloudFormation(properties.SseSpecification) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("verifiedAccessGroupId", "VerifiedAccessGroupId", (properties.VerifiedAccessGroupId != null ? cfn_parse.FromCloudFormation.getString(properties.VerifiedAccessGroupId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * An AWS Verified Access group is a collection of AWS Verified Access endpoints who's associated applications have similar security requirements.
 *
 * Each instance within a Verified Access group shares an Verified Access policy. For example, you can group all Verified Access instances associated with "sales" applications together and use one common Verified Access policy.
 *
 * @cloudformationResource AWS::EC2::VerifiedAccessGroup
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessgroup.html
 */
export class CfnVerifiedAccessGroup extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::VerifiedAccessGroup";

  /**
   * Build a CfnVerifiedAccessGroup from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnVerifiedAccessGroup {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnVerifiedAccessGroupPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnVerifiedAccessGroup(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The creation time.
   *
   * @cloudformationAttribute CreationTime
   */
  public readonly attrCreationTime: string;

  /**
   * The last updated time.
   *
   * @cloudformationAttribute LastUpdatedTime
   */
  public readonly attrLastUpdatedTime: string;

  /**
   * The ID of the AWS account that owns the group.
   *
   * @cloudformationAttribute Owner
   */
  public readonly attrOwner: string;

  /**
   * The ARN of the Verified Access group.
   *
   * @cloudformationAttribute VerifiedAccessGroupArn
   */
  public readonly attrVerifiedAccessGroupArn: string;

  /**
   * The ID of the Verified Access group.
   *
   * @cloudformationAttribute VerifiedAccessGroupId
   */
  public readonly attrVerifiedAccessGroupId: string;

  /**
   * A description for the AWS Verified Access group.
   */
  public description?: string;

  /**
   * The Verified Access policy document.
   */
  public policyDocument?: string;

  /**
   * The status of the Verified Access policy.
   */
  public policyEnabled?: boolean | cdk.IResolvable;

  /**
   * The options for additional server side encryption.
   */
  public sseSpecification?: cdk.IResolvable | CfnVerifiedAccessGroup.SseSpecificationProperty;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The ID of the AWS Verified Access instance.
   */
  public verifiedAccessInstanceId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnVerifiedAccessGroupProps) {
    super(scope, id, {
      "type": CfnVerifiedAccessGroup.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "verifiedAccessInstanceId", this);

    this.attrCreationTime = cdk.Token.asString(this.getAtt("CreationTime", cdk.ResolutionTypeHint.STRING));
    this.attrLastUpdatedTime = cdk.Token.asString(this.getAtt("LastUpdatedTime", cdk.ResolutionTypeHint.STRING));
    this.attrOwner = cdk.Token.asString(this.getAtt("Owner", cdk.ResolutionTypeHint.STRING));
    this.attrVerifiedAccessGroupArn = cdk.Token.asString(this.getAtt("VerifiedAccessGroupArn", cdk.ResolutionTypeHint.STRING));
    this.attrVerifiedAccessGroupId = cdk.Token.asString(this.getAtt("VerifiedAccessGroupId", cdk.ResolutionTypeHint.STRING));
    this.description = props.description;
    this.policyDocument = props.policyDocument;
    this.policyEnabled = props.policyEnabled;
    this.sseSpecification = props.sseSpecification;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::VerifiedAccessGroup", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.verifiedAccessInstanceId = props.verifiedAccessInstanceId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "description": this.description,
      "policyDocument": this.policyDocument,
      "policyEnabled": this.policyEnabled,
      "sseSpecification": this.sseSpecification,
      "tags": this.tags.renderTags(),
      "verifiedAccessInstanceId": this.verifiedAccessInstanceId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnVerifiedAccessGroup.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnVerifiedAccessGroupPropsToCloudFormation(props);
  }
}

export namespace CfnVerifiedAccessGroup {
  /**
   * AWS Verified Access provides server side encryption by default to data at rest using AWS -owned KMS keys.
   *
   * You also have the option of using customer managed KMS keys, which can be specified using the options below.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessgroup-ssespecification.html
   */
  export interface SseSpecificationProperty {
    /**
     * Enable or disable the use of customer managed KMS keys for server side encryption.
     *
     * Valid values: `True` | `False`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessgroup-ssespecification.html#cfn-ec2-verifiedaccessgroup-ssespecification-customermanagedkeyenabled
     */
    readonly customerManagedKeyEnabled?: boolean | cdk.IResolvable;

    /**
     * The ARN of the KMS key.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessgroup-ssespecification.html#cfn-ec2-verifiedaccessgroup-ssespecification-kmskeyarn
     */
    readonly kmsKeyArn?: string;
  }
}

/**
 * Properties for defining a `CfnVerifiedAccessGroup`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessgroup.html
 */
export interface CfnVerifiedAccessGroupProps {
  /**
   * A description for the AWS Verified Access group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessgroup.html#cfn-ec2-verifiedaccessgroup-description
   */
  readonly description?: string;

  /**
   * The Verified Access policy document.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessgroup.html#cfn-ec2-verifiedaccessgroup-policydocument
   */
  readonly policyDocument?: string;

  /**
   * The status of the Verified Access policy.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessgroup.html#cfn-ec2-verifiedaccessgroup-policyenabled
   */
  readonly policyEnabled?: boolean | cdk.IResolvable;

  /**
   * The options for additional server side encryption.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessgroup.html#cfn-ec2-verifiedaccessgroup-ssespecification
   */
  readonly sseSpecification?: cdk.IResolvable | CfnVerifiedAccessGroup.SseSpecificationProperty;

  /**
   * The tags.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessgroup.html#cfn-ec2-verifiedaccessgroup-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The ID of the AWS Verified Access instance.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessgroup.html#cfn-ec2-verifiedaccessgroup-verifiedaccessinstanceid
   */
  readonly verifiedAccessInstanceId: string;
}

/**
 * Determine whether the given properties match those of a `SseSpecificationProperty`
 *
 * @param properties - the TypeScript properties of a `SseSpecificationProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVerifiedAccessGroupSseSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("customerManagedKeyEnabled", cdk.validateBoolean)(properties.customerManagedKeyEnabled));
  errors.collect(cdk.propertyValidator("kmsKeyArn", cdk.validateString)(properties.kmsKeyArn));
  return errors.wrap("supplied properties not correct for \"SseSpecificationProperty\"");
}

// @ts-ignore TS6133
function convertCfnVerifiedAccessGroupSseSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVerifiedAccessGroupSseSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "CustomerManagedKeyEnabled": cdk.booleanToCloudFormation(properties.customerManagedKeyEnabled),
    "KmsKeyArn": cdk.stringToCloudFormation(properties.kmsKeyArn)
  };
}

// @ts-ignore TS6133
function CfnVerifiedAccessGroupSseSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnVerifiedAccessGroup.SseSpecificationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVerifiedAccessGroup.SseSpecificationProperty>();
  ret.addPropertyResult("customerManagedKeyEnabled", "CustomerManagedKeyEnabled", (properties.CustomerManagedKeyEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.CustomerManagedKeyEnabled) : undefined));
  ret.addPropertyResult("kmsKeyArn", "KmsKeyArn", (properties.KmsKeyArn != null ? cfn_parse.FromCloudFormation.getString(properties.KmsKeyArn) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `CfnVerifiedAccessGroupProps`
 *
 * @param properties - the TypeScript properties of a `CfnVerifiedAccessGroupProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVerifiedAccessGroupPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("policyDocument", cdk.validateString)(properties.policyDocument));
  errors.collect(cdk.propertyValidator("policyEnabled", cdk.validateBoolean)(properties.policyEnabled));
  errors.collect(cdk.propertyValidator("sseSpecification", CfnVerifiedAccessGroupSseSpecificationPropertyValidator)(properties.sseSpecification));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("verifiedAccessInstanceId", cdk.requiredValidator)(properties.verifiedAccessInstanceId));
  errors.collect(cdk.propertyValidator("verifiedAccessInstanceId", cdk.validateString)(properties.verifiedAccessInstanceId));
  return errors.wrap("supplied properties not correct for \"CfnVerifiedAccessGroupProps\"");
}

// @ts-ignore TS6133
function convertCfnVerifiedAccessGroupPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVerifiedAccessGroupPropsValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "PolicyDocument": cdk.stringToCloudFormation(properties.policyDocument),
    "PolicyEnabled": cdk.booleanToCloudFormation(properties.policyEnabled),
    "SseSpecification": convertCfnVerifiedAccessGroupSseSpecificationPropertyToCloudFormation(properties.sseSpecification),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "VerifiedAccessInstanceId": cdk.stringToCloudFormation(properties.verifiedAccessInstanceId)
  };
}

// @ts-ignore TS6133
function CfnVerifiedAccessGroupPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnVerifiedAccessGroupProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVerifiedAccessGroupProps>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("policyDocument", "PolicyDocument", (properties.PolicyDocument != null ? cfn_parse.FromCloudFormation.getString(properties.PolicyDocument) : undefined));
  ret.addPropertyResult("policyEnabled", "PolicyEnabled", (properties.PolicyEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.PolicyEnabled) : undefined));
  ret.addPropertyResult("sseSpecification", "SseSpecification", (properties.SseSpecification != null ? CfnVerifiedAccessGroupSseSpecificationPropertyFromCloudFormation(properties.SseSpecification) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("verifiedAccessInstanceId", "VerifiedAccessInstanceId", (properties.VerifiedAccessInstanceId != null ? cfn_parse.FromCloudFormation.getString(properties.VerifiedAccessInstanceId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * An AWS Verified Access instance is a regional entity that evaluates application requests and grants access only when your security requirements are met.
 *
 * @cloudformationResource AWS::EC2::VerifiedAccessInstance
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessinstance.html
 */
export class CfnVerifiedAccessInstance extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::VerifiedAccessInstance";

  /**
   * Build a CfnVerifiedAccessInstance from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnVerifiedAccessInstance {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnVerifiedAccessInstancePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnVerifiedAccessInstance(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The creation time.
   *
   * @cloudformationAttribute CreationTime
   */
  public readonly attrCreationTime: string;

  /**
   * The last updated time.
   *
   * @cloudformationAttribute LastUpdatedTime
   */
  public readonly attrLastUpdatedTime: string;

  /**
   * The ID of the Verified Access instance.
   *
   * @cloudformationAttribute VerifiedAccessInstanceId
   */
  public readonly attrVerifiedAccessInstanceId: string;

  /**
   * A description for the AWS Verified Access instance.
   */
  public description?: string;

  /**
   * Indicates whether support for Federal Information Processing Standards (FIPS) is enabled on the instance.
   */
  public fipsEnabled?: boolean | cdk.IResolvable;

  /**
   * The logging configuration for the Verified Access instances.
   */
  public loggingConfigurations?: cdk.IResolvable | CfnVerifiedAccessInstance.VerifiedAccessLogsProperty;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The IDs of the AWS Verified Access trust providers.
   */
  public verifiedAccessTrustProviderIds?: Array<string>;

  /**
   * The IDs of the AWS Verified Access trust providers.
   */
  public verifiedAccessTrustProviders?: Array<cdk.IResolvable | CfnVerifiedAccessInstance.VerifiedAccessTrustProviderProperty> | cdk.IResolvable;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnVerifiedAccessInstanceProps = {}) {
    super(scope, id, {
      "type": CfnVerifiedAccessInstance.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.attrCreationTime = cdk.Token.asString(this.getAtt("CreationTime", cdk.ResolutionTypeHint.STRING));
    this.attrLastUpdatedTime = cdk.Token.asString(this.getAtt("LastUpdatedTime", cdk.ResolutionTypeHint.STRING));
    this.attrVerifiedAccessInstanceId = cdk.Token.asString(this.getAtt("VerifiedAccessInstanceId", cdk.ResolutionTypeHint.STRING));
    this.description = props.description;
    this.fipsEnabled = props.fipsEnabled;
    this.loggingConfigurations = props.loggingConfigurations;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::VerifiedAccessInstance", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.verifiedAccessTrustProviderIds = props.verifiedAccessTrustProviderIds;
    this.verifiedAccessTrustProviders = props.verifiedAccessTrustProviders;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "description": this.description,
      "fipsEnabled": this.fipsEnabled,
      "loggingConfigurations": this.loggingConfigurations,
      "tags": this.tags.renderTags(),
      "verifiedAccessTrustProviderIds": this.verifiedAccessTrustProviderIds,
      "verifiedAccessTrustProviders": this.verifiedAccessTrustProviders
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnVerifiedAccessInstance.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnVerifiedAccessInstancePropsToCloudFormation(props);
  }
}

export namespace CfnVerifiedAccessInstance {
  /**
   * A trust provider is a third-party entity that creates, maintains, and manages identity information for users and devices.
   *
   * When an application request is made, the identity information sent by the trust provider is evaluated by Verified Access before allowing or denying the application request.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-verifiedaccesstrustprovider.html
   */
  export interface VerifiedAccessTrustProviderProperty {
    /**
     * A description for the AWS Verified Access trust provider.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccessinstance-verifiedaccesstrustprovider-description
     */
    readonly description?: string;

    /**
     * The type of device-based trust provider.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccessinstance-verifiedaccesstrustprovider-devicetrustprovidertype
     */
    readonly deviceTrustProviderType?: string;

    /**
     * The type of Verified Access trust provider.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccessinstance-verifiedaccesstrustprovider-trustprovidertype
     */
    readonly trustProviderType?: string;

    /**
     * The type of user-based trust provider.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccessinstance-verifiedaccesstrustprovider-usertrustprovidertype
     */
    readonly userTrustProviderType?: string;

    /**
     * The ID of the AWS Verified Access trust provider.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccessinstance-verifiedaccesstrustprovider-verifiedaccesstrustproviderid
     */
    readonly verifiedAccessTrustProviderId?: string;
  }

  /**
   * Describes the options for Verified Access logs.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-verifiedaccesslogs.html
   */
  export interface VerifiedAccessLogsProperty {
    /**
     * CloudWatch Logs logging destination.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-verifiedaccesslogs.html#cfn-ec2-verifiedaccessinstance-verifiedaccesslogs-cloudwatchlogs
     */
    readonly cloudWatchLogs?: CfnVerifiedAccessInstance.CloudWatchLogsProperty | cdk.IResolvable;

    /**
     * Indicates whether to include trust data sent by trust providers in the logs.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-verifiedaccesslogs.html#cfn-ec2-verifiedaccessinstance-verifiedaccesslogs-includetrustcontext
     */
    readonly includeTrustContext?: boolean | cdk.IResolvable;

    /**
     * Kinesis logging destination.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-verifiedaccesslogs.html#cfn-ec2-verifiedaccessinstance-verifiedaccesslogs-kinesisdatafirehose
     */
    readonly kinesisDataFirehose?: cdk.IResolvable | CfnVerifiedAccessInstance.KinesisDataFirehoseProperty;

    /**
     * The logging version.
     *
     * Valid values: `ocsf-0.1` | `ocsf-1.0.0-rc.2`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-verifiedaccesslogs.html#cfn-ec2-verifiedaccessinstance-verifiedaccesslogs-logversion
     */
    readonly logVersion?: string;

    /**
     * Amazon S3 logging options.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-verifiedaccesslogs.html#cfn-ec2-verifiedaccessinstance-verifiedaccesslogs-s3
     */
    readonly s3?: cdk.IResolvable | CfnVerifiedAccessInstance.S3Property;
  }

  /**
   * Options for Amazon S3 as a logging destination.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-s3.html
   */
  export interface S3Property {
    /**
     * The bucket name.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-s3.html#cfn-ec2-verifiedaccessinstance-s3-bucketname
     */
    readonly bucketName?: string;

    /**
     * The AWS account number that owns the bucket.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-s3.html#cfn-ec2-verifiedaccessinstance-s3-bucketowner
     */
    readonly bucketOwner?: string;

    /**
     * Indicates whether logging is enabled.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-s3.html#cfn-ec2-verifiedaccessinstance-s3-enabled
     */
    readonly enabled?: boolean | cdk.IResolvable;

    /**
     * The bucket prefix.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-s3.html#cfn-ec2-verifiedaccessinstance-s3-prefix
     */
    readonly prefix?: string;
  }

  /**
   * Options for Kinesis as a logging destination.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-kinesisdatafirehose.html
   */
  export interface KinesisDataFirehoseProperty {
    /**
     * The ID of the delivery stream.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-kinesisdatafirehose.html#cfn-ec2-verifiedaccessinstance-kinesisdatafirehose-deliverystream
     */
    readonly deliveryStream?: string;

    /**
     * Indicates whether logging is enabled.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-kinesisdatafirehose.html#cfn-ec2-verifiedaccessinstance-kinesisdatafirehose-enabled
     */
    readonly enabled?: boolean | cdk.IResolvable;
  }

  /**
   * Options for CloudWatch Logs as a logging destination.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-cloudwatchlogs.html
   */
  export interface CloudWatchLogsProperty {
    /**
     * Indicates whether logging is enabled.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-cloudwatchlogs.html#cfn-ec2-verifiedaccessinstance-cloudwatchlogs-enabled
     */
    readonly enabled?: boolean | cdk.IResolvable;

    /**
     * The ID of the CloudWatch Logs log group.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-cloudwatchlogs.html#cfn-ec2-verifiedaccessinstance-cloudwatchlogs-loggroup
     */
    readonly logGroup?: string;
  }
}

/**
 * Properties for defining a `CfnVerifiedAccessInstance`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessinstance.html
 */
export interface CfnVerifiedAccessInstanceProps {
  /**
   * A description for the AWS Verified Access instance.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessinstance.html#cfn-ec2-verifiedaccessinstance-description
   */
  readonly description?: string;

  /**
   * Indicates whether support for Federal Information Processing Standards (FIPS) is enabled on the instance.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessinstance.html#cfn-ec2-verifiedaccessinstance-fipsenabled
   */
  readonly fipsEnabled?: boolean | cdk.IResolvable;

  /**
   * The logging configuration for the Verified Access instances.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessinstance.html#cfn-ec2-verifiedaccessinstance-loggingconfigurations
   */
  readonly loggingConfigurations?: cdk.IResolvable | CfnVerifiedAccessInstance.VerifiedAccessLogsProperty;

  /**
   * The tags.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessinstance.html#cfn-ec2-verifiedaccessinstance-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The IDs of the AWS Verified Access trust providers.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessinstance.html#cfn-ec2-verifiedaccessinstance-verifiedaccesstrustproviderids
   */
  readonly verifiedAccessTrustProviderIds?: Array<string>;

  /**
   * The IDs of the AWS Verified Access trust providers.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessinstance.html#cfn-ec2-verifiedaccessinstance-verifiedaccesstrustproviders
   */
  readonly verifiedAccessTrustProviders?: Array<cdk.IResolvable | CfnVerifiedAccessInstance.VerifiedAccessTrustProviderProperty> | cdk.IResolvable;
}

/**
 * Determine whether the given properties match those of a `VerifiedAccessTrustProviderProperty`
 *
 * @param properties - the TypeScript properties of a `VerifiedAccessTrustProviderProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVerifiedAccessInstanceVerifiedAccessTrustProviderPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("deviceTrustProviderType", cdk.validateString)(properties.deviceTrustProviderType));
  errors.collect(cdk.propertyValidator("trustProviderType", cdk.validateString)(properties.trustProviderType));
  errors.collect(cdk.propertyValidator("userTrustProviderType", cdk.validateString)(properties.userTrustProviderType));
  errors.collect(cdk.propertyValidator("verifiedAccessTrustProviderId", cdk.validateString)(properties.verifiedAccessTrustProviderId));
  return errors.wrap("supplied properties not correct for \"VerifiedAccessTrustProviderProperty\"");
}

// @ts-ignore TS6133
function convertCfnVerifiedAccessInstanceVerifiedAccessTrustProviderPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVerifiedAccessInstanceVerifiedAccessTrustProviderPropertyValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "DeviceTrustProviderType": cdk.stringToCloudFormation(properties.deviceTrustProviderType),
    "TrustProviderType": cdk.stringToCloudFormation(properties.trustProviderType),
    "UserTrustProviderType": cdk.stringToCloudFormation(properties.userTrustProviderType),
    "VerifiedAccessTrustProviderId": cdk.stringToCloudFormation(properties.verifiedAccessTrustProviderId)
  };
}

// @ts-ignore TS6133
function CfnVerifiedAccessInstanceVerifiedAccessTrustProviderPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnVerifiedAccessInstance.VerifiedAccessTrustProviderProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVerifiedAccessInstance.VerifiedAccessTrustProviderProperty>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("deviceTrustProviderType", "DeviceTrustProviderType", (properties.DeviceTrustProviderType != null ? cfn_parse.FromCloudFormation.getString(properties.DeviceTrustProviderType) : undefined));
  ret.addPropertyResult("trustProviderType", "TrustProviderType", (properties.TrustProviderType != null ? cfn_parse.FromCloudFormation.getString(properties.TrustProviderType) : undefined));
  ret.addPropertyResult("userTrustProviderType", "UserTrustProviderType", (properties.UserTrustProviderType != null ? cfn_parse.FromCloudFormation.getString(properties.UserTrustProviderType) : undefined));
  ret.addPropertyResult("verifiedAccessTrustProviderId", "VerifiedAccessTrustProviderId", (properties.VerifiedAccessTrustProviderId != null ? cfn_parse.FromCloudFormation.getString(properties.VerifiedAccessTrustProviderId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `S3Property`
 *
 * @param properties - the TypeScript properties of a `S3Property`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVerifiedAccessInstanceS3PropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("bucketName", cdk.validateString)(properties.bucketName));
  errors.collect(cdk.propertyValidator("bucketOwner", cdk.validateString)(properties.bucketOwner));
  errors.collect(cdk.propertyValidator("enabled", cdk.validateBoolean)(properties.enabled));
  errors.collect(cdk.propertyValidator("prefix", cdk.validateString)(properties.prefix));
  return errors.wrap("supplied properties not correct for \"S3Property\"");
}

// @ts-ignore TS6133
function convertCfnVerifiedAccessInstanceS3PropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVerifiedAccessInstanceS3PropertyValidator(properties).assertSuccess();
  return {
    "BucketName": cdk.stringToCloudFormation(properties.bucketName),
    "BucketOwner": cdk.stringToCloudFormation(properties.bucketOwner),
    "Enabled": cdk.booleanToCloudFormation(properties.enabled),
    "Prefix": cdk.stringToCloudFormation(properties.prefix)
  };
}

// @ts-ignore TS6133
function CfnVerifiedAccessInstanceS3PropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnVerifiedAccessInstance.S3Property> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVerifiedAccessInstance.S3Property>();
  ret.addPropertyResult("bucketName", "BucketName", (properties.BucketName != null ? cfn_parse.FromCloudFormation.getString(properties.BucketName) : undefined));
  ret.addPropertyResult("bucketOwner", "BucketOwner", (properties.BucketOwner != null ? cfn_parse.FromCloudFormation.getString(properties.BucketOwner) : undefined));
  ret.addPropertyResult("enabled", "Enabled", (properties.Enabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Enabled) : undefined));
  ret.addPropertyResult("prefix", "Prefix", (properties.Prefix != null ? cfn_parse.FromCloudFormation.getString(properties.Prefix) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `KinesisDataFirehoseProperty`
 *
 * @param properties - the TypeScript properties of a `KinesisDataFirehoseProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVerifiedAccessInstanceKinesisDataFirehosePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("deliveryStream", cdk.validateString)(properties.deliveryStream));
  errors.collect(cdk.propertyValidator("enabled", cdk.validateBoolean)(properties.enabled));
  return errors.wrap("supplied properties not correct for \"KinesisDataFirehoseProperty\"");
}

// @ts-ignore TS6133
function convertCfnVerifiedAccessInstanceKinesisDataFirehosePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVerifiedAccessInstanceKinesisDataFirehosePropertyValidator(properties).assertSuccess();
  return {
    "DeliveryStream": cdk.stringToCloudFormation(properties.deliveryStream),
    "Enabled": cdk.booleanToCloudFormation(properties.enabled)
  };
}

// @ts-ignore TS6133
function CfnVerifiedAccessInstanceKinesisDataFirehosePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnVerifiedAccessInstance.KinesisDataFirehoseProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVerifiedAccessInstance.KinesisDataFirehoseProperty>();
  ret.addPropertyResult("deliveryStream", "DeliveryStream", (properties.DeliveryStream != null ? cfn_parse.FromCloudFormation.getString(properties.DeliveryStream) : undefined));
  ret.addPropertyResult("enabled", "Enabled", (properties.Enabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Enabled) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `CloudWatchLogsProperty`
 *
 * @param properties - the TypeScript properties of a `CloudWatchLogsProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVerifiedAccessInstanceCloudWatchLogsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("enabled", cdk.validateBoolean)(properties.enabled));
  errors.collect(cdk.propertyValidator("logGroup", cdk.validateString)(properties.logGroup));
  return errors.wrap("supplied properties not correct for \"CloudWatchLogsProperty\"");
}

// @ts-ignore TS6133
function convertCfnVerifiedAccessInstanceCloudWatchLogsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVerifiedAccessInstanceCloudWatchLogsPropertyValidator(properties).assertSuccess();
  return {
    "Enabled": cdk.booleanToCloudFormation(properties.enabled),
    "LogGroup": cdk.stringToCloudFormation(properties.logGroup)
  };
}

// @ts-ignore TS6133
function CfnVerifiedAccessInstanceCloudWatchLogsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnVerifiedAccessInstance.CloudWatchLogsProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVerifiedAccessInstance.CloudWatchLogsProperty>();
  ret.addPropertyResult("enabled", "Enabled", (properties.Enabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Enabled) : undefined));
  ret.addPropertyResult("logGroup", "LogGroup", (properties.LogGroup != null ? cfn_parse.FromCloudFormation.getString(properties.LogGroup) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `VerifiedAccessLogsProperty`
 *
 * @param properties - the TypeScript properties of a `VerifiedAccessLogsProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVerifiedAccessInstanceVerifiedAccessLogsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("cloudWatchLogs", CfnVerifiedAccessInstanceCloudWatchLogsPropertyValidator)(properties.cloudWatchLogs));
  errors.collect(cdk.propertyValidator("includeTrustContext", cdk.validateBoolean)(properties.includeTrustContext));
  errors.collect(cdk.propertyValidator("kinesisDataFirehose", CfnVerifiedAccessInstanceKinesisDataFirehosePropertyValidator)(properties.kinesisDataFirehose));
  errors.collect(cdk.propertyValidator("logVersion", cdk.validateString)(properties.logVersion));
  errors.collect(cdk.propertyValidator("s3", CfnVerifiedAccessInstanceS3PropertyValidator)(properties.s3));
  return errors.wrap("supplied properties not correct for \"VerifiedAccessLogsProperty\"");
}

// @ts-ignore TS6133
function convertCfnVerifiedAccessInstanceVerifiedAccessLogsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVerifiedAccessInstanceVerifiedAccessLogsPropertyValidator(properties).assertSuccess();
  return {
    "CloudWatchLogs": convertCfnVerifiedAccessInstanceCloudWatchLogsPropertyToCloudFormation(properties.cloudWatchLogs),
    "IncludeTrustContext": cdk.booleanToCloudFormation(properties.includeTrustContext),
    "KinesisDataFirehose": convertCfnVerifiedAccessInstanceKinesisDataFirehosePropertyToCloudFormation(properties.kinesisDataFirehose),
    "LogVersion": cdk.stringToCloudFormation(properties.logVersion),
    "S3": convertCfnVerifiedAccessInstanceS3PropertyToCloudFormation(properties.s3)
  };
}

// @ts-ignore TS6133
function CfnVerifiedAccessInstanceVerifiedAccessLogsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnVerifiedAccessInstance.VerifiedAccessLogsProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVerifiedAccessInstance.VerifiedAccessLogsProperty>();
  ret.addPropertyResult("cloudWatchLogs", "CloudWatchLogs", (properties.CloudWatchLogs != null ? CfnVerifiedAccessInstanceCloudWatchLogsPropertyFromCloudFormation(properties.CloudWatchLogs) : undefined));
  ret.addPropertyResult("includeTrustContext", "IncludeTrustContext", (properties.IncludeTrustContext != null ? cfn_parse.FromCloudFormation.getBoolean(properties.IncludeTrustContext) : undefined));
  ret.addPropertyResult("kinesisDataFirehose", "KinesisDataFirehose", (properties.KinesisDataFirehose != null ? CfnVerifiedAccessInstanceKinesisDataFirehosePropertyFromCloudFormation(properties.KinesisDataFirehose) : undefined));
  ret.addPropertyResult("logVersion", "LogVersion", (properties.LogVersion != null ? cfn_parse.FromCloudFormation.getString(properties.LogVersion) : undefined));
  ret.addPropertyResult("s3", "S3", (properties.S3 != null ? CfnVerifiedAccessInstanceS3PropertyFromCloudFormation(properties.S3) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `CfnVerifiedAccessInstanceProps`
 *
 * @param properties - the TypeScript properties of a `CfnVerifiedAccessInstanceProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVerifiedAccessInstancePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("fipsEnabled", cdk.validateBoolean)(properties.fipsEnabled));
  errors.collect(cdk.propertyValidator("loggingConfigurations", CfnVerifiedAccessInstanceVerifiedAccessLogsPropertyValidator)(properties.loggingConfigurations));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("verifiedAccessTrustProviderIds", cdk.listValidator(cdk.validateString))(properties.verifiedAccessTrustProviderIds));
  errors.collect(cdk.propertyValidator("verifiedAccessTrustProviders", cdk.listValidator(CfnVerifiedAccessInstanceVerifiedAccessTrustProviderPropertyValidator))(properties.verifiedAccessTrustProviders));
  return errors.wrap("supplied properties not correct for \"CfnVerifiedAccessInstanceProps\"");
}

// @ts-ignore TS6133
function convertCfnVerifiedAccessInstancePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVerifiedAccessInstancePropsValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "FipsEnabled": cdk.booleanToCloudFormation(properties.fipsEnabled),
    "LoggingConfigurations": convertCfnVerifiedAccessInstanceVerifiedAccessLogsPropertyToCloudFormation(properties.loggingConfigurations),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "VerifiedAccessTrustProviderIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.verifiedAccessTrustProviderIds),
    "VerifiedAccessTrustProviders": cdk.listMapper(convertCfnVerifiedAccessInstanceVerifiedAccessTrustProviderPropertyToCloudFormation)(properties.verifiedAccessTrustProviders)
  };
}

// @ts-ignore TS6133
function CfnVerifiedAccessInstancePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnVerifiedAccessInstanceProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVerifiedAccessInstanceProps>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("fipsEnabled", "FipsEnabled", (properties.FipsEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.FipsEnabled) : undefined));
  ret.addPropertyResult("loggingConfigurations", "LoggingConfigurations", (properties.LoggingConfigurations != null ? CfnVerifiedAccessInstanceVerifiedAccessLogsPropertyFromCloudFormation(properties.LoggingConfigurations) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("verifiedAccessTrustProviderIds", "VerifiedAccessTrustProviderIds", (properties.VerifiedAccessTrustProviderIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.VerifiedAccessTrustProviderIds) : undefined));
  ret.addPropertyResult("verifiedAccessTrustProviders", "VerifiedAccessTrustProviders", (properties.VerifiedAccessTrustProviders != null ? cfn_parse.FromCloudFormation.getArray(CfnVerifiedAccessInstanceVerifiedAccessTrustProviderPropertyFromCloudFormation)(properties.VerifiedAccessTrustProviders) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * A trust provider is a third-party entity that creates, maintains, and manages identity information for users and devices.
 *
 * When an application request is made, the identity information sent by the trust provider is evaluated by Verified Access before allowing or denying the application request.
 *
 * @cloudformationResource AWS::EC2::VerifiedAccessTrustProvider
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccesstrustprovider.html
 */
export class CfnVerifiedAccessTrustProvider extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::VerifiedAccessTrustProvider";

  /**
   * Build a CfnVerifiedAccessTrustProvider from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnVerifiedAccessTrustProvider {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnVerifiedAccessTrustProviderPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnVerifiedAccessTrustProvider(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The creation time.
   *
   * @cloudformationAttribute CreationTime
   */
  public readonly attrCreationTime: string;

  /**
   * The last updated time.
   *
   * @cloudformationAttribute LastUpdatedTime
   */
  public readonly attrLastUpdatedTime: string;

  /**
   * The ID of the Verified Access trust provider.
   *
   * @cloudformationAttribute VerifiedAccessTrustProviderId
   */
  public readonly attrVerifiedAccessTrustProviderId: string;

  /**
   * A description for the AWS Verified Access trust provider.
   */
  public description?: string;

  /**
   * The options for device-identity trust provider.
   */
  public deviceOptions?: CfnVerifiedAccessTrustProvider.DeviceOptionsProperty | cdk.IResolvable;

  /**
   * The type of device-based trust provider.
   */
  public deviceTrustProviderType?: string;

  /**
   * The options for an OpenID Connect-compatible user-identity trust provider.
   */
  public oidcOptions?: cdk.IResolvable | CfnVerifiedAccessTrustProvider.OidcOptionsProperty;

  /**
   * The identifier to be used when working with policy rules.
   */
  public policyReferenceName: string;

  /**
   * The options for additional server side encryption.
   */
  public sseSpecification?: cdk.IResolvable | CfnVerifiedAccessTrustProvider.SseSpecificationProperty;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The type of Verified Access trust provider.
   */
  public trustProviderType: string;

  /**
   * The type of user-based trust provider.
   */
  public userTrustProviderType?: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnVerifiedAccessTrustProviderProps) {
    super(scope, id, {
      "type": CfnVerifiedAccessTrustProvider.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "policyReferenceName", this);
    cdk.requireProperty(props, "trustProviderType", this);

    this.attrCreationTime = cdk.Token.asString(this.getAtt("CreationTime", cdk.ResolutionTypeHint.STRING));
    this.attrLastUpdatedTime = cdk.Token.asString(this.getAtt("LastUpdatedTime", cdk.ResolutionTypeHint.STRING));
    this.attrVerifiedAccessTrustProviderId = cdk.Token.asString(this.getAtt("VerifiedAccessTrustProviderId", cdk.ResolutionTypeHint.STRING));
    this.description = props.description;
    this.deviceOptions = props.deviceOptions;
    this.deviceTrustProviderType = props.deviceTrustProviderType;
    this.oidcOptions = props.oidcOptions;
    this.policyReferenceName = props.policyReferenceName;
    this.sseSpecification = props.sseSpecification;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::VerifiedAccessTrustProvider", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.trustProviderType = props.trustProviderType;
    this.userTrustProviderType = props.userTrustProviderType;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "description": this.description,
      "deviceOptions": this.deviceOptions,
      "deviceTrustProviderType": this.deviceTrustProviderType,
      "oidcOptions": this.oidcOptions,
      "policyReferenceName": this.policyReferenceName,
      "sseSpecification": this.sseSpecification,
      "tags": this.tags.renderTags(),
      "trustProviderType": this.trustProviderType,
      "userTrustProviderType": this.userTrustProviderType
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnVerifiedAccessTrustProvider.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnVerifiedAccessTrustProviderPropsToCloudFormation(props);
  }
}

export namespace CfnVerifiedAccessTrustProvider {
  /**
   * Describes the options for an AWS Verified Access device-identity based trust provider.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-deviceoptions.html
   */
  export interface DeviceOptionsProperty {
    /**
     * The URL AWS Verified Access will use to verify the authenticity of the device tokens.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-deviceoptions.html#cfn-ec2-verifiedaccesstrustprovider-deviceoptions-publicsigningkeyurl
     */
    readonly publicSigningKeyUrl?: string;

    /**
     * The ID of the tenant application with the device-identity provider.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-deviceoptions.html#cfn-ec2-verifiedaccesstrustprovider-deviceoptions-tenantid
     */
    readonly tenantId?: string;
  }

  /**
   * Describes the options for an OpenID Connect-compatible user-identity trust provider.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-oidcoptions.html
   */
  export interface OidcOptionsProperty {
    /**
     * The OIDC authorization endpoint.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-oidcoptions.html#cfn-ec2-verifiedaccesstrustprovider-oidcoptions-authorizationendpoint
     */
    readonly authorizationEndpoint?: string;

    /**
     * The client identifier.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-oidcoptions.html#cfn-ec2-verifiedaccesstrustprovider-oidcoptions-clientid
     */
    readonly clientId?: string;

    /**
     * The client secret.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-oidcoptions.html#cfn-ec2-verifiedaccesstrustprovider-oidcoptions-clientsecret
     */
    readonly clientSecret?: string;

    /**
     * The OIDC issuer.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-oidcoptions.html#cfn-ec2-verifiedaccesstrustprovider-oidcoptions-issuer
     */
    readonly issuer?: string;

    /**
     * The OpenID Connect (OIDC) scope specified.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-oidcoptions.html#cfn-ec2-verifiedaccesstrustprovider-oidcoptions-scope
     */
    readonly scope?: string;

    /**
     * The OIDC token endpoint.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-oidcoptions.html#cfn-ec2-verifiedaccesstrustprovider-oidcoptions-tokenendpoint
     */
    readonly tokenEndpoint?: string;

    /**
     * The OIDC user info endpoint.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-oidcoptions.html#cfn-ec2-verifiedaccesstrustprovider-oidcoptions-userinfoendpoint
     */
    readonly userInfoEndpoint?: string;
  }

  /**
   * AWS Verified Access provides server side encryption by default to data at rest using AWS -owned KMS keys.
   *
   * You also have the option of using customer managed KMS keys, which can be specified using the options below.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-ssespecification.html
   */
  export interface SseSpecificationProperty {
    /**
     * Enable or disable the use of customer managed KMS keys for server side encryption.
     *
     * Valid values: `True` | `False`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-ssespecification.html#cfn-ec2-verifiedaccesstrustprovider-ssespecification-customermanagedkeyenabled
     */
    readonly customerManagedKeyEnabled?: boolean | cdk.IResolvable;

    /**
     * The ARN of the KMS key.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-ssespecification.html#cfn-ec2-verifiedaccesstrustprovider-ssespecification-kmskeyarn
     */
    readonly kmsKeyArn?: string;
  }
}

/**
 * Properties for defining a `CfnVerifiedAccessTrustProvider`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccesstrustprovider.html
 */
export interface CfnVerifiedAccessTrustProviderProps {
  /**
   * A description for the AWS Verified Access trust provider.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccesstrustprovider-description
   */
  readonly description?: string;

  /**
   * The options for device-identity trust provider.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccesstrustprovider-deviceoptions
   */
  readonly deviceOptions?: CfnVerifiedAccessTrustProvider.DeviceOptionsProperty | cdk.IResolvable;

  /**
   * The type of device-based trust provider.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccesstrustprovider-devicetrustprovidertype
   */
  readonly deviceTrustProviderType?: string;

  /**
   * The options for an OpenID Connect-compatible user-identity trust provider.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccesstrustprovider-oidcoptions
   */
  readonly oidcOptions?: cdk.IResolvable | CfnVerifiedAccessTrustProvider.OidcOptionsProperty;

  /**
   * The identifier to be used when working with policy rules.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccesstrustprovider-policyreferencename
   */
  readonly policyReferenceName: string;

  /**
   * The options for additional server side encryption.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccesstrustprovider-ssespecification
   */
  readonly sseSpecification?: cdk.IResolvable | CfnVerifiedAccessTrustProvider.SseSpecificationProperty;

  /**
   * The tags.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccesstrustprovider-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The type of Verified Access trust provider.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccesstrustprovider-trustprovidertype
   */
  readonly trustProviderType: string;

  /**
   * The type of user-based trust provider.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccesstrustprovider-usertrustprovidertype
   */
  readonly userTrustProviderType?: string;
}

/**
 * Determine whether the given properties match those of a `DeviceOptionsProperty`
 *
 * @param properties - the TypeScript properties of a `DeviceOptionsProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVerifiedAccessTrustProviderDeviceOptionsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("publicSigningKeyUrl", cdk.validateString)(properties.publicSigningKeyUrl));
  errors.collect(cdk.propertyValidator("tenantId", cdk.validateString)(properties.tenantId));
  return errors.wrap("supplied properties not correct for \"DeviceOptionsProperty\"");
}

// @ts-ignore TS6133
function convertCfnVerifiedAccessTrustProviderDeviceOptionsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVerifiedAccessTrustProviderDeviceOptionsPropertyValidator(properties).assertSuccess();
  return {
    "PublicSigningKeyUrl": cdk.stringToCloudFormation(properties.publicSigningKeyUrl),
    "TenantId": cdk.stringToCloudFormation(properties.tenantId)
  };
}

// @ts-ignore TS6133
function CfnVerifiedAccessTrustProviderDeviceOptionsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnVerifiedAccessTrustProvider.DeviceOptionsProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVerifiedAccessTrustProvider.DeviceOptionsProperty>();
  ret.addPropertyResult("publicSigningKeyUrl", "PublicSigningKeyUrl", (properties.PublicSigningKeyUrl != null ? cfn_parse.FromCloudFormation.getString(properties.PublicSigningKeyUrl) : undefined));
  ret.addPropertyResult("tenantId", "TenantId", (properties.TenantId != null ? cfn_parse.FromCloudFormation.getString(properties.TenantId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `OidcOptionsProperty`
 *
 * @param properties - the TypeScript properties of a `OidcOptionsProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVerifiedAccessTrustProviderOidcOptionsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("authorizationEndpoint", cdk.validateString)(properties.authorizationEndpoint));
  errors.collect(cdk.propertyValidator("clientId", cdk.validateString)(properties.clientId));
  errors.collect(cdk.propertyValidator("clientSecret", cdk.validateString)(properties.clientSecret));
  errors.collect(cdk.propertyValidator("issuer", cdk.validateString)(properties.issuer));
  errors.collect(cdk.propertyValidator("scope", cdk.validateString)(properties.scope));
  errors.collect(cdk.propertyValidator("tokenEndpoint", cdk.validateString)(properties.tokenEndpoint));
  errors.collect(cdk.propertyValidator("userInfoEndpoint", cdk.validateString)(properties.userInfoEndpoint));
  return errors.wrap("supplied properties not correct for \"OidcOptionsProperty\"");
}

// @ts-ignore TS6133
function convertCfnVerifiedAccessTrustProviderOidcOptionsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVerifiedAccessTrustProviderOidcOptionsPropertyValidator(properties).assertSuccess();
  return {
    "AuthorizationEndpoint": cdk.stringToCloudFormation(properties.authorizationEndpoint),
    "ClientId": cdk.stringToCloudFormation(properties.clientId),
    "ClientSecret": cdk.stringToCloudFormation(properties.clientSecret),
    "Issuer": cdk.stringToCloudFormation(properties.issuer),
    "Scope": cdk.stringToCloudFormation(properties.scope),
    "TokenEndpoint": cdk.stringToCloudFormation(properties.tokenEndpoint),
    "UserInfoEndpoint": cdk.stringToCloudFormation(properties.userInfoEndpoint)
  };
}

// @ts-ignore TS6133
function CfnVerifiedAccessTrustProviderOidcOptionsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnVerifiedAccessTrustProvider.OidcOptionsProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVerifiedAccessTrustProvider.OidcOptionsProperty>();
  ret.addPropertyResult("authorizationEndpoint", "AuthorizationEndpoint", (properties.AuthorizationEndpoint != null ? cfn_parse.FromCloudFormation.getString(properties.AuthorizationEndpoint) : undefined));
  ret.addPropertyResult("clientId", "ClientId", (properties.ClientId != null ? cfn_parse.FromCloudFormation.getString(properties.ClientId) : undefined));
  ret.addPropertyResult("clientSecret", "ClientSecret", (properties.ClientSecret != null ? cfn_parse.FromCloudFormation.getString(properties.ClientSecret) : undefined));
  ret.addPropertyResult("issuer", "Issuer", (properties.Issuer != null ? cfn_parse.FromCloudFormation.getString(properties.Issuer) : undefined));
  ret.addPropertyResult("scope", "Scope", (properties.Scope != null ? cfn_parse.FromCloudFormation.getString(properties.Scope) : undefined));
  ret.addPropertyResult("tokenEndpoint", "TokenEndpoint", (properties.TokenEndpoint != null ? cfn_parse.FromCloudFormation.getString(properties.TokenEndpoint) : undefined));
  ret.addPropertyResult("userInfoEndpoint", "UserInfoEndpoint", (properties.UserInfoEndpoint != null ? cfn_parse.FromCloudFormation.getString(properties.UserInfoEndpoint) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `SseSpecificationProperty`
 *
 * @param properties - the TypeScript properties of a `SseSpecificationProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVerifiedAccessTrustProviderSseSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("customerManagedKeyEnabled", cdk.validateBoolean)(properties.customerManagedKeyEnabled));
  errors.collect(cdk.propertyValidator("kmsKeyArn", cdk.validateString)(properties.kmsKeyArn));
  return errors.wrap("supplied properties not correct for \"SseSpecificationProperty\"");
}

// @ts-ignore TS6133
function convertCfnVerifiedAccessTrustProviderSseSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVerifiedAccessTrustProviderSseSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "CustomerManagedKeyEnabled": cdk.booleanToCloudFormation(properties.customerManagedKeyEnabled),
    "KmsKeyArn": cdk.stringToCloudFormation(properties.kmsKeyArn)
  };
}

// @ts-ignore TS6133
function CfnVerifiedAccessTrustProviderSseSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnVerifiedAccessTrustProvider.SseSpecificationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVerifiedAccessTrustProvider.SseSpecificationProperty>();
  ret.addPropertyResult("customerManagedKeyEnabled", "CustomerManagedKeyEnabled", (properties.CustomerManagedKeyEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.CustomerManagedKeyEnabled) : undefined));
  ret.addPropertyResult("kmsKeyArn", "KmsKeyArn", (properties.KmsKeyArn != null ? cfn_parse.FromCloudFormation.getString(properties.KmsKeyArn) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `CfnVerifiedAccessTrustProviderProps`
 *
 * @param properties - the TypeScript properties of a `CfnVerifiedAccessTrustProviderProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVerifiedAccessTrustProviderPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("deviceOptions", CfnVerifiedAccessTrustProviderDeviceOptionsPropertyValidator)(properties.deviceOptions));
  errors.collect(cdk.propertyValidator("deviceTrustProviderType", cdk.validateString)(properties.deviceTrustProviderType));
  errors.collect(cdk.propertyValidator("oidcOptions", CfnVerifiedAccessTrustProviderOidcOptionsPropertyValidator)(properties.oidcOptions));
  errors.collect(cdk.propertyValidator("policyReferenceName", cdk.requiredValidator)(properties.policyReferenceName));
  errors.collect(cdk.propertyValidator("policyReferenceName", cdk.validateString)(properties.policyReferenceName));
  errors.collect(cdk.propertyValidator("sseSpecification", CfnVerifiedAccessTrustProviderSseSpecificationPropertyValidator)(properties.sseSpecification));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("trustProviderType", cdk.requiredValidator)(properties.trustProviderType));
  errors.collect(cdk.propertyValidator("trustProviderType", cdk.validateString)(properties.trustProviderType));
  errors.collect(cdk.propertyValidator("userTrustProviderType", cdk.validateString)(properties.userTrustProviderType));
  return errors.wrap("supplied properties not correct for \"CfnVerifiedAccessTrustProviderProps\"");
}

// @ts-ignore TS6133
function convertCfnVerifiedAccessTrustProviderPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVerifiedAccessTrustProviderPropsValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "DeviceOptions": convertCfnVerifiedAccessTrustProviderDeviceOptionsPropertyToCloudFormation(properties.deviceOptions),
    "DeviceTrustProviderType": cdk.stringToCloudFormation(properties.deviceTrustProviderType),
    "OidcOptions": convertCfnVerifiedAccessTrustProviderOidcOptionsPropertyToCloudFormation(properties.oidcOptions),
    "PolicyReferenceName": cdk.stringToCloudFormation(properties.policyReferenceName),
    "SseSpecification": convertCfnVerifiedAccessTrustProviderSseSpecificationPropertyToCloudFormation(properties.sseSpecification),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "TrustProviderType": cdk.stringToCloudFormation(properties.trustProviderType),
    "UserTrustProviderType": cdk.stringToCloudFormation(properties.userTrustProviderType)
  };
}

// @ts-ignore TS6133
function CfnVerifiedAccessTrustProviderPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnVerifiedAccessTrustProviderProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVerifiedAccessTrustProviderProps>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("deviceOptions", "DeviceOptions", (properties.DeviceOptions != null ? CfnVerifiedAccessTrustProviderDeviceOptionsPropertyFromCloudFormation(properties.DeviceOptions) : undefined));
  ret.addPropertyResult("deviceTrustProviderType", "DeviceTrustProviderType", (properties.DeviceTrustProviderType != null ? cfn_parse.FromCloudFormation.getString(properties.DeviceTrustProviderType) : undefined));
  ret.addPropertyResult("oidcOptions", "OidcOptions", (properties.OidcOptions != null ? CfnVerifiedAccessTrustProviderOidcOptionsPropertyFromCloudFormation(properties.OidcOptions) : undefined));
  ret.addPropertyResult("policyReferenceName", "PolicyReferenceName", (properties.PolicyReferenceName != null ? cfn_parse.FromCloudFormation.getString(properties.PolicyReferenceName) : undefined));
  ret.addPropertyResult("sseSpecification", "SseSpecification", (properties.SseSpecification != null ? CfnVerifiedAccessTrustProviderSseSpecificationPropertyFromCloudFormation(properties.SseSpecification) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("trustProviderType", "TrustProviderType", (properties.TrustProviderType != null ? cfn_parse.FromCloudFormation.getString(properties.TrustProviderType) : undefined));
  ret.addPropertyResult("userTrustProviderType", "UserTrustProviderType", (properties.UserTrustProviderType != null ? cfn_parse.FromCloudFormation.getString(properties.UserTrustProviderType) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies an Amazon Elastic Block Store (Amazon EBS) volume.
 *
 * When you use AWS CloudFormation to update an Amazon EBS volume that modifies `Iops` , `Size` , or `VolumeType` , there is a cooldown period before another operation can occur. This can cause your stack to report being in `UPDATE_IN_PROGRESS` or `UPDATE_ROLLBACK_IN_PROGRESS` for long periods of time.
 *
 * Amazon EBS does not support sizing down an Amazon EBS volume. AWS CloudFormation does not attempt to modify an Amazon EBS volume to a smaller size on rollback.
 *
 * Some common scenarios when you might encounter a cooldown period for Amazon EBS include:
 *
 * - You successfully update an Amazon EBS volume and the update succeeds. When you attempt another update within the cooldown window, that update will be subject to a cooldown period.
 * - You successfully update an Amazon EBS volume and the update succeeds but another change in your `update-stack` call fails. The rollback will be subject to a cooldown period.
 *
 * For more information on the cooldown period, see [Requirements when modifying volumes](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/modify-volume-requirements.html) .
 *
 * *DeletionPolicy attribute*
 *
 * To control how AWS CloudFormation handles the volume when the stack is deleted, set a deletion policy for your volume. You can choose to retain the volume, to delete the volume, or to create a snapshot of the volume. For more information, see [DeletionPolicy attribute](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html) .
 *
 * > If you set a deletion policy that creates a snapshot, all tags on the volume are included in the snapshot.
 *
 * @cloudformationResource AWS::EC2::Volume
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html
 */
export class CfnVolume extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::Volume";

  /**
   * Build a CfnVolume from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnVolume {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnVolumePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnVolume(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the volume.
   *
   * @cloudformationAttribute VolumeId
   */
  public readonly attrVolumeId: string;

  /**
   * Indicates whether the volume is auto-enabled for I/O operations.
   */
  public autoEnableIo?: boolean | cdk.IResolvable;

  /**
   * The ID of the Availability Zone in which to create the volume.
   */
  public availabilityZone: string;

  /**
   * Indicates whether the volume should be encrypted.
   */
  public encrypted?: boolean | cdk.IResolvable;

  /**
   * The number of I/O operations per second (IOPS).
   */
  public iops?: number;

  /**
   * The identifier of the AWS KMS key to use for Amazon EBS encryption.
   */
  public kmsKeyId?: string;

  /**
   * Indicates whether Amazon EBS Multi-Attach is enabled.
   */
  public multiAttachEnabled?: boolean | cdk.IResolvable;

  /**
   * The Amazon Resource Name (ARN) of the Outpost.
   */
  public outpostArn?: string;

  /**
   * The size of the volume, in GiBs.
   */
  public size?: number;

  /**
   * The snapshot from which to create the volume.
   */
  public snapshotId?: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags to apply to the volume during creation.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The throughput to provision for a volume, with a maximum of 1,000 MiB/s.
   */
  public throughput?: number;

  /**
   * The volume type. This parameter can be one of the following values:.
   */
  public volumeType?: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnVolumeProps) {
    super(scope, id, {
      "type": CfnVolume.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "availabilityZone", this);

    this.attrVolumeId = cdk.Token.asString(this.getAtt("VolumeId", cdk.ResolutionTypeHint.STRING));
    this.autoEnableIo = props.autoEnableIo;
    this.availabilityZone = props.availabilityZone;
    this.encrypted = props.encrypted;
    this.iops = props.iops;
    this.kmsKeyId = props.kmsKeyId;
    this.multiAttachEnabled = props.multiAttachEnabled;
    this.outpostArn = props.outpostArn;
    this.size = props.size;
    this.snapshotId = props.snapshotId;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::Volume", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.throughput = props.throughput;
    this.volumeType = props.volumeType;
    if ((this.node.scope != null && cdk.Resource.isResource(this.node.scope))) {
      this.node.addValidation({
        "validate": () => ((this.cfnOptions.deletionPolicy === undefined) ? ["'AWS::EC2::Volume' is a stateful resource type, and you must specify a Removal Policy for it. Call 'resource.applyRemovalPolicy()'."] : [])
      });
    }
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "autoEnableIo": this.autoEnableIo,
      "availabilityZone": this.availabilityZone,
      "encrypted": this.encrypted,
      "iops": this.iops,
      "kmsKeyId": this.kmsKeyId,
      "multiAttachEnabled": this.multiAttachEnabled,
      "outpostArn": this.outpostArn,
      "size": this.size,
      "snapshotId": this.snapshotId,
      "tags": this.tags.renderTags(),
      "throughput": this.throughput,
      "volumeType": this.volumeType
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnVolume.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnVolumePropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a `CfnVolume`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html
 */
export interface CfnVolumeProps {
  /**
   * Indicates whether the volume is auto-enabled for I/O operations.
   *
   * By default, Amazon EBS disables I/O to the volume from attached EC2 instances when it determines that a volume's data is potentially inconsistent. If the consistency of the volume is not a concern, and you prefer that the volume be made available immediately if it's impaired, you can configure the volume to automatically enable I/O.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-autoenableio
   */
  readonly autoEnableIo?: boolean | cdk.IResolvable;

  /**
   * The ID of the Availability Zone in which to create the volume.
   *
   * For example, `us-east-1a` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-availabilityzone
   */
  readonly availabilityZone: string;

  /**
   * Indicates whether the volume should be encrypted.
   *
   * The effect of setting the encryption state to `true` depends on the volume origin (new or from a snapshot), starting encryption state, ownership, and whether encryption by default is enabled. For more information, see [Encryption by default](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#encryption-by-default) in the *Amazon Elastic Compute Cloud User Guide* .
   *
   * Encrypted Amazon EBS volumes must be attached to instances that support Amazon EBS encryption. For more information, see [Supported instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#EBSEncryption_supported_instances) .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-encrypted
   */
  readonly encrypted?: boolean | cdk.IResolvable;

  /**
   * The number of I/O operations per second (IOPS).
   *
   * For `gp3` , `io1` , and `io2` volumes, this represents the number of IOPS that are provisioned for the volume. For `gp2` volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting.
   *
   * The following are the supported values for each volume type:
   *
   * - `gp3` : 3,000 - 16,000 IOPS
   * - `io1` : 100 - 64,000 IOPS
   * - `io2` : 100 - 256,000 IOPS
   *
   * For `io2` volumes, you can achieve up to 256,000 IOPS on [instances built on the Nitro System](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances) . On other instances, you can achieve performance up to 32,000 IOPS.
   *
   * This parameter is required for `io1` and `io2` volumes. The default for `gp3` volumes is 3,000 IOPS. This parameter is not supported for `gp2` , `st1` , `sc1` , or `standard` volumes.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-iops
   */
  readonly iops?: number;

  /**
   * The identifier of the AWS KMS key to use for Amazon EBS encryption.
   *
   * If `KmsKeyId` is specified, the encrypted state must be `true` .
   *
   * If you omit this property and your account is enabled for encryption by default, or *Encrypted* is set to `true` , then the volume is encrypted using the default key specified for your account. If your account does not have a default key, then the volume is encrypted using the AWS managed key .
   *
   * Alternatively, if you want to specify a different key, you can specify one of the following:
   *
   * - Key ID. For example, 1234abcd-12ab-34cd-56ef-1234567890ab.
   * - Key alias. Specify the alias for the key, prefixed with `alias/` . For example, for a key with the alias `my_cmk` , use `alias/my_cmk` . Or to specify the AWS managed key , use `alias/aws/ebs` .
   * - Key ARN. For example, arn:aws:kms:us-east-1:012345678910:key/1234abcd-12ab-34cd-56ef-1234567890ab.
   * - Alias ARN. For example, arn:aws:kms:us-east-1:012345678910:alias/ExampleAlias.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-kmskeyid
   */
  readonly kmsKeyId?: string;

  /**
   * Indicates whether Amazon EBS Multi-Attach is enabled.
   *
   * AWS CloudFormation does not currently support updating a single-attach volume to be multi-attach enabled, updating a multi-attach enabled volume to be single-attach, or updating the size or number of I/O operations per second (IOPS) of a multi-attach enabled volume.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-multiattachenabled
   */
  readonly multiAttachEnabled?: boolean | cdk.IResolvable;

  /**
   * The Amazon Resource Name (ARN) of the Outpost.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-outpostarn
   */
  readonly outpostArn?: string;

  /**
   * The size of the volume, in GiBs.
   *
   * You must specify either a snapshot ID or a volume size. If you specify a snapshot, the default is the snapshot size. You can specify a volume size that is equal to or larger than the snapshot size.
   *
   * The following are the supported volumes sizes for each volume type:
   *
   * - `gp2` and `gp3` : 1 - 16,384 GiB
   * - `io1` : 4 - 16,384 GiB
   * - `io2` : 4 - 65,536 GiB
   * - `st1` and `sc1` : 125 - 16,384 GiB
   * - `standard` : 1 - 1024 GiB
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-size
   */
  readonly size?: number;

  /**
   * The snapshot from which to create the volume.
   *
   * You must specify either a snapshot ID or a volume size.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-snapshotid
   */
  readonly snapshotId?: string;

  /**
   * The tags to apply to the volume during creation.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The throughput to provision for a volume, with a maximum of 1,000 MiB/s.
   *
   * This parameter is valid only for `gp3` volumes. The default value is 125.
   *
   * Valid Range: Minimum value of 125. Maximum value of 1000.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-throughput
   */
  readonly throughput?: number;

  /**
   * The volume type. This parameter can be one of the following values:.
   *
   * - General Purpose SSD: `gp2` | `gp3`
   * - Provisioned IOPS SSD: `io1` | `io2`
   * - Throughput Optimized HDD: `st1`
   * - Cold HDD: `sc1`
   * - Magnetic: `standard`
   *
   * For more information, see [Amazon EBS volume types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html) in the *Amazon Elastic Compute Cloud User Guide* .
   *
   * Default: `gp2`
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-volumetype
   */
  readonly volumeType?: string;
}

/**
 * Determine whether the given properties match those of a `CfnVolumeProps`
 *
 * @param properties - the TypeScript properties of a `CfnVolumeProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVolumePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("autoEnableIo", cdk.validateBoolean)(properties.autoEnableIo));
  errors.collect(cdk.propertyValidator("availabilityZone", cdk.requiredValidator)(properties.availabilityZone));
  errors.collect(cdk.propertyValidator("availabilityZone", cdk.validateString)(properties.availabilityZone));
  errors.collect(cdk.propertyValidator("encrypted", cdk.validateBoolean)(properties.encrypted));
  errors.collect(cdk.propertyValidator("iops", cdk.validateNumber)(properties.iops));
  errors.collect(cdk.propertyValidator("kmsKeyId", cdk.validateString)(properties.kmsKeyId));
  errors.collect(cdk.propertyValidator("multiAttachEnabled", cdk.validateBoolean)(properties.multiAttachEnabled));
  errors.collect(cdk.propertyValidator("outpostArn", cdk.validateString)(properties.outpostArn));
  errors.collect(cdk.propertyValidator("size", cdk.validateNumber)(properties.size));
  errors.collect(cdk.propertyValidator("snapshotId", cdk.validateString)(properties.snapshotId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("throughput", cdk.validateNumber)(properties.throughput));
  errors.collect(cdk.propertyValidator("volumeType", cdk.validateString)(properties.volumeType));
  return errors.wrap("supplied properties not correct for \"CfnVolumeProps\"");
}

// @ts-ignore TS6133
function convertCfnVolumePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVolumePropsValidator(properties).assertSuccess();
  return {
    "AutoEnableIO": cdk.booleanToCloudFormation(properties.autoEnableIo),
    "AvailabilityZone": cdk.stringToCloudFormation(properties.availabilityZone),
    "Encrypted": cdk.booleanToCloudFormation(properties.encrypted),
    "Iops": cdk.numberToCloudFormation(properties.iops),
    "KmsKeyId": cdk.stringToCloudFormation(properties.kmsKeyId),
    "MultiAttachEnabled": cdk.booleanToCloudFormation(properties.multiAttachEnabled),
    "OutpostArn": cdk.stringToCloudFormation(properties.outpostArn),
    "Size": cdk.numberToCloudFormation(properties.size),
    "SnapshotId": cdk.stringToCloudFormation(properties.snapshotId),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "Throughput": cdk.numberToCloudFormation(properties.throughput),
    "VolumeType": cdk.stringToCloudFormation(properties.volumeType)
  };
}

// @ts-ignore TS6133
function CfnVolumePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnVolumeProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVolumeProps>();
  ret.addPropertyResult("autoEnableIo", "AutoEnableIO", (properties.AutoEnableIO != null ? cfn_parse.FromCloudFormation.getBoolean(properties.AutoEnableIO) : undefined));
  ret.addPropertyResult("availabilityZone", "AvailabilityZone", (properties.AvailabilityZone != null ? cfn_parse.FromCloudFormation.getString(properties.AvailabilityZone) : undefined));
  ret.addPropertyResult("encrypted", "Encrypted", (properties.Encrypted != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Encrypted) : undefined));
  ret.addPropertyResult("iops", "Iops", (properties.Iops != null ? cfn_parse.FromCloudFormation.getNumber(properties.Iops) : undefined));
  ret.addPropertyResult("kmsKeyId", "KmsKeyId", (properties.KmsKeyId != null ? cfn_parse.FromCloudFormation.getString(properties.KmsKeyId) : undefined));
  ret.addPropertyResult("multiAttachEnabled", "MultiAttachEnabled", (properties.MultiAttachEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.MultiAttachEnabled) : undefined));
  ret.addPropertyResult("outpostArn", "OutpostArn", (properties.OutpostArn != null ? cfn_parse.FromCloudFormation.getString(properties.OutpostArn) : undefined));
  ret.addPropertyResult("size", "Size", (properties.Size != null ? cfn_parse.FromCloudFormation.getNumber(properties.Size) : undefined));
  ret.addPropertyResult("snapshotId", "SnapshotId", (properties.SnapshotId != null ? cfn_parse.FromCloudFormation.getString(properties.SnapshotId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("throughput", "Throughput", (properties.Throughput != null ? cfn_parse.FromCloudFormation.getNumber(properties.Throughput) : undefined));
  ret.addPropertyResult("volumeType", "VolumeType", (properties.VolumeType != null ? cfn_parse.FromCloudFormation.getString(properties.VolumeType) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Attaches an Amazon EBS volume to a running instance and exposes it to the instance with the specified device name.
 *
 * Before this resource can be deleted (and therefore the volume detached), you must first unmount the volume in the instance. Failure to do so results in the volume being stuck in the busy state while it is trying to detach, which could possibly damage the file system or the data it contains.
 *
 * If an Amazon EBS volume is the root device of an instance, it cannot be detached while the instance is in the "running" state. To detach the root volume, stop the instance first.
 *
 * If the root volume is detached from an instance with an AWS Marketplace product code, then the product codes from that volume are no longer associated with the instance.
 *
 * @cloudformationResource AWS::EC2::VolumeAttachment
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volumeattachment.html
 */
export class CfnVolumeAttachment extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::VolumeAttachment";

  /**
   * Build a CfnVolumeAttachment from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnVolumeAttachment {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnVolumeAttachmentPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnVolumeAttachment(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The device name (for example, `/dev/sdh` or `xvdh` ).
   */
  public device?: string;

  /**
   * The ID of the instance to which the volume attaches.
   */
  public instanceId: string;

  /**
   * The ID of the Amazon EBS volume.
   */
  public volumeId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnVolumeAttachmentProps) {
    super(scope, id, {
      "type": CfnVolumeAttachment.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "instanceId", this);
    cdk.requireProperty(props, "volumeId", this);

    this.device = props.device;
    this.instanceId = props.instanceId;
    this.volumeId = props.volumeId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "device": this.device,
      "instanceId": this.instanceId,
      "volumeId": this.volumeId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnVolumeAttachment.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnVolumeAttachmentPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a `CfnVolumeAttachment`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volumeattachment.html
 */
export interface CfnVolumeAttachmentProps {
  /**
   * The device name (for example, `/dev/sdh` or `xvdh` ).
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volumeattachment.html#cfn-ec2-volumeattachment-device
   */
  readonly device?: string;

  /**
   * The ID of the instance to which the volume attaches.
   *
   * This value can be a reference to an [`AWS::EC2::Instance`](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html) resource, or it can be the physical ID of an existing EC2 instance.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volumeattachment.html#cfn-ec2-volumeattachment-instanceid
   */
  readonly instanceId: string;

  /**
   * The ID of the Amazon EBS volume.
   *
   * The volume and instance must be within the same Availability Zone. This value can be a reference to an [`AWS::EC2::Volume`](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ebs-volume.html) resource, or it can be the volume ID of an existing Amazon EBS volume.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volumeattachment.html#cfn-ec2-volumeattachment-volumeid
   */
  readonly volumeId: string;
}

/**
 * Determine whether the given properties match those of a `CfnVolumeAttachmentProps`
 *
 * @param properties - the TypeScript properties of a `CfnVolumeAttachmentProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVolumeAttachmentPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("device", cdk.validateString)(properties.device));
  errors.collect(cdk.propertyValidator("instanceId", cdk.requiredValidator)(properties.instanceId));
  errors.collect(cdk.propertyValidator("instanceId", cdk.validateString)(properties.instanceId));
  errors.collect(cdk.propertyValidator("volumeId", cdk.requiredValidator)(properties.volumeId));
  errors.collect(cdk.propertyValidator("volumeId", cdk.validateString)(properties.volumeId));
  return errors.wrap("supplied properties not correct for \"CfnVolumeAttachmentProps\"");
}

// @ts-ignore TS6133
function convertCfnVolumeAttachmentPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVolumeAttachmentPropsValidator(properties).assertSuccess();
  return {
    "Device": cdk.stringToCloudFormation(properties.device),
    "InstanceId": cdk.stringToCloudFormation(properties.instanceId),
    "VolumeId": cdk.stringToCloudFormation(properties.volumeId)
  };
}

// @ts-ignore TS6133
function CfnVolumeAttachmentPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnVolumeAttachmentProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVolumeAttachmentProps>();
  ret.addPropertyResult("device", "Device", (properties.Device != null ? cfn_parse.FromCloudFormation.getString(properties.Device) : undefined));
  ret.addPropertyResult("instanceId", "InstanceId", (properties.InstanceId != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceId) : undefined));
  ret.addPropertyResult("volumeId", "VolumeId", (properties.VolumeId != null ? cfn_parse.FromCloudFormation.getString(properties.VolumeId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies the state of the *block public access for snapshots* setting for the Region.
 *
 * For more information, see [Block public access for snapshots](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/block-public-access-snapshots.html) .
 *
 * @cloudformationResource AWS::EC2::SnapshotBlockPublicAccess
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-snapshotblockpublicaccess.html
 */
export class CfnSnapshotBlockPublicAccess extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::SnapshotBlockPublicAccess";

  /**
   * Build a CfnSnapshotBlockPublicAccess from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnSnapshotBlockPublicAccess {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnSnapshotBlockPublicAccessPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnSnapshotBlockPublicAccess(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * `Ref` returns the ID of the AWS account.
   *
   * @cloudformationAttribute AccountId
   */
  public readonly attrAccountId: string;

  /**
   * The mode in which to enable block public access for snapshots for the Region.
   */
  public state: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnSnapshotBlockPublicAccessProps) {
    super(scope, id, {
      "type": CfnSnapshotBlockPublicAccess.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "state", this);

    this.attrAccountId = cdk.Token.asString(this.getAtt("AccountId", cdk.ResolutionTypeHint.STRING));
    this.state = props.state;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "state": this.state
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnSnapshotBlockPublicAccess.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnSnapshotBlockPublicAccessPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a `CfnSnapshotBlockPublicAccess`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-snapshotblockpublicaccess.html
 */
export interface CfnSnapshotBlockPublicAccessProps {
  /**
   * The mode in which to enable block public access for snapshots for the Region.
   *
   * Specify one of the following values:
   *
   * - `block-all-sharing` - Prevents all public sharing of snapshots in the Region. Users in the account will no longer be able to request new public sharing. Additionally, snapshots that are already publicly shared are treated as private and they are no longer publicly available.
   *
   * > If you enable block public access for snapshots in `block-all-sharing` mode, it does not change the permissions for snapshots that are already publicly shared. Instead, it prevents these snapshots from be publicly visible and publicly accessible. Therefore, the attributes for these snapshots still indicate that they are publicly shared, even though they are not publicly available.
   * - `block-new-sharing` - Prevents only new public sharing of snapshots in the Region. Users in the account will no longer be able to request new public sharing. However, snapshots that are already publicly shared, remain publicly available.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-snapshotblockpublicaccess.html#cfn-ec2-snapshotblockpublicaccess-state
   */
  readonly state: string;
}

/**
 * Determine whether the given properties match those of a `CfnSnapshotBlockPublicAccessProps`
 *
 * @param properties - the TypeScript properties of a `CfnSnapshotBlockPublicAccessProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSnapshotBlockPublicAccessPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("state", cdk.requiredValidator)(properties.state));
  errors.collect(cdk.propertyValidator("state", cdk.validateString)(properties.state));
  return errors.wrap("supplied properties not correct for \"CfnSnapshotBlockPublicAccessProps\"");
}

// @ts-ignore TS6133
function convertCfnSnapshotBlockPublicAccessPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSnapshotBlockPublicAccessPropsValidator(properties).assertSuccess();
  return {
    "State": cdk.stringToCloudFormation(properties.state)
  };
}

// @ts-ignore TS6133
function CfnSnapshotBlockPublicAccessPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSnapshotBlockPublicAccessProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSnapshotBlockPublicAccessProps>();
  ret.addPropertyResult("state", "State", (properties.State != null ? cfn_parse.FromCloudFormation.getString(properties.State) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}