/* eslint-disable prettier/prettier,max-len */
import * as cdk from "aws-cdk-lib";
import * as constructs from "constructs";
import * as cfn_parse from "aws-cdk-lib/core/lib/helpers-internal";

/**
 * The `AWS::CodeBuild::Project` resource configures how AWS CodeBuild builds your source code.
 *
 * For example, it tells CodeBuild where to get the source code and which build environment to use.
 *
 * > To unset or remove a project value via CFN, explicitly provide the attribute with value as empty input.
 *
 * @cloudformationResource AWS::CodeBuild::Project
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-codebuild-project.html
 */
export class CfnProject extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::CodeBuild::Project";

  /**
   * Build a CfnProject from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnProject {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnProjectPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnProject(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ARN of the AWS CodeBuild project, such as `arn:aws:codebuild:us-west-2:123456789012:project/myProjectName` .
   *
   * @cloudformationAttribute Arn
   */
  public readonly attrArn: string;

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * `Artifacts` is a property of the [AWS::CodeBuild::Project](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-codebuild-project.html) resource that specifies output settings for artifacts generated by an AWS CodeBuild build.
   */
  public artifacts: CfnProject.ArtifactsProperty | cdk.IResolvable;

  /**
   * Indicates whether AWS CodeBuild generates a publicly accessible URL for your project's build badge.
   */
  public badgeEnabled?: boolean | cdk.IResolvable;

  /**
   * A `ProjectBuildBatchConfig` object that defines the batch build options for the project.
   */
  public buildBatchConfig?: cdk.IResolvable | CfnProject.ProjectBuildBatchConfigProperty;

  /**
   * Settings that AWS CodeBuild uses to store and reuse build dependencies.
   */
  public cache?: cdk.IResolvable | CfnProject.ProjectCacheProperty;

  /**
   * The maximum number of concurrent builds that are allowed for this project.
   */
  public concurrentBuildLimit?: number;

  /**
   * A description that makes the build project easy to identify.
   */
  public description?: string;

  /**
   * The AWS Key Management Service customer master key (CMK) to be used for encrypting the build output artifacts.
   */
  public encryptionKey?: string;

  /**
   * The build environment settings for the project, such as the environment type or the environment variables to use for the build environment.
   */
  public environment: CfnProject.EnvironmentProperty | cdk.IResolvable;

  /**
   * An array of `ProjectFileSystemLocation` objects for a CodeBuild build project.
   */
  public fileSystemLocations?: Array<cdk.IResolvable | CfnProject.ProjectFileSystemLocationProperty> | cdk.IResolvable;

  /**
   * Information about logs for the build project.
   */
  public logsConfig?: cdk.IResolvable | CfnProject.LogsConfigProperty;

  /**
   * The name of the build project.
   */
  public name?: string;

  /**
   * The number of minutes a build is allowed to be queued before it times out.
   */
  public queuedTimeoutInMinutes?: number;

  /**
   * The ARN of the IAM role that enables CodeBuild to access the CloudWatch Logs and Amazon S3 artifacts for the project's builds.
   */
  public resourceAccessRole?: string;

  /**
   * A list of `Artifacts` objects.
   */
  public secondaryArtifacts?: Array<CfnProject.ArtifactsProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * An array of `ProjectSource` objects.
   */
  public secondarySources?: Array<cdk.IResolvable | CfnProject.SourceProperty> | cdk.IResolvable;

  /**
   * An array of `ProjectSourceVersion` objects.
   */
  public secondarySourceVersions?: Array<cdk.IResolvable | CfnProject.ProjectSourceVersionProperty> | cdk.IResolvable;

  /**
   * The ARN of the IAM role that enables AWS CodeBuild to interact with dependent AWS services on behalf of the AWS account.
   */
  public serviceRole: string;

  /**
   * The source code settings for the project, such as the source code's repository type and location.
   */
  public source: cdk.IResolvable | CfnProject.SourceProperty;

  /**
   * A version of the build input to be built for this project.
   */
  public sourceVersion?: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * An arbitrary set of tags (key-value pairs) for the AWS CodeBuild project.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * How long, in minutes, from 5 to 480 (8 hours), for AWS CodeBuild to wait before timing out any related build that did not get marked as completed.
   */
  public timeoutInMinutes?: number;

  /**
   * For an existing AWS CodeBuild build project that has its source code stored in a GitHub repository, enables AWS CodeBuild to begin automatically rebuilding the source code every time a code change is pushed to the repository.
   */
  public triggers?: cdk.IResolvable | CfnProject.ProjectTriggersProperty;

  /**
   * Specifies the visibility of the project's builds. Possible values are:.
   */
  public visibility?: string;

  /**
   * `VpcConfig` specifies settings that enable AWS CodeBuild to access resources in an Amazon VPC.
   */
  public vpcConfig?: cdk.IResolvable | CfnProject.VpcConfigProperty;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnProjectProps) {
    super(scope, id, {
      "type": CfnProject.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "artifacts", this);
    cdk.requireProperty(props, "environment", this);
    cdk.requireProperty(props, "serviceRole", this);
    cdk.requireProperty(props, "source", this);

    this.attrArn = cdk.Token.asString(this.getAtt("Arn", cdk.ResolutionTypeHint.STRING));
    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.artifacts = props.artifacts;
    this.badgeEnabled = props.badgeEnabled;
    this.buildBatchConfig = props.buildBatchConfig;
    this.cache = props.cache;
    this.concurrentBuildLimit = props.concurrentBuildLimit;
    this.description = props.description;
    this.encryptionKey = props.encryptionKey;
    this.environment = props.environment;
    this.fileSystemLocations = props.fileSystemLocations;
    this.logsConfig = props.logsConfig;
    this.name = props.name;
    this.queuedTimeoutInMinutes = props.queuedTimeoutInMinutes;
    this.resourceAccessRole = props.resourceAccessRole;
    this.secondaryArtifacts = props.secondaryArtifacts;
    this.secondarySources = props.secondarySources;
    this.secondarySourceVersions = props.secondarySourceVersions;
    this.serviceRole = props.serviceRole;
    this.source = props.source;
    this.sourceVersion = props.sourceVersion;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::CodeBuild::Project", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.timeoutInMinutes = props.timeoutInMinutes;
    this.triggers = props.triggers;
    this.visibility = props.visibility;
    this.vpcConfig = props.vpcConfig;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "artifacts": this.artifacts,
      "badgeEnabled": this.badgeEnabled,
      "buildBatchConfig": this.buildBatchConfig,
      "cache": this.cache,
      "concurrentBuildLimit": this.concurrentBuildLimit,
      "description": this.description,
      "encryptionKey": this.encryptionKey,
      "environment": this.environment,
      "fileSystemLocations": this.fileSystemLocations,
      "logsConfig": this.logsConfig,
      "name": this.name,
      "queuedTimeoutInMinutes": this.queuedTimeoutInMinutes,
      "resourceAccessRole": this.resourceAccessRole,
      "secondaryArtifacts": this.secondaryArtifacts,
      "secondarySources": this.secondarySources,
      "secondarySourceVersions": this.secondarySourceVersions,
      "serviceRole": this.serviceRole,
      "source": this.source,
      "sourceVersion": this.sourceVersion,
      "tags": this.tags.renderTags(),
      "timeoutInMinutes": this.timeoutInMinutes,
      "triggers": this.triggers,
      "visibility": this.visibility,
      "vpcConfig": this.vpcConfig
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnProject.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnProjectPropsToCloudFormation(props);
  }
}

export namespace CfnProject {
  /**
   * `VpcConfig` is a property of the [AWS::CodeBuild::Project](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-codebuild-project.html) resource that enable AWS CodeBuild to access resources in an Amazon VPC. For more information, see [Use AWS CodeBuild with Amazon Virtual Private Cloud](https://docs.aws.amazon.com/codebuild/latest/userguide/vpc-support.html) in the *AWS CodeBuild User Guide* .
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-vpcconfig.html
   */
  export interface VpcConfigProperty {
    /**
     * A list of one or more security groups IDs in your Amazon VPC.
     *
     * The maximum count is 5.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-vpcconfig.html#cfn-codebuild-project-vpcconfig-securitygroupids
     */
    readonly securityGroupIds?: Array<string>;

    /**
     * A list of one or more subnet IDs in your Amazon VPC.
     *
     * The maximum count is 16.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-vpcconfig.html#cfn-codebuild-project-vpcconfig-subnets
     */
    readonly subnets?: Array<string>;

    /**
     * The ID of the Amazon VPC.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-vpcconfig.html#cfn-codebuild-project-vpcconfig-vpcid
     */
    readonly vpcId?: string;
  }

  /**
   * `Source` is a property of the [AWS::CodeBuild::Project](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-codebuild-project.html) resource that specifies the source code settings for the project, such as the source code's repository type and location.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-source.html
   */
  export interface SourceProperty {
    /**
     * Information about the authorization settings for AWS CodeBuild to access the source code to be built.
     *
     * This information is for the AWS CodeBuild console's use only. Your code should not get or set `Auth` directly.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-source.html#cfn-codebuild-project-source-auth
     */
    readonly auth?: cdk.IResolvable | CfnProject.SourceAuthProperty;

    /**
     * The build specification for the project.
     *
     * If this value is not provided, then the source code must contain a buildspec file named `buildspec.yml` at the root level. If this value is provided, it can be either a single string containing the entire build specification, or the path to an alternate buildspec file relative to the value of the built-in environment variable `CODEBUILD_SRC_DIR` . The alternate buildspec file can have a name other than `buildspec.yml` , for example `myspec.yml` or `build_spec_qa.yml` or similar. For more information, see the [Build Spec Reference](https://docs.aws.amazon.com/codebuild/latest/userguide/build-spec-ref.html#build-spec-ref-example) in the *AWS CodeBuild User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-source.html#cfn-codebuild-project-source-buildspec
     */
    readonly buildSpec?: string;

    /**
     * Contains information that defines how the build project reports the build status to the source provider.
     *
     * This option is only used when the source provider is `GITHUB` , `GITHUB_ENTERPRISE` , or `BITBUCKET` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-source.html#cfn-codebuild-project-source-buildstatusconfig
     */
    readonly buildStatusConfig?: CfnProject.BuildStatusConfigProperty | cdk.IResolvable;

    /**
     * The depth of history to download.
     *
     * Minimum value is 0. If this value is 0, greater than 25, or not provided, then the full history is downloaded with each build project. If your source type is Amazon S3, this value is not supported.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-source.html#cfn-codebuild-project-source-gitclonedepth
     */
    readonly gitCloneDepth?: number;

    /**
     * Information about the Git submodules configuration for the build project.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-source.html#cfn-codebuild-project-source-gitsubmodulesconfig
     */
    readonly gitSubmodulesConfig?: CfnProject.GitSubmodulesConfigProperty | cdk.IResolvable;

    /**
     * This is used with GitHub Enterprise only.
     *
     * Set to true to ignore SSL warnings while connecting to your GitHub Enterprise project repository. The default value is `false` . `InsecureSsl` should be used for testing purposes only. It should not be used in a production environment.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-source.html#cfn-codebuild-project-source-insecuressl
     */
    readonly insecureSsl?: boolean | cdk.IResolvable;

    /**
     * Information about the location of the source code to be built. Valid values include:.
     *
     * - For source code settings that are specified in the source action of a pipeline in CodePipeline, `location` should not be specified. If it is specified, CodePipeline ignores it. This is because CodePipeline uses the settings in a pipeline's source action instead of this value.
     * - For source code in an CodeCommit repository, the HTTPS clone URL to the repository that contains the source code and the buildspec file (for example, `https://git-codecommit.<region-ID>.amazonaws.com/v1/repos/<repo-name>` ).
     * - For source code in an Amazon S3 input bucket, one of the following.
     *
     * - The path to the ZIP file that contains the source code (for example, `<bucket-name>/<path>/<object-name>.zip` ).
     * - The path to the folder that contains the source code (for example, `<bucket-name>/<path-to-source-code>/<folder>/` ).
     * - For source code in a GitHub repository, the HTTPS clone URL to the repository that contains the source and the buildspec file. You must connect your AWS account to your GitHub account. Use the AWS CodeBuild console to start creating a build project. When you use the console to connect (or reconnect) with GitHub, on the GitHub *Authorize application* page, for *Organization access* , choose *Request access* next to each repository you want to allow AWS CodeBuild to have access to, and then choose *Authorize application* . (After you have connected to your GitHub account, you do not need to finish creating the build project. You can leave the AWS CodeBuild console.) To instruct AWS CodeBuild to use this connection, in the `source` object, set the `auth` object's `type` value to `OAUTH` .
     * - For source code in a Bitbucket repository, the HTTPS clone URL to the repository that contains the source and the buildspec file. You must connect your AWS account to your Bitbucket account. Use the AWS CodeBuild console to start creating a build project. When you use the console to connect (or reconnect) with Bitbucket, on the Bitbucket *Confirm access to your account* page, choose *Grant access* . (After you have connected to your Bitbucket account, you do not need to finish creating the build project. You can leave the AWS CodeBuild console.) To instruct AWS CodeBuild to use this connection, in the `source` object, set the `auth` object's `type` value to `OAUTH` .
     *
     * If you specify `CODEPIPELINE` for the `Type` property, don't specify this property. For all of the other types, you must specify `Location` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-source.html#cfn-codebuild-project-source-location
     */
    readonly location?: string;

    /**
     * Set to true to report the status of a build's start and finish to your source provider.
     *
     * This option is valid only when your source provider is GitHub, GitHub Enterprise, or Bitbucket. If this is set and you use a different source provider, an `invalidInputException` is thrown.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-source.html#cfn-codebuild-project-source-reportbuildstatus
     */
    readonly reportBuildStatus?: boolean | cdk.IResolvable;

    /**
     * An identifier for this project source.
     *
     * The identifier can only contain alphanumeric characters and underscores, and must be less than 128 characters in length.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-source.html#cfn-codebuild-project-source-sourceidentifier
     */
    readonly sourceIdentifier?: string;

    /**
     * The type of repository that contains the source code to be built. Valid values include:.
     *
     * - `BITBUCKET` : The source code is in a Bitbucket repository.
     * - `CODECOMMIT` : The source code is in an CodeCommit repository.
     * - `CODEPIPELINE` : The source code settings are specified in the source action of a pipeline in CodePipeline.
     * - `GITHUB` : The source code is in a GitHub or GitHub Enterprise Cloud repository.
     * - `GITHUB_ENTERPRISE` : The source code is in a GitHub Enterprise Server repository.
     * - `NO_SOURCE` : The project does not have input source code.
     * - `S3` : The source code is in an Amazon S3 bucket.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-source.html#cfn-codebuild-project-source-type
     */
    readonly type: string;
  }

  /**
   * `SourceAuth` is a property of the [AWS CodeBuild Project Source](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-source.html) property type that specifies authorization settings for AWS CodeBuild to access the source code to be built.
   *
   * `SourceAuth` is for use by the CodeBuild console only. Do not get or set it directly.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-sourceauth.html
   */
  export interface SourceAuthProperty {
    /**
     * The resource value that applies to the specified authorization type.
     *
     * > This data type is used by the AWS CodeBuild console only.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-sourceauth.html#cfn-codebuild-project-sourceauth-resource
     */
    readonly resource?: string;

    /**
     * The authorization type to use. The only valid value is `OAUTH` , which represents the OAuth authorization type.
     *
     * > This data type is used by the AWS CodeBuild console only.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-sourceauth.html#cfn-codebuild-project-sourceauth-type
     */
    readonly type: string;
  }

  /**
   * Contains information that defines how the AWS CodeBuild build project reports the build status to the source provider.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-buildstatusconfig.html
   */
  export interface BuildStatusConfigProperty {
    /**
     * Specifies the context of the build status CodeBuild sends to the source provider.
     *
     * The usage of this parameter depends on the source provider.
     *
     * - **Bitbucket** - This parameter is used for the `name` parameter in the Bitbucket commit status. For more information, see [build](https://docs.aws.amazon.com/https://developer.atlassian.com/bitbucket/api/2/reference/resource/repositories/%7Bworkspace%7D/%7Brepo_slug%7D/commit/%7Bnode%7D/statuses/build) in the Bitbucket API documentation.
     * - **GitHub/GitHub Enterprise Server** - This parameter is used for the `context` parameter in the GitHub commit status. For more information, see [Create a commit status](https://docs.aws.amazon.com/https://developer.github.com/v3/repos/statuses/#create-a-commit-status) in the GitHub developer guide.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-buildstatusconfig.html#cfn-codebuild-project-buildstatusconfig-context
     */
    readonly context?: string;

    /**
     * Specifies the target url of the build status CodeBuild sends to the source provider.
     *
     * The usage of this parameter depends on the source provider.
     *
     * - **Bitbucket** - This parameter is used for the `url` parameter in the Bitbucket commit status. For more information, see [build](https://docs.aws.amazon.com/https://developer.atlassian.com/bitbucket/api/2/reference/resource/repositories/%7Bworkspace%7D/%7Brepo_slug%7D/commit/%7Bnode%7D/statuses/build) in the Bitbucket API documentation.
     * - **GitHub/GitHub Enterprise Server** - This parameter is used for the `target_url` parameter in the GitHub commit status. For more information, see [Create a commit status](https://docs.aws.amazon.com/https://developer.github.com/v3/repos/statuses/#create-a-commit-status) in the GitHub developer guide.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-buildstatusconfig.html#cfn-codebuild-project-buildstatusconfig-targeturl
     */
    readonly targetUrl?: string;
  }

  /**
   * `GitSubmodulesConfig` is a property of the [AWS CodeBuild Project Source](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-source.html) property type that specifies information about the Git submodules configuration for the build project.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-gitsubmodulesconfig.html
   */
  export interface GitSubmodulesConfigProperty {
    /**
     * Set to true to fetch Git submodules for your AWS CodeBuild build project.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-gitsubmodulesconfig.html#cfn-codebuild-project-gitsubmodulesconfig-fetchsubmodules
     */
    readonly fetchSubmodules: boolean | cdk.IResolvable;
  }

  /**
   * `ProjectTriggers` is a property of the [AWS CodeBuild Project](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-codebuild-project.html) resource that specifies webhooks that trigger an AWS CodeBuild build.
   *
   * > The Webhook feature isn't available in AWS CloudFormation for GitHub Enterprise projects. Use the AWS CLI or AWS CodeBuild console to create the webhook.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-projecttriggers.html
   */
  export interface ProjectTriggersProperty {
    /**
     * Specifies the type of build this webhook will trigger. Allowed values are:.
     *
     * - **BUILD** - A single build
     * - **BUILD_BATCH** - A batch build
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-projecttriggers.html#cfn-codebuild-project-projecttriggers-buildtype
     */
    readonly buildType?: string;

    /**
     * A list of lists of `WebhookFilter` objects used to determine which webhook events are triggered.
     *
     * At least one `WebhookFilter` in the array must specify `EVENT` as its type.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-projecttriggers.html#cfn-codebuild-project-projecttriggers-filtergroups
     */
    readonly filterGroups?: Array<Array<cdk.IResolvable | CfnProject.WebhookFilterProperty> | cdk.IResolvable> | cdk.IResolvable;

    /**
     * Specifies whether or not to begin automatically rebuilding the source code every time a code change is pushed to the repository.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-projecttriggers.html#cfn-codebuild-project-projecttriggers-webhook
     */
    readonly webhook?: boolean | cdk.IResolvable;
  }

  /**
   * `WebhookFilter` is a structure of the `FilterGroups` property on the [AWS CodeBuild Project ProjectTriggers](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-projecttriggers.html) property type that specifies which webhooks trigger an AWS CodeBuild build.
   *
   * > The Webhook feature isn't available in AWS CloudFormation for GitHub Enterprise projects. Use the AWS CLI or AWS CodeBuild console to create the webhook.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-webhookfilter.html
   */
  export interface WebhookFilterProperty {
    /**
     * Used to indicate that the `pattern` determines which webhook events do not trigger a build.
     *
     * If true, then a webhook event that does not match the `pattern` triggers a build. If false, then a webhook event that matches the `pattern` triggers a build.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-webhookfilter.html#cfn-codebuild-project-webhookfilter-excludematchedpattern
     */
    readonly excludeMatchedPattern?: boolean | cdk.IResolvable;

    /**
     * For a `WebHookFilter` that uses `EVENT` type, a comma-separated string that specifies one or more events.
     *
     * For example, the webhook filter `PUSH, PULL_REQUEST_CREATED, PULL_REQUEST_UPDATED` allows all push, pull request created, and pull request updated events to trigger a build.
     *
     * For a `WebHookFilter` that uses any of the other filter types, a regular expression pattern. For example, a `WebHookFilter` that uses `HEAD_REF` for its `type` and the pattern `^refs/heads/` triggers a build when the head reference is a branch with a reference name `refs/heads/branch-name` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-webhookfilter.html#cfn-codebuild-project-webhookfilter-pattern
     */
    readonly pattern: string;

    /**
     * The type of webhook filter.
     *
     * There are six webhook filter types: `EVENT` , `ACTOR_ACCOUNT_ID` , `HEAD_REF` , `BASE_REF` , `FILE_PATH` , and `COMMIT_MESSAGE` .
     *
     * - **EVENT** - A webhook event triggers a build when the provided `pattern` matches one of five event types: `PUSH` , `PULL_REQUEST_CREATED` , `PULL_REQUEST_UPDATED` , `PULL_REQUEST_REOPENED` , and `PULL_REQUEST_MERGED` . The `EVENT` patterns are specified as a comma-separated string. For example, `PUSH, PULL_REQUEST_CREATED, PULL_REQUEST_UPDATED` filters all push, pull request created, and pull request updated events.
     *
     * > The `PULL_REQUEST_REOPENED` works with GitHub and GitHub Enterprise only.
     * - **ACTOR_ACCOUNT_ID** - A webhook event triggers a build when a GitHub, GitHub Enterprise, or Bitbucket account ID matches the regular expression `pattern` .
     * - **HEAD_REF** - A webhook event triggers a build when the head reference matches the regular expression `pattern` . For example, `refs/heads/branch-name` and `refs/tags/tag-name` .
     *
     * Works with GitHub and GitHub Enterprise push, GitHub and GitHub Enterprise pull request, Bitbucket push, and Bitbucket pull request events.
     * - **BASE_REF** - A webhook event triggers a build when the base reference matches the regular expression `pattern` . For example, `refs/heads/branch-name` .
     *
     * > Works with pull request events only.
     * - **FILE_PATH** - A webhook triggers a build when the path of a changed file matches the regular expression `pattern` .
     *
     * > Works with GitHub and Bitbucket events push and pull requests events. Also works with GitHub Enterprise push events, but does not work with GitHub Enterprise pull request events.
     * - **COMMIT_MESSAGE** - A webhook triggers a build when the head commit message matches the regular expression `pattern` .
     *
     * > Works with GitHub and Bitbucket events push and pull requests events. Also works with GitHub Enterprise push events, but does not work with GitHub Enterprise pull request events.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-webhookfilter.html#cfn-codebuild-project-webhookfilter-type
     */
    readonly type: string;
  }

  /**
   * `Artifacts` is a property of the [AWS::CodeBuild::Project](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-codebuild-project.html) resource that specifies output settings for artifacts generated by an AWS CodeBuild build.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-artifacts.html
   */
  export interface ArtifactsProperty {
    /**
     * An identifier for this artifact definition.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-artifacts.html#cfn-codebuild-project-artifacts-artifactidentifier
     */
    readonly artifactIdentifier?: string;

    /**
     * Set to true if you do not want your output artifacts encrypted.
     *
     * This option is valid only if your artifacts type is Amazon Simple Storage Service (Amazon S3). If this is set with another artifacts type, an `invalidInputException` is thrown.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-artifacts.html#cfn-codebuild-project-artifacts-encryptiondisabled
     */
    readonly encryptionDisabled?: boolean | cdk.IResolvable;

    /**
     * Information about the build output artifact location:.
     *
     * - If `type` is set to `CODEPIPELINE` , AWS CodePipeline ignores this value if specified. This is because CodePipeline manages its build output locations instead of CodeBuild .
     * - If `type` is set to `NO_ARTIFACTS` , this value is ignored if specified, because no build output is produced.
     * - If `type` is set to `S3` , this is the name of the output bucket.
     *
     * If you specify `CODEPIPELINE` or `NO_ARTIFACTS` for the `Type` property, don't specify this property. For all of the other types, you must specify this property.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-artifacts.html#cfn-codebuild-project-artifacts-location
     */
    readonly location?: string;

    /**
     * Along with `path` and `namespaceType` , the pattern that AWS CodeBuild uses to name and store the output artifact:.
     *
     * - If `type` is set to `CODEPIPELINE` , AWS CodePipeline ignores this value if specified. This is because CodePipeline manages its build output names instead of AWS CodeBuild .
     * - If `type` is set to `NO_ARTIFACTS` , this value is ignored if specified, because no build output is produced.
     * - If `type` is set to `S3` , this is the name of the output artifact object. If you set the name to be a forward slash ("/"), the artifact is stored in the root of the output bucket.
     *
     * For example:
     *
     * - If `path` is set to `MyArtifacts` , `namespaceType` is set to `BUILD_ID` , and `name` is set to `MyArtifact.zip` , then the output artifact is stored in `MyArtifacts/ *build-ID* /MyArtifact.zip` .
     * - If `path` is empty, `namespaceType` is set to `NONE` , and `name` is set to " `/` ", the output artifact is stored in the root of the output bucket.
     * - If `path` is set to `MyArtifacts` , `namespaceType` is set to `BUILD_ID` , and `name` is set to " `/` ", the output artifact is stored in `MyArtifacts/ *build-ID*` .
     *
     * If you specify `CODEPIPELINE` or `NO_ARTIFACTS` for the `Type` property, don't specify this property. For all of the other types, you must specify this property.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-artifacts.html#cfn-codebuild-project-artifacts-name
     */
    readonly name?: string;

    /**
     * Along with `path` and `name` , the pattern that AWS CodeBuild uses to determine the name and location to store the output artifact:  - If `type` is set to `CODEPIPELINE` , CodePipeline ignores this value if specified.
     *
     * This is because CodePipeline manages its build output names instead of AWS CodeBuild .
     * - If `type` is set to `NO_ARTIFACTS` , this value is ignored if specified, because no build output is produced.
     * - If `type` is set to `S3` , valid values include:
     *
     * - `BUILD_ID` : Include the build ID in the location of the build output artifact.
     * - `NONE` : Do not include the build ID. This is the default if `namespaceType` is not specified.
     *
     * For example, if `path` is set to `MyArtifacts` , `namespaceType` is set to `BUILD_ID` , and `name` is set to `MyArtifact.zip` , the output artifact is stored in `MyArtifacts/<build-ID>/MyArtifact.zip` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-artifacts.html#cfn-codebuild-project-artifacts-namespacetype
     */
    readonly namespaceType?: string;

    /**
     * If set to true a name specified in the buildspec file overrides the artifact name.
     *
     * The name specified in a buildspec file is calculated at build time and uses the Shell command language. For example, you can append a date and time to your artifact name so that it is always unique.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-artifacts.html#cfn-codebuild-project-artifacts-overrideartifactname
     */
    readonly overrideArtifactName?: boolean | cdk.IResolvable;

    /**
     * The type of build output artifact to create:.
     *
     * - If `type` is set to `CODEPIPELINE` , CodePipeline ignores this value if specified. This is because CodePipeline manages its build output artifacts instead of AWS CodeBuild .
     * - If `type` is set to `NO_ARTIFACTS` , this value is ignored if specified, because no build output is produced.
     * - If `type` is set to `S3` , valid values include:
     *
     * - `NONE` : AWS CodeBuild creates in the output bucket a folder that contains the build output. This is the default if `packaging` is not specified.
     * - `ZIP` : AWS CodeBuild creates in the output bucket a ZIP file that contains the build output.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-artifacts.html#cfn-codebuild-project-artifacts-packaging
     */
    readonly packaging?: string;

    /**
     * Along with `namespaceType` and `name` , the pattern that AWS CodeBuild uses to name and store the output artifact:.
     *
     * - If `type` is set to `CODEPIPELINE` , CodePipeline ignores this value if specified. This is because CodePipeline manages its build output names instead of AWS CodeBuild .
     * - If `type` is set to `NO_ARTIFACTS` , this value is ignored if specified, because no build output is produced.
     * - If `type` is set to `S3` , this is the path to the output artifact. If `path` is not specified, `path` is not used.
     *
     * For example, if `path` is set to `MyArtifacts` , `namespaceType` is set to `NONE` , and `name` is set to `MyArtifact.zip` , the output artifact is stored in the output bucket at `MyArtifacts/MyArtifact.zip` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-artifacts.html#cfn-codebuild-project-artifacts-path
     */
    readonly path?: string;

    /**
     * The type of build output artifact. Valid values include:.
     *
     * - `CODEPIPELINE` : The build project has build output generated through CodePipeline.
     *
     * > The `CODEPIPELINE` type is not supported for `secondaryArtifacts` .
     * - `NO_ARTIFACTS` : The build project does not produce any build output.
     * - `S3` : The build project stores build output in Amazon S3.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-artifacts.html#cfn-codebuild-project-artifacts-type
     */
    readonly type: string;
  }

  /**
   * `LogsConfig` is a property of the [AWS CodeBuild Project](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-codebuild-project.html) resource that specifies information about logs for a build project. These can be logs in Amazon CloudWatch Logs, built in a specified S3 bucket, or both.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-logsconfig.html
   */
  export interface LogsConfigProperty {
    /**
     * Information about CloudWatch Logs for a build project.
     *
     * CloudWatch Logs are enabled by default.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-logsconfig.html#cfn-codebuild-project-logsconfig-cloudwatchlogs
     */
    readonly cloudWatchLogs?: CfnProject.CloudWatchLogsConfigProperty | cdk.IResolvable;

    /**
     * Information about logs built to an S3 bucket for a build project.
     *
     * S3 logs are not enabled by default.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-logsconfig.html#cfn-codebuild-project-logsconfig-s3logs
     */
    readonly s3Logs?: cdk.IResolvable | CfnProject.S3LogsConfigProperty;
  }

  /**
   * `CloudWatchLogs` is a property of the [AWS CodeBuild Project LogsConfig](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-logsconfig.html) property type that specifies settings for CloudWatch logs generated by an AWS CodeBuild build.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-cloudwatchlogsconfig.html
   */
  export interface CloudWatchLogsConfigProperty {
    /**
     * The group name of the logs in CloudWatch Logs.
     *
     * For more information, see [Working with Log Groups and Log Streams](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/Working-with-log-groups-and-streams.html) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-cloudwatchlogsconfig.html#cfn-codebuild-project-cloudwatchlogsconfig-groupname
     */
    readonly groupName?: string;

    /**
     * The current status of the logs in CloudWatch Logs for a build project. Valid values are:.
     *
     * - `ENABLED` : CloudWatch Logs are enabled for this build project.
     * - `DISABLED` : CloudWatch Logs are not enabled for this build project.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-cloudwatchlogsconfig.html#cfn-codebuild-project-cloudwatchlogsconfig-status
     */
    readonly status: string;

    /**
     * The prefix of the stream name of the CloudWatch Logs.
     *
     * For more information, see [Working with Log Groups and Log Streams](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/Working-with-log-groups-and-streams.html) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-cloudwatchlogsconfig.html#cfn-codebuild-project-cloudwatchlogsconfig-streamname
     */
    readonly streamName?: string;
  }

  /**
   * `S3Logs` is a property of the [AWS CodeBuild Project LogsConfig](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-logsconfig.html) property type that specifies settings for logs generated by an AWS CodeBuild build in an S3 bucket.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-s3logsconfig.html
   */
  export interface S3LogsConfigProperty {
    /**
     * Set to true if you do not want your S3 build log output encrypted.
     *
     * By default S3 build logs are encrypted.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-s3logsconfig.html#cfn-codebuild-project-s3logsconfig-encryptiondisabled
     */
    readonly encryptionDisabled?: boolean | cdk.IResolvable;

    /**
     * The ARN of an S3 bucket and the path prefix for S3 logs.
     *
     * If your Amazon S3 bucket name is `my-bucket` , and your path prefix is `build-log` , then acceptable formats are `my-bucket/build-log` or `arn:aws:s3:::my-bucket/build-log` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-s3logsconfig.html#cfn-codebuild-project-s3logsconfig-location
     */
    readonly location?: string;

    /**
     * The current status of the S3 build logs. Valid values are:.
     *
     * - `ENABLED` : S3 build logs are enabled for this build project.
     * - `DISABLED` : S3 build logs are not enabled for this build project.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-s3logsconfig.html#cfn-codebuild-project-s3logsconfig-status
     */
    readonly status: string;
  }

  /**
   * Information about a file system created by Amazon Elastic File System (EFS).
   *
   * For more information, see [What Is Amazon Elastic File System?](https://docs.aws.amazon.com/efs/latest/ug/whatisefs.html)
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-projectfilesystemlocation.html
   */
  export interface ProjectFileSystemLocationProperty {
    /**
     * The name used to access a file system created by Amazon EFS.
     *
     * CodeBuild creates an environment variable by appending the `identifier` in all capital letters to `CODEBUILD_` . For example, if you specify `my_efs` for `identifier` , a new environment variable is create named `CODEBUILD_MY_EFS` .
     *
     * The `identifier` is used to mount your file system.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-projectfilesystemlocation.html#cfn-codebuild-project-projectfilesystemlocation-identifier
     */
    readonly identifier: string;

    /**
     * A string that specifies the location of the file system created by Amazon EFS.
     *
     * Its format is `efs-dns-name:/directory-path` . You can find the DNS name of file system when you view it in the Amazon EFS console. The directory path is a path to a directory in the file system that CodeBuild mounts. For example, if the DNS name of a file system is `fs-abcd1234.efs.us-west-2.amazonaws.com` , and its mount directory is `my-efs-mount-directory` , then the `location` is `fs-abcd1234.efs.us-west-2.amazonaws.com:/my-efs-mount-directory` .
     *
     * The directory path in the format `efs-dns-name:/directory-path` is optional. If you do not specify a directory path, the location is only the DNS name and CodeBuild mounts the entire file system.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-projectfilesystemlocation.html#cfn-codebuild-project-projectfilesystemlocation-location
     */
    readonly location: string;

    /**
     * The mount options for a file system created by Amazon EFS.
     *
     * The default mount options used by CodeBuild are `nfsvers=4.1,rsize=1048576,wsize=1048576,hard,timeo=600,retrans=2` . For more information, see [Recommended NFS Mount Options](https://docs.aws.amazon.com/efs/latest/ug/mounting-fs-nfs-mount-settings.html) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-projectfilesystemlocation.html#cfn-codebuild-project-projectfilesystemlocation-mountoptions
     */
    readonly mountOptions?: string;

    /**
     * The location in the container where you mount the file system.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-projectfilesystemlocation.html#cfn-codebuild-project-projectfilesystemlocation-mountpoint
     */
    readonly mountPoint: string;

    /**
     * The type of the file system.
     *
     * The one supported type is `EFS` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-projectfilesystemlocation.html#cfn-codebuild-project-projectfilesystemlocation-type
     */
    readonly type: string;
  }

  /**
   * `Environment` is a property of the [AWS::CodeBuild::Project](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-codebuild-project.html) resource that specifies the environment for an AWS CodeBuild project.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-environment.html
   */
  export interface EnvironmentProperty {
    /**
     * The ARN of the Amazon S3 bucket, path prefix, and object key that contains the PEM-encoded certificate for the build project.
     *
     * For more information, see [certificate](https://docs.aws.amazon.com/codebuild/latest/userguide/create-project-cli.html#cli.environment.certificate) in the *AWS CodeBuild User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-environment.html#cfn-codebuild-project-environment-certificate
     */
    readonly certificate?: string;

    /**
     * The type of compute environment.
     *
     * This determines the number of CPU cores and memory the build environment uses. Available values include:
     *
     * - `BUILD_GENERAL1_SMALL` : Use up to 3 GB memory and 2 vCPUs for builds.
     * - `BUILD_GENERAL1_MEDIUM` : Use up to 7 GB memory and 4 vCPUs for builds.
     * - `BUILD_GENERAL1_LARGE` : Use up to 15 GB memory and 8 vCPUs for builds.
     *
     * For more information, see [Build Environment Compute Types](https://docs.aws.amazon.com/codebuild/latest/userguide/build-env-ref-compute-types.html) in the *AWS CodeBuild User Guide.*
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-environment.html#cfn-codebuild-project-environment-computetype
     */
    readonly computeType?: string;

    /**
     * A set of environment variables to make available to builds for this build project.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-environment.html#cfn-codebuild-project-environment-environmentvariables
     */
    readonly environmentVariables?: Array<CfnProject.EnvironmentVariableProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The image tag or image digest that identifies the Docker image to use for this build project.
     *
     * Use the following formats:
     *
     * - For an image tag: `<registry>/<repository>:<tag>` . For example, in the Docker repository that CodeBuild uses to manage its Docker images, this would be `aws/codebuild/standard:4.0` .
     * - For an image digest: `<registry>/<repository>@<digest>` . For example, to specify an image with the digest "sha256:cbbf2f9a99b47fc460d422812b6a5adff7dfee951d8fa2e4a98caa0382cfbdbf," use `<registry>/<repository>@sha256:cbbf2f9a99b47fc460d422812b6a5adff7dfee951d8fa2e4a98caa0382cfbdbf` .
     *
     * For more information, see [Docker images provided by CodeBuild](https://docs.aws.amazon.com//codebuild/latest/userguide/build-env-ref-available.html) in the *AWS CodeBuild user guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-environment.html#cfn-codebuild-project-environment-image
     */
    readonly image: string;

    /**
     * The type of credentials AWS CodeBuild uses to pull images in your build. There are two valid values:.
     *
     * - `CODEBUILD` specifies that AWS CodeBuild uses its own credentials. This requires that you modify your ECR repository policy to trust AWS CodeBuild service principal.
     * - `SERVICE_ROLE` specifies that AWS CodeBuild uses your build project's service role.
     *
     * When you use a cross-account or private registry image, you must use SERVICE_ROLE credentials. When you use an AWS CodeBuild curated image, you must use CODEBUILD credentials.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-environment.html#cfn-codebuild-project-environment-imagepullcredentialstype
     */
    readonly imagePullCredentialsType?: string;

    /**
     * Enables running the Docker daemon inside a Docker container.
     *
     * Set to true only if the build project is used to build Docker images. Otherwise, a build that attempts to interact with the Docker daemon fails. The default setting is `false` .
     *
     * You can initialize the Docker daemon during the install phase of your build by adding one of the following sets of commands to the install phase of your buildspec file:
     *
     * If the operating system's base image is Ubuntu Linux:
     *
     * `- nohup /usr/local/bin/dockerd --host=unix:///var/run/docker.sock --host=tcp://0.0.0.0:2375 --storage-driver=overlay&`
     *
     * `- timeout 15 sh -c "until docker info; do echo .; sleep 1; done"`
     *
     * If the operating system's base image is Alpine Linux and the previous command does not work, add the `-t` argument to `timeout` :
     *
     * `- nohup /usr/local/bin/dockerd --host=unix:///var/run/docker.sock --host=tcp://0.0.0.0:2375 --storage-driver=overlay&`
     *
     * `- timeout -t 15 sh -c "until docker info; do echo .; sleep 1; done"`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-environment.html#cfn-codebuild-project-environment-privilegedmode
     */
    readonly privilegedMode?: boolean | cdk.IResolvable;

    /**
     * `RegistryCredential` is a property of the [AWS::CodeBuild::Project Environment](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-codebuild-project.html#cfn-codebuild-project-environment) property that specifies information about credentials that provide access to a private Docker registry. When this is set:.
     *
     * - `imagePullCredentialsType` must be set to `SERVICE_ROLE` .
     * - images cannot be curated or an Amazon ECR image.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-environment.html#cfn-codebuild-project-environment-registrycredential
     */
    readonly registryCredential?: cdk.IResolvable | CfnProject.RegistryCredentialProperty;

    /**
     * The type of build environment to use for related builds.
     *
     * - The environment type `ARM_CONTAINER` is available only in regions US East (N. Virginia), US East (Ohio), US West (Oregon), EU (Ireland), Asia Pacific (Mumbai), Asia Pacific (Tokyo), Asia Pacific (Sydney), and EU (Frankfurt).
     * - The environment type `LINUX_CONTAINER` with compute type `build.general1.2xlarge` is available only in regions US East (N. Virginia), US East (Ohio), US West (Oregon), Canada (Central), EU (Ireland), EU (London), EU (Frankfurt), Asia Pacific (Tokyo), Asia Pacific (Seoul), Asia Pacific (Singapore), Asia Pacific (Sydney), China (Beijing), and China (Ningxia).
     * - The environment type `LINUX_GPU_CONTAINER` is available only in regions US East (N. Virginia), US East (Ohio), US West (Oregon), Canada (Central), EU (Ireland), EU (London), EU (Frankfurt), Asia Pacific (Tokyo), Asia Pacific (Seoul), Asia Pacific (Singapore), Asia Pacific (Sydney) , China (Beijing), and China (Ningxia).
     *
     * - The environment types `ARM_LAMBDA_CONTAINER` and `LINUX_LAMBDA_CONTAINER` are available only in regions US East (N. Virginia), US East (Ohio), US West (Oregon), Asia Pacific (Mumbai), Asia Pacific (Singapore), Asia Pacific (Sydney), Asia Pacific (Tokyo), EU (Frankfurt), EU (Ireland), and South America (So Paulo).
     *
     * - The environment types `WINDOWS_CONTAINER` and `WINDOWS_SERVER_2019_CONTAINER` are available only in regions US East (N. Virginia), US East (Ohio), US West (Oregon), and EU (Ireland).
     *
     * For more information, see [Build environment compute types](https://docs.aws.amazon.com//codebuild/latest/userguide/build-env-ref-compute-types.html) in the *AWS CodeBuild user guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-environment.html#cfn-codebuild-project-environment-type
     */
    readonly type?: string;
  }

  /**
   * `EnvironmentVariable` is a property of the [AWS CodeBuild Project Environment](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-environment.html) property type that specifies the name and value of an environment variable for an AWS CodeBuild project environment. When you use the environment to run a build, these variables are available for your builds to use. `EnvironmentVariable` contains a list of `EnvironmentVariable` property types.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-environmentvariable.html
   */
  export interface EnvironmentVariableProperty {
    /**
     * The name or key of the environment variable.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-environmentvariable.html#cfn-codebuild-project-environmentvariable-name
     */
    readonly name: string;

    /**
     * The type of environment variable. Valid values include:.
     *
     * - `PARAMETER_STORE` : An environment variable stored in Systems Manager Parameter Store. For environment variables of this type, specify the name of the parameter as the `value` of the EnvironmentVariable. The parameter value will be substituted for the name at runtime. You can also define Parameter Store environment variables in the buildspec. To learn how to do so, see [env/parameter-store](https://docs.aws.amazon.com/codebuild/latest/userguide/build-spec-ref.html#build-spec.env.parameter-store) in the *AWS CodeBuild User Guide* .
     * - `PLAINTEXT` : An environment variable in plain text format. This is the default value.
     * - `SECRETS_MANAGER` : An environment variable stored in AWS Secrets Manager . For environment variables of this type, specify the name of the secret as the `value` of the EnvironmentVariable. The secret value will be substituted for the name at runtime. You can also define AWS Secrets Manager environment variables in the buildspec. To learn how to do so, see [env/secrets-manager](https://docs.aws.amazon.com/codebuild/latest/userguide/build-spec-ref.html#build-spec.env.secrets-manager) in the *AWS CodeBuild User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-environmentvariable.html#cfn-codebuild-project-environmentvariable-type
     */
    readonly type?: string;

    /**
     * The value of the environment variable.
     *
     * > We strongly discourage the use of `PLAINTEXT` environment variables to store sensitive values, especially AWS secret key IDs. `PLAINTEXT` environment variables can be displayed in plain text using the AWS CodeBuild console and the AWS CLI . For sensitive values, we recommend you use an environment variable of type `PARAMETER_STORE` or `SECRETS_MANAGER` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-environmentvariable.html#cfn-codebuild-project-environmentvariable-value
     */
    readonly value: string;
  }

  /**
   * `RegistryCredential` is a property of the [AWS CodeBuild Project Environment](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-environment.html) property type that specifies information about credentials that provide access to a private Docker registry. When this is set:.
   *
   * - `imagePullCredentialsType` must be set to `SERVICE_ROLE` .
   * - images cannot be curated or an Amazon ECR image.
   *
   * For more information, see [Private Registry with AWS Secrets Manager Sample for AWS CodeBuild](https://docs.aws.amazon.com/codebuild/latest/userguide/sample-private-registry.html) .
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-registrycredential.html
   */
  export interface RegistryCredentialProperty {
    /**
     * The Amazon Resource Name (ARN) or name of credentials created using AWS Secrets Manager .
     *
     * > The `credential` can use the name of the credentials only if they exist in your current AWS Region .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-registrycredential.html#cfn-codebuild-project-registrycredential-credential
     */
    readonly credential: string;

    /**
     * The service that created the credentials to access a private Docker registry.
     *
     * The valid value, SECRETS_MANAGER, is for AWS Secrets Manager .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-registrycredential.html#cfn-codebuild-project-registrycredential-credentialprovider
     */
    readonly credentialProvider: string;
  }

  /**
   * A source identifier and its corresponding version.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-projectsourceversion.html
   */
  export interface ProjectSourceVersionProperty {
    /**
     * An identifier for a source in the build project.
     *
     * The identifier can only contain alphanumeric characters and underscores, and must be less than 128 characters in length.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-projectsourceversion.html#cfn-codebuild-project-projectsourceversion-sourceidentifier
     */
    readonly sourceIdentifier: string;

    /**
     * The source version for the corresponding source identifier. If specified, must be one of:.
     *
     * - For CodeCommit: the commit ID, branch, or Git tag to use.
     * - For GitHub: the commit ID, pull request ID, branch name, or tag name that corresponds to the version of the source code you want to build. If a pull request ID is specified, it must use the format `pr/pull-request-ID` (for example, `pr/25` ). If a branch name is specified, the branch's HEAD commit ID is used. If not specified, the default branch's HEAD commit ID is used.
     * - For Bitbucket: the commit ID, branch name, or tag name that corresponds to the version of the source code you want to build. If a branch name is specified, the branch's HEAD commit ID is used. If not specified, the default branch's HEAD commit ID is used.
     * - For Amazon S3: the version ID of the object that represents the build input ZIP file to use.
     *
     * For more information, see [Source Version Sample with CodeBuild](https://docs.aws.amazon.com/codebuild/latest/userguide/sample-source-version.html) in the *AWS CodeBuild User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-projectsourceversion.html#cfn-codebuild-project-projectsourceversion-sourceversion
     */
    readonly sourceVersion?: string;
  }

  /**
   * Contains configuration information about a batch build project.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-projectbuildbatchconfig.html
   */
  export interface ProjectBuildBatchConfigProperty {
    /**
     * Specifies how build status reports are sent to the source provider for the batch build.
     *
     * This property is only used when the source provider for your project is Bitbucket, GitHub, or GitHub Enterprise, and your project is configured to report build statuses to the source provider.
     *
     * - **REPORT_AGGREGATED_BATCH** - (Default) Aggregate all of the build statuses into a single status report.
     * - **REPORT_INDIVIDUAL_BUILDS** - Send a separate status report for each individual build.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-projectbuildbatchconfig.html#cfn-codebuild-project-projectbuildbatchconfig-batchreportmode
     */
    readonly batchReportMode?: string;

    /**
     * Specifies if the build artifacts for the batch build should be combined into a single artifact location.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-projectbuildbatchconfig.html#cfn-codebuild-project-projectbuildbatchconfig-combineartifacts
     */
    readonly combineArtifacts?: boolean | cdk.IResolvable;

    /**
     * A `BatchRestrictions` object that specifies the restrictions for the batch build.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-projectbuildbatchconfig.html#cfn-codebuild-project-projectbuildbatchconfig-restrictions
     */
    readonly restrictions?: CfnProject.BatchRestrictionsProperty | cdk.IResolvable;

    /**
     * Specifies the service role ARN for the batch build project.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-projectbuildbatchconfig.html#cfn-codebuild-project-projectbuildbatchconfig-servicerole
     */
    readonly serviceRole?: string;

    /**
     * Specifies the maximum amount of time, in minutes, that the batch build must be completed in.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-projectbuildbatchconfig.html#cfn-codebuild-project-projectbuildbatchconfig-timeoutinmins
     */
    readonly timeoutInMins?: number;
  }

  /**
   * Specifies restrictions for the batch build.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-batchrestrictions.html
   */
  export interface BatchRestrictionsProperty {
    /**
     * An array of strings that specify the compute types that are allowed for the batch build.
     *
     * See [Build environment compute types](https://docs.aws.amazon.com/codebuild/latest/userguide/build-env-ref-compute-types.html) in the *AWS CodeBuild User Guide* for these values.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-batchrestrictions.html#cfn-codebuild-project-batchrestrictions-computetypesallowed
     */
    readonly computeTypesAllowed?: Array<string>;

    /**
     * Specifies the maximum number of builds allowed.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-batchrestrictions.html#cfn-codebuild-project-batchrestrictions-maximumbuildsallowed
     */
    readonly maximumBuildsAllowed?: number;
  }

  /**
   * `ProjectCache` is a property of the [AWS CodeBuild Project](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-codebuild-project.html) resource that specifies information about the cache for the build project. If `ProjectCache` is not specified, then both of its properties default to `NO_CACHE` .
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-projectcache.html
   */
  export interface ProjectCacheProperty {
    /**
     * Information about the cache location:.
     *
     * - `NO_CACHE` or `LOCAL` : This value is ignored.
     * - `S3` : This is the S3 bucket name/prefix.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-projectcache.html#cfn-codebuild-project-projectcache-location
     */
    readonly location?: string;

    /**
     * An array of strings that specify the local cache modes.
     *
     * You can use one or more local cache modes at the same time. This is only used for `LOCAL` cache types.
     *
     * Possible values are:
     *
     * - **LOCAL_SOURCE_CACHE** - Caches Git metadata for primary and secondary sources. After the cache is created, subsequent builds pull only the change between commits. This mode is a good choice for projects with a clean working directory and a source that is a large Git repository. If you choose this option and your project does not use a Git repository (GitHub, GitHub Enterprise, or Bitbucket), the option is ignored.
     * - **LOCAL_DOCKER_LAYER_CACHE** - Caches existing Docker layers. This mode is a good choice for projects that build or pull large Docker images. It can prevent the performance issues caused by pulling large Docker images down from the network.
     *
     * > - You can use a Docker layer cache in the Linux environment only.
     * > - The `privileged` flag must be set so that your project has the required Docker permissions.
     * > - You should consider the security implications before you use a Docker layer cache.
     * - **LOCAL_CUSTOM_CACHE** - Caches directories you specify in the buildspec file. This mode is a good choice if your build scenario is not suited to one of the other three local cache modes. If you use a custom cache:
     *
     * - Only directories can be specified for caching. You cannot specify individual files.
     * - Symlinks are used to reference cached directories.
     * - Cached directories are linked to your build before it downloads its project sources. Cached items are overridden if a source item has the same name. Directories are specified using cache paths in the buildspec file.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-projectcache.html#cfn-codebuild-project-projectcache-modes
     */
    readonly modes?: Array<string>;

    /**
     * The type of cache used by the build project. Valid values include:.
     *
     * - `NO_CACHE` : The build project does not use any cache.
     * - `S3` : The build project reads and writes from and to S3.
     * - `LOCAL` : The build project stores a cache locally on a build host that is only available to that build host.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-projectcache.html#cfn-codebuild-project-projectcache-type
     */
    readonly type: string;
  }
}

/**
 * Properties for defining a `CfnProject`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-codebuild-project.html
 */
export interface CfnProjectProps {
  /**
   * `Artifacts` is a property of the [AWS::CodeBuild::Project](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-codebuild-project.html) resource that specifies output settings for artifacts generated by an AWS CodeBuild build.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-codebuild-project.html#cfn-codebuild-project-artifacts
   */
  readonly artifacts: CfnProject.ArtifactsProperty | cdk.IResolvable;

  /**
   * Indicates whether AWS CodeBuild generates a publicly accessible URL for your project's build badge.
   *
   * For more information, see [Build Badges Sample](https://docs.aws.amazon.com/codebuild/latest/userguide/sample-build-badges.html) in the *AWS CodeBuild User Guide* .
   *
   * > Including build badges with your project is currently not supported if the source type is CodePipeline. If you specify `CODEPIPELINE` for the `Source` property, do not specify the `BadgeEnabled` property.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-codebuild-project.html#cfn-codebuild-project-badgeenabled
   */
  readonly badgeEnabled?: boolean | cdk.IResolvable;

  /**
   * A `ProjectBuildBatchConfig` object that defines the batch build options for the project.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-codebuild-project.html#cfn-codebuild-project-buildbatchconfig
   */
  readonly buildBatchConfig?: cdk.IResolvable | CfnProject.ProjectBuildBatchConfigProperty;

  /**
   * Settings that AWS CodeBuild uses to store and reuse build dependencies.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-codebuild-project.html#cfn-codebuild-project-cache
   */
  readonly cache?: cdk.IResolvable | CfnProject.ProjectCacheProperty;

  /**
   * The maximum number of concurrent builds that are allowed for this project.
   *
   * New builds are only started if the current number of builds is less than or equal to this limit. If the current build count meets this limit, new builds are throttled and are not run.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-codebuild-project.html#cfn-codebuild-project-concurrentbuildlimit
   */
  readonly concurrentBuildLimit?: number;

  /**
   * A description that makes the build project easy to identify.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-codebuild-project.html#cfn-codebuild-project-description
   */
  readonly description?: string;

  /**
   * The AWS Key Management Service customer master key (CMK) to be used for encrypting the build output artifacts.
   *
   * > You can use a cross-account KMS key to encrypt the build output artifacts if your service role has permission to that key.
   *
   * You can specify either the Amazon Resource Name (ARN) of the CMK or, if available, the CMK's alias (using the format `alias/<alias-name>` ). If you don't specify a value, CodeBuild uses the managed CMK for Amazon Simple Storage Service (Amazon S3).
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-codebuild-project.html#cfn-codebuild-project-encryptionkey
   */
  readonly encryptionKey?: string;

  /**
   * The build environment settings for the project, such as the environment type or the environment variables to use for the build environment.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-codebuild-project.html#cfn-codebuild-project-environment
   */
  readonly environment: CfnProject.EnvironmentProperty | cdk.IResolvable;

  /**
   * An array of `ProjectFileSystemLocation` objects for a CodeBuild build project.
   *
   * A `ProjectFileSystemLocation` object specifies the `identifier` , `location` , `mountOptions` , `mountPoint` , and `type` of a file system created using Amazon Elastic File System.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-codebuild-project.html#cfn-codebuild-project-filesystemlocations
   */
  readonly fileSystemLocations?: Array<cdk.IResolvable | CfnProject.ProjectFileSystemLocationProperty> | cdk.IResolvable;

  /**
   * Information about logs for the build project.
   *
   * A project can create logs in CloudWatch Logs, an S3 bucket, or both.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-codebuild-project.html#cfn-codebuild-project-logsconfig
   */
  readonly logsConfig?: cdk.IResolvable | CfnProject.LogsConfigProperty;

  /**
   * The name of the build project.
   *
   * The name must be unique across all of the projects in your AWS account .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-codebuild-project.html#cfn-codebuild-project-name
   */
  readonly name?: string;

  /**
   * The number of minutes a build is allowed to be queued before it times out.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-codebuild-project.html#cfn-codebuild-project-queuedtimeoutinminutes
   */
  readonly queuedTimeoutInMinutes?: number;

  /**
   * The ARN of the IAM role that enables CodeBuild to access the CloudWatch Logs and Amazon S3 artifacts for the project's builds.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-codebuild-project.html#cfn-codebuild-project-resourceaccessrole
   */
  readonly resourceAccessRole?: string;

  /**
   * A list of `Artifacts` objects.
   *
   * Each artifacts object specifies output settings that the project generates during a build.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-codebuild-project.html#cfn-codebuild-project-secondaryartifacts
   */
  readonly secondaryArtifacts?: Array<CfnProject.ArtifactsProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * An array of `ProjectSource` objects.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-codebuild-project.html#cfn-codebuild-project-secondarysources
   */
  readonly secondarySources?: Array<cdk.IResolvable | CfnProject.SourceProperty> | cdk.IResolvable;

  /**
   * An array of `ProjectSourceVersion` objects.
   *
   * If `secondarySourceVersions` is specified at the build level, then they take over these `secondarySourceVersions` (at the project level).
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-codebuild-project.html#cfn-codebuild-project-secondarysourceversions
   */
  readonly secondarySourceVersions?: Array<cdk.IResolvable | CfnProject.ProjectSourceVersionProperty> | cdk.IResolvable;

  /**
   * The ARN of the IAM role that enables AWS CodeBuild to interact with dependent AWS services on behalf of the AWS account.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-codebuild-project.html#cfn-codebuild-project-servicerole
   */
  readonly serviceRole: string;

  /**
   * The source code settings for the project, such as the source code's repository type and location.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-codebuild-project.html#cfn-codebuild-project-source
   */
  readonly source: cdk.IResolvable | CfnProject.SourceProperty;

  /**
   * A version of the build input to be built for this project.
   *
   * If not specified, the latest version is used. If specified, it must be one of:
   *
   * - For CodeCommit: the commit ID, branch, or Git tag to use.
   * - For GitHub: the commit ID, pull request ID, branch name, or tag name that corresponds to the version of the source code you want to build. If a pull request ID is specified, it must use the format `pr/pull-request-ID` (for example `pr/25` ). If a branch name is specified, the branch's HEAD commit ID is used. If not specified, the default branch's HEAD commit ID is used.
   * - For Bitbucket: the commit ID, branch name, or tag name that corresponds to the version of the source code you want to build. If a branch name is specified, the branch's HEAD commit ID is used. If not specified, the default branch's HEAD commit ID is used.
   * - For Amazon S3: the version ID of the object that represents the build input ZIP file to use.
   *
   * If `sourceVersion` is specified at the build level, then that version takes precedence over this `sourceVersion` (at the project level).
   *
   * For more information, see [Source Version Sample with CodeBuild](https://docs.aws.amazon.com/codebuild/latest/userguide/sample-source-version.html) in the *AWS CodeBuild User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-codebuild-project.html#cfn-codebuild-project-sourceversion
   */
  readonly sourceVersion?: string;

  /**
   * An arbitrary set of tags (key-value pairs) for the AWS CodeBuild project.
   *
   * These tags are available for use by AWS services that support AWS CodeBuild build project tags.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-codebuild-project.html#cfn-codebuild-project-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * How long, in minutes, from 5 to 480 (8 hours), for AWS CodeBuild to wait before timing out any related build that did not get marked as completed.
   *
   * The default is 60 minutes.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-codebuild-project.html#cfn-codebuild-project-timeoutinminutes
   */
  readonly timeoutInMinutes?: number;

  /**
   * For an existing AWS CodeBuild build project that has its source code stored in a GitHub repository, enables AWS CodeBuild to begin automatically rebuilding the source code every time a code change is pushed to the repository.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-codebuild-project.html#cfn-codebuild-project-triggers
   */
  readonly triggers?: cdk.IResolvable | CfnProject.ProjectTriggersProperty;

  /**
   * Specifies the visibility of the project's builds. Possible values are:.
   *
   * - **PUBLIC_READ** - The project builds are visible to the public.
   * - **PRIVATE** - The project builds are not visible to the public.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-codebuild-project.html#cfn-codebuild-project-visibility
   */
  readonly visibility?: string;

  /**
   * `VpcConfig` specifies settings that enable AWS CodeBuild to access resources in an Amazon VPC.
   *
   * For more information, see [Use AWS CodeBuild with Amazon Virtual Private Cloud](https://docs.aws.amazon.com/codebuild/latest/userguide/vpc-support.html) in the *AWS CodeBuild User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-codebuild-project.html#cfn-codebuild-project-vpcconfig
   */
  readonly vpcConfig?: cdk.IResolvable | CfnProject.VpcConfigProperty;
}

/**
 * Determine whether the given properties match those of a `VpcConfigProperty`
 *
 * @param properties - the TypeScript properties of a `VpcConfigProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnProjectVpcConfigPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("securityGroupIds", cdk.listValidator(cdk.validateString))(properties.securityGroupIds));
  errors.collect(cdk.propertyValidator("subnets", cdk.listValidator(cdk.validateString))(properties.subnets));
  errors.collect(cdk.propertyValidator("vpcId", cdk.validateString)(properties.vpcId));
  return errors.wrap("supplied properties not correct for \"VpcConfigProperty\"");
}

// @ts-ignore TS6133
function convertCfnProjectVpcConfigPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnProjectVpcConfigPropertyValidator(properties).assertSuccess();
  return {
    "SecurityGroupIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.securityGroupIds),
    "Subnets": cdk.listMapper(cdk.stringToCloudFormation)(properties.subnets),
    "VpcId": cdk.stringToCloudFormation(properties.vpcId)
  };
}

// @ts-ignore TS6133
function CfnProjectVpcConfigPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnProject.VpcConfigProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnProject.VpcConfigProperty>();
  ret.addPropertyResult("securityGroupIds", "SecurityGroupIds", (properties.SecurityGroupIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecurityGroupIds) : undefined));
  ret.addPropertyResult("subnets", "Subnets", (properties.Subnets != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.Subnets) : undefined));
  ret.addPropertyResult("vpcId", "VpcId", (properties.VpcId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `SourceAuthProperty`
 *
 * @param properties - the TypeScript properties of a `SourceAuthProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnProjectSourceAuthPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("resource", cdk.validateString)(properties.resource));
  errors.collect(cdk.propertyValidator("type", cdk.requiredValidator)(properties.type));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  return errors.wrap("supplied properties not correct for \"SourceAuthProperty\"");
}

// @ts-ignore TS6133
function convertCfnProjectSourceAuthPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnProjectSourceAuthPropertyValidator(properties).assertSuccess();
  return {
    "Resource": cdk.stringToCloudFormation(properties.resource),
    "Type": cdk.stringToCloudFormation(properties.type)
  };
}

// @ts-ignore TS6133
function CfnProjectSourceAuthPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnProject.SourceAuthProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnProject.SourceAuthProperty>();
  ret.addPropertyResult("resource", "Resource", (properties.Resource != null ? cfn_parse.FromCloudFormation.getString(properties.Resource) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `BuildStatusConfigProperty`
 *
 * @param properties - the TypeScript properties of a `BuildStatusConfigProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnProjectBuildStatusConfigPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("context", cdk.validateString)(properties.context));
  errors.collect(cdk.propertyValidator("targetUrl", cdk.validateString)(properties.targetUrl));
  return errors.wrap("supplied properties not correct for \"BuildStatusConfigProperty\"");
}

// @ts-ignore TS6133
function convertCfnProjectBuildStatusConfigPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnProjectBuildStatusConfigPropertyValidator(properties).assertSuccess();
  return {
    "Context": cdk.stringToCloudFormation(properties.context),
    "TargetUrl": cdk.stringToCloudFormation(properties.targetUrl)
  };
}

// @ts-ignore TS6133
function CfnProjectBuildStatusConfigPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnProject.BuildStatusConfigProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnProject.BuildStatusConfigProperty>();
  ret.addPropertyResult("context", "Context", (properties.Context != null ? cfn_parse.FromCloudFormation.getString(properties.Context) : undefined));
  ret.addPropertyResult("targetUrl", "TargetUrl", (properties.TargetUrl != null ? cfn_parse.FromCloudFormation.getString(properties.TargetUrl) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `GitSubmodulesConfigProperty`
 *
 * @param properties - the TypeScript properties of a `GitSubmodulesConfigProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnProjectGitSubmodulesConfigPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("fetchSubmodules", cdk.requiredValidator)(properties.fetchSubmodules));
  errors.collect(cdk.propertyValidator("fetchSubmodules", cdk.validateBoolean)(properties.fetchSubmodules));
  return errors.wrap("supplied properties not correct for \"GitSubmodulesConfigProperty\"");
}

// @ts-ignore TS6133
function convertCfnProjectGitSubmodulesConfigPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnProjectGitSubmodulesConfigPropertyValidator(properties).assertSuccess();
  return {
    "FetchSubmodules": cdk.booleanToCloudFormation(properties.fetchSubmodules)
  };
}

// @ts-ignore TS6133
function CfnProjectGitSubmodulesConfigPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnProject.GitSubmodulesConfigProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnProject.GitSubmodulesConfigProperty>();
  ret.addPropertyResult("fetchSubmodules", "FetchSubmodules", (properties.FetchSubmodules != null ? cfn_parse.FromCloudFormation.getBoolean(properties.FetchSubmodules) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `SourceProperty`
 *
 * @param properties - the TypeScript properties of a `SourceProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnProjectSourcePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("auth", CfnProjectSourceAuthPropertyValidator)(properties.auth));
  errors.collect(cdk.propertyValidator("buildSpec", cdk.validateString)(properties.buildSpec));
  errors.collect(cdk.propertyValidator("buildStatusConfig", CfnProjectBuildStatusConfigPropertyValidator)(properties.buildStatusConfig));
  errors.collect(cdk.propertyValidator("gitCloneDepth", cdk.validateNumber)(properties.gitCloneDepth));
  errors.collect(cdk.propertyValidator("gitSubmodulesConfig", CfnProjectGitSubmodulesConfigPropertyValidator)(properties.gitSubmodulesConfig));
  errors.collect(cdk.propertyValidator("insecureSsl", cdk.validateBoolean)(properties.insecureSsl));
  errors.collect(cdk.propertyValidator("location", cdk.validateString)(properties.location));
  errors.collect(cdk.propertyValidator("reportBuildStatus", cdk.validateBoolean)(properties.reportBuildStatus));
  errors.collect(cdk.propertyValidator("sourceIdentifier", cdk.validateString)(properties.sourceIdentifier));
  errors.collect(cdk.propertyValidator("type", cdk.requiredValidator)(properties.type));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  return errors.wrap("supplied properties not correct for \"SourceProperty\"");
}

// @ts-ignore TS6133
function convertCfnProjectSourcePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnProjectSourcePropertyValidator(properties).assertSuccess();
  return {
    "Auth": convertCfnProjectSourceAuthPropertyToCloudFormation(properties.auth),
    "BuildSpec": cdk.stringToCloudFormation(properties.buildSpec),
    "BuildStatusConfig": convertCfnProjectBuildStatusConfigPropertyToCloudFormation(properties.buildStatusConfig),
    "GitCloneDepth": cdk.numberToCloudFormation(properties.gitCloneDepth),
    "GitSubmodulesConfig": convertCfnProjectGitSubmodulesConfigPropertyToCloudFormation(properties.gitSubmodulesConfig),
    "InsecureSsl": cdk.booleanToCloudFormation(properties.insecureSsl),
    "Location": cdk.stringToCloudFormation(properties.location),
    "ReportBuildStatus": cdk.booleanToCloudFormation(properties.reportBuildStatus),
    "SourceIdentifier": cdk.stringToCloudFormation(properties.sourceIdentifier),
    "Type": cdk.stringToCloudFormation(properties.type)
  };
}

// @ts-ignore TS6133
function CfnProjectSourcePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnProject.SourceProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnProject.SourceProperty>();
  ret.addPropertyResult("auth", "Auth", (properties.Auth != null ? CfnProjectSourceAuthPropertyFromCloudFormation(properties.Auth) : undefined));
  ret.addPropertyResult("buildSpec", "BuildSpec", (properties.BuildSpec != null ? cfn_parse.FromCloudFormation.getString(properties.BuildSpec) : undefined));
  ret.addPropertyResult("buildStatusConfig", "BuildStatusConfig", (properties.BuildStatusConfig != null ? CfnProjectBuildStatusConfigPropertyFromCloudFormation(properties.BuildStatusConfig) : undefined));
  ret.addPropertyResult("gitCloneDepth", "GitCloneDepth", (properties.GitCloneDepth != null ? cfn_parse.FromCloudFormation.getNumber(properties.GitCloneDepth) : undefined));
  ret.addPropertyResult("gitSubmodulesConfig", "GitSubmodulesConfig", (properties.GitSubmodulesConfig != null ? CfnProjectGitSubmodulesConfigPropertyFromCloudFormation(properties.GitSubmodulesConfig) : undefined));
  ret.addPropertyResult("insecureSsl", "InsecureSsl", (properties.InsecureSsl != null ? cfn_parse.FromCloudFormation.getBoolean(properties.InsecureSsl) : undefined));
  ret.addPropertyResult("location", "Location", (properties.Location != null ? cfn_parse.FromCloudFormation.getString(properties.Location) : undefined));
  ret.addPropertyResult("reportBuildStatus", "ReportBuildStatus", (properties.ReportBuildStatus != null ? cfn_parse.FromCloudFormation.getBoolean(properties.ReportBuildStatus) : undefined));
  ret.addPropertyResult("sourceIdentifier", "SourceIdentifier", (properties.SourceIdentifier != null ? cfn_parse.FromCloudFormation.getString(properties.SourceIdentifier) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `WebhookFilterProperty`
 *
 * @param properties - the TypeScript properties of a `WebhookFilterProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnProjectWebhookFilterPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("excludeMatchedPattern", cdk.validateBoolean)(properties.excludeMatchedPattern));
  errors.collect(cdk.propertyValidator("pattern", cdk.requiredValidator)(properties.pattern));
  errors.collect(cdk.propertyValidator("pattern", cdk.validateString)(properties.pattern));
  errors.collect(cdk.propertyValidator("type", cdk.requiredValidator)(properties.type));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  return errors.wrap("supplied properties not correct for \"WebhookFilterProperty\"");
}

// @ts-ignore TS6133
function convertCfnProjectWebhookFilterPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnProjectWebhookFilterPropertyValidator(properties).assertSuccess();
  return {
    "ExcludeMatchedPattern": cdk.booleanToCloudFormation(properties.excludeMatchedPattern),
    "Pattern": cdk.stringToCloudFormation(properties.pattern),
    "Type": cdk.stringToCloudFormation(properties.type)
  };
}

// @ts-ignore TS6133
function CfnProjectWebhookFilterPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnProject.WebhookFilterProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnProject.WebhookFilterProperty>();
  ret.addPropertyResult("excludeMatchedPattern", "ExcludeMatchedPattern", (properties.ExcludeMatchedPattern != null ? cfn_parse.FromCloudFormation.getBoolean(properties.ExcludeMatchedPattern) : undefined));
  ret.addPropertyResult("pattern", "Pattern", (properties.Pattern != null ? cfn_parse.FromCloudFormation.getString(properties.Pattern) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `ProjectTriggersProperty`
 *
 * @param properties - the TypeScript properties of a `ProjectTriggersProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnProjectProjectTriggersPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("buildType", cdk.validateString)(properties.buildType));
  errors.collect(cdk.propertyValidator("filterGroups", cdk.listValidator(cdk.listValidator(CfnProjectWebhookFilterPropertyValidator)))(properties.filterGroups));
  errors.collect(cdk.propertyValidator("webhook", cdk.validateBoolean)(properties.webhook));
  return errors.wrap("supplied properties not correct for \"ProjectTriggersProperty\"");
}

// @ts-ignore TS6133
function convertCfnProjectProjectTriggersPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnProjectProjectTriggersPropertyValidator(properties).assertSuccess();
  return {
    "BuildType": cdk.stringToCloudFormation(properties.buildType),
    "FilterGroups": cdk.listMapper(cdk.listMapper(convertCfnProjectWebhookFilterPropertyToCloudFormation))(properties.filterGroups),
    "Webhook": cdk.booleanToCloudFormation(properties.webhook)
  };
}

// @ts-ignore TS6133
function CfnProjectProjectTriggersPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnProject.ProjectTriggersProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnProject.ProjectTriggersProperty>();
  ret.addPropertyResult("buildType", "BuildType", (properties.BuildType != null ? cfn_parse.FromCloudFormation.getString(properties.BuildType) : undefined));
  ret.addPropertyResult("filterGroups", "FilterGroups", (properties.FilterGroups != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getArray(CfnProjectWebhookFilterPropertyFromCloudFormation))(properties.FilterGroups) : undefined));
  ret.addPropertyResult("webhook", "Webhook", (properties.Webhook != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Webhook) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `ArtifactsProperty`
 *
 * @param properties - the TypeScript properties of a `ArtifactsProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnProjectArtifactsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("artifactIdentifier", cdk.validateString)(properties.artifactIdentifier));
  errors.collect(cdk.propertyValidator("encryptionDisabled", cdk.validateBoolean)(properties.encryptionDisabled));
  errors.collect(cdk.propertyValidator("location", cdk.validateString)(properties.location));
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  errors.collect(cdk.propertyValidator("namespaceType", cdk.validateString)(properties.namespaceType));
  errors.collect(cdk.propertyValidator("overrideArtifactName", cdk.validateBoolean)(properties.overrideArtifactName));
  errors.collect(cdk.propertyValidator("packaging", cdk.validateString)(properties.packaging));
  errors.collect(cdk.propertyValidator("path", cdk.validateString)(properties.path));
  errors.collect(cdk.propertyValidator("type", cdk.requiredValidator)(properties.type));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  return errors.wrap("supplied properties not correct for \"ArtifactsProperty\"");
}

// @ts-ignore TS6133
function convertCfnProjectArtifactsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnProjectArtifactsPropertyValidator(properties).assertSuccess();
  return {
    "ArtifactIdentifier": cdk.stringToCloudFormation(properties.artifactIdentifier),
    "EncryptionDisabled": cdk.booleanToCloudFormation(properties.encryptionDisabled),
    "Location": cdk.stringToCloudFormation(properties.location),
    "Name": cdk.stringToCloudFormation(properties.name),
    "NamespaceType": cdk.stringToCloudFormation(properties.namespaceType),
    "OverrideArtifactName": cdk.booleanToCloudFormation(properties.overrideArtifactName),
    "Packaging": cdk.stringToCloudFormation(properties.packaging),
    "Path": cdk.stringToCloudFormation(properties.path),
    "Type": cdk.stringToCloudFormation(properties.type)
  };
}

// @ts-ignore TS6133
function CfnProjectArtifactsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnProject.ArtifactsProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnProject.ArtifactsProperty>();
  ret.addPropertyResult("artifactIdentifier", "ArtifactIdentifier", (properties.ArtifactIdentifier != null ? cfn_parse.FromCloudFormation.getString(properties.ArtifactIdentifier) : undefined));
  ret.addPropertyResult("encryptionDisabled", "EncryptionDisabled", (properties.EncryptionDisabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EncryptionDisabled) : undefined));
  ret.addPropertyResult("location", "Location", (properties.Location != null ? cfn_parse.FromCloudFormation.getString(properties.Location) : undefined));
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addPropertyResult("namespaceType", "NamespaceType", (properties.NamespaceType != null ? cfn_parse.FromCloudFormation.getString(properties.NamespaceType) : undefined));
  ret.addPropertyResult("overrideArtifactName", "OverrideArtifactName", (properties.OverrideArtifactName != null ? cfn_parse.FromCloudFormation.getBoolean(properties.OverrideArtifactName) : undefined));
  ret.addPropertyResult("packaging", "Packaging", (properties.Packaging != null ? cfn_parse.FromCloudFormation.getString(properties.Packaging) : undefined));
  ret.addPropertyResult("path", "Path", (properties.Path != null ? cfn_parse.FromCloudFormation.getString(properties.Path) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `CloudWatchLogsConfigProperty`
 *
 * @param properties - the TypeScript properties of a `CloudWatchLogsConfigProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnProjectCloudWatchLogsConfigPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("groupName", cdk.validateString)(properties.groupName));
  errors.collect(cdk.propertyValidator("status", cdk.requiredValidator)(properties.status));
  errors.collect(cdk.propertyValidator("status", cdk.validateString)(properties.status));
  errors.collect(cdk.propertyValidator("streamName", cdk.validateString)(properties.streamName));
  return errors.wrap("supplied properties not correct for \"CloudWatchLogsConfigProperty\"");
}

// @ts-ignore TS6133
function convertCfnProjectCloudWatchLogsConfigPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnProjectCloudWatchLogsConfigPropertyValidator(properties).assertSuccess();
  return {
    "GroupName": cdk.stringToCloudFormation(properties.groupName),
    "Status": cdk.stringToCloudFormation(properties.status),
    "StreamName": cdk.stringToCloudFormation(properties.streamName)
  };
}

// @ts-ignore TS6133
function CfnProjectCloudWatchLogsConfigPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnProject.CloudWatchLogsConfigProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnProject.CloudWatchLogsConfigProperty>();
  ret.addPropertyResult("groupName", "GroupName", (properties.GroupName != null ? cfn_parse.FromCloudFormation.getString(properties.GroupName) : undefined));
  ret.addPropertyResult("status", "Status", (properties.Status != null ? cfn_parse.FromCloudFormation.getString(properties.Status) : undefined));
  ret.addPropertyResult("streamName", "StreamName", (properties.StreamName != null ? cfn_parse.FromCloudFormation.getString(properties.StreamName) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `S3LogsConfigProperty`
 *
 * @param properties - the TypeScript properties of a `S3LogsConfigProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnProjectS3LogsConfigPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("encryptionDisabled", cdk.validateBoolean)(properties.encryptionDisabled));
  errors.collect(cdk.propertyValidator("location", cdk.validateString)(properties.location));
  errors.collect(cdk.propertyValidator("status", cdk.requiredValidator)(properties.status));
  errors.collect(cdk.propertyValidator("status", cdk.validateString)(properties.status));
  return errors.wrap("supplied properties not correct for \"S3LogsConfigProperty\"");
}

// @ts-ignore TS6133
function convertCfnProjectS3LogsConfigPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnProjectS3LogsConfigPropertyValidator(properties).assertSuccess();
  return {
    "EncryptionDisabled": cdk.booleanToCloudFormation(properties.encryptionDisabled),
    "Location": cdk.stringToCloudFormation(properties.location),
    "Status": cdk.stringToCloudFormation(properties.status)
  };
}

// @ts-ignore TS6133
function CfnProjectS3LogsConfigPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnProject.S3LogsConfigProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnProject.S3LogsConfigProperty>();
  ret.addPropertyResult("encryptionDisabled", "EncryptionDisabled", (properties.EncryptionDisabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EncryptionDisabled) : undefined));
  ret.addPropertyResult("location", "Location", (properties.Location != null ? cfn_parse.FromCloudFormation.getString(properties.Location) : undefined));
  ret.addPropertyResult("status", "Status", (properties.Status != null ? cfn_parse.FromCloudFormation.getString(properties.Status) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `LogsConfigProperty`
 *
 * @param properties - the TypeScript properties of a `LogsConfigProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnProjectLogsConfigPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("cloudWatchLogs", CfnProjectCloudWatchLogsConfigPropertyValidator)(properties.cloudWatchLogs));
  errors.collect(cdk.propertyValidator("s3Logs", CfnProjectS3LogsConfigPropertyValidator)(properties.s3Logs));
  return errors.wrap("supplied properties not correct for \"LogsConfigProperty\"");
}

// @ts-ignore TS6133
function convertCfnProjectLogsConfigPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnProjectLogsConfigPropertyValidator(properties).assertSuccess();
  return {
    "CloudWatchLogs": convertCfnProjectCloudWatchLogsConfigPropertyToCloudFormation(properties.cloudWatchLogs),
    "S3Logs": convertCfnProjectS3LogsConfigPropertyToCloudFormation(properties.s3Logs)
  };
}

// @ts-ignore TS6133
function CfnProjectLogsConfigPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnProject.LogsConfigProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnProject.LogsConfigProperty>();
  ret.addPropertyResult("cloudWatchLogs", "CloudWatchLogs", (properties.CloudWatchLogs != null ? CfnProjectCloudWatchLogsConfigPropertyFromCloudFormation(properties.CloudWatchLogs) : undefined));
  ret.addPropertyResult("s3Logs", "S3Logs", (properties.S3Logs != null ? CfnProjectS3LogsConfigPropertyFromCloudFormation(properties.S3Logs) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `ProjectFileSystemLocationProperty`
 *
 * @param properties - the TypeScript properties of a `ProjectFileSystemLocationProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnProjectProjectFileSystemLocationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("identifier", cdk.requiredValidator)(properties.identifier));
  errors.collect(cdk.propertyValidator("identifier", cdk.validateString)(properties.identifier));
  errors.collect(cdk.propertyValidator("location", cdk.requiredValidator)(properties.location));
  errors.collect(cdk.propertyValidator("location", cdk.validateString)(properties.location));
  errors.collect(cdk.propertyValidator("mountOptions", cdk.validateString)(properties.mountOptions));
  errors.collect(cdk.propertyValidator("mountPoint", cdk.requiredValidator)(properties.mountPoint));
  errors.collect(cdk.propertyValidator("mountPoint", cdk.validateString)(properties.mountPoint));
  errors.collect(cdk.propertyValidator("type", cdk.requiredValidator)(properties.type));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  return errors.wrap("supplied properties not correct for \"ProjectFileSystemLocationProperty\"");
}

// @ts-ignore TS6133
function convertCfnProjectProjectFileSystemLocationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnProjectProjectFileSystemLocationPropertyValidator(properties).assertSuccess();
  return {
    "Identifier": cdk.stringToCloudFormation(properties.identifier),
    "Location": cdk.stringToCloudFormation(properties.location),
    "MountOptions": cdk.stringToCloudFormation(properties.mountOptions),
    "MountPoint": cdk.stringToCloudFormation(properties.mountPoint),
    "Type": cdk.stringToCloudFormation(properties.type)
  };
}

// @ts-ignore TS6133
function CfnProjectProjectFileSystemLocationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnProject.ProjectFileSystemLocationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnProject.ProjectFileSystemLocationProperty>();
  ret.addPropertyResult("identifier", "Identifier", (properties.Identifier != null ? cfn_parse.FromCloudFormation.getString(properties.Identifier) : undefined));
  ret.addPropertyResult("location", "Location", (properties.Location != null ? cfn_parse.FromCloudFormation.getString(properties.Location) : undefined));
  ret.addPropertyResult("mountOptions", "MountOptions", (properties.MountOptions != null ? cfn_parse.FromCloudFormation.getString(properties.MountOptions) : undefined));
  ret.addPropertyResult("mountPoint", "MountPoint", (properties.MountPoint != null ? cfn_parse.FromCloudFormation.getString(properties.MountPoint) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `EnvironmentVariableProperty`
 *
 * @param properties - the TypeScript properties of a `EnvironmentVariableProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnProjectEnvironmentVariablePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("name", cdk.requiredValidator)(properties.name));
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  errors.collect(cdk.propertyValidator("value", cdk.requiredValidator)(properties.value));
  errors.collect(cdk.propertyValidator("value", cdk.validateString)(properties.value));
  return errors.wrap("supplied properties not correct for \"EnvironmentVariableProperty\"");
}

// @ts-ignore TS6133
function convertCfnProjectEnvironmentVariablePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnProjectEnvironmentVariablePropertyValidator(properties).assertSuccess();
  return {
    "Name": cdk.stringToCloudFormation(properties.name),
    "Type": cdk.stringToCloudFormation(properties.type),
    "Value": cdk.stringToCloudFormation(properties.value)
  };
}

// @ts-ignore TS6133
function CfnProjectEnvironmentVariablePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnProject.EnvironmentVariableProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnProject.EnvironmentVariableProperty>();
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addPropertyResult("value", "Value", (properties.Value != null ? cfn_parse.FromCloudFormation.getString(properties.Value) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `RegistryCredentialProperty`
 *
 * @param properties - the TypeScript properties of a `RegistryCredentialProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnProjectRegistryCredentialPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("credential", cdk.requiredValidator)(properties.credential));
  errors.collect(cdk.propertyValidator("credential", cdk.validateString)(properties.credential));
  errors.collect(cdk.propertyValidator("credentialProvider", cdk.requiredValidator)(properties.credentialProvider));
  errors.collect(cdk.propertyValidator("credentialProvider", cdk.validateString)(properties.credentialProvider));
  return errors.wrap("supplied properties not correct for \"RegistryCredentialProperty\"");
}

// @ts-ignore TS6133
function convertCfnProjectRegistryCredentialPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnProjectRegistryCredentialPropertyValidator(properties).assertSuccess();
  return {
    "Credential": cdk.stringToCloudFormation(properties.credential),
    "CredentialProvider": cdk.stringToCloudFormation(properties.credentialProvider)
  };
}

// @ts-ignore TS6133
function CfnProjectRegistryCredentialPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnProject.RegistryCredentialProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnProject.RegistryCredentialProperty>();
  ret.addPropertyResult("credential", "Credential", (properties.Credential != null ? cfn_parse.FromCloudFormation.getString(properties.Credential) : undefined));
  ret.addPropertyResult("credentialProvider", "CredentialProvider", (properties.CredentialProvider != null ? cfn_parse.FromCloudFormation.getString(properties.CredentialProvider) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `EnvironmentProperty`
 *
 * @param properties - the TypeScript properties of a `EnvironmentProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnProjectEnvironmentPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("certificate", cdk.validateString)(properties.certificate));
  errors.collect(cdk.propertyValidator("computeType", cdk.validateString)(properties.computeType));
  errors.collect(cdk.propertyValidator("environmentVariables", cdk.listValidator(CfnProjectEnvironmentVariablePropertyValidator))(properties.environmentVariables));
  errors.collect(cdk.propertyValidator("image", cdk.requiredValidator)(properties.image));
  errors.collect(cdk.propertyValidator("image", cdk.validateString)(properties.image));
  errors.collect(cdk.propertyValidator("imagePullCredentialsType", cdk.validateString)(properties.imagePullCredentialsType));
  errors.collect(cdk.propertyValidator("privilegedMode", cdk.validateBoolean)(properties.privilegedMode));
  errors.collect(cdk.propertyValidator("registryCredential", CfnProjectRegistryCredentialPropertyValidator)(properties.registryCredential));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  return errors.wrap("supplied properties not correct for \"EnvironmentProperty\"");
}

// @ts-ignore TS6133
function convertCfnProjectEnvironmentPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnProjectEnvironmentPropertyValidator(properties).assertSuccess();
  return {
    "Certificate": cdk.stringToCloudFormation(properties.certificate),
    "ComputeType": cdk.stringToCloudFormation(properties.computeType),
    "EnvironmentVariables": cdk.listMapper(convertCfnProjectEnvironmentVariablePropertyToCloudFormation)(properties.environmentVariables),
    "Image": cdk.stringToCloudFormation(properties.image),
    "ImagePullCredentialsType": cdk.stringToCloudFormation(properties.imagePullCredentialsType),
    "PrivilegedMode": cdk.booleanToCloudFormation(properties.privilegedMode),
    "RegistryCredential": convertCfnProjectRegistryCredentialPropertyToCloudFormation(properties.registryCredential),
    "Type": cdk.stringToCloudFormation(properties.type)
  };
}

// @ts-ignore TS6133
function CfnProjectEnvironmentPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnProject.EnvironmentProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnProject.EnvironmentProperty>();
  ret.addPropertyResult("certificate", "Certificate", (properties.Certificate != null ? cfn_parse.FromCloudFormation.getString(properties.Certificate) : undefined));
  ret.addPropertyResult("computeType", "ComputeType", (properties.ComputeType != null ? cfn_parse.FromCloudFormation.getString(properties.ComputeType) : undefined));
  ret.addPropertyResult("environmentVariables", "EnvironmentVariables", (properties.EnvironmentVariables != null ? cfn_parse.FromCloudFormation.getArray(CfnProjectEnvironmentVariablePropertyFromCloudFormation)(properties.EnvironmentVariables) : undefined));
  ret.addPropertyResult("image", "Image", (properties.Image != null ? cfn_parse.FromCloudFormation.getString(properties.Image) : undefined));
  ret.addPropertyResult("imagePullCredentialsType", "ImagePullCredentialsType", (properties.ImagePullCredentialsType != null ? cfn_parse.FromCloudFormation.getString(properties.ImagePullCredentialsType) : undefined));
  ret.addPropertyResult("privilegedMode", "PrivilegedMode", (properties.PrivilegedMode != null ? cfn_parse.FromCloudFormation.getBoolean(properties.PrivilegedMode) : undefined));
  ret.addPropertyResult("registryCredential", "RegistryCredential", (properties.RegistryCredential != null ? CfnProjectRegistryCredentialPropertyFromCloudFormation(properties.RegistryCredential) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `ProjectSourceVersionProperty`
 *
 * @param properties - the TypeScript properties of a `ProjectSourceVersionProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnProjectProjectSourceVersionPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("sourceIdentifier", cdk.requiredValidator)(properties.sourceIdentifier));
  errors.collect(cdk.propertyValidator("sourceIdentifier", cdk.validateString)(properties.sourceIdentifier));
  errors.collect(cdk.propertyValidator("sourceVersion", cdk.validateString)(properties.sourceVersion));
  return errors.wrap("supplied properties not correct for \"ProjectSourceVersionProperty\"");
}

// @ts-ignore TS6133
function convertCfnProjectProjectSourceVersionPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnProjectProjectSourceVersionPropertyValidator(properties).assertSuccess();
  return {
    "SourceIdentifier": cdk.stringToCloudFormation(properties.sourceIdentifier),
    "SourceVersion": cdk.stringToCloudFormation(properties.sourceVersion)
  };
}

// @ts-ignore TS6133
function CfnProjectProjectSourceVersionPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnProject.ProjectSourceVersionProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnProject.ProjectSourceVersionProperty>();
  ret.addPropertyResult("sourceIdentifier", "SourceIdentifier", (properties.SourceIdentifier != null ? cfn_parse.FromCloudFormation.getString(properties.SourceIdentifier) : undefined));
  ret.addPropertyResult("sourceVersion", "SourceVersion", (properties.SourceVersion != null ? cfn_parse.FromCloudFormation.getString(properties.SourceVersion) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `BatchRestrictionsProperty`
 *
 * @param properties - the TypeScript properties of a `BatchRestrictionsProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnProjectBatchRestrictionsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("computeTypesAllowed", cdk.listValidator(cdk.validateString))(properties.computeTypesAllowed));
  errors.collect(cdk.propertyValidator("maximumBuildsAllowed", cdk.validateNumber)(properties.maximumBuildsAllowed));
  return errors.wrap("supplied properties not correct for \"BatchRestrictionsProperty\"");
}

// @ts-ignore TS6133
function convertCfnProjectBatchRestrictionsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnProjectBatchRestrictionsPropertyValidator(properties).assertSuccess();
  return {
    "ComputeTypesAllowed": cdk.listMapper(cdk.stringToCloudFormation)(properties.computeTypesAllowed),
    "MaximumBuildsAllowed": cdk.numberToCloudFormation(properties.maximumBuildsAllowed)
  };
}

// @ts-ignore TS6133
function CfnProjectBatchRestrictionsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnProject.BatchRestrictionsProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnProject.BatchRestrictionsProperty>();
  ret.addPropertyResult("computeTypesAllowed", "ComputeTypesAllowed", (properties.ComputeTypesAllowed != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.ComputeTypesAllowed) : undefined));
  ret.addPropertyResult("maximumBuildsAllowed", "MaximumBuildsAllowed", (properties.MaximumBuildsAllowed != null ? cfn_parse.FromCloudFormation.getNumber(properties.MaximumBuildsAllowed) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `ProjectBuildBatchConfigProperty`
 *
 * @param properties - the TypeScript properties of a `ProjectBuildBatchConfigProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnProjectProjectBuildBatchConfigPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("batchReportMode", cdk.validateString)(properties.batchReportMode));
  errors.collect(cdk.propertyValidator("combineArtifacts", cdk.validateBoolean)(properties.combineArtifacts));
  errors.collect(cdk.propertyValidator("restrictions", CfnProjectBatchRestrictionsPropertyValidator)(properties.restrictions));
  errors.collect(cdk.propertyValidator("serviceRole", cdk.validateString)(properties.serviceRole));
  errors.collect(cdk.propertyValidator("timeoutInMins", cdk.validateNumber)(properties.timeoutInMins));
  return errors.wrap("supplied properties not correct for \"ProjectBuildBatchConfigProperty\"");
}

// @ts-ignore TS6133
function convertCfnProjectProjectBuildBatchConfigPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnProjectProjectBuildBatchConfigPropertyValidator(properties).assertSuccess();
  return {
    "BatchReportMode": cdk.stringToCloudFormation(properties.batchReportMode),
    "CombineArtifacts": cdk.booleanToCloudFormation(properties.combineArtifacts),
    "Restrictions": convertCfnProjectBatchRestrictionsPropertyToCloudFormation(properties.restrictions),
    "ServiceRole": cdk.stringToCloudFormation(properties.serviceRole),
    "TimeoutInMins": cdk.numberToCloudFormation(properties.timeoutInMins)
  };
}

// @ts-ignore TS6133
function CfnProjectProjectBuildBatchConfigPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnProject.ProjectBuildBatchConfigProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnProject.ProjectBuildBatchConfigProperty>();
  ret.addPropertyResult("batchReportMode", "BatchReportMode", (properties.BatchReportMode != null ? cfn_parse.FromCloudFormation.getString(properties.BatchReportMode) : undefined));
  ret.addPropertyResult("combineArtifacts", "CombineArtifacts", (properties.CombineArtifacts != null ? cfn_parse.FromCloudFormation.getBoolean(properties.CombineArtifacts) : undefined));
  ret.addPropertyResult("restrictions", "Restrictions", (properties.Restrictions != null ? CfnProjectBatchRestrictionsPropertyFromCloudFormation(properties.Restrictions) : undefined));
  ret.addPropertyResult("serviceRole", "ServiceRole", (properties.ServiceRole != null ? cfn_parse.FromCloudFormation.getString(properties.ServiceRole) : undefined));
  ret.addPropertyResult("timeoutInMins", "TimeoutInMins", (properties.TimeoutInMins != null ? cfn_parse.FromCloudFormation.getNumber(properties.TimeoutInMins) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `ProjectCacheProperty`
 *
 * @param properties - the TypeScript properties of a `ProjectCacheProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnProjectProjectCachePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("location", cdk.validateString)(properties.location));
  errors.collect(cdk.propertyValidator("modes", cdk.listValidator(cdk.validateString))(properties.modes));
  errors.collect(cdk.propertyValidator("type", cdk.requiredValidator)(properties.type));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  return errors.wrap("supplied properties not correct for \"ProjectCacheProperty\"");
}

// @ts-ignore TS6133
function convertCfnProjectProjectCachePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnProjectProjectCachePropertyValidator(properties).assertSuccess();
  return {
    "Location": cdk.stringToCloudFormation(properties.location),
    "Modes": cdk.listMapper(cdk.stringToCloudFormation)(properties.modes),
    "Type": cdk.stringToCloudFormation(properties.type)
  };
}

// @ts-ignore TS6133
function CfnProjectProjectCachePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnProject.ProjectCacheProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnProject.ProjectCacheProperty>();
  ret.addPropertyResult("location", "Location", (properties.Location != null ? cfn_parse.FromCloudFormation.getString(properties.Location) : undefined));
  ret.addPropertyResult("modes", "Modes", (properties.Modes != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.Modes) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `CfnProjectProps`
 *
 * @param properties - the TypeScript properties of a `CfnProjectProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnProjectPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("artifacts", cdk.requiredValidator)(properties.artifacts));
  errors.collect(cdk.propertyValidator("artifacts", CfnProjectArtifactsPropertyValidator)(properties.artifacts));
  errors.collect(cdk.propertyValidator("badgeEnabled", cdk.validateBoolean)(properties.badgeEnabled));
  errors.collect(cdk.propertyValidator("buildBatchConfig", CfnProjectProjectBuildBatchConfigPropertyValidator)(properties.buildBatchConfig));
  errors.collect(cdk.propertyValidator("cache", CfnProjectProjectCachePropertyValidator)(properties.cache));
  errors.collect(cdk.propertyValidator("concurrentBuildLimit", cdk.validateNumber)(properties.concurrentBuildLimit));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("encryptionKey", cdk.validateString)(properties.encryptionKey));
  errors.collect(cdk.propertyValidator("environment", cdk.requiredValidator)(properties.environment));
  errors.collect(cdk.propertyValidator("environment", CfnProjectEnvironmentPropertyValidator)(properties.environment));
  errors.collect(cdk.propertyValidator("fileSystemLocations", cdk.listValidator(CfnProjectProjectFileSystemLocationPropertyValidator))(properties.fileSystemLocations));
  errors.collect(cdk.propertyValidator("logsConfig", CfnProjectLogsConfigPropertyValidator)(properties.logsConfig));
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  errors.collect(cdk.propertyValidator("queuedTimeoutInMinutes", cdk.validateNumber)(properties.queuedTimeoutInMinutes));
  errors.collect(cdk.propertyValidator("resourceAccessRole", cdk.validateString)(properties.resourceAccessRole));
  errors.collect(cdk.propertyValidator("secondaryArtifacts", cdk.listValidator(CfnProjectArtifactsPropertyValidator))(properties.secondaryArtifacts));
  errors.collect(cdk.propertyValidator("secondarySourceVersions", cdk.listValidator(CfnProjectProjectSourceVersionPropertyValidator))(properties.secondarySourceVersions));
  errors.collect(cdk.propertyValidator("secondarySources", cdk.listValidator(CfnProjectSourcePropertyValidator))(properties.secondarySources));
  errors.collect(cdk.propertyValidator("serviceRole", cdk.requiredValidator)(properties.serviceRole));
  errors.collect(cdk.propertyValidator("serviceRole", cdk.validateString)(properties.serviceRole));
  errors.collect(cdk.propertyValidator("source", cdk.requiredValidator)(properties.source));
  errors.collect(cdk.propertyValidator("source", CfnProjectSourcePropertyValidator)(properties.source));
  errors.collect(cdk.propertyValidator("sourceVersion", cdk.validateString)(properties.sourceVersion));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("timeoutInMinutes", cdk.validateNumber)(properties.timeoutInMinutes));
  errors.collect(cdk.propertyValidator("triggers", CfnProjectProjectTriggersPropertyValidator)(properties.triggers));
  errors.collect(cdk.propertyValidator("visibility", cdk.validateString)(properties.visibility));
  errors.collect(cdk.propertyValidator("vpcConfig", CfnProjectVpcConfigPropertyValidator)(properties.vpcConfig));
  return errors.wrap("supplied properties not correct for \"CfnProjectProps\"");
}

// @ts-ignore TS6133
function convertCfnProjectPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnProjectPropsValidator(properties).assertSuccess();
  return {
    "Artifacts": convertCfnProjectArtifactsPropertyToCloudFormation(properties.artifacts),
    "BadgeEnabled": cdk.booleanToCloudFormation(properties.badgeEnabled),
    "BuildBatchConfig": convertCfnProjectProjectBuildBatchConfigPropertyToCloudFormation(properties.buildBatchConfig),
    "Cache": convertCfnProjectProjectCachePropertyToCloudFormation(properties.cache),
    "ConcurrentBuildLimit": cdk.numberToCloudFormation(properties.concurrentBuildLimit),
    "Description": cdk.stringToCloudFormation(properties.description),
    "EncryptionKey": cdk.stringToCloudFormation(properties.encryptionKey),
    "Environment": convertCfnProjectEnvironmentPropertyToCloudFormation(properties.environment),
    "FileSystemLocations": cdk.listMapper(convertCfnProjectProjectFileSystemLocationPropertyToCloudFormation)(properties.fileSystemLocations),
    "LogsConfig": convertCfnProjectLogsConfigPropertyToCloudFormation(properties.logsConfig),
    "Name": cdk.stringToCloudFormation(properties.name),
    "QueuedTimeoutInMinutes": cdk.numberToCloudFormation(properties.queuedTimeoutInMinutes),
    "ResourceAccessRole": cdk.stringToCloudFormation(properties.resourceAccessRole),
    "SecondaryArtifacts": cdk.listMapper(convertCfnProjectArtifactsPropertyToCloudFormation)(properties.secondaryArtifacts),
    "SecondarySourceVersions": cdk.listMapper(convertCfnProjectProjectSourceVersionPropertyToCloudFormation)(properties.secondarySourceVersions),
    "SecondarySources": cdk.listMapper(convertCfnProjectSourcePropertyToCloudFormation)(properties.secondarySources),
    "ServiceRole": cdk.stringToCloudFormation(properties.serviceRole),
    "Source": convertCfnProjectSourcePropertyToCloudFormation(properties.source),
    "SourceVersion": cdk.stringToCloudFormation(properties.sourceVersion),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "TimeoutInMinutes": cdk.numberToCloudFormation(properties.timeoutInMinutes),
    "Triggers": convertCfnProjectProjectTriggersPropertyToCloudFormation(properties.triggers),
    "Visibility": cdk.stringToCloudFormation(properties.visibility),
    "VpcConfig": convertCfnProjectVpcConfigPropertyToCloudFormation(properties.vpcConfig)
  };
}

// @ts-ignore TS6133
function CfnProjectPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnProjectProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnProjectProps>();
  ret.addPropertyResult("artifacts", "Artifacts", (properties.Artifacts != null ? CfnProjectArtifactsPropertyFromCloudFormation(properties.Artifacts) : undefined));
  ret.addPropertyResult("badgeEnabled", "BadgeEnabled", (properties.BadgeEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.BadgeEnabled) : undefined));
  ret.addPropertyResult("buildBatchConfig", "BuildBatchConfig", (properties.BuildBatchConfig != null ? CfnProjectProjectBuildBatchConfigPropertyFromCloudFormation(properties.BuildBatchConfig) : undefined));
  ret.addPropertyResult("cache", "Cache", (properties.Cache != null ? CfnProjectProjectCachePropertyFromCloudFormation(properties.Cache) : undefined));
  ret.addPropertyResult("concurrentBuildLimit", "ConcurrentBuildLimit", (properties.ConcurrentBuildLimit != null ? cfn_parse.FromCloudFormation.getNumber(properties.ConcurrentBuildLimit) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("encryptionKey", "EncryptionKey", (properties.EncryptionKey != null ? cfn_parse.FromCloudFormation.getString(properties.EncryptionKey) : undefined));
  ret.addPropertyResult("environment", "Environment", (properties.Environment != null ? CfnProjectEnvironmentPropertyFromCloudFormation(properties.Environment) : undefined));
  ret.addPropertyResult("fileSystemLocations", "FileSystemLocations", (properties.FileSystemLocations != null ? cfn_parse.FromCloudFormation.getArray(CfnProjectProjectFileSystemLocationPropertyFromCloudFormation)(properties.FileSystemLocations) : undefined));
  ret.addPropertyResult("logsConfig", "LogsConfig", (properties.LogsConfig != null ? CfnProjectLogsConfigPropertyFromCloudFormation(properties.LogsConfig) : undefined));
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addPropertyResult("queuedTimeoutInMinutes", "QueuedTimeoutInMinutes", (properties.QueuedTimeoutInMinutes != null ? cfn_parse.FromCloudFormation.getNumber(properties.QueuedTimeoutInMinutes) : undefined));
  ret.addPropertyResult("resourceAccessRole", "ResourceAccessRole", (properties.ResourceAccessRole != null ? cfn_parse.FromCloudFormation.getString(properties.ResourceAccessRole) : undefined));
  ret.addPropertyResult("secondaryArtifacts", "SecondaryArtifacts", (properties.SecondaryArtifacts != null ? cfn_parse.FromCloudFormation.getArray(CfnProjectArtifactsPropertyFromCloudFormation)(properties.SecondaryArtifacts) : undefined));
  ret.addPropertyResult("secondarySources", "SecondarySources", (properties.SecondarySources != null ? cfn_parse.FromCloudFormation.getArray(CfnProjectSourcePropertyFromCloudFormation)(properties.SecondarySources) : undefined));
  ret.addPropertyResult("secondarySourceVersions", "SecondarySourceVersions", (properties.SecondarySourceVersions != null ? cfn_parse.FromCloudFormation.getArray(CfnProjectProjectSourceVersionPropertyFromCloudFormation)(properties.SecondarySourceVersions) : undefined));
  ret.addPropertyResult("serviceRole", "ServiceRole", (properties.ServiceRole != null ? cfn_parse.FromCloudFormation.getString(properties.ServiceRole) : undefined));
  ret.addPropertyResult("source", "Source", (properties.Source != null ? CfnProjectSourcePropertyFromCloudFormation(properties.Source) : undefined));
  ret.addPropertyResult("sourceVersion", "SourceVersion", (properties.SourceVersion != null ? cfn_parse.FromCloudFormation.getString(properties.SourceVersion) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("timeoutInMinutes", "TimeoutInMinutes", (properties.TimeoutInMinutes != null ? cfn_parse.FromCloudFormation.getNumber(properties.TimeoutInMinutes) : undefined));
  ret.addPropertyResult("triggers", "Triggers", (properties.Triggers != null ? CfnProjectProjectTriggersPropertyFromCloudFormation(properties.Triggers) : undefined));
  ret.addPropertyResult("visibility", "Visibility", (properties.Visibility != null ? cfn_parse.FromCloudFormation.getString(properties.Visibility) : undefined));
  ret.addPropertyResult("vpcConfig", "VpcConfig", (properties.VpcConfig != null ? CfnProjectVpcConfigPropertyFromCloudFormation(properties.VpcConfig) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Represents a report group.
 *
 * A report group contains a collection of reports.
 *
 * @cloudformationResource AWS::CodeBuild::ReportGroup
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-codebuild-reportgroup.html
 */
export class CfnReportGroup extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::CodeBuild::ReportGroup";

  /**
   * Build a CfnReportGroup from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnReportGroup {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnReportGroupPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnReportGroup(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ARN of the AWS CodeBuild report group, such as `arn:aws:codebuild:region:123456789012:report-group/myReportGroupName` .
   *
   * @cloudformationAttribute Arn
   */
  public readonly attrArn: string;

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * When deleting a report group, specifies if reports within the report group should be deleted.
   */
  public deleteReports?: boolean | cdk.IResolvable;

  /**
   * Information about the destination where the raw data of this `ReportGroup` is exported.
   */
  public exportConfig: cdk.IResolvable | CfnReportGroup.ReportExportConfigProperty;

  /**
   * The name of the `ReportGroup` .
   */
  public name?: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * A list of tag key and value pairs associated with this report group.
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The type of the `ReportGroup` . This can be one of the following values:.
   */
  public type: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnReportGroupProps) {
    super(scope, id, {
      "type": CfnReportGroup.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "exportConfig", this);
    cdk.requireProperty(props, "type", this);

    this.attrArn = cdk.Token.asString(this.getAtt("Arn", cdk.ResolutionTypeHint.STRING));
    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.deleteReports = props.deleteReports;
    this.exportConfig = props.exportConfig;
    this.name = props.name;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::CodeBuild::ReportGroup", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.type = props.type;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "deleteReports": this.deleteReports,
      "exportConfig": this.exportConfig,
      "name": this.name,
      "tags": this.tags.renderTags(),
      "type": this.type
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnReportGroup.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnReportGroupPropsToCloudFormation(props);
  }
}

export namespace CfnReportGroup {
  /**
   * Information about the location where the run of a report is exported.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-reportgroup-reportexportconfig.html
   */
  export interface ReportExportConfigProperty {
    /**
     * The export configuration type. Valid values are:.
     *
     * - `S3` : The report results are exported to an S3 bucket.
     * - `NO_EXPORT` : The report results are not exported.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-reportgroup-reportexportconfig.html#cfn-codebuild-reportgroup-reportexportconfig-exportconfigtype
     */
    readonly exportConfigType: string;

    /**
     * A `S3ReportExportConfig` object that contains information about the S3 bucket where the run of a report is exported.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-reportgroup-reportexportconfig.html#cfn-codebuild-reportgroup-reportexportconfig-s3destination
     */
    readonly s3Destination?: cdk.IResolvable | CfnReportGroup.S3ReportExportConfigProperty;
  }

  /**
   * Information about the S3 bucket where the raw data of a report are exported.
   *
   * @struct
   * @stability external
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-reportgroup-s3reportexportconfig.html
   */
  export interface S3ReportExportConfigProperty {
    /**
     * The name of the S3 bucket where the raw data of a report are exported.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-reportgroup-s3reportexportconfig.html#cfn-codebuild-reportgroup-s3reportexportconfig-bucket
     */
    readonly bucket: string;

    /**
     * The AWS account identifier of the owner of the Amazon S3 bucket.
     *
     * This allows report data to be exported to an Amazon S3 bucket that is owned by an account other than the account running the build.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-reportgroup-s3reportexportconfig.html#cfn-codebuild-reportgroup-s3reportexportconfig-bucketowner
     */
    readonly bucketOwner?: string;

    /**
     * A boolean value that specifies if the results of a report are encrypted.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-reportgroup-s3reportexportconfig.html#cfn-codebuild-reportgroup-s3reportexportconfig-encryptiondisabled
     */
    readonly encryptionDisabled?: boolean | cdk.IResolvable;

    /**
     * The encryption key for the report's encrypted raw data.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-reportgroup-s3reportexportconfig.html#cfn-codebuild-reportgroup-s3reportexportconfig-encryptionkey
     */
    readonly encryptionKey?: string;

    /**
     * The type of build output artifact to create. Valid values include:.
     *
     * - `NONE` : CodeBuild creates the raw data in the output bucket. This is the default if packaging is not specified.
     * - `ZIP` : CodeBuild creates a ZIP file with the raw data in the output bucket.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-reportgroup-s3reportexportconfig.html#cfn-codebuild-reportgroup-s3reportexportconfig-packaging
     */
    readonly packaging?: string;

    /**
     * The path to the exported report's raw data results.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-reportgroup-s3reportexportconfig.html#cfn-codebuild-reportgroup-s3reportexportconfig-path
     */
    readonly path?: string;
  }
}

/**
 * Properties for defining a `CfnReportGroup`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-codebuild-reportgroup.html
 */
export interface CfnReportGroupProps {
  /**
   * When deleting a report group, specifies if reports within the report group should be deleted.
   *
   * - **true** - Deletes any reports that belong to the report group before deleting the report group.
   * - **false** - You must delete any reports in the report group. This is the default value. If you delete a report group that contains one or more reports, an exception is thrown.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-codebuild-reportgroup.html#cfn-codebuild-reportgroup-deletereports
   */
  readonly deleteReports?: boolean | cdk.IResolvable;

  /**
   * Information about the destination where the raw data of this `ReportGroup` is exported.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-codebuild-reportgroup.html#cfn-codebuild-reportgroup-exportconfig
   */
  readonly exportConfig: cdk.IResolvable | CfnReportGroup.ReportExportConfigProperty;

  /**
   * The name of the `ReportGroup` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-codebuild-reportgroup.html#cfn-codebuild-reportgroup-name
   */
  readonly name?: string;

  /**
   * A list of tag key and value pairs associated with this report group.
   *
   * These tags are available for use by AWS services that support AWS CodeBuild report group tags.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-codebuild-reportgroup.html#cfn-codebuild-reportgroup-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The type of the `ReportGroup` . This can be one of the following values:.
   *
   * - **CODE_COVERAGE** - The report group contains code coverage reports.
   * - **TEST** - The report group contains test reports.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-codebuild-reportgroup.html#cfn-codebuild-reportgroup-type
   */
  readonly type: string;
}

/**
 * Determine whether the given properties match those of a `S3ReportExportConfigProperty`
 *
 * @param properties - the TypeScript properties of a `S3ReportExportConfigProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnReportGroupS3ReportExportConfigPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("bucket", cdk.requiredValidator)(properties.bucket));
  errors.collect(cdk.propertyValidator("bucket", cdk.validateString)(properties.bucket));
  errors.collect(cdk.propertyValidator("bucketOwner", cdk.validateString)(properties.bucketOwner));
  errors.collect(cdk.propertyValidator("encryptionDisabled", cdk.validateBoolean)(properties.encryptionDisabled));
  errors.collect(cdk.propertyValidator("encryptionKey", cdk.validateString)(properties.encryptionKey));
  errors.collect(cdk.propertyValidator("packaging", cdk.validateString)(properties.packaging));
  errors.collect(cdk.propertyValidator("path", cdk.validateString)(properties.path));
  return errors.wrap("supplied properties not correct for \"S3ReportExportConfigProperty\"");
}

// @ts-ignore TS6133
function convertCfnReportGroupS3ReportExportConfigPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnReportGroupS3ReportExportConfigPropertyValidator(properties).assertSuccess();
  return {
    "Bucket": cdk.stringToCloudFormation(properties.bucket),
    "BucketOwner": cdk.stringToCloudFormation(properties.bucketOwner),
    "EncryptionDisabled": cdk.booleanToCloudFormation(properties.encryptionDisabled),
    "EncryptionKey": cdk.stringToCloudFormation(properties.encryptionKey),
    "Packaging": cdk.stringToCloudFormation(properties.packaging),
    "Path": cdk.stringToCloudFormation(properties.path)
  };
}

// @ts-ignore TS6133
function CfnReportGroupS3ReportExportConfigPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnReportGroup.S3ReportExportConfigProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnReportGroup.S3ReportExportConfigProperty>();
  ret.addPropertyResult("bucket", "Bucket", (properties.Bucket != null ? cfn_parse.FromCloudFormation.getString(properties.Bucket) : undefined));
  ret.addPropertyResult("bucketOwner", "BucketOwner", (properties.BucketOwner != null ? cfn_parse.FromCloudFormation.getString(properties.BucketOwner) : undefined));
  ret.addPropertyResult("encryptionDisabled", "EncryptionDisabled", (properties.EncryptionDisabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EncryptionDisabled) : undefined));
  ret.addPropertyResult("encryptionKey", "EncryptionKey", (properties.EncryptionKey != null ? cfn_parse.FromCloudFormation.getString(properties.EncryptionKey) : undefined));
  ret.addPropertyResult("packaging", "Packaging", (properties.Packaging != null ? cfn_parse.FromCloudFormation.getString(properties.Packaging) : undefined));
  ret.addPropertyResult("path", "Path", (properties.Path != null ? cfn_parse.FromCloudFormation.getString(properties.Path) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `ReportExportConfigProperty`
 *
 * @param properties - the TypeScript properties of a `ReportExportConfigProperty`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnReportGroupReportExportConfigPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("exportConfigType", cdk.requiredValidator)(properties.exportConfigType));
  errors.collect(cdk.propertyValidator("exportConfigType", cdk.validateString)(properties.exportConfigType));
  errors.collect(cdk.propertyValidator("s3Destination", CfnReportGroupS3ReportExportConfigPropertyValidator)(properties.s3Destination));
  return errors.wrap("supplied properties not correct for \"ReportExportConfigProperty\"");
}

// @ts-ignore TS6133
function convertCfnReportGroupReportExportConfigPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnReportGroupReportExportConfigPropertyValidator(properties).assertSuccess();
  return {
    "ExportConfigType": cdk.stringToCloudFormation(properties.exportConfigType),
    "S3Destination": convertCfnReportGroupS3ReportExportConfigPropertyToCloudFormation(properties.s3Destination)
  };
}

// @ts-ignore TS6133
function CfnReportGroupReportExportConfigPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnReportGroup.ReportExportConfigProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnReportGroup.ReportExportConfigProperty>();
  ret.addPropertyResult("exportConfigType", "ExportConfigType", (properties.ExportConfigType != null ? cfn_parse.FromCloudFormation.getString(properties.ExportConfigType) : undefined));
  ret.addPropertyResult("s3Destination", "S3Destination", (properties.S3Destination != null ? CfnReportGroupS3ReportExportConfigPropertyFromCloudFormation(properties.S3Destination) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a `CfnReportGroupProps`
 *
 * @param properties - the TypeScript properties of a `CfnReportGroupProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnReportGroupPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("deleteReports", cdk.validateBoolean)(properties.deleteReports));
  errors.collect(cdk.propertyValidator("exportConfig", cdk.requiredValidator)(properties.exportConfig));
  errors.collect(cdk.propertyValidator("exportConfig", CfnReportGroupReportExportConfigPropertyValidator)(properties.exportConfig));
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("type", cdk.requiredValidator)(properties.type));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  return errors.wrap("supplied properties not correct for \"CfnReportGroupProps\"");
}

// @ts-ignore TS6133
function convertCfnReportGroupPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnReportGroupPropsValidator(properties).assertSuccess();
  return {
    "DeleteReports": cdk.booleanToCloudFormation(properties.deleteReports),
    "ExportConfig": convertCfnReportGroupReportExportConfigPropertyToCloudFormation(properties.exportConfig),
    "Name": cdk.stringToCloudFormation(properties.name),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "Type": cdk.stringToCloudFormation(properties.type)
  };
}

// @ts-ignore TS6133
function CfnReportGroupPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnReportGroupProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnReportGroupProps>();
  ret.addPropertyResult("deleteReports", "DeleteReports", (properties.DeleteReports != null ? cfn_parse.FromCloudFormation.getBoolean(properties.DeleteReports) : undefined));
  ret.addPropertyResult("exportConfig", "ExportConfig", (properties.ExportConfig != null ? CfnReportGroupReportExportConfigPropertyFromCloudFormation(properties.ExportConfig) : undefined));
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Information about the credentials for a GitHub, GitHub Enterprise, or Bitbucket repository.
 *
 * We strongly recommend that you use AWS Secrets Manager to store your credentials. If you use Secrets Manager , you must have secrets in your secrets manager. For more information, see [Using Dynamic References to Specify Template Values](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/dynamic-references.html#dynamic-references-secretsmanager) .
 *
 * > For security purposes, do not use plain text in your AWS CloudFormation template to store your credentials.
 *
 * @cloudformationResource AWS::CodeBuild::SourceCredential
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-codebuild-sourcecredential.html
 */
export class CfnSourceCredential extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::CodeBuild::SourceCredential";

  /**
   * Build a CfnSourceCredential from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnSourceCredential {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnSourceCredentialPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnSourceCredential(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The type of authentication used by the credentials.
   */
  public authType: string;

  /**
   * The type of source provider.
   */
  public serverType: string;

  /**
   * For GitHub or GitHub Enterprise, this is the personal access token.
   */
  public token: string;

  /**
   * The Bitbucket username when the `authType` is BASIC_AUTH.
   */
  public username?: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnSourceCredentialProps) {
    super(scope, id, {
      "type": CfnSourceCredential.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "authType", this);
    cdk.requireProperty(props, "serverType", this);
    cdk.requireProperty(props, "token", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.authType = props.authType;
    this.serverType = props.serverType;
    this.token = props.token;
    this.username = props.username;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "authType": this.authType,
      "serverType": this.serverType,
      "token": this.token,
      "username": this.username
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnSourceCredential.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnSourceCredentialPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a `CfnSourceCredential`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-codebuild-sourcecredential.html
 */
export interface CfnSourceCredentialProps {
  /**
   * The type of authentication used by the credentials.
   *
   * Valid options are OAUTH, BASIC_AUTH, or PERSONAL_ACCESS_TOKEN.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-codebuild-sourcecredential.html#cfn-codebuild-sourcecredential-authtype
   */
  readonly authType: string;

  /**
   * The type of source provider.
   *
   * The valid options are GITHUB, GITHUB_ENTERPRISE, or BITBUCKET.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-codebuild-sourcecredential.html#cfn-codebuild-sourcecredential-servertype
   */
  readonly serverType: string;

  /**
   * For GitHub or GitHub Enterprise, this is the personal access token.
   *
   * For Bitbucket, this is the app password.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-codebuild-sourcecredential.html#cfn-codebuild-sourcecredential-token
   */
  readonly token: string;

  /**
   * The Bitbucket username when the `authType` is BASIC_AUTH.
   *
   * This parameter is not valid for other types of source providers or connections.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-codebuild-sourcecredential.html#cfn-codebuild-sourcecredential-username
   */
  readonly username?: string;
}

/**
 * Determine whether the given properties match those of a `CfnSourceCredentialProps`
 *
 * @param properties - the TypeScript properties of a `CfnSourceCredentialProps`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSourceCredentialPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("authType", cdk.requiredValidator)(properties.authType));
  errors.collect(cdk.propertyValidator("authType", cdk.validateString)(properties.authType));
  errors.collect(cdk.propertyValidator("serverType", cdk.requiredValidator)(properties.serverType));
  errors.collect(cdk.propertyValidator("serverType", cdk.validateString)(properties.serverType));
  errors.collect(cdk.propertyValidator("token", cdk.requiredValidator)(properties.token));
  errors.collect(cdk.propertyValidator("token", cdk.validateString)(properties.token));
  errors.collect(cdk.propertyValidator("username", cdk.validateString)(properties.username));
  return errors.wrap("supplied properties not correct for \"CfnSourceCredentialProps\"");
}

// @ts-ignore TS6133
function convertCfnSourceCredentialPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSourceCredentialPropsValidator(properties).assertSuccess();
  return {
    "AuthType": cdk.stringToCloudFormation(properties.authType),
    "ServerType": cdk.stringToCloudFormation(properties.serverType),
    "Token": cdk.stringToCloudFormation(properties.token),
    "Username": cdk.stringToCloudFormation(properties.username)
  };
}

// @ts-ignore TS6133
function CfnSourceCredentialPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSourceCredentialProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSourceCredentialProps>();
  ret.addPropertyResult("authType", "AuthType", (properties.AuthType != null ? cfn_parse.FromCloudFormation.getString(properties.AuthType) : undefined));
  ret.addPropertyResult("serverType", "ServerType", (properties.ServerType != null ? cfn_parse.FromCloudFormation.getString(properties.ServerType) : undefined));
  ret.addPropertyResult("token", "Token", (properties.Token != null ? cfn_parse.FromCloudFormation.getString(properties.Token) : undefined));
  ret.addPropertyResult("username", "Username", (properties.Username != null ? cfn_parse.FromCloudFormation.getString(properties.Username) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}