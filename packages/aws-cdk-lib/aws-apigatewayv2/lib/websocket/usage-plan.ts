import { Construct } from 'constructs';
import { IWebSocketApi } from './api';
import { IApiKey } from './api-key';
import { IWebSocketStage } from './stage';
import { CfnUsagePlan, CfnUsagePlanKey } from '../../../aws-apigateway/lib';
import { validateDouble, validateInteger } from '../../../aws-apigateway/lib/util';
import { IResource, Names, Resource, Lazy } from '../../../core';
import { addConstructMetadata, MethodMetadata } from '../../../core/lib/metadata-resource';
import { propertyInjectable } from '../../../core/lib/prop-injectable';
import { ThrottleSettings } from '../common';

/**
 * Time period for which quota settings apply.
 */
export enum Period {
  /**
   * The quota resets every day.
   */
  DAY = 'DAY',
  /**
   * The quota resets every week.
   */
  WEEK = 'WEEK',
  /**
   * The quota resets every month.
   */
  MONTH = 'MONTH',
}

/**
 * Specifies the maximum number of requests that clients can make to API Gateway APIs.
 */
export interface QuotaSettings {
  /**
   * The maximum number of requests that users can make within the specified time period.
   * @default none
   */
  readonly limit?: number;

  /**
   * For the initial time period, the number of requests to subtract from the specified limit.
   * @default none
   */
  readonly offset?: number;

  /**
   * The time period for which the maximum limit of requests applies.
   * @default none
   */
  readonly period?: Period;
}

/**
 * Type of Usage Plan Key. Currently the only supported type is 'ApiKey'
 */
enum UsagePlanKeyType {
  API_KEY = 'API_KEY',
}

/**
 * Represents the API stages that a usage plan applies to.
 */
export interface UsagePlanPerApiStage {

  /**
   * The WebSocket API to associate with the usage plan.
   * @default none
   */
  readonly api?: IWebSocketApi;

  /**
   *
   * [disable-awslint:ref-via-interface]
   * @default none
   */
  readonly stage?: IWebSocketStage;
}

/**
 * Properties for defining an API Gateway Usage Plan for WebSocket APIs.
 */
export interface UsagePlanProps {
  /**
   * API Stages to be associated with the usage plan.
   * @default none
   */
  readonly apiStages?: UsagePlanPerApiStage[];

  /**
   * Represents usage plan purpose.
   * @default none
   */
  readonly description?: string;

  /**
   * Number of requests clients can make in a given time period.
   * @default none
   */
  readonly quota?: QuotaSettings;

  /**
   * Overall throttle settings for the API.
   * @default none
   */
  readonly throttle?: ThrottleSettings;

  /**
   * Name for this usage plan.
   * @default none
   */
  readonly usagePlanName?: string;
}

/**
 * Options to the UsagePlan.addApiKey() method
 */
export interface AddApiKeyOptions {
  /**
   * Override the CloudFormation logical id of the AWS::ApiGateway::UsagePlanKey resource
   * @default - autogenerated by the CDK
   */
  readonly overrideLogicalId?: string;
}

/**
 * A UsagePlan, either managed by this CDK app, or imported.
 */
export interface IUsagePlan extends IResource {
  /**
   * Id of the usage plan
   * @attribute
   */
  readonly usagePlanId: string;

  /**
   * Adds an ApiKey.
   *
   * @param apiKey the api key to associate with this usage plan
   * @param options options that control the behaviour of this method
   */
  addApiKey(apiKey: IApiKey, options?: AddApiKeyOptions): void;

}

abstract class UsagePlanBase extends Resource implements IUsagePlan {
  /**
   * Id of the usage plan
   * @attribute
   */
  public abstract readonly usagePlanId: string;

  /**
   * Adds an ApiKey.
   *
   * @param apiKey the api key to associate with this usage plan
   * @param options options that control the behaviour of this method
   */
  public addApiKey(apiKey: IApiKey, options?: AddApiKeyOptions): void {
    const prefix = 'UsagePlanKeyResource';

    const resource = new CfnUsagePlanKey(this, `${prefix}:${Names.nodeUniqueId(apiKey.node)}`, {
      keyId: apiKey.keyId,
      keyType: UsagePlanKeyType.API_KEY,
      usagePlanId: this.usagePlanId,
    });
    if (options?.overrideLogicalId) {
      resource.overrideLogicalId(options?.overrideLogicalId);
    }
  }
}

/**
 * A UsagePlan.
 *
 * @resource AWS::ApiGateway::UsagePlan
 */
@propertyInjectable
export class UsagePlan extends UsagePlanBase {
  /** Uniquely identifies this class. */
  public static readonly PROPERTY_INJECTION_ID: string = 'aws-cdk-lib.aws-apigatewayv2.websocket.UsagePlan';

  /**
   * Import an externally defined usage plan using its ARN.
   *
   * @param scope  the construct that will "own" the imported usage plan.
   * @param id     the id of the imported usage plan in the construct tree.
   * @param usagePlanId the id of an existing usage plan.
   */
  public static fromUsagePlanId(scope: Construct, id: string, usagePlanId: string): IUsagePlan {
    class Import extends UsagePlanBase {
      public readonly usagePlanId = usagePlanId;

      constructor() {
        super(scope, id);
      }
    }
    return new Import();
  }

  /**
   * @attribute
   */
  public readonly usagePlanId: string;

  private readonly apiStages = new Array<UsagePlanPerApiStage>();

  constructor(scope: Construct, id: string, props: UsagePlanProps = { }) {
    super(scope, id);
    // Enhanced CDK Analytics Telemetry
    addConstructMetadata(this, props);

    const resource = new CfnUsagePlan(this, 'Resource', {
      apiStages: Lazy.any({ produce: () => this.renderApiStages(this.apiStages) }),
      description: props.description,
      quota: this.renderQuota(props),
      throttle: this.renderThrottle(props.throttle),
      usagePlanName: props.usagePlanName,
    });

    this.apiStages.push(...(props.apiStages || []));

    this.usagePlanId = resource.ref;

    // This ensures that the stages are created before the usage plan
    if (props.apiStages) {
      for (const apiStage of props.apiStages) {
        if (apiStage.stage) {
          this.node.addDependency(apiStage.stage);
        }
        if (apiStage.api) {
          this.node.addDependency(apiStage.api);
        }
      }
    }
  }

  /**
   * Adds an apiStage.
   */
  @MethodMetadata()
  public addApiStage(apiStage: UsagePlanPerApiStage) {
    this.apiStages.push(apiStage);
  }

  private renderApiStages(apiStages: UsagePlanPerApiStage[] | undefined): (CfnUsagePlan.ApiStageProperty[] | undefined) {
    if (apiStages && apiStages.length > 0) {
      const stages: CfnUsagePlan.ApiStageProperty[] = [];
      apiStages.forEach((apiStage: UsagePlanPerApiStage) => {
        const stage = this.createStage(apiStage);
        if ( stage !== undefined) {
          stages.push(stage);
        }
      });
      return stages;
    }
    return undefined;
  }

  private createStage(apiStage: UsagePlanPerApiStage): (CfnUsagePlan.ApiStageProperty | undefined) {
    if (apiStage.stage === undefined) {
      return undefined;
    } else {
      return {
        stage: apiStage.stage.stageName.toString(),
        apiId: apiStage.stage.api.apiId,
      };
    }
  }

  private renderQuota(props: UsagePlanProps): (CfnUsagePlan.QuotaSettingsProperty | undefined) {
    if (props.quota === undefined) {
      return undefined;
    } else {
      validateInteger(props.quota.limit, 'Throttle quota limit');
      const ret = {
        limit: props.quota.limit,
        offset: props.quota.offset,
        period: props.quota.period,
      };
      return ret;
    }
  }

  private renderThrottle(props: ThrottleSettings | undefined): (CfnUsagePlan.ThrottleSettingsProperty | undefined) {
    if (props === undefined) {
      return undefined;
    } else {
      const burstLimit = props.burstLimit;
      validateInteger(burstLimit, 'Throttle burst limit');
      const rateLimit = props.rateLimit;
      validateDouble(rateLimit, 'Throttle rate limit');

      return {
        burstLimit: burstLimit,
        rateLimit: rateLimit,
      };
    }
  }
}
